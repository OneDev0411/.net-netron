/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
(function($protobuf) {
    "use strict";

    var $Reader = $protobuf.Reader, $util = $protobuf.util;
    
    var $root = $protobuf.roots.coreml || ($protobuf.roots.coreml = {});
    
    $root.CoreML = (function() {
    
        var CoreML = {};
    
        CoreML.Specification = (function() {
    
            var Specification = {};
    
            Specification.Pipeline = (function() {
    
                function Pipeline(properties) {
                    this.models = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Pipeline.prototype.models = $util.emptyArray;
    
                Pipeline.create = function create(properties) {
                    return new Pipeline(properties);
                };
    
                Pipeline.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Pipeline();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.models && message.models.length))
                                message.models = [];
                            message.models.push($root.CoreML.Specification.Model.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Pipeline.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.models != null && message.hasOwnProperty("models")) {
                        if (!Array.isArray(message.models))
                            return "models: array expected";
                        for (var i = 0; i < message.models.length; ++i) {
                            var error = $root.CoreML.Specification.Model.verify(message.models[i]);
                            if (error)
                                return "models." + error;
                        }
                    }
                    return null;
                };
    
                Pipeline.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Pipeline)
                        return object;
                    var message = new $root.CoreML.Specification.Pipeline();
                    if (object.models) {
                        if (!Array.isArray(object.models))
                            throw TypeError(".CoreML.Specification.Pipeline.models: array expected");
                        message.models = [];
                        for (var i = 0; i < object.models.length; ++i) {
                            if (typeof object.models[i] !== "object")
                                throw TypeError(".CoreML.Specification.Pipeline.models: object expected");
                            message.models[i] = $root.CoreML.Specification.Model.fromObject(object.models[i]);
                        }
                    }
                    return message;
                };
    
                Pipeline.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.models = [];
                    if (message.models && message.models.length) {
                        object.models = [];
                        for (var j = 0; j < message.models.length; ++j)
                            object.models[j] = $root.CoreML.Specification.Model.toObject(message.models[j], options);
                    }
                    return object;
                };
    
                Pipeline.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Pipeline;
            })();
    
            Specification.PipelineClassifier = (function() {
    
                function PipelineClassifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                PipelineClassifier.prototype.pipeline = null;
    
                PipelineClassifier.create = function create(properties) {
                    return new PipelineClassifier(properties);
                };
    
                PipelineClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PipelineClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pipeline = $root.CoreML.Specification.Pipeline.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                PipelineClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        var error = $root.CoreML.Specification.Pipeline.verify(message.pipeline);
                        if (error)
                            return "pipeline." + error;
                    }
                    return null;
                };
    
                PipelineClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PipelineClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.PipelineClassifier();
                    if (object.pipeline != null) {
                        if (typeof object.pipeline !== "object")
                            throw TypeError(".CoreML.Specification.PipelineClassifier.pipeline: object expected");
                        message.pipeline = $root.CoreML.Specification.Pipeline.fromObject(object.pipeline);
                    }
                    return message;
                };
    
                PipelineClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pipeline = null;
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        object.pipeline = $root.CoreML.Specification.Pipeline.toObject(message.pipeline, options);
                    return object;
                };
    
                PipelineClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PipelineClassifier;
            })();
    
            Specification.PipelineRegressor = (function() {
    
                function PipelineRegressor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                PipelineRegressor.prototype.pipeline = null;
    
                PipelineRegressor.create = function create(properties) {
                    return new PipelineRegressor(properties);
                };
    
                PipelineRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PipelineRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pipeline = $root.CoreML.Specification.Pipeline.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                PipelineRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        var error = $root.CoreML.Specification.Pipeline.verify(message.pipeline);
                        if (error)
                            return "pipeline." + error;
                    }
                    return null;
                };
    
                PipelineRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PipelineRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.PipelineRegressor();
                    if (object.pipeline != null) {
                        if (typeof object.pipeline !== "object")
                            throw TypeError(".CoreML.Specification.PipelineRegressor.pipeline: object expected");
                        message.pipeline = $root.CoreML.Specification.Pipeline.fromObject(object.pipeline);
                    }
                    return message;
                };
    
                PipelineRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pipeline = null;
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        object.pipeline = $root.CoreML.Specification.Pipeline.toObject(message.pipeline, options);
                    return object;
                };
    
                PipelineRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PipelineRegressor;
            })();
    
            Specification.FeatureDescription = (function() {
    
                function FeatureDescription(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                FeatureDescription.prototype.name = "";
                FeatureDescription.prototype.shortDescription = "";
                FeatureDescription.prototype.type = null;
    
                FeatureDescription.create = function create(properties) {
                    return new FeatureDescription(properties);
                };
    
                FeatureDescription.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureDescription();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.shortDescription = reader.string();
                            break;
                        case 3:
                            message.type = $root.CoreML.Specification.FeatureType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                FeatureDescription.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.CoreML.Specification.FeatureType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    return null;
                };
    
                FeatureDescription.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FeatureDescription)
                        return object;
                    var message = new $root.CoreML.Specification.FeatureDescription();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.shortDescription != null)
                        message.shortDescription = String(object.shortDescription);
                    if (object.type != null) {
                        if (typeof object.type !== "object")
                            throw TypeError(".CoreML.Specification.FeatureDescription.type: object expected");
                        message.type = $root.CoreML.Specification.FeatureType.fromObject(object.type);
                    }
                    return message;
                };
    
                FeatureDescription.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.shortDescription = "";
                        object.type = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        object.shortDescription = message.shortDescription;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = $root.CoreML.Specification.FeatureType.toObject(message.type, options);
                    return object;
                };
    
                FeatureDescription.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FeatureDescription;
            })();
    
            Specification.Metadata = (function() {
    
                function Metadata(properties) {
                    this.userDefined = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Metadata.prototype.shortDescription = "";
                Metadata.prototype.versionString = "";
                Metadata.prototype.author = "";
                Metadata.prototype.license = "";
                Metadata.prototype.userDefined = $util.emptyObject;
    
                Metadata.create = function create(properties) {
                    return new Metadata(properties);
                };
    
                Metadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Metadata(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.shortDescription = reader.string();
                            break;
                        case 2:
                            message.versionString = reader.string();
                            break;
                        case 3:
                            message.author = reader.string();
                            break;
                        case 4:
                            message.license = reader.string();
                            break;
                        case 100:
                            reader.skip().pos++;
                            if (message.userDefined === $util.emptyObject)
                                message.userDefined = {};
                            key = reader.string();
                            reader.pos++;
                            message.userDefined[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Metadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    if (message.versionString != null && message.hasOwnProperty("versionString"))
                        if (!$util.isString(message.versionString))
                            return "versionString: string expected";
                    if (message.author != null && message.hasOwnProperty("author"))
                        if (!$util.isString(message.author))
                            return "author: string expected";
                    if (message.license != null && message.hasOwnProperty("license"))
                        if (!$util.isString(message.license))
                            return "license: string expected";
                    if (message.userDefined != null && message.hasOwnProperty("userDefined")) {
                        if (!$util.isObject(message.userDefined))
                            return "userDefined: object expected";
                        var key = Object.keys(message.userDefined);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.userDefined[key[i]]))
                                return "userDefined: string{k:string} expected";
                    }
                    return null;
                };
    
                Metadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Metadata)
                        return object;
                    var message = new $root.CoreML.Specification.Metadata();
                    if (object.shortDescription != null)
                        message.shortDescription = String(object.shortDescription);
                    if (object.versionString != null)
                        message.versionString = String(object.versionString);
                    if (object.author != null)
                        message.author = String(object.author);
                    if (object.license != null)
                        message.license = String(object.license);
                    if (object.userDefined) {
                        if (typeof object.userDefined !== "object")
                            throw TypeError(".CoreML.Specification.Metadata.userDefined: object expected");
                        message.userDefined = {};
                        for (var keys = Object.keys(object.userDefined), i = 0; i < keys.length; ++i)
                            message.userDefined[keys[i]] = String(object.userDefined[keys[i]]);
                    }
                    return message;
                };
    
                Metadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.userDefined = {};
                    if (options.defaults) {
                        object.shortDescription = "";
                        object.versionString = "";
                        object.author = "";
                        object.license = "";
                    }
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        object.shortDescription = message.shortDescription;
                    if (message.versionString != null && message.hasOwnProperty("versionString"))
                        object.versionString = message.versionString;
                    if (message.author != null && message.hasOwnProperty("author"))
                        object.author = message.author;
                    if (message.license != null && message.hasOwnProperty("license"))
                        object.license = message.license;
                    var keys2;
                    if (message.userDefined && (keys2 = Object.keys(message.userDefined)).length) {
                        object.userDefined = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.userDefined[keys2[j]] = message.userDefined[keys2[j]];
                    }
                    return object;
                };
    
                Metadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Metadata;
            })();
    
            Specification.ModelDescription = (function() {
    
                function ModelDescription(properties) {
                    this.input = [];
                    this.output = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ModelDescription.prototype.input = $util.emptyArray;
                ModelDescription.prototype.output = $util.emptyArray;
                ModelDescription.prototype.predictedFeatureName = "";
                ModelDescription.prototype.predictedProbabilitiesName = "";
                ModelDescription.prototype.metadata = null;
    
                ModelDescription.create = function create(properties) {
                    return new ModelDescription(properties);
                };
    
                ModelDescription.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ModelDescription();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.input && message.input.length))
                                message.input = [];
                            message.input.push($root.CoreML.Specification.FeatureDescription.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.output && message.output.length))
                                message.output = [];
                            message.output.push($root.CoreML.Specification.FeatureDescription.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            message.predictedFeatureName = reader.string();
                            break;
                        case 12:
                            message.predictedProbabilitiesName = reader.string();
                            break;
                        case 100:
                            message.metadata = $root.CoreML.Specification.Metadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ModelDescription.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.input != null && message.hasOwnProperty("input")) {
                        if (!Array.isArray(message.input))
                            return "input: array expected";
                        for (var i = 0; i < message.input.length; ++i) {
                            var error = $root.CoreML.Specification.FeatureDescription.verify(message.input[i]);
                            if (error)
                                return "input." + error;
                        }
                    }
                    if (message.output != null && message.hasOwnProperty("output")) {
                        if (!Array.isArray(message.output))
                            return "output: array expected";
                        for (var i = 0; i < message.output.length; ++i) {
                            var error = $root.CoreML.Specification.FeatureDescription.verify(message.output[i]);
                            if (error)
                                return "output." + error;
                        }
                    }
                    if (message.predictedFeatureName != null && message.hasOwnProperty("predictedFeatureName"))
                        if (!$util.isString(message.predictedFeatureName))
                            return "predictedFeatureName: string expected";
                    if (message.predictedProbabilitiesName != null && message.hasOwnProperty("predictedProbabilitiesName"))
                        if (!$util.isString(message.predictedProbabilitiesName))
                            return "predictedProbabilitiesName: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.CoreML.Specification.Metadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                ModelDescription.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ModelDescription)
                        return object;
                    var message = new $root.CoreML.Specification.ModelDescription();
                    if (object.input) {
                        if (!Array.isArray(object.input))
                            throw TypeError(".CoreML.Specification.ModelDescription.input: array expected");
                        message.input = [];
                        for (var i = 0; i < object.input.length; ++i) {
                            if (typeof object.input[i] !== "object")
                                throw TypeError(".CoreML.Specification.ModelDescription.input: object expected");
                            message.input[i] = $root.CoreML.Specification.FeatureDescription.fromObject(object.input[i]);
                        }
                    }
                    if (object.output) {
                        if (!Array.isArray(object.output))
                            throw TypeError(".CoreML.Specification.ModelDescription.output: array expected");
                        message.output = [];
                        for (var i = 0; i < object.output.length; ++i) {
                            if (typeof object.output[i] !== "object")
                                throw TypeError(".CoreML.Specification.ModelDescription.output: object expected");
                            message.output[i] = $root.CoreML.Specification.FeatureDescription.fromObject(object.output[i]);
                        }
                    }
                    if (object.predictedFeatureName != null)
                        message.predictedFeatureName = String(object.predictedFeatureName);
                    if (object.predictedProbabilitiesName != null)
                        message.predictedProbabilitiesName = String(object.predictedProbabilitiesName);
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".CoreML.Specification.ModelDescription.metadata: object expected");
                        message.metadata = $root.CoreML.Specification.Metadata.fromObject(object.metadata);
                    }
                    return message;
                };
    
                ModelDescription.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.input = [];
                        object.output = [];
                    }
                    if (options.defaults) {
                        object.predictedFeatureName = "";
                        object.predictedProbabilitiesName = "";
                        object.metadata = null;
                    }
                    if (message.input && message.input.length) {
                        object.input = [];
                        for (var j = 0; j < message.input.length; ++j)
                            object.input[j] = $root.CoreML.Specification.FeatureDescription.toObject(message.input[j], options);
                    }
                    if (message.output && message.output.length) {
                        object.output = [];
                        for (var j = 0; j < message.output.length; ++j)
                            object.output[j] = $root.CoreML.Specification.FeatureDescription.toObject(message.output[j], options);
                    }
                    if (message.predictedFeatureName != null && message.hasOwnProperty("predictedFeatureName"))
                        object.predictedFeatureName = message.predictedFeatureName;
                    if (message.predictedProbabilitiesName != null && message.hasOwnProperty("predictedProbabilitiesName"))
                        object.predictedProbabilitiesName = message.predictedProbabilitiesName;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.CoreML.Specification.Metadata.toObject(message.metadata, options);
                    return object;
                };
    
                ModelDescription.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ModelDescription;
            })();
    
            Specification.Model = (function() {
    
                function Model(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Model.prototype.specificationVersion = 0;
                Model.prototype.description = null;
                Model.prototype.pipelineClassifier = null;
                Model.prototype.pipelineRegressor = null;
                Model.prototype.pipeline = null;
                Model.prototype.glmRegressor = null;
                Model.prototype.supportVectorRegressor = null;
                Model.prototype.treeEnsembleRegressor = null;
                Model.prototype.neuralNetworkRegressor = null;
                Model.prototype.bayesianProbitRegressor = null;
                Model.prototype.glmClassifier = null;
                Model.prototype.supportVectorClassifier = null;
                Model.prototype.treeEnsembleClassifier = null;
                Model.prototype.neuralNetworkClassifier = null;
                Model.prototype.neuralNetwork = null;
                Model.prototype.customModel = null;
                Model.prototype.oneHotEncoder = null;
                Model.prototype.imputer = null;
                Model.prototype.featureVectorizer = null;
                Model.prototype.dictVectorizer = null;
                Model.prototype.scaler = null;
                Model.prototype.categoricalMapping = null;
                Model.prototype.normalizer = null;
                Model.prototype.arrayFeatureExtractor = null;
                Model.prototype.nonMaximumSuppression = null;
                Model.prototype.identity = null;
                Model.prototype.textClassifier = null;
                Model.prototype.wordTagger = null;
                Model.prototype.visionFeaturePrint = null;
    
                var $oneOfFields;
    
                Object.defineProperty(Model.prototype, "Type", {
                    get: $util.oneOfGetter($oneOfFields = ["pipelineClassifier", "pipelineRegressor", "pipeline", "glmRegressor", "supportVectorRegressor", "treeEnsembleRegressor", "neuralNetworkRegressor", "bayesianProbitRegressor", "glmClassifier", "supportVectorClassifier", "treeEnsembleClassifier", "neuralNetworkClassifier", "neuralNetwork", "customModel", "oneHotEncoder", "imputer", "featureVectorizer", "dictVectorizer", "scaler", "categoricalMapping", "normalizer", "arrayFeatureExtractor", "nonMaximumSuppression", "identity", "textClassifier", "wordTagger", "visionFeaturePrint"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Model.create = function create(properties) {
                    return new Model(properties);
                };
    
                Model.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Model();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.specificationVersion = reader.int32();
                            break;
                        case 2:
                            message.description = $root.CoreML.Specification.ModelDescription.decode(reader, reader.uint32());
                            break;
                        case 200:
                            message.pipelineClassifier = $root.CoreML.Specification.PipelineClassifier.decode(reader, reader.uint32());
                            break;
                        case 201:
                            message.pipelineRegressor = $root.CoreML.Specification.PipelineRegressor.decode(reader, reader.uint32());
                            break;
                        case 202:
                            message.pipeline = $root.CoreML.Specification.Pipeline.decode(reader, reader.uint32());
                            break;
                        case 300:
                            message.glmRegressor = $root.CoreML.Specification.GLMRegressor.decode(reader, reader.uint32());
                            break;
                        case 301:
                            message.supportVectorRegressor = $root.CoreML.Specification.SupportVectorRegressor.decode(reader, reader.uint32());
                            break;
                        case 302:
                            message.treeEnsembleRegressor = $root.CoreML.Specification.TreeEnsembleRegressor.decode(reader, reader.uint32());
                            break;
                        case 303:
                            message.neuralNetworkRegressor = $root.CoreML.Specification.NeuralNetworkRegressor.decode(reader, reader.uint32());
                            break;
                        case 304:
                            message.bayesianProbitRegressor = $root.CoreML.Specification.BayesianProbitRegressor.decode(reader, reader.uint32());
                            break;
                        case 400:
                            message.glmClassifier = $root.CoreML.Specification.GLMClassifier.decode(reader, reader.uint32());
                            break;
                        case 401:
                            message.supportVectorClassifier = $root.CoreML.Specification.SupportVectorClassifier.decode(reader, reader.uint32());
                            break;
                        case 402:
                            message.treeEnsembleClassifier = $root.CoreML.Specification.TreeEnsembleClassifier.decode(reader, reader.uint32());
                            break;
                        case 403:
                            message.neuralNetworkClassifier = $root.CoreML.Specification.NeuralNetworkClassifier.decode(reader, reader.uint32());
                            break;
                        case 500:
                            message.neuralNetwork = $root.CoreML.Specification.NeuralNetwork.decode(reader, reader.uint32());
                            break;
                        case 555:
                            message.customModel = $root.CoreML.Specification.CustomModel.decode(reader, reader.uint32());
                            break;
                        case 600:
                            message.oneHotEncoder = $root.CoreML.Specification.OneHotEncoder.decode(reader, reader.uint32());
                            break;
                        case 601:
                            message.imputer = $root.CoreML.Specification.Imputer.decode(reader, reader.uint32());
                            break;
                        case 602:
                            message.featureVectorizer = $root.CoreML.Specification.FeatureVectorizer.decode(reader, reader.uint32());
                            break;
                        case 603:
                            message.dictVectorizer = $root.CoreML.Specification.DictVectorizer.decode(reader, reader.uint32());
                            break;
                        case 604:
                            message.scaler = $root.CoreML.Specification.Scaler.decode(reader, reader.uint32());
                            break;
                        case 606:
                            message.categoricalMapping = $root.CoreML.Specification.CategoricalMapping.decode(reader, reader.uint32());
                            break;
                        case 607:
                            message.normalizer = $root.CoreML.Specification.Normalizer.decode(reader, reader.uint32());
                            break;
                        case 609:
                            message.arrayFeatureExtractor = $root.CoreML.Specification.ArrayFeatureExtractor.decode(reader, reader.uint32());
                            break;
                        case 610:
                            message.nonMaximumSuppression = $root.CoreML.Specification.NonMaximumSuppression.decode(reader, reader.uint32());
                            break;
                        case 900:
                            message.identity = $root.CoreML.Specification.Identity.decode(reader, reader.uint32());
                            break;
                        case 2000:
                            message.textClassifier = $root.CoreML.Specification.CoreMLModels.TextClassifier.decode(reader, reader.uint32());
                            break;
                        case 2001:
                            message.wordTagger = $root.CoreML.Specification.CoreMLModels.WordTagger.decode(reader, reader.uint32());
                            break;
                        case 2002:
                            message.visionFeaturePrint = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Model.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.specificationVersion != null && message.hasOwnProperty("specificationVersion"))
                        if (!$util.isInteger(message.specificationVersion))
                            return "specificationVersion: integer expected";
                    if (message.description != null && message.hasOwnProperty("description")) {
                        var error = $root.CoreML.Specification.ModelDescription.verify(message.description);
                        if (error)
                            return "description." + error;
                    }
                    if (message.pipelineClassifier != null && message.hasOwnProperty("pipelineClassifier")) {
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.PipelineClassifier.verify(message.pipelineClassifier);
                            if (error)
                                return "pipelineClassifier." + error;
                        }
                    }
                    if (message.pipelineRegressor != null && message.hasOwnProperty("pipelineRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.PipelineRegressor.verify(message.pipelineRegressor);
                            if (error)
                                return "pipelineRegressor." + error;
                        }
                    }
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Pipeline.verify(message.pipeline);
                            if (error)
                                return "pipeline." + error;
                        }
                    }
                    if (message.glmRegressor != null && message.hasOwnProperty("glmRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.GLMRegressor.verify(message.glmRegressor);
                            if (error)
                                return "glmRegressor." + error;
                        }
                    }
                    if (message.supportVectorRegressor != null && message.hasOwnProperty("supportVectorRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.SupportVectorRegressor.verify(message.supportVectorRegressor);
                            if (error)
                                return "supportVectorRegressor." + error;
                        }
                    }
                    if (message.treeEnsembleRegressor != null && message.hasOwnProperty("treeEnsembleRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.TreeEnsembleRegressor.verify(message.treeEnsembleRegressor);
                            if (error)
                                return "treeEnsembleRegressor." + error;
                        }
                    }
                    if (message.neuralNetworkRegressor != null && message.hasOwnProperty("neuralNetworkRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkRegressor.verify(message.neuralNetworkRegressor);
                            if (error)
                                return "neuralNetworkRegressor." + error;
                        }
                    }
                    if (message.bayesianProbitRegressor != null && message.hasOwnProperty("bayesianProbitRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.BayesianProbitRegressor.verify(message.bayesianProbitRegressor);
                            if (error)
                                return "bayesianProbitRegressor." + error;
                        }
                    }
                    if (message.glmClassifier != null && message.hasOwnProperty("glmClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.GLMClassifier.verify(message.glmClassifier);
                            if (error)
                                return "glmClassifier." + error;
                        }
                    }
                    if (message.supportVectorClassifier != null && message.hasOwnProperty("supportVectorClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.SupportVectorClassifier.verify(message.supportVectorClassifier);
                            if (error)
                                return "supportVectorClassifier." + error;
                        }
                    }
                    if (message.treeEnsembleClassifier != null && message.hasOwnProperty("treeEnsembleClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.TreeEnsembleClassifier.verify(message.treeEnsembleClassifier);
                            if (error)
                                return "treeEnsembleClassifier." + error;
                        }
                    }
                    if (message.neuralNetworkClassifier != null && message.hasOwnProperty("neuralNetworkClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkClassifier.verify(message.neuralNetworkClassifier);
                            if (error)
                                return "neuralNetworkClassifier." + error;
                        }
                    }
                    if (message.neuralNetwork != null && message.hasOwnProperty("neuralNetwork")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetwork.verify(message.neuralNetwork);
                            if (error)
                                return "neuralNetwork." + error;
                        }
                    }
                    if (message.customModel != null && message.hasOwnProperty("customModel")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.CustomModel.verify(message.customModel);
                            if (error)
                                return "customModel." + error;
                        }
                    }
                    if (message.oneHotEncoder != null && message.hasOwnProperty("oneHotEncoder")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.OneHotEncoder.verify(message.oneHotEncoder);
                            if (error)
                                return "oneHotEncoder." + error;
                        }
                    }
                    if (message.imputer != null && message.hasOwnProperty("imputer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Imputer.verify(message.imputer);
                            if (error)
                                return "imputer." + error;
                        }
                    }
                    if (message.featureVectorizer != null && message.hasOwnProperty("featureVectorizer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.FeatureVectorizer.verify(message.featureVectorizer);
                            if (error)
                                return "featureVectorizer." + error;
                        }
                    }
                    if (message.dictVectorizer != null && message.hasOwnProperty("dictVectorizer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.DictVectorizer.verify(message.dictVectorizer);
                            if (error)
                                return "dictVectorizer." + error;
                        }
                    }
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Scaler.verify(message.scaler);
                            if (error)
                                return "scaler." + error;
                        }
                    }
                    if (message.categoricalMapping != null && message.hasOwnProperty("categoricalMapping")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.CategoricalMapping.verify(message.categoricalMapping);
                            if (error)
                                return "categoricalMapping." + error;
                        }
                    }
                    if (message.normalizer != null && message.hasOwnProperty("normalizer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Normalizer.verify(message.normalizer);
                            if (error)
                                return "normalizer." + error;
                        }
                    }
                    if (message.arrayFeatureExtractor != null && message.hasOwnProperty("arrayFeatureExtractor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.ArrayFeatureExtractor.verify(message.arrayFeatureExtractor);
                            if (error)
                                return "arrayFeatureExtractor." + error;
                        }
                    }
                    if (message.nonMaximumSuppression != null && message.hasOwnProperty("nonMaximumSuppression")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NonMaximumSuppression.verify(message.nonMaximumSuppression);
                            if (error)
                                return "nonMaximumSuppression." + error;
                        }
                    }
                    if (message.identity != null && message.hasOwnProperty("identity")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Identity.verify(message.identity);
                            if (error)
                                return "identity." + error;
                        }
                    }
                    if (message.textClassifier != null && message.hasOwnProperty("textClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.CoreMLModels.TextClassifier.verify(message.textClassifier);
                            if (error)
                                return "textClassifier." + error;
                        }
                    }
                    if (message.wordTagger != null && message.hasOwnProperty("wordTagger")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.CoreMLModels.WordTagger.verify(message.wordTagger);
                            if (error)
                                return "wordTagger." + error;
                        }
                    }
                    if (message.visionFeaturePrint != null && message.hasOwnProperty("visionFeaturePrint")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.verify(message.visionFeaturePrint);
                            if (error)
                                return "visionFeaturePrint." + error;
                        }
                    }
                    return null;
                };
    
                Model.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Model)
                        return object;
                    var message = new $root.CoreML.Specification.Model();
                    if (object.specificationVersion != null)
                        message.specificationVersion = object.specificationVersion | 0;
                    if (object.description != null) {
                        if (typeof object.description !== "object")
                            throw TypeError(".CoreML.Specification.Model.description: object expected");
                        message.description = $root.CoreML.Specification.ModelDescription.fromObject(object.description);
                    }
                    if (object.pipelineClassifier != null) {
                        if (typeof object.pipelineClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.pipelineClassifier: object expected");
                        message.pipelineClassifier = $root.CoreML.Specification.PipelineClassifier.fromObject(object.pipelineClassifier);
                    }
                    if (object.pipelineRegressor != null) {
                        if (typeof object.pipelineRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.pipelineRegressor: object expected");
                        message.pipelineRegressor = $root.CoreML.Specification.PipelineRegressor.fromObject(object.pipelineRegressor);
                    }
                    if (object.pipeline != null) {
                        if (typeof object.pipeline !== "object")
                            throw TypeError(".CoreML.Specification.Model.pipeline: object expected");
                        message.pipeline = $root.CoreML.Specification.Pipeline.fromObject(object.pipeline);
                    }
                    if (object.glmRegressor != null) {
                        if (typeof object.glmRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.glmRegressor: object expected");
                        message.glmRegressor = $root.CoreML.Specification.GLMRegressor.fromObject(object.glmRegressor);
                    }
                    if (object.supportVectorRegressor != null) {
                        if (typeof object.supportVectorRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.supportVectorRegressor: object expected");
                        message.supportVectorRegressor = $root.CoreML.Specification.SupportVectorRegressor.fromObject(object.supportVectorRegressor);
                    }
                    if (object.treeEnsembleRegressor != null) {
                        if (typeof object.treeEnsembleRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.treeEnsembleRegressor: object expected");
                        message.treeEnsembleRegressor = $root.CoreML.Specification.TreeEnsembleRegressor.fromObject(object.treeEnsembleRegressor);
                    }
                    if (object.neuralNetworkRegressor != null) {
                        if (typeof object.neuralNetworkRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.neuralNetworkRegressor: object expected");
                        message.neuralNetworkRegressor = $root.CoreML.Specification.NeuralNetworkRegressor.fromObject(object.neuralNetworkRegressor);
                    }
                    if (object.bayesianProbitRegressor != null) {
                        if (typeof object.bayesianProbitRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.bayesianProbitRegressor: object expected");
                        message.bayesianProbitRegressor = $root.CoreML.Specification.BayesianProbitRegressor.fromObject(object.bayesianProbitRegressor);
                    }
                    if (object.glmClassifier != null) {
                        if (typeof object.glmClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.glmClassifier: object expected");
                        message.glmClassifier = $root.CoreML.Specification.GLMClassifier.fromObject(object.glmClassifier);
                    }
                    if (object.supportVectorClassifier != null) {
                        if (typeof object.supportVectorClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.supportVectorClassifier: object expected");
                        message.supportVectorClassifier = $root.CoreML.Specification.SupportVectorClassifier.fromObject(object.supportVectorClassifier);
                    }
                    if (object.treeEnsembleClassifier != null) {
                        if (typeof object.treeEnsembleClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.treeEnsembleClassifier: object expected");
                        message.treeEnsembleClassifier = $root.CoreML.Specification.TreeEnsembleClassifier.fromObject(object.treeEnsembleClassifier);
                    }
                    if (object.neuralNetworkClassifier != null) {
                        if (typeof object.neuralNetworkClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.neuralNetworkClassifier: object expected");
                        message.neuralNetworkClassifier = $root.CoreML.Specification.NeuralNetworkClassifier.fromObject(object.neuralNetworkClassifier);
                    }
                    if (object.neuralNetwork != null) {
                        if (typeof object.neuralNetwork !== "object")
                            throw TypeError(".CoreML.Specification.Model.neuralNetwork: object expected");
                        message.neuralNetwork = $root.CoreML.Specification.NeuralNetwork.fromObject(object.neuralNetwork);
                    }
                    if (object.customModel != null) {
                        if (typeof object.customModel !== "object")
                            throw TypeError(".CoreML.Specification.Model.customModel: object expected");
                        message.customModel = $root.CoreML.Specification.CustomModel.fromObject(object.customModel);
                    }
                    if (object.oneHotEncoder != null) {
                        if (typeof object.oneHotEncoder !== "object")
                            throw TypeError(".CoreML.Specification.Model.oneHotEncoder: object expected");
                        message.oneHotEncoder = $root.CoreML.Specification.OneHotEncoder.fromObject(object.oneHotEncoder);
                    }
                    if (object.imputer != null) {
                        if (typeof object.imputer !== "object")
                            throw TypeError(".CoreML.Specification.Model.imputer: object expected");
                        message.imputer = $root.CoreML.Specification.Imputer.fromObject(object.imputer);
                    }
                    if (object.featureVectorizer != null) {
                        if (typeof object.featureVectorizer !== "object")
                            throw TypeError(".CoreML.Specification.Model.featureVectorizer: object expected");
                        message.featureVectorizer = $root.CoreML.Specification.FeatureVectorizer.fromObject(object.featureVectorizer);
                    }
                    if (object.dictVectorizer != null) {
                        if (typeof object.dictVectorizer !== "object")
                            throw TypeError(".CoreML.Specification.Model.dictVectorizer: object expected");
                        message.dictVectorizer = $root.CoreML.Specification.DictVectorizer.fromObject(object.dictVectorizer);
                    }
                    if (object.scaler != null) {
                        if (typeof object.scaler !== "object")
                            throw TypeError(".CoreML.Specification.Model.scaler: object expected");
                        message.scaler = $root.CoreML.Specification.Scaler.fromObject(object.scaler);
                    }
                    if (object.categoricalMapping != null) {
                        if (typeof object.categoricalMapping !== "object")
                            throw TypeError(".CoreML.Specification.Model.categoricalMapping: object expected");
                        message.categoricalMapping = $root.CoreML.Specification.CategoricalMapping.fromObject(object.categoricalMapping);
                    }
                    if (object.normalizer != null) {
                        if (typeof object.normalizer !== "object")
                            throw TypeError(".CoreML.Specification.Model.normalizer: object expected");
                        message.normalizer = $root.CoreML.Specification.Normalizer.fromObject(object.normalizer);
                    }
                    if (object.arrayFeatureExtractor != null) {
                        if (typeof object.arrayFeatureExtractor !== "object")
                            throw TypeError(".CoreML.Specification.Model.arrayFeatureExtractor: object expected");
                        message.arrayFeatureExtractor = $root.CoreML.Specification.ArrayFeatureExtractor.fromObject(object.arrayFeatureExtractor);
                    }
                    if (object.nonMaximumSuppression != null) {
                        if (typeof object.nonMaximumSuppression !== "object")
                            throw TypeError(".CoreML.Specification.Model.nonMaximumSuppression: object expected");
                        message.nonMaximumSuppression = $root.CoreML.Specification.NonMaximumSuppression.fromObject(object.nonMaximumSuppression);
                    }
                    if (object.identity != null) {
                        if (typeof object.identity !== "object")
                            throw TypeError(".CoreML.Specification.Model.identity: object expected");
                        message.identity = $root.CoreML.Specification.Identity.fromObject(object.identity);
                    }
                    if (object.textClassifier != null) {
                        if (typeof object.textClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.textClassifier: object expected");
                        message.textClassifier = $root.CoreML.Specification.CoreMLModels.TextClassifier.fromObject(object.textClassifier);
                    }
                    if (object.wordTagger != null) {
                        if (typeof object.wordTagger !== "object")
                            throw TypeError(".CoreML.Specification.Model.wordTagger: object expected");
                        message.wordTagger = $root.CoreML.Specification.CoreMLModels.WordTagger.fromObject(object.wordTagger);
                    }
                    if (object.visionFeaturePrint != null) {
                        if (typeof object.visionFeaturePrint !== "object")
                            throw TypeError(".CoreML.Specification.Model.visionFeaturePrint: object expected");
                        message.visionFeaturePrint = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.fromObject(object.visionFeaturePrint);
                    }
                    return message;
                };
    
                Model.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.specificationVersion = 0;
                        object.description = null;
                    }
                    if (message.specificationVersion != null && message.hasOwnProperty("specificationVersion"))
                        object.specificationVersion = message.specificationVersion;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = $root.CoreML.Specification.ModelDescription.toObject(message.description, options);
                    if (message.pipelineClassifier != null && message.hasOwnProperty("pipelineClassifier")) {
                        object.pipelineClassifier = $root.CoreML.Specification.PipelineClassifier.toObject(message.pipelineClassifier, options);
                        if (options.oneofs)
                            object.Type = "pipelineClassifier";
                    }
                    if (message.pipelineRegressor != null && message.hasOwnProperty("pipelineRegressor")) {
                        object.pipelineRegressor = $root.CoreML.Specification.PipelineRegressor.toObject(message.pipelineRegressor, options);
                        if (options.oneofs)
                            object.Type = "pipelineRegressor";
                    }
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        object.pipeline = $root.CoreML.Specification.Pipeline.toObject(message.pipeline, options);
                        if (options.oneofs)
                            object.Type = "pipeline";
                    }
                    if (message.glmRegressor != null && message.hasOwnProperty("glmRegressor")) {
                        object.glmRegressor = $root.CoreML.Specification.GLMRegressor.toObject(message.glmRegressor, options);
                        if (options.oneofs)
                            object.Type = "glmRegressor";
                    }
                    if (message.supportVectorRegressor != null && message.hasOwnProperty("supportVectorRegressor")) {
                        object.supportVectorRegressor = $root.CoreML.Specification.SupportVectorRegressor.toObject(message.supportVectorRegressor, options);
                        if (options.oneofs)
                            object.Type = "supportVectorRegressor";
                    }
                    if (message.treeEnsembleRegressor != null && message.hasOwnProperty("treeEnsembleRegressor")) {
                        object.treeEnsembleRegressor = $root.CoreML.Specification.TreeEnsembleRegressor.toObject(message.treeEnsembleRegressor, options);
                        if (options.oneofs)
                            object.Type = "treeEnsembleRegressor";
                    }
                    if (message.neuralNetworkRegressor != null && message.hasOwnProperty("neuralNetworkRegressor")) {
                        object.neuralNetworkRegressor = $root.CoreML.Specification.NeuralNetworkRegressor.toObject(message.neuralNetworkRegressor, options);
                        if (options.oneofs)
                            object.Type = "neuralNetworkRegressor";
                    }
                    if (message.bayesianProbitRegressor != null && message.hasOwnProperty("bayesianProbitRegressor")) {
                        object.bayesianProbitRegressor = $root.CoreML.Specification.BayesianProbitRegressor.toObject(message.bayesianProbitRegressor, options);
                        if (options.oneofs)
                            object.Type = "bayesianProbitRegressor";
                    }
                    if (message.glmClassifier != null && message.hasOwnProperty("glmClassifier")) {
                        object.glmClassifier = $root.CoreML.Specification.GLMClassifier.toObject(message.glmClassifier, options);
                        if (options.oneofs)
                            object.Type = "glmClassifier";
                    }
                    if (message.supportVectorClassifier != null && message.hasOwnProperty("supportVectorClassifier")) {
                        object.supportVectorClassifier = $root.CoreML.Specification.SupportVectorClassifier.toObject(message.supportVectorClassifier, options);
                        if (options.oneofs)
                            object.Type = "supportVectorClassifier";
                    }
                    if (message.treeEnsembleClassifier != null && message.hasOwnProperty("treeEnsembleClassifier")) {
                        object.treeEnsembleClassifier = $root.CoreML.Specification.TreeEnsembleClassifier.toObject(message.treeEnsembleClassifier, options);
                        if (options.oneofs)
                            object.Type = "treeEnsembleClassifier";
                    }
                    if (message.neuralNetworkClassifier != null && message.hasOwnProperty("neuralNetworkClassifier")) {
                        object.neuralNetworkClassifier = $root.CoreML.Specification.NeuralNetworkClassifier.toObject(message.neuralNetworkClassifier, options);
                        if (options.oneofs)
                            object.Type = "neuralNetworkClassifier";
                    }
                    if (message.neuralNetwork != null && message.hasOwnProperty("neuralNetwork")) {
                        object.neuralNetwork = $root.CoreML.Specification.NeuralNetwork.toObject(message.neuralNetwork, options);
                        if (options.oneofs)
                            object.Type = "neuralNetwork";
                    }
                    if (message.customModel != null && message.hasOwnProperty("customModel")) {
                        object.customModel = $root.CoreML.Specification.CustomModel.toObject(message.customModel, options);
                        if (options.oneofs)
                            object.Type = "customModel";
                    }
                    if (message.oneHotEncoder != null && message.hasOwnProperty("oneHotEncoder")) {
                        object.oneHotEncoder = $root.CoreML.Specification.OneHotEncoder.toObject(message.oneHotEncoder, options);
                        if (options.oneofs)
                            object.Type = "oneHotEncoder";
                    }
                    if (message.imputer != null && message.hasOwnProperty("imputer")) {
                        object.imputer = $root.CoreML.Specification.Imputer.toObject(message.imputer, options);
                        if (options.oneofs)
                            object.Type = "imputer";
                    }
                    if (message.featureVectorizer != null && message.hasOwnProperty("featureVectorizer")) {
                        object.featureVectorizer = $root.CoreML.Specification.FeatureVectorizer.toObject(message.featureVectorizer, options);
                        if (options.oneofs)
                            object.Type = "featureVectorizer";
                    }
                    if (message.dictVectorizer != null && message.hasOwnProperty("dictVectorizer")) {
                        object.dictVectorizer = $root.CoreML.Specification.DictVectorizer.toObject(message.dictVectorizer, options);
                        if (options.oneofs)
                            object.Type = "dictVectorizer";
                    }
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        object.scaler = $root.CoreML.Specification.Scaler.toObject(message.scaler, options);
                        if (options.oneofs)
                            object.Type = "scaler";
                    }
                    if (message.categoricalMapping != null && message.hasOwnProperty("categoricalMapping")) {
                        object.categoricalMapping = $root.CoreML.Specification.CategoricalMapping.toObject(message.categoricalMapping, options);
                        if (options.oneofs)
                            object.Type = "categoricalMapping";
                    }
                    if (message.normalizer != null && message.hasOwnProperty("normalizer")) {
                        object.normalizer = $root.CoreML.Specification.Normalizer.toObject(message.normalizer, options);
                        if (options.oneofs)
                            object.Type = "normalizer";
                    }
                    if (message.arrayFeatureExtractor != null && message.hasOwnProperty("arrayFeatureExtractor")) {
                        object.arrayFeatureExtractor = $root.CoreML.Specification.ArrayFeatureExtractor.toObject(message.arrayFeatureExtractor, options);
                        if (options.oneofs)
                            object.Type = "arrayFeatureExtractor";
                    }
                    if (message.nonMaximumSuppression != null && message.hasOwnProperty("nonMaximumSuppression")) {
                        object.nonMaximumSuppression = $root.CoreML.Specification.NonMaximumSuppression.toObject(message.nonMaximumSuppression, options);
                        if (options.oneofs)
                            object.Type = "nonMaximumSuppression";
                    }
                    if (message.identity != null && message.hasOwnProperty("identity")) {
                        object.identity = $root.CoreML.Specification.Identity.toObject(message.identity, options);
                        if (options.oneofs)
                            object.Type = "identity";
                    }
                    if (message.textClassifier != null && message.hasOwnProperty("textClassifier")) {
                        object.textClassifier = $root.CoreML.Specification.CoreMLModels.TextClassifier.toObject(message.textClassifier, options);
                        if (options.oneofs)
                            object.Type = "textClassifier";
                    }
                    if (message.wordTagger != null && message.hasOwnProperty("wordTagger")) {
                        object.wordTagger = $root.CoreML.Specification.CoreMLModels.WordTagger.toObject(message.wordTagger, options);
                        if (options.oneofs)
                            object.Type = "wordTagger";
                    }
                    if (message.visionFeaturePrint != null && message.hasOwnProperty("visionFeaturePrint")) {
                        object.visionFeaturePrint = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.toObject(message.visionFeaturePrint, options);
                        if (options.oneofs)
                            object.Type = "visionFeaturePrint";
                    }
                    return object;
                };
    
                Model.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Model;
            })();
    
            Specification.CoreMLModels = (function() {
    
                var CoreMLModels = {};
    
                CoreMLModels.VisionFeaturePrint = (function() {
    
                    function VisionFeaturePrint(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    VisionFeaturePrint.prototype.scene = null;
    
                    var $oneOfFields;
    
                    Object.defineProperty(VisionFeaturePrint.prototype, "VisionFeaturePrintType", {
                        get: $util.oneOfGetter($oneOfFields = ["scene"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    VisionFeaturePrint.create = function create(properties) {
                        return new VisionFeaturePrint(properties);
                    };
    
                    VisionFeaturePrint.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 20:
                                message.scene = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    VisionFeaturePrint.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.scene != null && message.hasOwnProperty("scene")) {
                            properties.VisionFeaturePrintType = 1;
                            {
                                var error = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene.verify(message.scene);
                                if (error)
                                    return "scene." + error;
                            }
                        }
                        return null;
                    };
    
                    VisionFeaturePrint.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint)
                            return object;
                        var message = new $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint();
                        if (object.scene != null) {
                            if (typeof object.scene !== "object")
                                throw TypeError(".CoreML.Specification.CoreMLModels.VisionFeaturePrint.scene: object expected");
                            message.scene = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene.fromObject(object.scene);
                        }
                        return message;
                    };
    
                    VisionFeaturePrint.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.scene != null && message.hasOwnProperty("scene")) {
                            object.scene = $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene.toObject(message.scene, options);
                            if (options.oneofs)
                                object.VisionFeaturePrintType = "scene";
                        }
                        return object;
                    };
    
                    VisionFeaturePrint.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    VisionFeaturePrint.Scene = (function() {
    
                        function Scene(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        Scene.prototype.version = 0;
    
                        Scene.create = function create(properties) {
                            return new Scene(properties);
                        };
    
                        Scene.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.version = reader.int32();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        Scene.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.version != null && message.hasOwnProperty("version"))
                                switch (message.version) {
                                default:
                                    return "version: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };
    
                        Scene.fromObject = function fromObject(object) {
                            if (object instanceof $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene)
                                return object;
                            var message = new $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene();
                            switch (object.version) {
                            case "SCENE_VERSION_INVALID":
                            case 0:
                                message.version = 0;
                                break;
                            case "SCENE_VERSION_1":
                            case 1:
                                message.version = 1;
                                break;
                            }
                            return message;
                        };
    
                        Scene.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults)
                                object.version = options.enums === String ? "SCENE_VERSION_INVALID" : 0;
                            if (message.version != null && message.hasOwnProperty("version"))
                                object.version = options.enums === String ? $root.CoreML.Specification.CoreMLModels.VisionFeaturePrint.Scene.SceneVersion[message.version] : message.version;
                            return object;
                        };
    
                        Scene.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        Scene.SceneVersion = (function() {
                            var valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "SCENE_VERSION_INVALID"] = 0;
                            values[valuesById[1] = "SCENE_VERSION_1"] = 1;
                            return values;
                        })();
    
                        return Scene;
                    })();
    
                    return VisionFeaturePrint;
                })();
    
                CoreMLModels.TextClassifier = (function() {
    
                    function TextClassifier(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    TextClassifier.prototype.revision = 0;
                    TextClassifier.prototype.language = "";
                    TextClassifier.prototype.modelParameterData = $util.newBuffer([]);
                    TextClassifier.prototype.stringClassLabels = null;
    
                    var $oneOfFields;
    
                    Object.defineProperty(TextClassifier.prototype, "ClassLabels", {
                        get: $util.oneOfGetter($oneOfFields = ["stringClassLabels"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    TextClassifier.create = function create(properties) {
                        return new TextClassifier(properties);
                    };
    
                    TextClassifier.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CoreMLModels.TextClassifier();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.revision = reader.uint32();
                                break;
                            case 10:
                                message.language = reader.string();
                                break;
                            case 100:
                                message.modelParameterData = reader.bytes();
                                break;
                            case 200:
                                message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    TextClassifier.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.revision != null && message.hasOwnProperty("revision"))
                            if (!$util.isInteger(message.revision))
                                return "revision: integer expected";
                        if (message.language != null && message.hasOwnProperty("language"))
                            if (!$util.isString(message.language))
                                return "language: string expected";
                        if (message.modelParameterData != null && message.hasOwnProperty("modelParameterData"))
                            if (!(message.modelParameterData && typeof message.modelParameterData.length === "number" || $util.isString(message.modelParameterData)))
                                return "modelParameterData: buffer expected";
                        if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                            properties.ClassLabels = 1;
                            {
                                var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                                if (error)
                                    return "stringClassLabels." + error;
                            }
                        }
                        return null;
                    };
    
                    TextClassifier.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.CoreMLModels.TextClassifier)
                            return object;
                        var message = new $root.CoreML.Specification.CoreMLModels.TextClassifier();
                        if (object.revision != null)
                            message.revision = object.revision >>> 0;
                        if (object.language != null)
                            message.language = String(object.language);
                        if (object.modelParameterData != null)
                            if (typeof object.modelParameterData === "string")
                                $util.base64.decode(object.modelParameterData, message.modelParameterData = $util.newBuffer($util.base64.length(object.modelParameterData)), 0);
                            else if (object.modelParameterData.length)
                                message.modelParameterData = object.modelParameterData;
                        if (object.stringClassLabels != null) {
                            if (typeof object.stringClassLabels !== "object")
                                throw TypeError(".CoreML.Specification.CoreMLModels.TextClassifier.stringClassLabels: object expected");
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                        }
                        return message;
                    };
    
                    TextClassifier.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.revision = 0;
                            object.language = "";
                            if (options.bytes === String)
                                object.modelParameterData = "";
                            else {
                                object.modelParameterData = [];
                                if (options.bytes !== Array)
                                    object.modelParameterData = $util.newBuffer(object.modelParameterData);
                            }
                        }
                        if (message.revision != null && message.hasOwnProperty("revision"))
                            object.revision = message.revision;
                        if (message.language != null && message.hasOwnProperty("language"))
                            object.language = message.language;
                        if (message.modelParameterData != null && message.hasOwnProperty("modelParameterData"))
                            object.modelParameterData = options.bytes === String ? $util.base64.encode(message.modelParameterData, 0, message.modelParameterData.length) : options.bytes === Array ? Array.prototype.slice.call(message.modelParameterData) : message.modelParameterData;
                        if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                            object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                            if (options.oneofs)
                                object.ClassLabels = "stringClassLabels";
                        }
                        return object;
                    };
    
                    TextClassifier.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return TextClassifier;
                })();
    
                CoreMLModels.WordTagger = (function() {
    
                    function WordTagger(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    WordTagger.prototype.revision = 0;
                    WordTagger.prototype.language = "";
                    WordTagger.prototype.tokensOutputFeatureName = "";
                    WordTagger.prototype.tokenTagsOutputFeatureName = "";
                    WordTagger.prototype.tokenLocationsOutputFeatureName = "";
                    WordTagger.prototype.tokenLengthsOutputFeatureName = "";
                    WordTagger.prototype.modelParameterData = $util.newBuffer([]);
                    WordTagger.prototype.stringTags = null;
    
                    var $oneOfFields;
    
                    Object.defineProperty(WordTagger.prototype, "Tags", {
                        get: $util.oneOfGetter($oneOfFields = ["stringTags"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    WordTagger.create = function create(properties) {
                        return new WordTagger(properties);
                    };
    
                    WordTagger.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CoreMLModels.WordTagger();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.revision = reader.uint32();
                                break;
                            case 10:
                                message.language = reader.string();
                                break;
                            case 20:
                                message.tokensOutputFeatureName = reader.string();
                                break;
                            case 21:
                                message.tokenTagsOutputFeatureName = reader.string();
                                break;
                            case 22:
                                message.tokenLocationsOutputFeatureName = reader.string();
                                break;
                            case 23:
                                message.tokenLengthsOutputFeatureName = reader.string();
                                break;
                            case 100:
                                message.modelParameterData = reader.bytes();
                                break;
                            case 200:
                                message.stringTags = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    WordTagger.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.revision != null && message.hasOwnProperty("revision"))
                            if (!$util.isInteger(message.revision))
                                return "revision: integer expected";
                        if (message.language != null && message.hasOwnProperty("language"))
                            if (!$util.isString(message.language))
                                return "language: string expected";
                        if (message.tokensOutputFeatureName != null && message.hasOwnProperty("tokensOutputFeatureName"))
                            if (!$util.isString(message.tokensOutputFeatureName))
                                return "tokensOutputFeatureName: string expected";
                        if (message.tokenTagsOutputFeatureName != null && message.hasOwnProperty("tokenTagsOutputFeatureName"))
                            if (!$util.isString(message.tokenTagsOutputFeatureName))
                                return "tokenTagsOutputFeatureName: string expected";
                        if (message.tokenLocationsOutputFeatureName != null && message.hasOwnProperty("tokenLocationsOutputFeatureName"))
                            if (!$util.isString(message.tokenLocationsOutputFeatureName))
                                return "tokenLocationsOutputFeatureName: string expected";
                        if (message.tokenLengthsOutputFeatureName != null && message.hasOwnProperty("tokenLengthsOutputFeatureName"))
                            if (!$util.isString(message.tokenLengthsOutputFeatureName))
                                return "tokenLengthsOutputFeatureName: string expected";
                        if (message.modelParameterData != null && message.hasOwnProperty("modelParameterData"))
                            if (!(message.modelParameterData && typeof message.modelParameterData.length === "number" || $util.isString(message.modelParameterData)))
                                return "modelParameterData: buffer expected";
                        if (message.stringTags != null && message.hasOwnProperty("stringTags")) {
                            properties.Tags = 1;
                            {
                                var error = $root.CoreML.Specification.StringVector.verify(message.stringTags);
                                if (error)
                                    return "stringTags." + error;
                            }
                        }
                        return null;
                    };
    
                    WordTagger.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.CoreMLModels.WordTagger)
                            return object;
                        var message = new $root.CoreML.Specification.CoreMLModels.WordTagger();
                        if (object.revision != null)
                            message.revision = object.revision >>> 0;
                        if (object.language != null)
                            message.language = String(object.language);
                        if (object.tokensOutputFeatureName != null)
                            message.tokensOutputFeatureName = String(object.tokensOutputFeatureName);
                        if (object.tokenTagsOutputFeatureName != null)
                            message.tokenTagsOutputFeatureName = String(object.tokenTagsOutputFeatureName);
                        if (object.tokenLocationsOutputFeatureName != null)
                            message.tokenLocationsOutputFeatureName = String(object.tokenLocationsOutputFeatureName);
                        if (object.tokenLengthsOutputFeatureName != null)
                            message.tokenLengthsOutputFeatureName = String(object.tokenLengthsOutputFeatureName);
                        if (object.modelParameterData != null)
                            if (typeof object.modelParameterData === "string")
                                $util.base64.decode(object.modelParameterData, message.modelParameterData = $util.newBuffer($util.base64.length(object.modelParameterData)), 0);
                            else if (object.modelParameterData.length)
                                message.modelParameterData = object.modelParameterData;
                        if (object.stringTags != null) {
                            if (typeof object.stringTags !== "object")
                                throw TypeError(".CoreML.Specification.CoreMLModels.WordTagger.stringTags: object expected");
                            message.stringTags = $root.CoreML.Specification.StringVector.fromObject(object.stringTags);
                        }
                        return message;
                    };
    
                    WordTagger.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.revision = 0;
                            object.language = "";
                            object.tokensOutputFeatureName = "";
                            object.tokenTagsOutputFeatureName = "";
                            object.tokenLocationsOutputFeatureName = "";
                            object.tokenLengthsOutputFeatureName = "";
                            if (options.bytes === String)
                                object.modelParameterData = "";
                            else {
                                object.modelParameterData = [];
                                if (options.bytes !== Array)
                                    object.modelParameterData = $util.newBuffer(object.modelParameterData);
                            }
                        }
                        if (message.revision != null && message.hasOwnProperty("revision"))
                            object.revision = message.revision;
                        if (message.language != null && message.hasOwnProperty("language"))
                            object.language = message.language;
                        if (message.tokensOutputFeatureName != null && message.hasOwnProperty("tokensOutputFeatureName"))
                            object.tokensOutputFeatureName = message.tokensOutputFeatureName;
                        if (message.tokenTagsOutputFeatureName != null && message.hasOwnProperty("tokenTagsOutputFeatureName"))
                            object.tokenTagsOutputFeatureName = message.tokenTagsOutputFeatureName;
                        if (message.tokenLocationsOutputFeatureName != null && message.hasOwnProperty("tokenLocationsOutputFeatureName"))
                            object.tokenLocationsOutputFeatureName = message.tokenLocationsOutputFeatureName;
                        if (message.tokenLengthsOutputFeatureName != null && message.hasOwnProperty("tokenLengthsOutputFeatureName"))
                            object.tokenLengthsOutputFeatureName = message.tokenLengthsOutputFeatureName;
                        if (message.modelParameterData != null && message.hasOwnProperty("modelParameterData"))
                            object.modelParameterData = options.bytes === String ? $util.base64.encode(message.modelParameterData, 0, message.modelParameterData.length) : options.bytes === Array ? Array.prototype.slice.call(message.modelParameterData) : message.modelParameterData;
                        if (message.stringTags != null && message.hasOwnProperty("stringTags")) {
                            object.stringTags = $root.CoreML.Specification.StringVector.toObject(message.stringTags, options);
                            if (options.oneofs)
                                object.Tags = "stringTags";
                        }
                        return object;
                    };
    
                    WordTagger.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return WordTagger;
                })();
    
                return CoreMLModels;
            })();
    
            Specification.StringToInt64Map = (function() {
    
                function StringToInt64Map(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                StringToInt64Map.prototype.map = $util.emptyObject;
    
                StringToInt64Map.create = function create(properties) {
                    return new StringToInt64Map(properties);
                };
    
                StringToInt64Map.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringToInt64Map(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.string();
                            reader.pos++;
                            message.map[key] = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                StringToInt64Map.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isInteger(message.map[key[i]]) && !(message.map[key[i]] && $util.isInteger(message.map[key[i]].low) && $util.isInteger(message.map[key[i]].high)))
                                return "map: integer|Long{k:string} expected";
                    }
                    return null;
                };
    
                StringToInt64Map.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringToInt64Map)
                        return object;
                    var message = new $root.CoreML.Specification.StringToInt64Map();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.StringToInt64Map.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            if ($util.Long)
                                (message.map[keys[i]] = $util.Long.fromValue(object.map[keys[i]])).unsigned = false;
                            else if (typeof object.map[keys[i]] === "string")
                                message.map[keys[i]] = parseInt(object.map[keys[i]], 10);
                            else if (typeof object.map[keys[i]] === "number")
                                message.map[keys[i]] = object.map[keys[i]];
                            else if (typeof object.map[keys[i]] === "object")
                                message.map[keys[i]] = new $util.LongBits(object.map[keys[i]].low >>> 0, object.map[keys[i]].high >>> 0).toNumber();
                    }
                    return message;
                };
    
                StringToInt64Map.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            if (typeof message.map[keys2[j]] === "number")
                                object.map[keys2[j]] = options.longs === String ? String(message.map[keys2[j]]) : message.map[keys2[j]];
                            else
                                object.map[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.map[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.map[keys2[j]].low >>> 0, message.map[keys2[j]].high >>> 0).toNumber() : message.map[keys2[j]];
                    }
                    return object;
                };
    
                StringToInt64Map.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringToInt64Map;
            })();
    
            Specification.Int64ToStringMap = (function() {
    
                function Int64ToStringMap(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Int64ToStringMap.prototype.map = $util.emptyObject;
    
                Int64ToStringMap.create = function create(properties) {
                    return new Int64ToStringMap(properties);
                };
    
                Int64ToStringMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64ToStringMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.int64();
                            reader.pos++;
                            message.map[typeof key === "object" ? $util.longToHash(key) : key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Int64ToStringMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "map: integer|Long key{k:int64} expected";
                            if (!$util.isString(message.map[key[i]]))
                                return "map: string{k:int64} expected";
                        }
                    }
                    return null;
                };
    
                Int64ToStringMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64ToStringMap)
                        return object;
                    var message = new $root.CoreML.Specification.Int64ToStringMap();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.Int64ToStringMap.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            message.map[keys[i]] = String(object.map[keys[i]]);
                    }
                    return message;
                };
    
                Int64ToStringMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.map[keys2[j]] = message.map[keys2[j]];
                    }
                    return object;
                };
    
                Int64ToStringMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64ToStringMap;
            })();
    
            Specification.StringToDoubleMap = (function() {
    
                function StringToDoubleMap(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                StringToDoubleMap.prototype.map = $util.emptyObject;
    
                StringToDoubleMap.create = function create(properties) {
                    return new StringToDoubleMap(properties);
                };
    
                StringToDoubleMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringToDoubleMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.string();
                            reader.pos++;
                            message.map[key] = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                StringToDoubleMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i)
                            if (typeof message.map[key[i]] !== "number")
                                return "map: number{k:string} expected";
                    }
                    return null;
                };
    
                StringToDoubleMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringToDoubleMap)
                        return object;
                    var message = new $root.CoreML.Specification.StringToDoubleMap();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.StringToDoubleMap.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            message.map[keys[i]] = Number(object.map[keys[i]]);
                    }
                    return message;
                };
    
                StringToDoubleMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.map[keys2[j]] = options.json && !isFinite(message.map[keys2[j]]) ? String(message.map[keys2[j]]) : message.map[keys2[j]];
                    }
                    return object;
                };
    
                StringToDoubleMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringToDoubleMap;
            })();
    
            Specification.Int64ToDoubleMap = (function() {
    
                function Int64ToDoubleMap(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Int64ToDoubleMap.prototype.map = $util.emptyObject;
    
                Int64ToDoubleMap.create = function create(properties) {
                    return new Int64ToDoubleMap(properties);
                };
    
                Int64ToDoubleMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64ToDoubleMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.int64();
                            reader.pos++;
                            message.map[typeof key === "object" ? $util.longToHash(key) : key] = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Int64ToDoubleMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "map: integer|Long key{k:int64} expected";
                            if (typeof message.map[key[i]] !== "number")
                                return "map: number{k:int64} expected";
                        }
                    }
                    return null;
                };
    
                Int64ToDoubleMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64ToDoubleMap)
                        return object;
                    var message = new $root.CoreML.Specification.Int64ToDoubleMap();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.Int64ToDoubleMap.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            message.map[keys[i]] = Number(object.map[keys[i]]);
                    }
                    return message;
                };
    
                Int64ToDoubleMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.map[keys2[j]] = options.json && !isFinite(message.map[keys2[j]]) ? String(message.map[keys2[j]]) : message.map[keys2[j]];
                    }
                    return object;
                };
    
                Int64ToDoubleMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64ToDoubleMap;
            })();
    
            Specification.StringVector = (function() {
    
                function StringVector(properties) {
                    this.vector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                StringVector.prototype.vector = $util.emptyArray;
    
                StringVector.create = function create(properties) {
                    return new StringVector(properties);
                };
    
                StringVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vector && message.vector.length))
                                message.vector = [];
                            message.vector.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                StringVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vector != null && message.hasOwnProperty("vector")) {
                        if (!Array.isArray(message.vector))
                            return "vector: array expected";
                        for (var i = 0; i < message.vector.length; ++i)
                            if (!$util.isString(message.vector[i]))
                                return "vector: string[] expected";
                    }
                    return null;
                };
    
                StringVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringVector)
                        return object;
                    var message = new $root.CoreML.Specification.StringVector();
                    if (object.vector) {
                        if (!Array.isArray(object.vector))
                            throw TypeError(".CoreML.Specification.StringVector.vector: array expected");
                        message.vector = [];
                        for (var i = 0; i < object.vector.length; ++i)
                            message.vector[i] = String(object.vector[i]);
                    }
                    return message;
                };
    
                StringVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vector = [];
                    if (message.vector && message.vector.length) {
                        object.vector = [];
                        for (var j = 0; j < message.vector.length; ++j)
                            object.vector[j] = message.vector[j];
                    }
                    return object;
                };
    
                StringVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringVector;
            })();
    
            Specification.Int64Vector = (function() {
    
                function Int64Vector(properties) {
                    this.vector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Int64Vector.prototype.vector = $util.emptyArray;
    
                Int64Vector.create = function create(properties) {
                    return new Int64Vector(properties);
                };
    
                Int64Vector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64Vector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vector && message.vector.length))
                                message.vector = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.vector.push(reader.int64());
                            } else
                                message.vector.push(reader.int64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Int64Vector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vector != null && message.hasOwnProperty("vector")) {
                        if (!Array.isArray(message.vector))
                            return "vector: array expected";
                        for (var i = 0; i < message.vector.length; ++i)
                            if (!$util.isInteger(message.vector[i]) && !(message.vector[i] && $util.isInteger(message.vector[i].low) && $util.isInteger(message.vector[i].high)))
                                return "vector: integer|Long[] expected";
                    }
                    return null;
                };
    
                Int64Vector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64Vector)
                        return object;
                    var message = new $root.CoreML.Specification.Int64Vector();
                    if (object.vector) {
                        if (!Array.isArray(object.vector))
                            throw TypeError(".CoreML.Specification.Int64Vector.vector: array expected");
                        message.vector = [];
                        for (var i = 0; i < object.vector.length; ++i)
                            if ($util.Long)
                                (message.vector[i] = $util.Long.fromValue(object.vector[i])).unsigned = false;
                            else if (typeof object.vector[i] === "string")
                                message.vector[i] = parseInt(object.vector[i], 10);
                            else if (typeof object.vector[i] === "number")
                                message.vector[i] = object.vector[i];
                            else if (typeof object.vector[i] === "object")
                                message.vector[i] = new $util.LongBits(object.vector[i].low >>> 0, object.vector[i].high >>> 0).toNumber();
                    }
                    return message;
                };
    
                Int64Vector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vector = [];
                    if (message.vector && message.vector.length) {
                        object.vector = [];
                        for (var j = 0; j < message.vector.length; ++j)
                            if (typeof message.vector[j] === "number")
                                object.vector[j] = options.longs === String ? String(message.vector[j]) : message.vector[j];
                            else
                                object.vector[j] = options.longs === String ? $util.Long.prototype.toString.call(message.vector[j]) : options.longs === Number ? new $util.LongBits(message.vector[j].low >>> 0, message.vector[j].high >>> 0).toNumber() : message.vector[j];
                    }
                    return object;
                };
    
                Int64Vector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64Vector;
            })();
    
            Specification.DoubleVector = (function() {
    
                function DoubleVector(properties) {
                    this.vector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DoubleVector.prototype.vector = $util.emptyArray;
    
                DoubleVector.create = function create(properties) {
                    return new DoubleVector(properties);
                };
    
                DoubleVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DoubleVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vector && message.vector.length))
                                message.vector = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.vector.push(reader.double());
                            } else
                                message.vector.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DoubleVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vector != null && message.hasOwnProperty("vector")) {
                        if (!Array.isArray(message.vector))
                            return "vector: array expected";
                        for (var i = 0; i < message.vector.length; ++i)
                            if (typeof message.vector[i] !== "number")
                                return "vector: number[] expected";
                    }
                    return null;
                };
    
                DoubleVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DoubleVector)
                        return object;
                    var message = new $root.CoreML.Specification.DoubleVector();
                    if (object.vector) {
                        if (!Array.isArray(object.vector))
                            throw TypeError(".CoreML.Specification.DoubleVector.vector: array expected");
                        message.vector = [];
                        for (var i = 0; i < object.vector.length; ++i)
                            message.vector[i] = Number(object.vector[i]);
                    }
                    return message;
                };
    
                DoubleVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vector = [];
                    if (message.vector && message.vector.length) {
                        object.vector = [];
                        for (var j = 0; j < message.vector.length; ++j)
                            object.vector[j] = options.json && !isFinite(message.vector[j]) ? String(message.vector[j]) : message.vector[j];
                    }
                    return object;
                };
    
                DoubleVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DoubleVector;
            })();
    
            Specification.Int64FeatureType = (function() {
    
                function Int64FeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Int64FeatureType.create = function create(properties) {
                    return new Int64FeatureType(properties);
                };
    
                Int64FeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64FeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Int64FeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                Int64FeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64FeatureType)
                        return object;
                    return new $root.CoreML.Specification.Int64FeatureType();
                };
    
                Int64FeatureType.toObject = function toObject() {
                    return {};
                };
    
                Int64FeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64FeatureType;
            })();
    
            Specification.DoubleFeatureType = (function() {
    
                function DoubleFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DoubleFeatureType.create = function create(properties) {
                    return new DoubleFeatureType(properties);
                };
    
                DoubleFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DoubleFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DoubleFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                DoubleFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DoubleFeatureType)
                        return object;
                    return new $root.CoreML.Specification.DoubleFeatureType();
                };
    
                DoubleFeatureType.toObject = function toObject() {
                    return {};
                };
    
                DoubleFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DoubleFeatureType;
            })();
    
            Specification.StringFeatureType = (function() {
    
                function StringFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                StringFeatureType.create = function create(properties) {
                    return new StringFeatureType(properties);
                };
    
                StringFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                StringFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                StringFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringFeatureType)
                        return object;
                    return new $root.CoreML.Specification.StringFeatureType();
                };
    
                StringFeatureType.toObject = function toObject() {
                    return {};
                };
    
                StringFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringFeatureType;
            })();
    
            Specification.SizeRange = (function() {
    
                function SizeRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SizeRange.prototype.lowerBound = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                SizeRange.prototype.upperBound = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                SizeRange.create = function create(properties) {
                    return new SizeRange(properties);
                };
    
                SizeRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SizeRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.lowerBound = reader.uint64();
                            break;
                        case 2:
                            message.upperBound = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SizeRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.lowerBound != null && message.hasOwnProperty("lowerBound"))
                        if (!$util.isInteger(message.lowerBound) && !(message.lowerBound && $util.isInteger(message.lowerBound.low) && $util.isInteger(message.lowerBound.high)))
                            return "lowerBound: integer|Long expected";
                    if (message.upperBound != null && message.hasOwnProperty("upperBound"))
                        if (!$util.isInteger(message.upperBound) && !(message.upperBound && $util.isInteger(message.upperBound.low) && $util.isInteger(message.upperBound.high)))
                            return "upperBound: integer|Long expected";
                    return null;
                };
    
                SizeRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SizeRange)
                        return object;
                    var message = new $root.CoreML.Specification.SizeRange();
                    if (object.lowerBound != null)
                        if ($util.Long)
                            (message.lowerBound = $util.Long.fromValue(object.lowerBound)).unsigned = true;
                        else if (typeof object.lowerBound === "string")
                            message.lowerBound = parseInt(object.lowerBound, 10);
                        else if (typeof object.lowerBound === "number")
                            message.lowerBound = object.lowerBound;
                        else if (typeof object.lowerBound === "object")
                            message.lowerBound = new $util.LongBits(object.lowerBound.low >>> 0, object.lowerBound.high >>> 0).toNumber(true);
                    if (object.upperBound != null)
                        if ($util.Long)
                            (message.upperBound = $util.Long.fromValue(object.upperBound)).unsigned = false;
                        else if (typeof object.upperBound === "string")
                            message.upperBound = parseInt(object.upperBound, 10);
                        else if (typeof object.upperBound === "number")
                            message.upperBound = object.upperBound;
                        else if (typeof object.upperBound === "object")
                            message.upperBound = new $util.LongBits(object.upperBound.low >>> 0, object.upperBound.high >>> 0).toNumber();
                    return message;
                };
    
                SizeRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.lowerBound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.lowerBound = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.upperBound = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.upperBound = options.longs === String ? "0" : 0;
                    }
                    if (message.lowerBound != null && message.hasOwnProperty("lowerBound"))
                        if (typeof message.lowerBound === "number")
                            object.lowerBound = options.longs === String ? String(message.lowerBound) : message.lowerBound;
                        else
                            object.lowerBound = options.longs === String ? $util.Long.prototype.toString.call(message.lowerBound) : options.longs === Number ? new $util.LongBits(message.lowerBound.low >>> 0, message.lowerBound.high >>> 0).toNumber(true) : message.lowerBound;
                    if (message.upperBound != null && message.hasOwnProperty("upperBound"))
                        if (typeof message.upperBound === "number")
                            object.upperBound = options.longs === String ? String(message.upperBound) : message.upperBound;
                        else
                            object.upperBound = options.longs === String ? $util.Long.prototype.toString.call(message.upperBound) : options.longs === Number ? new $util.LongBits(message.upperBound.low >>> 0, message.upperBound.high >>> 0).toNumber() : message.upperBound;
                    return object;
                };
    
                SizeRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SizeRange;
            })();
    
            Specification.ImageFeatureType = (function() {
    
                function ImageFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ImageFeatureType.prototype.width = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                ImageFeatureType.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                ImageFeatureType.prototype.enumeratedSizes = null;
                ImageFeatureType.prototype.imageSizeRange = null;
                ImageFeatureType.prototype.colorSpace = 0;
    
                var $oneOfFields;
    
                Object.defineProperty(ImageFeatureType.prototype, "SizeFlexibility", {
                    get: $util.oneOfGetter($oneOfFields = ["enumeratedSizes", "imageSizeRange"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                ImageFeatureType.create = function create(properties) {
                    return new ImageFeatureType(properties);
                };
    
                ImageFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ImageFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.width = reader.int64();
                            break;
                        case 2:
                            message.height = reader.int64();
                            break;
                        case 21:
                            message.enumeratedSizes = $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.imageSizeRange = $root.CoreML.Specification.ImageFeatureType.ImageSizeRange.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.colorSpace = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ImageFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (!$util.isInteger(message.width) && !(message.width && $util.isInteger(message.width.low) && $util.isInteger(message.width.high)))
                            return "width: integer|Long expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    if (message.enumeratedSizes != null && message.hasOwnProperty("enumeratedSizes")) {
                        properties.SizeFlexibility = 1;
                        {
                            var error = $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.verify(message.enumeratedSizes);
                            if (error)
                                return "enumeratedSizes." + error;
                        }
                    }
                    if (message.imageSizeRange != null && message.hasOwnProperty("imageSizeRange")) {
                        if (properties.SizeFlexibility === 1)
                            return "SizeFlexibility: multiple values";
                        properties.SizeFlexibility = 1;
                        {
                            var error = $root.CoreML.Specification.ImageFeatureType.ImageSizeRange.verify(message.imageSizeRange);
                            if (error)
                                return "imageSizeRange." + error;
                        }
                    }
                    if (message.colorSpace != null && message.hasOwnProperty("colorSpace"))
                        switch (message.colorSpace) {
                        default:
                            return "colorSpace: enum value expected";
                        case 0:
                        case 10:
                        case 20:
                        case 30:
                            break;
                        }
                    return null;
                };
    
                ImageFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ImageFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.ImageFeatureType();
                    if (object.width != null)
                        if ($util.Long)
                            (message.width = $util.Long.fromValue(object.width)).unsigned = false;
                        else if (typeof object.width === "string")
                            message.width = parseInt(object.width, 10);
                        else if (typeof object.width === "number")
                            message.width = object.width;
                        else if (typeof object.width === "object")
                            message.width = new $util.LongBits(object.width.low >>> 0, object.width.high >>> 0).toNumber();
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = false;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();
                    if (object.enumeratedSizes != null) {
                        if (typeof object.enumeratedSizes !== "object")
                            throw TypeError(".CoreML.Specification.ImageFeatureType.enumeratedSizes: object expected");
                        message.enumeratedSizes = $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.fromObject(object.enumeratedSizes);
                    }
                    if (object.imageSizeRange != null) {
                        if (typeof object.imageSizeRange !== "object")
                            throw TypeError(".CoreML.Specification.ImageFeatureType.imageSizeRange: object expected");
                        message.imageSizeRange = $root.CoreML.Specification.ImageFeatureType.ImageSizeRange.fromObject(object.imageSizeRange);
                    }
                    switch (object.colorSpace) {
                    case "INVALID_COLOR_SPACE":
                    case 0:
                        message.colorSpace = 0;
                        break;
                    case "GRAYSCALE":
                    case 10:
                        message.colorSpace = 10;
                        break;
                    case "RGB":
                    case 20:
                        message.colorSpace = 20;
                        break;
                    case "BGR":
                    case 30:
                        message.colorSpace = 30;
                        break;
                    }
                    return message;
                };
    
                ImageFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.width = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.width = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                        object.colorSpace = options.enums === String ? "INVALID_COLOR_SPACE" : 0;
                    }
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (typeof message.width === "number")
                            object.width = options.longs === String ? String(message.width) : message.width;
                        else
                            object.width = options.longs === String ? $util.Long.prototype.toString.call(message.width) : options.longs === Number ? new $util.LongBits(message.width.low >>> 0, message.width.high >>> 0).toNumber() : message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;
                    if (message.colorSpace != null && message.hasOwnProperty("colorSpace"))
                        object.colorSpace = options.enums === String ? $root.CoreML.Specification.ImageFeatureType.ColorSpace[message.colorSpace] : message.colorSpace;
                    if (message.enumeratedSizes != null && message.hasOwnProperty("enumeratedSizes")) {
                        object.enumeratedSizes = $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.toObject(message.enumeratedSizes, options);
                        if (options.oneofs)
                            object.SizeFlexibility = "enumeratedSizes";
                    }
                    if (message.imageSizeRange != null && message.hasOwnProperty("imageSizeRange")) {
                        object.imageSizeRange = $root.CoreML.Specification.ImageFeatureType.ImageSizeRange.toObject(message.imageSizeRange, options);
                        if (options.oneofs)
                            object.SizeFlexibility = "imageSizeRange";
                    }
                    return object;
                };
    
                ImageFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                ImageFeatureType.ColorSpace = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_COLOR_SPACE"] = 0;
                    values[valuesById[10] = "GRAYSCALE"] = 10;
                    values[valuesById[20] = "RGB"] = 20;
                    values[valuesById[30] = "BGR"] = 30;
                    return values;
                })();
    
                ImageFeatureType.ImageSize = (function() {
    
                    function ImageSize(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    ImageSize.prototype.width = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    ImageSize.prototype.height = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    ImageSize.create = function create(properties) {
                        return new ImageSize(properties);
                    };
    
                    ImageSize.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ImageFeatureType.ImageSize();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.width = reader.uint64();
                                break;
                            case 2:
                                message.height = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    ImageSize.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.width != null && message.hasOwnProperty("width"))
                            if (!$util.isInteger(message.width) && !(message.width && $util.isInteger(message.width.low) && $util.isInteger(message.width.high)))
                                return "width: integer|Long expected";
                        if (message.height != null && message.hasOwnProperty("height"))
                            if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                                return "height: integer|Long expected";
                        return null;
                    };
    
                    ImageSize.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.ImageFeatureType.ImageSize)
                            return object;
                        var message = new $root.CoreML.Specification.ImageFeatureType.ImageSize();
                        if (object.width != null)
                            if ($util.Long)
                                (message.width = $util.Long.fromValue(object.width)).unsigned = true;
                            else if (typeof object.width === "string")
                                message.width = parseInt(object.width, 10);
                            else if (typeof object.width === "number")
                                message.width = object.width;
                            else if (typeof object.width === "object")
                                message.width = new $util.LongBits(object.width.low >>> 0, object.width.high >>> 0).toNumber(true);
                        if (object.height != null)
                            if ($util.Long)
                                (message.height = $util.Long.fromValue(object.height)).unsigned = true;
                            else if (typeof object.height === "string")
                                message.height = parseInt(object.height, 10);
                            else if (typeof object.height === "number")
                                message.height = object.height;
                            else if (typeof object.height === "object")
                                message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    ImageSize.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.width = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.width = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.height = options.longs === String ? "0" : 0;
                        }
                        if (message.width != null && message.hasOwnProperty("width"))
                            if (typeof message.width === "number")
                                object.width = options.longs === String ? String(message.width) : message.width;
                            else
                                object.width = options.longs === String ? $util.Long.prototype.toString.call(message.width) : options.longs === Number ? new $util.LongBits(message.width.low >>> 0, message.width.high >>> 0).toNumber(true) : message.width;
                        if (message.height != null && message.hasOwnProperty("height"))
                            if (typeof message.height === "number")
                                object.height = options.longs === String ? String(message.height) : message.height;
                            else
                                object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber(true) : message.height;
                        return object;
                    };
    
                    ImageSize.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ImageSize;
                })();
    
                ImageFeatureType.EnumeratedImageSizes = (function() {
    
                    function EnumeratedImageSizes(properties) {
                        this.sizes = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    EnumeratedImageSizes.prototype.sizes = $util.emptyArray;
    
                    EnumeratedImageSizes.create = function create(properties) {
                        return new EnumeratedImageSizes(properties);
                    };
    
                    EnumeratedImageSizes.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.sizes && message.sizes.length))
                                    message.sizes = [];
                                message.sizes.push($root.CoreML.Specification.ImageFeatureType.ImageSize.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    EnumeratedImageSizes.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sizes != null && message.hasOwnProperty("sizes")) {
                            if (!Array.isArray(message.sizes))
                                return "sizes: array expected";
                            for (var i = 0; i < message.sizes.length; ++i) {
                                var error = $root.CoreML.Specification.ImageFeatureType.ImageSize.verify(message.sizes[i]);
                                if (error)
                                    return "sizes." + error;
                            }
                        }
                        return null;
                    };
    
                    EnumeratedImageSizes.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes)
                            return object;
                        var message = new $root.CoreML.Specification.ImageFeatureType.EnumeratedImageSizes();
                        if (object.sizes) {
                            if (!Array.isArray(object.sizes))
                                throw TypeError(".CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes: array expected");
                            message.sizes = [];
                            for (var i = 0; i < object.sizes.length; ++i) {
                                if (typeof object.sizes[i] !== "object")
                                    throw TypeError(".CoreML.Specification.ImageFeatureType.EnumeratedImageSizes.sizes: object expected");
                                message.sizes[i] = $root.CoreML.Specification.ImageFeatureType.ImageSize.fromObject(object.sizes[i]);
                            }
                        }
                        return message;
                    };
    
                    EnumeratedImageSizes.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.sizes = [];
                        if (message.sizes && message.sizes.length) {
                            object.sizes = [];
                            for (var j = 0; j < message.sizes.length; ++j)
                                object.sizes[j] = $root.CoreML.Specification.ImageFeatureType.ImageSize.toObject(message.sizes[j], options);
                        }
                        return object;
                    };
    
                    EnumeratedImageSizes.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return EnumeratedImageSizes;
                })();
    
                ImageFeatureType.ImageSizeRange = (function() {
    
                    function ImageSizeRange(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    ImageSizeRange.prototype.widthRange = null;
                    ImageSizeRange.prototype.heightRange = null;
    
                    ImageSizeRange.create = function create(properties) {
                        return new ImageSizeRange(properties);
                    };
    
                    ImageSizeRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ImageFeatureType.ImageSizeRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.widthRange = $root.CoreML.Specification.SizeRange.decode(reader, reader.uint32());
                                break;
                            case 2:
                                message.heightRange = $root.CoreML.Specification.SizeRange.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    ImageSizeRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.widthRange != null && message.hasOwnProperty("widthRange")) {
                            var error = $root.CoreML.Specification.SizeRange.verify(message.widthRange);
                            if (error)
                                return "widthRange." + error;
                        }
                        if (message.heightRange != null && message.hasOwnProperty("heightRange")) {
                            var error = $root.CoreML.Specification.SizeRange.verify(message.heightRange);
                            if (error)
                                return "heightRange." + error;
                        }
                        return null;
                    };
    
                    ImageSizeRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.ImageFeatureType.ImageSizeRange)
                            return object;
                        var message = new $root.CoreML.Specification.ImageFeatureType.ImageSizeRange();
                        if (object.widthRange != null) {
                            if (typeof object.widthRange !== "object")
                                throw TypeError(".CoreML.Specification.ImageFeatureType.ImageSizeRange.widthRange: object expected");
                            message.widthRange = $root.CoreML.Specification.SizeRange.fromObject(object.widthRange);
                        }
                        if (object.heightRange != null) {
                            if (typeof object.heightRange !== "object")
                                throw TypeError(".CoreML.Specification.ImageFeatureType.ImageSizeRange.heightRange: object expected");
                            message.heightRange = $root.CoreML.Specification.SizeRange.fromObject(object.heightRange);
                        }
                        return message;
                    };
    
                    ImageSizeRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.widthRange = null;
                            object.heightRange = null;
                        }
                        if (message.widthRange != null && message.hasOwnProperty("widthRange"))
                            object.widthRange = $root.CoreML.Specification.SizeRange.toObject(message.widthRange, options);
                        if (message.heightRange != null && message.hasOwnProperty("heightRange"))
                            object.heightRange = $root.CoreML.Specification.SizeRange.toObject(message.heightRange, options);
                        return object;
                    };
    
                    ImageSizeRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ImageSizeRange;
                })();
    
                return ImageFeatureType;
            })();
    
            Specification.ArrayFeatureType = (function() {
    
                function ArrayFeatureType(properties) {
                    this.shape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ArrayFeatureType.prototype.shape = $util.emptyArray;
                ArrayFeatureType.prototype.dataType = 0;
                ArrayFeatureType.prototype.enumeratedShapes = null;
                ArrayFeatureType.prototype.shapeRange = null;
    
                var $oneOfFields;
    
                Object.defineProperty(ArrayFeatureType.prototype, "ShapeFlexibility", {
                    get: $util.oneOfGetter($oneOfFields = ["enumeratedShapes", "shapeRange"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                ArrayFeatureType.create = function create(properties) {
                    return new ArrayFeatureType(properties);
                };
    
                ArrayFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shape && message.shape.length))
                                message.shape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shape.push(reader.int64());
                            } else
                                message.shape.push(reader.int64());
                            break;
                        case 2:
                            message.dataType = reader.int32();
                            break;
                        case 21:
                            message.enumeratedShapes = $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.shapeRange = $root.CoreML.Specification.ArrayFeatureType.ShapeRange.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ArrayFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        if (!Array.isArray(message.shape))
                            return "shape: array expected";
                        for (var i = 0; i < message.shape.length; ++i)
                            if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                return "shape: integer|Long[] expected";
                    }
                    if (message.dataType != null && message.hasOwnProperty("dataType"))
                        switch (message.dataType) {
                        default:
                            return "dataType: enum value expected";
                        case 0:
                        case 65568:
                        case 65600:
                        case 131104:
                            break;
                        }
                    if (message.enumeratedShapes != null && message.hasOwnProperty("enumeratedShapes")) {
                        properties.ShapeFlexibility = 1;
                        {
                            var error = $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes.verify(message.enumeratedShapes);
                            if (error)
                                return "enumeratedShapes." + error;
                        }
                    }
                    if (message.shapeRange != null && message.hasOwnProperty("shapeRange")) {
                        if (properties.ShapeFlexibility === 1)
                            return "ShapeFlexibility: multiple values";
                        properties.ShapeFlexibility = 1;
                        {
                            var error = $root.CoreML.Specification.ArrayFeatureType.ShapeRange.verify(message.shapeRange);
                            if (error)
                                return "shapeRange." + error;
                        }
                    }
                    return null;
                };
    
                ArrayFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ArrayFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.ArrayFeatureType();
                    if (object.shape) {
                        if (!Array.isArray(object.shape))
                            throw TypeError(".CoreML.Specification.ArrayFeatureType.shape: array expected");
                        message.shape = [];
                        for (var i = 0; i < object.shape.length; ++i)
                            if ($util.Long)
                                (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = false;
                            else if (typeof object.shape[i] === "string")
                                message.shape[i] = parseInt(object.shape[i], 10);
                            else if (typeof object.shape[i] === "number")
                                message.shape[i] = object.shape[i];
                            else if (typeof object.shape[i] === "object")
                                message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber();
                    }
                    switch (object.dataType) {
                    case "INVALID_ARRAY_DATA_TYPE":
                    case 0:
                        message.dataType = 0;
                        break;
                    case "FLOAT32":
                    case 65568:
                        message.dataType = 65568;
                        break;
                    case "DOUBLE":
                    case 65600:
                        message.dataType = 65600;
                        break;
                    case "INT32":
                    case 131104:
                        message.dataType = 131104;
                        break;
                    }
                    if (object.enumeratedShapes != null) {
                        if (typeof object.enumeratedShapes !== "object")
                            throw TypeError(".CoreML.Specification.ArrayFeatureType.enumeratedShapes: object expected");
                        message.enumeratedShapes = $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes.fromObject(object.enumeratedShapes);
                    }
                    if (object.shapeRange != null) {
                        if (typeof object.shapeRange !== "object")
                            throw TypeError(".CoreML.Specification.ArrayFeatureType.shapeRange: object expected");
                        message.shapeRange = $root.CoreML.Specification.ArrayFeatureType.ShapeRange.fromObject(object.shapeRange);
                    }
                    return message;
                };
    
                ArrayFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.shape = [];
                    if (options.defaults)
                        object.dataType = options.enums === String ? "INVALID_ARRAY_DATA_TYPE" : 0;
                    if (message.shape && message.shape.length) {
                        object.shape = [];
                        for (var j = 0; j < message.shape.length; ++j)
                            if (typeof message.shape[j] === "number")
                                object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                            else
                                object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber() : message.shape[j];
                    }
                    if (message.dataType != null && message.hasOwnProperty("dataType"))
                        object.dataType = options.enums === String ? $root.CoreML.Specification.ArrayFeatureType.ArrayDataType[message.dataType] : message.dataType;
                    if (message.enumeratedShapes != null && message.hasOwnProperty("enumeratedShapes")) {
                        object.enumeratedShapes = $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes.toObject(message.enumeratedShapes, options);
                        if (options.oneofs)
                            object.ShapeFlexibility = "enumeratedShapes";
                    }
                    if (message.shapeRange != null && message.hasOwnProperty("shapeRange")) {
                        object.shapeRange = $root.CoreML.Specification.ArrayFeatureType.ShapeRange.toObject(message.shapeRange, options);
                        if (options.oneofs)
                            object.ShapeFlexibility = "shapeRange";
                    }
                    return object;
                };
    
                ArrayFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                ArrayFeatureType.ArrayDataType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_ARRAY_DATA_TYPE"] = 0;
                    values[valuesById[65568] = "FLOAT32"] = 65568;
                    values[valuesById[65600] = "DOUBLE"] = 65600;
                    values[valuesById[131104] = "INT32"] = 131104;
                    return values;
                })();
    
                ArrayFeatureType.Shape = (function() {
    
                    function Shape(properties) {
                        this.shape = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    Shape.prototype.shape = $util.emptyArray;
    
                    Shape.create = function create(properties) {
                        return new Shape(properties);
                    };
    
                    Shape.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureType.Shape();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.shape && message.shape.length))
                                    message.shape = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.shape.push(reader.int64());
                                } else
                                    message.shape.push(reader.int64());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    Shape.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.shape != null && message.hasOwnProperty("shape")) {
                            if (!Array.isArray(message.shape))
                                return "shape: array expected";
                            for (var i = 0; i < message.shape.length; ++i)
                                if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                    return "shape: integer|Long[] expected";
                        }
                        return null;
                    };
    
                    Shape.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.ArrayFeatureType.Shape)
                            return object;
                        var message = new $root.CoreML.Specification.ArrayFeatureType.Shape();
                        if (object.shape) {
                            if (!Array.isArray(object.shape))
                                throw TypeError(".CoreML.Specification.ArrayFeatureType.Shape.shape: array expected");
                            message.shape = [];
                            for (var i = 0; i < object.shape.length; ++i)
                                if ($util.Long)
                                    (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = false;
                                else if (typeof object.shape[i] === "string")
                                    message.shape[i] = parseInt(object.shape[i], 10);
                                else if (typeof object.shape[i] === "number")
                                    message.shape[i] = object.shape[i];
                                else if (typeof object.shape[i] === "object")
                                    message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber();
                        }
                        return message;
                    };
    
                    Shape.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.shape = [];
                        if (message.shape && message.shape.length) {
                            object.shape = [];
                            for (var j = 0; j < message.shape.length; ++j)
                                if (typeof message.shape[j] === "number")
                                    object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                                else
                                    object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber() : message.shape[j];
                        }
                        return object;
                    };
    
                    Shape.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Shape;
                })();
    
                ArrayFeatureType.EnumeratedShapes = (function() {
    
                    function EnumeratedShapes(properties) {
                        this.shapes = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    EnumeratedShapes.prototype.shapes = $util.emptyArray;
    
                    EnumeratedShapes.create = function create(properties) {
                        return new EnumeratedShapes(properties);
                    };
    
                    EnumeratedShapes.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.shapes && message.shapes.length))
                                    message.shapes = [];
                                message.shapes.push($root.CoreML.Specification.ArrayFeatureType.Shape.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    EnumeratedShapes.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.shapes != null && message.hasOwnProperty("shapes")) {
                            if (!Array.isArray(message.shapes))
                                return "shapes: array expected";
                            for (var i = 0; i < message.shapes.length; ++i) {
                                var error = $root.CoreML.Specification.ArrayFeatureType.Shape.verify(message.shapes[i]);
                                if (error)
                                    return "shapes." + error;
                            }
                        }
                        return null;
                    };
    
                    EnumeratedShapes.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes)
                            return object;
                        var message = new $root.CoreML.Specification.ArrayFeatureType.EnumeratedShapes();
                        if (object.shapes) {
                            if (!Array.isArray(object.shapes))
                                throw TypeError(".CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes: array expected");
                            message.shapes = [];
                            for (var i = 0; i < object.shapes.length; ++i) {
                                if (typeof object.shapes[i] !== "object")
                                    throw TypeError(".CoreML.Specification.ArrayFeatureType.EnumeratedShapes.shapes: object expected");
                                message.shapes[i] = $root.CoreML.Specification.ArrayFeatureType.Shape.fromObject(object.shapes[i]);
                            }
                        }
                        return message;
                    };
    
                    EnumeratedShapes.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.shapes = [];
                        if (message.shapes && message.shapes.length) {
                            object.shapes = [];
                            for (var j = 0; j < message.shapes.length; ++j)
                                object.shapes[j] = $root.CoreML.Specification.ArrayFeatureType.Shape.toObject(message.shapes[j], options);
                        }
                        return object;
                    };
    
                    EnumeratedShapes.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return EnumeratedShapes;
                })();
    
                ArrayFeatureType.ShapeRange = (function() {
    
                    function ShapeRange(properties) {
                        this.sizeRanges = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    ShapeRange.prototype.sizeRanges = $util.emptyArray;
    
                    ShapeRange.create = function create(properties) {
                        return new ShapeRange(properties);
                    };
    
                    ShapeRange.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureType.ShapeRange();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.sizeRanges && message.sizeRanges.length))
                                    message.sizeRanges = [];
                                message.sizeRanges.push($root.CoreML.Specification.SizeRange.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    ShapeRange.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.sizeRanges != null && message.hasOwnProperty("sizeRanges")) {
                            if (!Array.isArray(message.sizeRanges))
                                return "sizeRanges: array expected";
                            for (var i = 0; i < message.sizeRanges.length; ++i) {
                                var error = $root.CoreML.Specification.SizeRange.verify(message.sizeRanges[i]);
                                if (error)
                                    return "sizeRanges." + error;
                            }
                        }
                        return null;
                    };
    
                    ShapeRange.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.ArrayFeatureType.ShapeRange)
                            return object;
                        var message = new $root.CoreML.Specification.ArrayFeatureType.ShapeRange();
                        if (object.sizeRanges) {
                            if (!Array.isArray(object.sizeRanges))
                                throw TypeError(".CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges: array expected");
                            message.sizeRanges = [];
                            for (var i = 0; i < object.sizeRanges.length; ++i) {
                                if (typeof object.sizeRanges[i] !== "object")
                                    throw TypeError(".CoreML.Specification.ArrayFeatureType.ShapeRange.sizeRanges: object expected");
                                message.sizeRanges[i] = $root.CoreML.Specification.SizeRange.fromObject(object.sizeRanges[i]);
                            }
                        }
                        return message;
                    };
    
                    ShapeRange.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.sizeRanges = [];
                        if (message.sizeRanges && message.sizeRanges.length) {
                            object.sizeRanges = [];
                            for (var j = 0; j < message.sizeRanges.length; ++j)
                                object.sizeRanges[j] = $root.CoreML.Specification.SizeRange.toObject(message.sizeRanges[j], options);
                        }
                        return object;
                    };
    
                    ShapeRange.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ShapeRange;
                })();
    
                return ArrayFeatureType;
            })();
    
            Specification.DictionaryFeatureType = (function() {
    
                function DictionaryFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DictionaryFeatureType.prototype.int64KeyType = null;
                DictionaryFeatureType.prototype.stringKeyType = null;
    
                var $oneOfFields;
    
                Object.defineProperty(DictionaryFeatureType.prototype, "KeyType", {
                    get: $util.oneOfGetter($oneOfFields = ["int64KeyType", "stringKeyType"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                DictionaryFeatureType.create = function create(properties) {
                    return new DictionaryFeatureType(properties);
                };
    
                DictionaryFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DictionaryFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.int64KeyType = $root.CoreML.Specification.Int64FeatureType.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.stringKeyType = $root.CoreML.Specification.StringFeatureType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DictionaryFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.int64KeyType != null && message.hasOwnProperty("int64KeyType")) {
                        properties.KeyType = 1;
                        {
                            var error = $root.CoreML.Specification.Int64FeatureType.verify(message.int64KeyType);
                            if (error)
                                return "int64KeyType." + error;
                        }
                    }
                    if (message.stringKeyType != null && message.hasOwnProperty("stringKeyType")) {
                        if (properties.KeyType === 1)
                            return "KeyType: multiple values";
                        properties.KeyType = 1;
                        {
                            var error = $root.CoreML.Specification.StringFeatureType.verify(message.stringKeyType);
                            if (error)
                                return "stringKeyType." + error;
                        }
                    }
                    return null;
                };
    
                DictionaryFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DictionaryFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.DictionaryFeatureType();
                    if (object.int64KeyType != null) {
                        if (typeof object.int64KeyType !== "object")
                            throw TypeError(".CoreML.Specification.DictionaryFeatureType.int64KeyType: object expected");
                        message.int64KeyType = $root.CoreML.Specification.Int64FeatureType.fromObject(object.int64KeyType);
                    }
                    if (object.stringKeyType != null) {
                        if (typeof object.stringKeyType !== "object")
                            throw TypeError(".CoreML.Specification.DictionaryFeatureType.stringKeyType: object expected");
                        message.stringKeyType = $root.CoreML.Specification.StringFeatureType.fromObject(object.stringKeyType);
                    }
                    return message;
                };
    
                DictionaryFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.int64KeyType != null && message.hasOwnProperty("int64KeyType")) {
                        object.int64KeyType = $root.CoreML.Specification.Int64FeatureType.toObject(message.int64KeyType, options);
                        if (options.oneofs)
                            object.KeyType = "int64KeyType";
                    }
                    if (message.stringKeyType != null && message.hasOwnProperty("stringKeyType")) {
                        object.stringKeyType = $root.CoreML.Specification.StringFeatureType.toObject(message.stringKeyType, options);
                        if (options.oneofs)
                            object.KeyType = "stringKeyType";
                    }
                    return object;
                };
    
                DictionaryFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictionaryFeatureType;
            })();
    
            Specification.SequenceFeatureType = (function() {
    
                function SequenceFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SequenceFeatureType.prototype.int64Type = null;
                SequenceFeatureType.prototype.stringType = null;
                SequenceFeatureType.prototype.sizeRange = null;
    
                var $oneOfFields;
    
                Object.defineProperty(SequenceFeatureType.prototype, "Type", {
                    get: $util.oneOfGetter($oneOfFields = ["int64Type", "stringType"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                SequenceFeatureType.create = function create(properties) {
                    return new SequenceFeatureType(properties);
                };
    
                SequenceFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SequenceFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.int64Type = $root.CoreML.Specification.Int64FeatureType.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.stringType = $root.CoreML.Specification.StringFeatureType.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.sizeRange = $root.CoreML.Specification.SizeRange.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SequenceFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.int64Type != null && message.hasOwnProperty("int64Type")) {
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Int64FeatureType.verify(message.int64Type);
                            if (error)
                                return "int64Type." + error;
                        }
                    }
                    if (message.stringType != null && message.hasOwnProperty("stringType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.StringFeatureType.verify(message.stringType);
                            if (error)
                                return "stringType." + error;
                        }
                    }
                    if (message.sizeRange != null && message.hasOwnProperty("sizeRange")) {
                        var error = $root.CoreML.Specification.SizeRange.verify(message.sizeRange);
                        if (error)
                            return "sizeRange." + error;
                    }
                    return null;
                };
    
                SequenceFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SequenceFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.SequenceFeatureType();
                    if (object.int64Type != null) {
                        if (typeof object.int64Type !== "object")
                            throw TypeError(".CoreML.Specification.SequenceFeatureType.int64Type: object expected");
                        message.int64Type = $root.CoreML.Specification.Int64FeatureType.fromObject(object.int64Type);
                    }
                    if (object.stringType != null) {
                        if (typeof object.stringType !== "object")
                            throw TypeError(".CoreML.Specification.SequenceFeatureType.stringType: object expected");
                        message.stringType = $root.CoreML.Specification.StringFeatureType.fromObject(object.stringType);
                    }
                    if (object.sizeRange != null) {
                        if (typeof object.sizeRange !== "object")
                            throw TypeError(".CoreML.Specification.SequenceFeatureType.sizeRange: object expected");
                        message.sizeRange = $root.CoreML.Specification.SizeRange.fromObject(object.sizeRange);
                    }
                    return message;
                };
    
                SequenceFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.sizeRange = null;
                    if (message.int64Type != null && message.hasOwnProperty("int64Type")) {
                        object.int64Type = $root.CoreML.Specification.Int64FeatureType.toObject(message.int64Type, options);
                        if (options.oneofs)
                            object.Type = "int64Type";
                    }
                    if (message.stringType != null && message.hasOwnProperty("stringType")) {
                        object.stringType = $root.CoreML.Specification.StringFeatureType.toObject(message.stringType, options);
                        if (options.oneofs)
                            object.Type = "stringType";
                    }
                    if (message.sizeRange != null && message.hasOwnProperty("sizeRange"))
                        object.sizeRange = $root.CoreML.Specification.SizeRange.toObject(message.sizeRange, options);
                    return object;
                };
    
                SequenceFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SequenceFeatureType;
            })();
    
            Specification.FeatureType = (function() {
    
                function FeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                FeatureType.prototype.int64Type = null;
                FeatureType.prototype.doubleType = null;
                FeatureType.prototype.stringType = null;
                FeatureType.prototype.imageType = null;
                FeatureType.prototype.multiArrayType = null;
                FeatureType.prototype.dictionaryType = null;
                FeatureType.prototype.sequenceType = null;
                FeatureType.prototype.isOptional = false;
    
                var $oneOfFields;
    
                Object.defineProperty(FeatureType.prototype, "Type", {
                    get: $util.oneOfGetter($oneOfFields = ["int64Type", "doubleType", "stringType", "imageType", "multiArrayType", "dictionaryType", "sequenceType"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                FeatureType.create = function create(properties) {
                    return new FeatureType(properties);
                };
    
                FeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.int64Type = $root.CoreML.Specification.Int64FeatureType.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.doubleType = $root.CoreML.Specification.DoubleFeatureType.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.stringType = $root.CoreML.Specification.StringFeatureType.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.imageType = $root.CoreML.Specification.ImageFeatureType.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.multiArrayType = $root.CoreML.Specification.ArrayFeatureType.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.dictionaryType = $root.CoreML.Specification.DictionaryFeatureType.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.sequenceType = $root.CoreML.Specification.SequenceFeatureType.decode(reader, reader.uint32());
                            break;
                        case 1000:
                            message.isOptional = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                FeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.int64Type != null && message.hasOwnProperty("int64Type")) {
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Int64FeatureType.verify(message.int64Type);
                            if (error)
                                return "int64Type." + error;
                        }
                    }
                    if (message.doubleType != null && message.hasOwnProperty("doubleType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.DoubleFeatureType.verify(message.doubleType);
                            if (error)
                                return "doubleType." + error;
                        }
                    }
                    if (message.stringType != null && message.hasOwnProperty("stringType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.StringFeatureType.verify(message.stringType);
                            if (error)
                                return "stringType." + error;
                        }
                    }
                    if (message.imageType != null && message.hasOwnProperty("imageType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.ImageFeatureType.verify(message.imageType);
                            if (error)
                                return "imageType." + error;
                        }
                    }
                    if (message.multiArrayType != null && message.hasOwnProperty("multiArrayType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.ArrayFeatureType.verify(message.multiArrayType);
                            if (error)
                                return "multiArrayType." + error;
                        }
                    }
                    if (message.dictionaryType != null && message.hasOwnProperty("dictionaryType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.DictionaryFeatureType.verify(message.dictionaryType);
                            if (error)
                                return "dictionaryType." + error;
                        }
                    }
                    if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.SequenceFeatureType.verify(message.sequenceType);
                            if (error)
                                return "sequenceType." + error;
                        }
                    }
                    if (message.isOptional != null && message.hasOwnProperty("isOptional"))
                        if (typeof message.isOptional !== "boolean")
                            return "isOptional: boolean expected";
                    return null;
                };
    
                FeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.FeatureType();
                    if (object.int64Type != null) {
                        if (typeof object.int64Type !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.int64Type: object expected");
                        message.int64Type = $root.CoreML.Specification.Int64FeatureType.fromObject(object.int64Type);
                    }
                    if (object.doubleType != null) {
                        if (typeof object.doubleType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.doubleType: object expected");
                        message.doubleType = $root.CoreML.Specification.DoubleFeatureType.fromObject(object.doubleType);
                    }
                    if (object.stringType != null) {
                        if (typeof object.stringType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.stringType: object expected");
                        message.stringType = $root.CoreML.Specification.StringFeatureType.fromObject(object.stringType);
                    }
                    if (object.imageType != null) {
                        if (typeof object.imageType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.imageType: object expected");
                        message.imageType = $root.CoreML.Specification.ImageFeatureType.fromObject(object.imageType);
                    }
                    if (object.multiArrayType != null) {
                        if (typeof object.multiArrayType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.multiArrayType: object expected");
                        message.multiArrayType = $root.CoreML.Specification.ArrayFeatureType.fromObject(object.multiArrayType);
                    }
                    if (object.dictionaryType != null) {
                        if (typeof object.dictionaryType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.dictionaryType: object expected");
                        message.dictionaryType = $root.CoreML.Specification.DictionaryFeatureType.fromObject(object.dictionaryType);
                    }
                    if (object.sequenceType != null) {
                        if (typeof object.sequenceType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.sequenceType: object expected");
                        message.sequenceType = $root.CoreML.Specification.SequenceFeatureType.fromObject(object.sequenceType);
                    }
                    if (object.isOptional != null)
                        message.isOptional = Boolean(object.isOptional);
                    return message;
                };
    
                FeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.isOptional = false;
                    if (message.int64Type != null && message.hasOwnProperty("int64Type")) {
                        object.int64Type = $root.CoreML.Specification.Int64FeatureType.toObject(message.int64Type, options);
                        if (options.oneofs)
                            object.Type = "int64Type";
                    }
                    if (message.doubleType != null && message.hasOwnProperty("doubleType")) {
                        object.doubleType = $root.CoreML.Specification.DoubleFeatureType.toObject(message.doubleType, options);
                        if (options.oneofs)
                            object.Type = "doubleType";
                    }
                    if (message.stringType != null && message.hasOwnProperty("stringType")) {
                        object.stringType = $root.CoreML.Specification.StringFeatureType.toObject(message.stringType, options);
                        if (options.oneofs)
                            object.Type = "stringType";
                    }
                    if (message.imageType != null && message.hasOwnProperty("imageType")) {
                        object.imageType = $root.CoreML.Specification.ImageFeatureType.toObject(message.imageType, options);
                        if (options.oneofs)
                            object.Type = "imageType";
                    }
                    if (message.multiArrayType != null && message.hasOwnProperty("multiArrayType")) {
                        object.multiArrayType = $root.CoreML.Specification.ArrayFeatureType.toObject(message.multiArrayType, options);
                        if (options.oneofs)
                            object.Type = "multiArrayType";
                    }
                    if (message.dictionaryType != null && message.hasOwnProperty("dictionaryType")) {
                        object.dictionaryType = $root.CoreML.Specification.DictionaryFeatureType.toObject(message.dictionaryType, options);
                        if (options.oneofs)
                            object.Type = "dictionaryType";
                    }
                    if (message.sequenceType != null && message.hasOwnProperty("sequenceType")) {
                        object.sequenceType = $root.CoreML.Specification.SequenceFeatureType.toObject(message.sequenceType, options);
                        if (options.oneofs)
                            object.Type = "sequenceType";
                    }
                    if (message.isOptional != null && message.hasOwnProperty("isOptional"))
                        object.isOptional = message.isOptional;
                    return object;
                };
    
                FeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FeatureType;
            })();
    
            Specification.ArrayFeatureExtractor = (function() {
    
                function ArrayFeatureExtractor(properties) {
                    this.extractIndex = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ArrayFeatureExtractor.prototype.extractIndex = $util.emptyArray;
    
                ArrayFeatureExtractor.create = function create(properties) {
                    return new ArrayFeatureExtractor(properties);
                };
    
                ArrayFeatureExtractor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureExtractor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.extractIndex && message.extractIndex.length))
                                message.extractIndex = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.extractIndex.push(reader.uint64());
                            } else
                                message.extractIndex.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ArrayFeatureExtractor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.extractIndex != null && message.hasOwnProperty("extractIndex")) {
                        if (!Array.isArray(message.extractIndex))
                            return "extractIndex: array expected";
                        for (var i = 0; i < message.extractIndex.length; ++i)
                            if (!$util.isInteger(message.extractIndex[i]) && !(message.extractIndex[i] && $util.isInteger(message.extractIndex[i].low) && $util.isInteger(message.extractIndex[i].high)))
                                return "extractIndex: integer|Long[] expected";
                    }
                    return null;
                };
    
                ArrayFeatureExtractor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ArrayFeatureExtractor)
                        return object;
                    var message = new $root.CoreML.Specification.ArrayFeatureExtractor();
                    if (object.extractIndex) {
                        if (!Array.isArray(object.extractIndex))
                            throw TypeError(".CoreML.Specification.ArrayFeatureExtractor.extractIndex: array expected");
                        message.extractIndex = [];
                        for (var i = 0; i < object.extractIndex.length; ++i)
                            if ($util.Long)
                                (message.extractIndex[i] = $util.Long.fromValue(object.extractIndex[i])).unsigned = true;
                            else if (typeof object.extractIndex[i] === "string")
                                message.extractIndex[i] = parseInt(object.extractIndex[i], 10);
                            else if (typeof object.extractIndex[i] === "number")
                                message.extractIndex[i] = object.extractIndex[i];
                            else if (typeof object.extractIndex[i] === "object")
                                message.extractIndex[i] = new $util.LongBits(object.extractIndex[i].low >>> 0, object.extractIndex[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                ArrayFeatureExtractor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.extractIndex = [];
                    if (message.extractIndex && message.extractIndex.length) {
                        object.extractIndex = [];
                        for (var j = 0; j < message.extractIndex.length; ++j)
                            if (typeof message.extractIndex[j] === "number")
                                object.extractIndex[j] = options.longs === String ? String(message.extractIndex[j]) : message.extractIndex[j];
                            else
                                object.extractIndex[j] = options.longs === String ? $util.Long.prototype.toString.call(message.extractIndex[j]) : options.longs === Number ? new $util.LongBits(message.extractIndex[j].low >>> 0, message.extractIndex[j].high >>> 0).toNumber(true) : message.extractIndex[j];
                    }
                    return object;
                };
    
                ArrayFeatureExtractor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ArrayFeatureExtractor;
            })();
    
            Specification.BayesianProbitRegressor = (function() {
    
                function BayesianProbitRegressor(properties) {
                    this.features = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                BayesianProbitRegressor.prototype.numberOfFeatures = 0;
                BayesianProbitRegressor.prototype.bias = null;
                BayesianProbitRegressor.prototype.features = $util.emptyArray;
                BayesianProbitRegressor.prototype.regressionInputFeatureName = "";
                BayesianProbitRegressor.prototype.optimismInputFeatureName = "";
                BayesianProbitRegressor.prototype.samplingScaleInputFeatureName = "";
                BayesianProbitRegressor.prototype.samplingTruncationInputFeatureName = "";
                BayesianProbitRegressor.prototype.meanOutputFeatureName = "";
                BayesianProbitRegressor.prototype.varianceOutputFeatureName = "";
                BayesianProbitRegressor.prototype.pessimisticProbabilityOutputFeatureName = "";
                BayesianProbitRegressor.prototype.sampledProbabilityOutputFeatureName = "";
    
                BayesianProbitRegressor.create = function create(properties) {
                    return new BayesianProbitRegressor(properties);
                };
    
                BayesianProbitRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BayesianProbitRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.numberOfFeatures = reader.uint32();
                            break;
                        case 2:
                            message.bias = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.decode(reader, reader.uint32());
                            break;
                        case 3:
                            if (!(message.features && message.features.length))
                                message.features = [];
                            message.features.push($root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            message.regressionInputFeatureName = reader.string();
                            break;
                        case 11:
                            message.optimismInputFeatureName = reader.string();
                            break;
                        case 12:
                            message.samplingScaleInputFeatureName = reader.string();
                            break;
                        case 13:
                            message.samplingTruncationInputFeatureName = reader.string();
                            break;
                        case 20:
                            message.meanOutputFeatureName = reader.string();
                            break;
                        case 21:
                            message.varianceOutputFeatureName = reader.string();
                            break;
                        case 22:
                            message.pessimisticProbabilityOutputFeatureName = reader.string();
                            break;
                        case 23:
                            message.sampledProbabilityOutputFeatureName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                BayesianProbitRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.numberOfFeatures != null && message.hasOwnProperty("numberOfFeatures"))
                        if (!$util.isInteger(message.numberOfFeatures))
                            return "numberOfFeatures: integer expected";
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    if (message.features != null && message.hasOwnProperty("features")) {
                        if (!Array.isArray(message.features))
                            return "features: array expected";
                        for (var i = 0; i < message.features.length; ++i) {
                            var error = $root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight.verify(message.features[i]);
                            if (error)
                                return "features." + error;
                        }
                    }
                    if (message.regressionInputFeatureName != null && message.hasOwnProperty("regressionInputFeatureName"))
                        if (!$util.isString(message.regressionInputFeatureName))
                            return "regressionInputFeatureName: string expected";
                    if (message.optimismInputFeatureName != null && message.hasOwnProperty("optimismInputFeatureName"))
                        if (!$util.isString(message.optimismInputFeatureName))
                            return "optimismInputFeatureName: string expected";
                    if (message.samplingScaleInputFeatureName != null && message.hasOwnProperty("samplingScaleInputFeatureName"))
                        if (!$util.isString(message.samplingScaleInputFeatureName))
                            return "samplingScaleInputFeatureName: string expected";
                    if (message.samplingTruncationInputFeatureName != null && message.hasOwnProperty("samplingTruncationInputFeatureName"))
                        if (!$util.isString(message.samplingTruncationInputFeatureName))
                            return "samplingTruncationInputFeatureName: string expected";
                    if (message.meanOutputFeatureName != null && message.hasOwnProperty("meanOutputFeatureName"))
                        if (!$util.isString(message.meanOutputFeatureName))
                            return "meanOutputFeatureName: string expected";
                    if (message.varianceOutputFeatureName != null && message.hasOwnProperty("varianceOutputFeatureName"))
                        if (!$util.isString(message.varianceOutputFeatureName))
                            return "varianceOutputFeatureName: string expected";
                    if (message.pessimisticProbabilityOutputFeatureName != null && message.hasOwnProperty("pessimisticProbabilityOutputFeatureName"))
                        if (!$util.isString(message.pessimisticProbabilityOutputFeatureName))
                            return "pessimisticProbabilityOutputFeatureName: string expected";
                    if (message.sampledProbabilityOutputFeatureName != null && message.hasOwnProperty("sampledProbabilityOutputFeatureName"))
                        if (!$util.isString(message.sampledProbabilityOutputFeatureName))
                            return "sampledProbabilityOutputFeatureName: string expected";
                    return null;
                };
    
                BayesianProbitRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BayesianProbitRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.BayesianProbitRegressor();
                    if (object.numberOfFeatures != null)
                        message.numberOfFeatures = object.numberOfFeatures >>> 0;
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.BayesianProbitRegressor.bias: object expected");
                        message.bias = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.fromObject(object.bias);
                    }
                    if (object.features) {
                        if (!Array.isArray(object.features))
                            throw TypeError(".CoreML.Specification.BayesianProbitRegressor.features: array expected");
                        message.features = [];
                        for (var i = 0; i < object.features.length; ++i) {
                            if (typeof object.features[i] !== "object")
                                throw TypeError(".CoreML.Specification.BayesianProbitRegressor.features: object expected");
                            message.features[i] = $root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight.fromObject(object.features[i]);
                        }
                    }
                    if (object.regressionInputFeatureName != null)
                        message.regressionInputFeatureName = String(object.regressionInputFeatureName);
                    if (object.optimismInputFeatureName != null)
                        message.optimismInputFeatureName = String(object.optimismInputFeatureName);
                    if (object.samplingScaleInputFeatureName != null)
                        message.samplingScaleInputFeatureName = String(object.samplingScaleInputFeatureName);
                    if (object.samplingTruncationInputFeatureName != null)
                        message.samplingTruncationInputFeatureName = String(object.samplingTruncationInputFeatureName);
                    if (object.meanOutputFeatureName != null)
                        message.meanOutputFeatureName = String(object.meanOutputFeatureName);
                    if (object.varianceOutputFeatureName != null)
                        message.varianceOutputFeatureName = String(object.varianceOutputFeatureName);
                    if (object.pessimisticProbabilityOutputFeatureName != null)
                        message.pessimisticProbabilityOutputFeatureName = String(object.pessimisticProbabilityOutputFeatureName);
                    if (object.sampledProbabilityOutputFeatureName != null)
                        message.sampledProbabilityOutputFeatureName = String(object.sampledProbabilityOutputFeatureName);
                    return message;
                };
    
                BayesianProbitRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.features = [];
                    if (options.defaults) {
                        object.numberOfFeatures = 0;
                        object.bias = null;
                        object.regressionInputFeatureName = "";
                        object.optimismInputFeatureName = "";
                        object.samplingScaleInputFeatureName = "";
                        object.samplingTruncationInputFeatureName = "";
                        object.meanOutputFeatureName = "";
                        object.varianceOutputFeatureName = "";
                        object.pessimisticProbabilityOutputFeatureName = "";
                        object.sampledProbabilityOutputFeatureName = "";
                    }
                    if (message.numberOfFeatures != null && message.hasOwnProperty("numberOfFeatures"))
                        object.numberOfFeatures = message.numberOfFeatures;
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.toObject(message.bias, options);
                    if (message.features && message.features.length) {
                        object.features = [];
                        for (var j = 0; j < message.features.length; ++j)
                            object.features[j] = $root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight.toObject(message.features[j], options);
                    }
                    if (message.regressionInputFeatureName != null && message.hasOwnProperty("regressionInputFeatureName"))
                        object.regressionInputFeatureName = message.regressionInputFeatureName;
                    if (message.optimismInputFeatureName != null && message.hasOwnProperty("optimismInputFeatureName"))
                        object.optimismInputFeatureName = message.optimismInputFeatureName;
                    if (message.samplingScaleInputFeatureName != null && message.hasOwnProperty("samplingScaleInputFeatureName"))
                        object.samplingScaleInputFeatureName = message.samplingScaleInputFeatureName;
                    if (message.samplingTruncationInputFeatureName != null && message.hasOwnProperty("samplingTruncationInputFeatureName"))
                        object.samplingTruncationInputFeatureName = message.samplingTruncationInputFeatureName;
                    if (message.meanOutputFeatureName != null && message.hasOwnProperty("meanOutputFeatureName"))
                        object.meanOutputFeatureName = message.meanOutputFeatureName;
                    if (message.varianceOutputFeatureName != null && message.hasOwnProperty("varianceOutputFeatureName"))
                        object.varianceOutputFeatureName = message.varianceOutputFeatureName;
                    if (message.pessimisticProbabilityOutputFeatureName != null && message.hasOwnProperty("pessimisticProbabilityOutputFeatureName"))
                        object.pessimisticProbabilityOutputFeatureName = message.pessimisticProbabilityOutputFeatureName;
                    if (message.sampledProbabilityOutputFeatureName != null && message.hasOwnProperty("sampledProbabilityOutputFeatureName"))
                        object.sampledProbabilityOutputFeatureName = message.sampledProbabilityOutputFeatureName;
                    return object;
                };
    
                BayesianProbitRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                BayesianProbitRegressor.Gaussian = (function() {
    
                    function Gaussian(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    Gaussian.prototype.mean = 0;
                    Gaussian.prototype.precision = 0;
    
                    Gaussian.create = function create(properties) {
                        return new Gaussian(properties);
                    };
    
                    Gaussian.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BayesianProbitRegressor.Gaussian();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.mean = reader.double();
                                break;
                            case 2:
                                message.precision = reader.double();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    Gaussian.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.mean != null && message.hasOwnProperty("mean"))
                            if (typeof message.mean !== "number")
                                return "mean: number expected";
                        if (message.precision != null && message.hasOwnProperty("precision"))
                            if (typeof message.precision !== "number")
                                return "precision: number expected";
                        return null;
                    };
    
                    Gaussian.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.BayesianProbitRegressor.Gaussian)
                            return object;
                        var message = new $root.CoreML.Specification.BayesianProbitRegressor.Gaussian();
                        if (object.mean != null)
                            message.mean = Number(object.mean);
                        if (object.precision != null)
                            message.precision = Number(object.precision);
                        return message;
                    };
    
                    Gaussian.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.mean = 0;
                            object.precision = 0;
                        }
                        if (message.mean != null && message.hasOwnProperty("mean"))
                            object.mean = options.json && !isFinite(message.mean) ? String(message.mean) : message.mean;
                        if (message.precision != null && message.hasOwnProperty("precision"))
                            object.precision = options.json && !isFinite(message.precision) ? String(message.precision) : message.precision;
                        return object;
                    };
    
                    Gaussian.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return Gaussian;
                })();
    
                BayesianProbitRegressor.FeatureValueWeight = (function() {
    
                    function FeatureValueWeight(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    FeatureValueWeight.prototype.featureValue = 0;
                    FeatureValueWeight.prototype.featureWeight = null;
    
                    FeatureValueWeight.create = function create(properties) {
                        return new FeatureValueWeight(properties);
                    };
    
                    FeatureValueWeight.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.featureValue = reader.uint32();
                                break;
                            case 2:
                                message.featureWeight = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    FeatureValueWeight.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.featureValue != null && message.hasOwnProperty("featureValue"))
                            if (!$util.isInteger(message.featureValue))
                                return "featureValue: integer expected";
                        if (message.featureWeight != null && message.hasOwnProperty("featureWeight")) {
                            var error = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.verify(message.featureWeight);
                            if (error)
                                return "featureWeight." + error;
                        }
                        return null;
                    };
    
                    FeatureValueWeight.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight)
                            return object;
                        var message = new $root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight();
                        if (object.featureValue != null)
                            message.featureValue = object.featureValue >>> 0;
                        if (object.featureWeight != null) {
                            if (typeof object.featureWeight !== "object")
                                throw TypeError(".CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.featureWeight: object expected");
                            message.featureWeight = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.fromObject(object.featureWeight);
                        }
                        return message;
                    };
    
                    FeatureValueWeight.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.featureValue = 0;
                            object.featureWeight = null;
                        }
                        if (message.featureValue != null && message.hasOwnProperty("featureValue"))
                            object.featureValue = message.featureValue;
                        if (message.featureWeight != null && message.hasOwnProperty("featureWeight"))
                            object.featureWeight = $root.CoreML.Specification.BayesianProbitRegressor.Gaussian.toObject(message.featureWeight, options);
                        return object;
                    };
    
                    FeatureValueWeight.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return FeatureValueWeight;
                })();
    
                BayesianProbitRegressor.FeatureWeight = (function() {
    
                    function FeatureWeight(properties) {
                        this.weights = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    FeatureWeight.prototype.featureId = 0;
                    FeatureWeight.prototype.weights = $util.emptyArray;
    
                    FeatureWeight.create = function create(properties) {
                        return new FeatureWeight(properties);
                    };
    
                    FeatureWeight.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.featureId = reader.uint32();
                                break;
                            case 2:
                                if (!(message.weights && message.weights.length))
                                    message.weights = [];
                                message.weights.push($root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.decode(reader, reader.uint32()));
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    FeatureWeight.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.featureId != null && message.hasOwnProperty("featureId"))
                            if (!$util.isInteger(message.featureId))
                                return "featureId: integer expected";
                        if (message.weights != null && message.hasOwnProperty("weights")) {
                            if (!Array.isArray(message.weights))
                                return "weights: array expected";
                            for (var i = 0; i < message.weights.length; ++i) {
                                var error = $root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.verify(message.weights[i]);
                                if (error)
                                    return "weights." + error;
                            }
                        }
                        return null;
                    };
    
                    FeatureWeight.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight)
                            return object;
                        var message = new $root.CoreML.Specification.BayesianProbitRegressor.FeatureWeight();
                        if (object.featureId != null)
                            message.featureId = object.featureId >>> 0;
                        if (object.weights) {
                            if (!Array.isArray(object.weights))
                                throw TypeError(".CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights: array expected");
                            message.weights = [];
                            for (var i = 0; i < object.weights.length; ++i) {
                                if (typeof object.weights[i] !== "object")
                                    throw TypeError(".CoreML.Specification.BayesianProbitRegressor.FeatureWeight.weights: object expected");
                                message.weights[i] = $root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.fromObject(object.weights[i]);
                            }
                        }
                        return message;
                    };
    
                    FeatureWeight.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.weights = [];
                        if (options.defaults)
                            object.featureId = 0;
                        if (message.featureId != null && message.hasOwnProperty("featureId"))
                            object.featureId = message.featureId;
                        if (message.weights && message.weights.length) {
                            object.weights = [];
                            for (var j = 0; j < message.weights.length; ++j)
                                object.weights[j] = $root.CoreML.Specification.BayesianProbitRegressor.FeatureValueWeight.toObject(message.weights[j], options);
                        }
                        return object;
                    };
    
                    FeatureWeight.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return FeatureWeight;
                })();
    
                return BayesianProbitRegressor;
            })();
    
            Specification.CategoricalMapping = (function() {
    
                function CategoricalMapping(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                CategoricalMapping.prototype.stringToInt64Map = null;
                CategoricalMapping.prototype.int64ToStringMap = null;
                CategoricalMapping.prototype.strValue = "";
                CategoricalMapping.prototype.int64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                var $oneOfFields;
    
                Object.defineProperty(CategoricalMapping.prototype, "MappingType", {
                    get: $util.oneOfGetter($oneOfFields = ["stringToInt64Map", "int64ToStringMap"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Object.defineProperty(CategoricalMapping.prototype, "ValueOnUnknown", {
                    get: $util.oneOfGetter($oneOfFields = ["strValue", "int64Value"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                CategoricalMapping.create = function create(properties) {
                    return new CategoricalMapping(properties);
                };
    
                CategoricalMapping.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CategoricalMapping();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringToInt64Map = $root.CoreML.Specification.StringToInt64Map.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.int64ToStringMap = $root.CoreML.Specification.Int64ToStringMap.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.strValue = reader.string();
                            break;
                        case 102:
                            message.int64Value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                CategoricalMapping.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringToInt64Map != null && message.hasOwnProperty("stringToInt64Map")) {
                        properties.MappingType = 1;
                        {
                            var error = $root.CoreML.Specification.StringToInt64Map.verify(message.stringToInt64Map);
                            if (error)
                                return "stringToInt64Map." + error;
                        }
                    }
                    if (message.int64ToStringMap != null && message.hasOwnProperty("int64ToStringMap")) {
                        if (properties.MappingType === 1)
                            return "MappingType: multiple values";
                        properties.MappingType = 1;
                        {
                            var error = $root.CoreML.Specification.Int64ToStringMap.verify(message.int64ToStringMap);
                            if (error)
                                return "int64ToStringMap." + error;
                        }
                    }
                    if (message.strValue != null && message.hasOwnProperty("strValue")) {
                        properties.ValueOnUnknown = 1;
                        if (!$util.isString(message.strValue))
                            return "strValue: string expected";
                    }
                    if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                        if (properties.ValueOnUnknown === 1)
                            return "ValueOnUnknown: multiple values";
                        properties.ValueOnUnknown = 1;
                        if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                            return "int64Value: integer|Long expected";
                    }
                    return null;
                };
    
                CategoricalMapping.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CategoricalMapping)
                        return object;
                    var message = new $root.CoreML.Specification.CategoricalMapping();
                    if (object.stringToInt64Map != null) {
                        if (typeof object.stringToInt64Map !== "object")
                            throw TypeError(".CoreML.Specification.CategoricalMapping.stringToInt64Map: object expected");
                        message.stringToInt64Map = $root.CoreML.Specification.StringToInt64Map.fromObject(object.stringToInt64Map);
                    }
                    if (object.int64ToStringMap != null) {
                        if (typeof object.int64ToStringMap !== "object")
                            throw TypeError(".CoreML.Specification.CategoricalMapping.int64ToStringMap: object expected");
                        message.int64ToStringMap = $root.CoreML.Specification.Int64ToStringMap.fromObject(object.int64ToStringMap);
                    }
                    if (object.strValue != null)
                        message.strValue = String(object.strValue);
                    if (object.int64Value != null)
                        if ($util.Long)
                            (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                        else if (typeof object.int64Value === "string")
                            message.int64Value = parseInt(object.int64Value, 10);
                        else if (typeof object.int64Value === "number")
                            message.int64Value = object.int64Value;
                        else if (typeof object.int64Value === "object")
                            message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
                    return message;
                };
    
                CategoricalMapping.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.stringToInt64Map != null && message.hasOwnProperty("stringToInt64Map")) {
                        object.stringToInt64Map = $root.CoreML.Specification.StringToInt64Map.toObject(message.stringToInt64Map, options);
                        if (options.oneofs)
                            object.MappingType = "stringToInt64Map";
                    }
                    if (message.int64ToStringMap != null && message.hasOwnProperty("int64ToStringMap")) {
                        object.int64ToStringMap = $root.CoreML.Specification.Int64ToStringMap.toObject(message.int64ToStringMap, options);
                        if (options.oneofs)
                            object.MappingType = "int64ToStringMap";
                    }
                    if (message.strValue != null && message.hasOwnProperty("strValue")) {
                        object.strValue = message.strValue;
                        if (options.oneofs)
                            object.ValueOnUnknown = "strValue";
                    }
                    if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                        if (typeof message.int64Value === "number")
                            object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                        else
                            object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
                        if (options.oneofs)
                            object.ValueOnUnknown = "int64Value";
                    }
                    return object;
                };
    
                CategoricalMapping.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CategoricalMapping;
            })();
    
            Specification.CustomModel = (function() {
    
                function CustomModel(properties) {
                    this.parameters = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                CustomModel.prototype.className = "";
                CustomModel.prototype.parameters = $util.emptyObject;
                CustomModel.prototype.description = "";
    
                CustomModel.create = function create(properties) {
                    return new CustomModel(properties);
                };
    
                CustomModel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CustomModel(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.className = reader.string();
                            break;
                        case 30:
                            reader.skip().pos++;
                            if (message.parameters === $util.emptyObject)
                                message.parameters = {};
                            key = reader.string();
                            reader.pos++;
                            message.parameters[key] = $root.CoreML.Specification.CustomModel.CustomModelParamValue.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                CustomModel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.className != null && message.hasOwnProperty("className"))
                        if (!$util.isString(message.className))
                            return "className: string expected";
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!$util.isObject(message.parameters))
                            return "parameters: object expected";
                        var key = Object.keys(message.parameters);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.CoreML.Specification.CustomModel.CustomModelParamValue.verify(message.parameters[key[i]]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };
    
                CustomModel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CustomModel)
                        return object;
                    var message = new $root.CoreML.Specification.CustomModel();
                    if (object.className != null)
                        message.className = String(object.className);
                    if (object.parameters) {
                        if (typeof object.parameters !== "object")
                            throw TypeError(".CoreML.Specification.CustomModel.parameters: object expected");
                        message.parameters = {};
                        for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                            if (typeof object.parameters[keys[i]] !== "object")
                                throw TypeError(".CoreML.Specification.CustomModel.parameters: object expected");
                            message.parameters[keys[i]] = $root.CoreML.Specification.CustomModel.CustomModelParamValue.fromObject(object.parameters[keys[i]]);
                        }
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };
    
                CustomModel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.parameters = {};
                    if (options.defaults) {
                        object.className = "";
                        object.description = "";
                    }
                    if (message.className != null && message.hasOwnProperty("className"))
                        object.className = message.className;
                    var keys2;
                    if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                        object.parameters = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.parameters[keys2[j]] = $root.CoreML.Specification.CustomModel.CustomModelParamValue.toObject(message.parameters[keys2[j]], options);
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };
    
                CustomModel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                CustomModel.CustomModelParamValue = (function() {
    
                    function CustomModelParamValue(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    CustomModelParamValue.prototype.doubleValue = 0;
                    CustomModelParamValue.prototype.stringValue = "";
                    CustomModelParamValue.prototype.intValue = 0;
                    CustomModelParamValue.prototype.longValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    CustomModelParamValue.prototype.boolValue = false;
                    CustomModelParamValue.prototype.bytesValue = $util.newBuffer([]);
    
                    var $oneOfFields;
    
                    Object.defineProperty(CustomModelParamValue.prototype, "value", {
                        get: $util.oneOfGetter($oneOfFields = ["doubleValue", "stringValue", "intValue", "longValue", "boolValue", "bytesValue"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    CustomModelParamValue.create = function create(properties) {
                        return new CustomModelParamValue(properties);
                    };
    
                    CustomModelParamValue.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CustomModel.CustomModelParamValue();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 10:
                                message.doubleValue = reader.double();
                                break;
                            case 20:
                                message.stringValue = reader.string();
                                break;
                            case 30:
                                message.intValue = reader.int32();
                                break;
                            case 40:
                                message.longValue = reader.int64();
                                break;
                            case 50:
                                message.boolValue = reader.bool();
                                break;
                            case 60:
                                message.bytesValue = reader.bytes();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    CustomModelParamValue.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                            properties.value = 1;
                            if (typeof message.doubleValue !== "number")
                                return "doubleValue: number expected";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isString(message.stringValue))
                                return "stringValue: string expected";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.intValue))
                                return "intValue: integer expected";
                        }
                        if (message.longValue != null && message.hasOwnProperty("longValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.longValue) && !(message.longValue && $util.isInteger(message.longValue.low) && $util.isInteger(message.longValue.high)))
                                return "longValue: integer|Long expected";
                        }
                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (typeof message.boolValue !== "boolean")
                                return "boolValue: boolean expected";
                        }
                        if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                                return "bytesValue: buffer expected";
                        }
                        return null;
                    };
    
                    CustomModelParamValue.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.CustomModel.CustomModelParamValue)
                            return object;
                        var message = new $root.CoreML.Specification.CustomModel.CustomModelParamValue();
                        if (object.doubleValue != null)
                            message.doubleValue = Number(object.doubleValue);
                        if (object.stringValue != null)
                            message.stringValue = String(object.stringValue);
                        if (object.intValue != null)
                            message.intValue = object.intValue | 0;
                        if (object.longValue != null)
                            if ($util.Long)
                                (message.longValue = $util.Long.fromValue(object.longValue)).unsigned = false;
                            else if (typeof object.longValue === "string")
                                message.longValue = parseInt(object.longValue, 10);
                            else if (typeof object.longValue === "number")
                                message.longValue = object.longValue;
                            else if (typeof object.longValue === "object")
                                message.longValue = new $util.LongBits(object.longValue.low >>> 0, object.longValue.high >>> 0).toNumber();
                        if (object.boolValue != null)
                            message.boolValue = Boolean(object.boolValue);
                        if (object.bytesValue != null)
                            if (typeof object.bytesValue === "string")
                                $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                            else if (object.bytesValue.length)
                                message.bytesValue = object.bytesValue;
                        return message;
                    };
    
                    CustomModelParamValue.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                            if (options.oneofs)
                                object.value = "doubleValue";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            object.stringValue = message.stringValue;
                            if (options.oneofs)
                                object.value = "stringValue";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            object.intValue = message.intValue;
                            if (options.oneofs)
                                object.value = "intValue";
                        }
                        if (message.longValue != null && message.hasOwnProperty("longValue")) {
                            if (typeof message.longValue === "number")
                                object.longValue = options.longs === String ? String(message.longValue) : message.longValue;
                            else
                                object.longValue = options.longs === String ? $util.Long.prototype.toString.call(message.longValue) : options.longs === Number ? new $util.LongBits(message.longValue.low >>> 0, message.longValue.high >>> 0).toNumber() : message.longValue;
                            if (options.oneofs)
                                object.value = "longValue";
                        }
                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                            object.boolValue = message.boolValue;
                            if (options.oneofs)
                                object.value = "boolValue";
                        }
                        if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                            object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                            if (options.oneofs)
                                object.value = "bytesValue";
                        }
                        return object;
                    };
    
                    CustomModelParamValue.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CustomModelParamValue;
                })();
    
                return CustomModel;
            })();
    
            Specification.DictVectorizer = (function() {
    
                function DictVectorizer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DictVectorizer.prototype.stringToIndex = null;
                DictVectorizer.prototype.int64ToIndex = null;
    
                var $oneOfFields;
    
                Object.defineProperty(DictVectorizer.prototype, "Map", {
                    get: $util.oneOfGetter($oneOfFields = ["stringToIndex", "int64ToIndex"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                DictVectorizer.create = function create(properties) {
                    return new DictVectorizer(properties);
                };
    
                DictVectorizer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DictVectorizer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringToIndex = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.int64ToIndex = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DictVectorizer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringToIndex != null && message.hasOwnProperty("stringToIndex")) {
                        properties.Map = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringToIndex);
                            if (error)
                                return "stringToIndex." + error;
                        }
                    }
                    if (message.int64ToIndex != null && message.hasOwnProperty("int64ToIndex")) {
                        if (properties.Map === 1)
                            return "Map: multiple values";
                        properties.Map = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ToIndex);
                            if (error)
                                return "int64ToIndex." + error;
                        }
                    }
                    return null;
                };
    
                DictVectorizer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DictVectorizer)
                        return object;
                    var message = new $root.CoreML.Specification.DictVectorizer();
                    if (object.stringToIndex != null) {
                        if (typeof object.stringToIndex !== "object")
                            throw TypeError(".CoreML.Specification.DictVectorizer.stringToIndex: object expected");
                        message.stringToIndex = $root.CoreML.Specification.StringVector.fromObject(object.stringToIndex);
                    }
                    if (object.int64ToIndex != null) {
                        if (typeof object.int64ToIndex !== "object")
                            throw TypeError(".CoreML.Specification.DictVectorizer.int64ToIndex: object expected");
                        message.int64ToIndex = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ToIndex);
                    }
                    return message;
                };
    
                DictVectorizer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.stringToIndex != null && message.hasOwnProperty("stringToIndex")) {
                        object.stringToIndex = $root.CoreML.Specification.StringVector.toObject(message.stringToIndex, options);
                        if (options.oneofs)
                            object.Map = "stringToIndex";
                    }
                    if (message.int64ToIndex != null && message.hasOwnProperty("int64ToIndex")) {
                        object.int64ToIndex = $root.CoreML.Specification.Int64Vector.toObject(message.int64ToIndex, options);
                        if (options.oneofs)
                            object.Map = "int64ToIndex";
                    }
                    return object;
                };
    
                DictVectorizer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictVectorizer;
            })();
    
            Specification.FeatureVectorizer = (function() {
    
                function FeatureVectorizer(properties) {
                    this.inputList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                FeatureVectorizer.prototype.inputList = $util.emptyArray;
    
                FeatureVectorizer.create = function create(properties) {
                    return new FeatureVectorizer(properties);
                };
    
                FeatureVectorizer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureVectorizer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.inputList && message.inputList.length))
                                message.inputList = [];
                            message.inputList.push($root.CoreML.Specification.FeatureVectorizer.InputColumn.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                FeatureVectorizer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputList != null && message.hasOwnProperty("inputList")) {
                        if (!Array.isArray(message.inputList))
                            return "inputList: array expected";
                        for (var i = 0; i < message.inputList.length; ++i) {
                            var error = $root.CoreML.Specification.FeatureVectorizer.InputColumn.verify(message.inputList[i]);
                            if (error)
                                return "inputList." + error;
                        }
                    }
                    return null;
                };
    
                FeatureVectorizer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FeatureVectorizer)
                        return object;
                    var message = new $root.CoreML.Specification.FeatureVectorizer();
                    if (object.inputList) {
                        if (!Array.isArray(object.inputList))
                            throw TypeError(".CoreML.Specification.FeatureVectorizer.inputList: array expected");
                        message.inputList = [];
                        for (var i = 0; i < object.inputList.length; ++i) {
                            if (typeof object.inputList[i] !== "object")
                                throw TypeError(".CoreML.Specification.FeatureVectorizer.inputList: object expected");
                            message.inputList[i] = $root.CoreML.Specification.FeatureVectorizer.InputColumn.fromObject(object.inputList[i]);
                        }
                    }
                    return message;
                };
    
                FeatureVectorizer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.inputList = [];
                    if (message.inputList && message.inputList.length) {
                        object.inputList = [];
                        for (var j = 0; j < message.inputList.length; ++j)
                            object.inputList[j] = $root.CoreML.Specification.FeatureVectorizer.InputColumn.toObject(message.inputList[j], options);
                    }
                    return object;
                };
    
                FeatureVectorizer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                FeatureVectorizer.InputColumn = (function() {
    
                    function InputColumn(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    InputColumn.prototype.inputColumn = "";
                    InputColumn.prototype.inputDimensions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    InputColumn.create = function create(properties) {
                        return new InputColumn(properties);
                    };
    
                    InputColumn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureVectorizer.InputColumn();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.inputColumn = reader.string();
                                break;
                            case 2:
                                message.inputDimensions = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    InputColumn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.inputColumn != null && message.hasOwnProperty("inputColumn"))
                            if (!$util.isString(message.inputColumn))
                                return "inputColumn: string expected";
                        if (message.inputDimensions != null && message.hasOwnProperty("inputDimensions"))
                            if (!$util.isInteger(message.inputDimensions) && !(message.inputDimensions && $util.isInteger(message.inputDimensions.low) && $util.isInteger(message.inputDimensions.high)))
                                return "inputDimensions: integer|Long expected";
                        return null;
                    };
    
                    InputColumn.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.FeatureVectorizer.InputColumn)
                            return object;
                        var message = new $root.CoreML.Specification.FeatureVectorizer.InputColumn();
                        if (object.inputColumn != null)
                            message.inputColumn = String(object.inputColumn);
                        if (object.inputDimensions != null)
                            if ($util.Long)
                                (message.inputDimensions = $util.Long.fromValue(object.inputDimensions)).unsigned = true;
                            else if (typeof object.inputDimensions === "string")
                                message.inputDimensions = parseInt(object.inputDimensions, 10);
                            else if (typeof object.inputDimensions === "number")
                                message.inputDimensions = object.inputDimensions;
                            else if (typeof object.inputDimensions === "object")
                                message.inputDimensions = new $util.LongBits(object.inputDimensions.low >>> 0, object.inputDimensions.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    InputColumn.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.inputColumn = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.inputDimensions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.inputDimensions = options.longs === String ? "0" : 0;
                        }
                        if (message.inputColumn != null && message.hasOwnProperty("inputColumn"))
                            object.inputColumn = message.inputColumn;
                        if (message.inputDimensions != null && message.hasOwnProperty("inputDimensions"))
                            if (typeof message.inputDimensions === "number")
                                object.inputDimensions = options.longs === String ? String(message.inputDimensions) : message.inputDimensions;
                            else
                                object.inputDimensions = options.longs === String ? $util.Long.prototype.toString.call(message.inputDimensions) : options.longs === Number ? new $util.LongBits(message.inputDimensions.low >>> 0, message.inputDimensions.high >>> 0).toNumber(true) : message.inputDimensions;
                        return object;
                    };
    
                    InputColumn.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return InputColumn;
                })();
    
                return FeatureVectorizer;
            })();
    
            Specification.GLMRegressor = (function() {
    
                function GLMRegressor(properties) {
                    this.weights = [];
                    this.offset = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                GLMRegressor.prototype.weights = $util.emptyArray;
                GLMRegressor.prototype.offset = $util.emptyArray;
                GLMRegressor.prototype.postEvaluationTransform = 0;
    
                GLMRegressor.create = function create(properties) {
                    return new GLMRegressor(properties);
                };
    
                GLMRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.weights && message.weights.length))
                                message.weights = [];
                            message.weights.push($root.CoreML.Specification.GLMRegressor.DoubleArray.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.offset && message.offset.length))
                                message.offset = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.offset.push(reader.double());
                            } else
                                message.offset.push(reader.double());
                            break;
                        case 3:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                GLMRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        if (!Array.isArray(message.weights))
                            return "weights: array expected";
                        for (var i = 0; i < message.weights.length; ++i) {
                            var error = $root.CoreML.Specification.GLMRegressor.DoubleArray.verify(message.weights[i]);
                            if (error)
                                return "weights." + error;
                        }
                    }
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        if (!Array.isArray(message.offset))
                            return "offset: array expected";
                        for (var i = 0; i < message.offset.length; ++i)
                            if (typeof message.offset[i] !== "number")
                                return "offset: number[] expected";
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                GLMRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.GLMRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.GLMRegressor();
                    if (object.weights) {
                        if (!Array.isArray(object.weights))
                            throw TypeError(".CoreML.Specification.GLMRegressor.weights: array expected");
                        message.weights = [];
                        for (var i = 0; i < object.weights.length; ++i) {
                            if (typeof object.weights[i] !== "object")
                                throw TypeError(".CoreML.Specification.GLMRegressor.weights: object expected");
                            message.weights[i] = $root.CoreML.Specification.GLMRegressor.DoubleArray.fromObject(object.weights[i]);
                        }
                    }
                    if (object.offset) {
                        if (!Array.isArray(object.offset))
                            throw TypeError(".CoreML.Specification.GLMRegressor.offset: array expected");
                        message.offset = [];
                        for (var i = 0; i < object.offset.length; ++i)
                            message.offset[i] = Number(object.offset[i]);
                    }
                    switch (object.postEvaluationTransform) {
                    case "NoTransform":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Logit":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    case "Probit":
                    case 2:
                        message.postEvaluationTransform = 2;
                        break;
                    }
                    return message;
                };
    
                GLMRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.weights = [];
                        object.offset = [];
                    }
                    if (options.defaults)
                        object.postEvaluationTransform = options.enums === String ? "NoTransform" : 0;
                    if (message.weights && message.weights.length) {
                        object.weights = [];
                        for (var j = 0; j < message.weights.length; ++j)
                            object.weights[j] = $root.CoreML.Specification.GLMRegressor.DoubleArray.toObject(message.weights[j], options);
                    }
                    if (message.offset && message.offset.length) {
                        object.offset = [];
                        for (var j = 0; j < message.offset.length; ++j)
                            object.offset[j] = options.json && !isFinite(message.offset[j]) ? String(message.offset[j]) : message.offset[j];
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.GLMRegressor.PostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    return object;
                };
    
                GLMRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GLMRegressor.DoubleArray = (function() {
    
                    function DoubleArray(properties) {
                        this.value = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    DoubleArray.prototype.value = $util.emptyArray;
    
                    DoubleArray.create = function create(properties) {
                        return new DoubleArray(properties);
                    };
    
                    DoubleArray.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMRegressor.DoubleArray();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.value.push(reader.double());
                                } else
                                    message.value.push(reader.double());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    DoubleArray.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            if (!Array.isArray(message.value))
                                return "value: array expected";
                            for (var i = 0; i < message.value.length; ++i)
                                if (typeof message.value[i] !== "number")
                                    return "value: number[] expected";
                        }
                        return null;
                    };
    
                    DoubleArray.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.GLMRegressor.DoubleArray)
                            return object;
                        var message = new $root.CoreML.Specification.GLMRegressor.DoubleArray();
                        if (object.value) {
                            if (!Array.isArray(object.value))
                                throw TypeError(".CoreML.Specification.GLMRegressor.DoubleArray.value: array expected");
                            message.value = [];
                            for (var i = 0; i < object.value.length; ++i)
                                message.value[i] = Number(object.value[i]);
                        }
                        return message;
                    };
    
                    DoubleArray.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.value = [];
                        if (message.value && message.value.length) {
                            object.value = [];
                            for (var j = 0; j < message.value.length; ++j)
                                object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                        }
                        return object;
                    };
    
                    DoubleArray.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DoubleArray;
                })();
    
                GLMRegressor.PostEvaluationTransform = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NoTransform"] = 0;
                    values[valuesById[1] = "Logit"] = 1;
                    values[valuesById[2] = "Probit"] = 2;
                    return values;
                })();
    
                return GLMRegressor;
            })();
    
            Specification.GLMClassifier = (function() {
    
                function GLMClassifier(properties) {
                    this.weights = [];
                    this.offset = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                GLMClassifier.prototype.weights = $util.emptyArray;
                GLMClassifier.prototype.offset = $util.emptyArray;
                GLMClassifier.prototype.postEvaluationTransform = 0;
                GLMClassifier.prototype.classEncoding = 0;
                GLMClassifier.prototype.stringClassLabels = null;
                GLMClassifier.prototype.int64ClassLabels = null;
    
                var $oneOfFields;
    
                Object.defineProperty(GLMClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                GLMClassifier.create = function create(properties) {
                    return new GLMClassifier(properties);
                };
    
                GLMClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.weights && message.weights.length))
                                message.weights = [];
                            message.weights.push($root.CoreML.Specification.GLMClassifier.DoubleArray.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.offset && message.offset.length))
                                message.offset = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.offset.push(reader.double());
                            } else
                                message.offset.push(reader.double());
                            break;
                        case 3:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        case 4:
                            message.classEncoding = reader.int32();
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                GLMClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        if (!Array.isArray(message.weights))
                            return "weights: array expected";
                        for (var i = 0; i < message.weights.length; ++i) {
                            var error = $root.CoreML.Specification.GLMClassifier.DoubleArray.verify(message.weights[i]);
                            if (error)
                                return "weights." + error;
                        }
                    }
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        if (!Array.isArray(message.offset))
                            return "offset: array expected";
                        for (var i = 0; i < message.offset.length; ++i)
                            if (typeof message.offset[i] !== "number")
                                return "offset: number[] expected";
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.classEncoding != null && message.hasOwnProperty("classEncoding"))
                        switch (message.classEncoding) {
                        default:
                            return "classEncoding: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    return null;
                };
    
                GLMClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.GLMClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.GLMClassifier();
                    if (object.weights) {
                        if (!Array.isArray(object.weights))
                            throw TypeError(".CoreML.Specification.GLMClassifier.weights: array expected");
                        message.weights = [];
                        for (var i = 0; i < object.weights.length; ++i) {
                            if (typeof object.weights[i] !== "object")
                                throw TypeError(".CoreML.Specification.GLMClassifier.weights: object expected");
                            message.weights[i] = $root.CoreML.Specification.GLMClassifier.DoubleArray.fromObject(object.weights[i]);
                        }
                    }
                    if (object.offset) {
                        if (!Array.isArray(object.offset))
                            throw TypeError(".CoreML.Specification.GLMClassifier.offset: array expected");
                        message.offset = [];
                        for (var i = 0; i < object.offset.length; ++i)
                            message.offset[i] = Number(object.offset[i]);
                    }
                    switch (object.postEvaluationTransform) {
                    case "Logit":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Probit":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    }
                    switch (object.classEncoding) {
                    case "ReferenceClass":
                    case 0:
                        message.classEncoding = 0;
                        break;
                    case "OneVsRest":
                    case 1:
                        message.classEncoding = 1;
                        break;
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.GLMClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.GLMClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    return message;
                };
    
                GLMClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.weights = [];
                        object.offset = [];
                    }
                    if (options.defaults) {
                        object.postEvaluationTransform = options.enums === String ? "Logit" : 0;
                        object.classEncoding = options.enums === String ? "ReferenceClass" : 0;
                    }
                    if (message.weights && message.weights.length) {
                        object.weights = [];
                        for (var j = 0; j < message.weights.length; ++j)
                            object.weights[j] = $root.CoreML.Specification.GLMClassifier.DoubleArray.toObject(message.weights[j], options);
                    }
                    if (message.offset && message.offset.length) {
                        object.offset = [];
                        for (var j = 0; j < message.offset.length; ++j)
                            object.offset[j] = options.json && !isFinite(message.offset[j]) ? String(message.offset[j]) : message.offset[j];
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.GLMClassifier.PostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    if (message.classEncoding != null && message.hasOwnProperty("classEncoding"))
                        object.classEncoding = options.enums === String ? $root.CoreML.Specification.GLMClassifier.ClassEncoding[message.classEncoding] : message.classEncoding;
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    return object;
                };
    
                GLMClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GLMClassifier.DoubleArray = (function() {
    
                    function DoubleArray(properties) {
                        this.value = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    DoubleArray.prototype.value = $util.emptyArray;
    
                    DoubleArray.create = function create(properties) {
                        return new DoubleArray(properties);
                    };
    
                    DoubleArray.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMClassifier.DoubleArray();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.value.push(reader.double());
                                } else
                                    message.value.push(reader.double());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    DoubleArray.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            if (!Array.isArray(message.value))
                                return "value: array expected";
                            for (var i = 0; i < message.value.length; ++i)
                                if (typeof message.value[i] !== "number")
                                    return "value: number[] expected";
                        }
                        return null;
                    };
    
                    DoubleArray.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.GLMClassifier.DoubleArray)
                            return object;
                        var message = new $root.CoreML.Specification.GLMClassifier.DoubleArray();
                        if (object.value) {
                            if (!Array.isArray(object.value))
                                throw TypeError(".CoreML.Specification.GLMClassifier.DoubleArray.value: array expected");
                            message.value = [];
                            for (var i = 0; i < object.value.length; ++i)
                                message.value[i] = Number(object.value[i]);
                        }
                        return message;
                    };
    
                    DoubleArray.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.value = [];
                        if (message.value && message.value.length) {
                            object.value = [];
                            for (var j = 0; j < message.value.length; ++j)
                                object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                        }
                        return object;
                    };
    
                    DoubleArray.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DoubleArray;
                })();
    
                GLMClassifier.PostEvaluationTransform = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "Logit"] = 0;
                    values[valuesById[1] = "Probit"] = 1;
                    return values;
                })();
    
                GLMClassifier.ClassEncoding = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ReferenceClass"] = 0;
                    values[valuesById[1] = "OneVsRest"] = 1;
                    return values;
                })();
    
                return GLMClassifier;
            })();
    
            Specification.Identity = (function() {
    
                function Identity(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Identity.create = function create(properties) {
                    return new Identity(properties);
                };
    
                Identity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Identity();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Identity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                Identity.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Identity)
                        return object;
                    return new $root.CoreML.Specification.Identity();
                };
    
                Identity.toObject = function toObject() {
                    return {};
                };
    
                Identity.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Identity;
            })();
    
            Specification.Imputer = (function() {
    
                function Imputer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Imputer.prototype.imputedDoubleValue = 0;
                Imputer.prototype.imputedInt64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                Imputer.prototype.imputedStringValue = "";
                Imputer.prototype.imputedDoubleArray = null;
                Imputer.prototype.imputedInt64Array = null;
                Imputer.prototype.imputedStringDictionary = null;
                Imputer.prototype.imputedInt64Dictionary = null;
                Imputer.prototype.replaceDoubleValue = 0;
                Imputer.prototype.replaceInt64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                Imputer.prototype.replaceStringValue = "";
    
                var $oneOfFields;
    
                Object.defineProperty(Imputer.prototype, "ImputedValue", {
                    get: $util.oneOfGetter($oneOfFields = ["imputedDoubleValue", "imputedInt64Value", "imputedStringValue", "imputedDoubleArray", "imputedInt64Array", "imputedStringDictionary", "imputedInt64Dictionary"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Object.defineProperty(Imputer.prototype, "ReplaceValue", {
                    get: $util.oneOfGetter($oneOfFields = ["replaceDoubleValue", "replaceInt64Value", "replaceStringValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Imputer.create = function create(properties) {
                    return new Imputer(properties);
                };
    
                Imputer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Imputer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.imputedDoubleValue = reader.double();
                            break;
                        case 2:
                            message.imputedInt64Value = reader.int64();
                            break;
                        case 3:
                            message.imputedStringValue = reader.string();
                            break;
                        case 4:
                            message.imputedDoubleArray = $root.CoreML.Specification.DoubleVector.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.imputedInt64Array = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.imputedStringDictionary = $root.CoreML.Specification.StringToDoubleMap.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.imputedInt64Dictionary = $root.CoreML.Specification.Int64ToDoubleMap.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.replaceDoubleValue = reader.double();
                            break;
                        case 12:
                            message.replaceInt64Value = reader.int64();
                            break;
                        case 13:
                            message.replaceStringValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Imputer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.imputedDoubleValue != null && message.hasOwnProperty("imputedDoubleValue")) {
                        properties.ImputedValue = 1;
                        if (typeof message.imputedDoubleValue !== "number")
                            return "imputedDoubleValue: number expected";
                    }
                    if (message.imputedInt64Value != null && message.hasOwnProperty("imputedInt64Value")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        if (!$util.isInteger(message.imputedInt64Value) && !(message.imputedInt64Value && $util.isInteger(message.imputedInt64Value.low) && $util.isInteger(message.imputedInt64Value.high)))
                            return "imputedInt64Value: integer|Long expected";
                    }
                    if (message.imputedStringValue != null && message.hasOwnProperty("imputedStringValue")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        if (!$util.isString(message.imputedStringValue))
                            return "imputedStringValue: string expected";
                    }
                    if (message.imputedDoubleArray != null && message.hasOwnProperty("imputedDoubleArray")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.DoubleVector.verify(message.imputedDoubleArray);
                            if (error)
                                return "imputedDoubleArray." + error;
                        }
                    }
                    if (message.imputedInt64Array != null && message.hasOwnProperty("imputedInt64Array")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.imputedInt64Array);
                            if (error)
                                return "imputedInt64Array." + error;
                        }
                    }
                    if (message.imputedStringDictionary != null && message.hasOwnProperty("imputedStringDictionary")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.StringToDoubleMap.verify(message.imputedStringDictionary);
                            if (error)
                                return "imputedStringDictionary." + error;
                        }
                    }
                    if (message.imputedInt64Dictionary != null && message.hasOwnProperty("imputedInt64Dictionary")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.Int64ToDoubleMap.verify(message.imputedInt64Dictionary);
                            if (error)
                                return "imputedInt64Dictionary." + error;
                        }
                    }
                    if (message.replaceDoubleValue != null && message.hasOwnProperty("replaceDoubleValue")) {
                        properties.ReplaceValue = 1;
                        if (typeof message.replaceDoubleValue !== "number")
                            return "replaceDoubleValue: number expected";
                    }
                    if (message.replaceInt64Value != null && message.hasOwnProperty("replaceInt64Value")) {
                        if (properties.ReplaceValue === 1)
                            return "ReplaceValue: multiple values";
                        properties.ReplaceValue = 1;
                        if (!$util.isInteger(message.replaceInt64Value) && !(message.replaceInt64Value && $util.isInteger(message.replaceInt64Value.low) && $util.isInteger(message.replaceInt64Value.high)))
                            return "replaceInt64Value: integer|Long expected";
                    }
                    if (message.replaceStringValue != null && message.hasOwnProperty("replaceStringValue")) {
                        if (properties.ReplaceValue === 1)
                            return "ReplaceValue: multiple values";
                        properties.ReplaceValue = 1;
                        if (!$util.isString(message.replaceStringValue))
                            return "replaceStringValue: string expected";
                    }
                    return null;
                };
    
                Imputer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Imputer)
                        return object;
                    var message = new $root.CoreML.Specification.Imputer();
                    if (object.imputedDoubleValue != null)
                        message.imputedDoubleValue = Number(object.imputedDoubleValue);
                    if (object.imputedInt64Value != null)
                        if ($util.Long)
                            (message.imputedInt64Value = $util.Long.fromValue(object.imputedInt64Value)).unsigned = false;
                        else if (typeof object.imputedInt64Value === "string")
                            message.imputedInt64Value = parseInt(object.imputedInt64Value, 10);
                        else if (typeof object.imputedInt64Value === "number")
                            message.imputedInt64Value = object.imputedInt64Value;
                        else if (typeof object.imputedInt64Value === "object")
                            message.imputedInt64Value = new $util.LongBits(object.imputedInt64Value.low >>> 0, object.imputedInt64Value.high >>> 0).toNumber();
                    if (object.imputedStringValue != null)
                        message.imputedStringValue = String(object.imputedStringValue);
                    if (object.imputedDoubleArray != null) {
                        if (typeof object.imputedDoubleArray !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedDoubleArray: object expected");
                        message.imputedDoubleArray = $root.CoreML.Specification.DoubleVector.fromObject(object.imputedDoubleArray);
                    }
                    if (object.imputedInt64Array != null) {
                        if (typeof object.imputedInt64Array !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedInt64Array: object expected");
                        message.imputedInt64Array = $root.CoreML.Specification.Int64Vector.fromObject(object.imputedInt64Array);
                    }
                    if (object.imputedStringDictionary != null) {
                        if (typeof object.imputedStringDictionary !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedStringDictionary: object expected");
                        message.imputedStringDictionary = $root.CoreML.Specification.StringToDoubleMap.fromObject(object.imputedStringDictionary);
                    }
                    if (object.imputedInt64Dictionary != null) {
                        if (typeof object.imputedInt64Dictionary !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedInt64Dictionary: object expected");
                        message.imputedInt64Dictionary = $root.CoreML.Specification.Int64ToDoubleMap.fromObject(object.imputedInt64Dictionary);
                    }
                    if (object.replaceDoubleValue != null)
                        message.replaceDoubleValue = Number(object.replaceDoubleValue);
                    if (object.replaceInt64Value != null)
                        if ($util.Long)
                            (message.replaceInt64Value = $util.Long.fromValue(object.replaceInt64Value)).unsigned = false;
                        else if (typeof object.replaceInt64Value === "string")
                            message.replaceInt64Value = parseInt(object.replaceInt64Value, 10);
                        else if (typeof object.replaceInt64Value === "number")
                            message.replaceInt64Value = object.replaceInt64Value;
                        else if (typeof object.replaceInt64Value === "object")
                            message.replaceInt64Value = new $util.LongBits(object.replaceInt64Value.low >>> 0, object.replaceInt64Value.high >>> 0).toNumber();
                    if (object.replaceStringValue != null)
                        message.replaceStringValue = String(object.replaceStringValue);
                    return message;
                };
    
                Imputer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.imputedDoubleValue != null && message.hasOwnProperty("imputedDoubleValue")) {
                        object.imputedDoubleValue = options.json && !isFinite(message.imputedDoubleValue) ? String(message.imputedDoubleValue) : message.imputedDoubleValue;
                        if (options.oneofs)
                            object.ImputedValue = "imputedDoubleValue";
                    }
                    if (message.imputedInt64Value != null && message.hasOwnProperty("imputedInt64Value")) {
                        if (typeof message.imputedInt64Value === "number")
                            object.imputedInt64Value = options.longs === String ? String(message.imputedInt64Value) : message.imputedInt64Value;
                        else
                            object.imputedInt64Value = options.longs === String ? $util.Long.prototype.toString.call(message.imputedInt64Value) : options.longs === Number ? new $util.LongBits(message.imputedInt64Value.low >>> 0, message.imputedInt64Value.high >>> 0).toNumber() : message.imputedInt64Value;
                        if (options.oneofs)
                            object.ImputedValue = "imputedInt64Value";
                    }
                    if (message.imputedStringValue != null && message.hasOwnProperty("imputedStringValue")) {
                        object.imputedStringValue = message.imputedStringValue;
                        if (options.oneofs)
                            object.ImputedValue = "imputedStringValue";
                    }
                    if (message.imputedDoubleArray != null && message.hasOwnProperty("imputedDoubleArray")) {
                        object.imputedDoubleArray = $root.CoreML.Specification.DoubleVector.toObject(message.imputedDoubleArray, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedDoubleArray";
                    }
                    if (message.imputedInt64Array != null && message.hasOwnProperty("imputedInt64Array")) {
                        object.imputedInt64Array = $root.CoreML.Specification.Int64Vector.toObject(message.imputedInt64Array, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedInt64Array";
                    }
                    if (message.imputedStringDictionary != null && message.hasOwnProperty("imputedStringDictionary")) {
                        object.imputedStringDictionary = $root.CoreML.Specification.StringToDoubleMap.toObject(message.imputedStringDictionary, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedStringDictionary";
                    }
                    if (message.imputedInt64Dictionary != null && message.hasOwnProperty("imputedInt64Dictionary")) {
                        object.imputedInt64Dictionary = $root.CoreML.Specification.Int64ToDoubleMap.toObject(message.imputedInt64Dictionary, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedInt64Dictionary";
                    }
                    if (message.replaceDoubleValue != null && message.hasOwnProperty("replaceDoubleValue")) {
                        object.replaceDoubleValue = options.json && !isFinite(message.replaceDoubleValue) ? String(message.replaceDoubleValue) : message.replaceDoubleValue;
                        if (options.oneofs)
                            object.ReplaceValue = "replaceDoubleValue";
                    }
                    if (message.replaceInt64Value != null && message.hasOwnProperty("replaceInt64Value")) {
                        if (typeof message.replaceInt64Value === "number")
                            object.replaceInt64Value = options.longs === String ? String(message.replaceInt64Value) : message.replaceInt64Value;
                        else
                            object.replaceInt64Value = options.longs === String ? $util.Long.prototype.toString.call(message.replaceInt64Value) : options.longs === Number ? new $util.LongBits(message.replaceInt64Value.low >>> 0, message.replaceInt64Value.high >>> 0).toNumber() : message.replaceInt64Value;
                        if (options.oneofs)
                            object.ReplaceValue = "replaceInt64Value";
                    }
                    if (message.replaceStringValue != null && message.hasOwnProperty("replaceStringValue")) {
                        object.replaceStringValue = message.replaceStringValue;
                        if (options.oneofs)
                            object.ReplaceValue = "replaceStringValue";
                    }
                    return object;
                };
    
                Imputer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Imputer;
            })();
    
            Specification.NeuralNetwork = (function() {
    
                function NeuralNetwork(properties) {
                    this.layers = [];
                    this.preprocessing = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetwork.prototype.layers = $util.emptyArray;
                NeuralNetwork.prototype.preprocessing = $util.emptyArray;
    
                NeuralNetwork.create = function create(properties) {
                    return new NeuralNetwork(properties);
                };
    
                NeuralNetwork.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetwork();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.layers && message.layers.length))
                                message.layers = [];
                            message.layers.push($root.CoreML.Specification.NeuralNetworkLayer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.preprocessing && message.preprocessing.length))
                                message.preprocessing = [];
                            message.preprocessing.push($root.CoreML.Specification.NeuralNetworkPreprocessing.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetwork.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.layers != null && message.hasOwnProperty("layers")) {
                        if (!Array.isArray(message.layers))
                            return "layers: array expected";
                        for (var i = 0; i < message.layers.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkLayer.verify(message.layers[i]);
                            if (error)
                                return "layers." + error;
                        }
                    }
                    if (message.preprocessing != null && message.hasOwnProperty("preprocessing")) {
                        if (!Array.isArray(message.preprocessing))
                            return "preprocessing: array expected";
                        for (var i = 0; i < message.preprocessing.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkPreprocessing.verify(message.preprocessing[i]);
                            if (error)
                                return "preprocessing." + error;
                        }
                    }
                    return null;
                };
    
                NeuralNetwork.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetwork)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetwork();
                    if (object.layers) {
                        if (!Array.isArray(object.layers))
                            throw TypeError(".CoreML.Specification.NeuralNetwork.layers: array expected");
                        message.layers = [];
                        for (var i = 0; i < object.layers.length; ++i) {
                            if (typeof object.layers[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetwork.layers: object expected");
                            message.layers[i] = $root.CoreML.Specification.NeuralNetworkLayer.fromObject(object.layers[i]);
                        }
                    }
                    if (object.preprocessing) {
                        if (!Array.isArray(object.preprocessing))
                            throw TypeError(".CoreML.Specification.NeuralNetwork.preprocessing: array expected");
                        message.preprocessing = [];
                        for (var i = 0; i < object.preprocessing.length; ++i) {
                            if (typeof object.preprocessing[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetwork.preprocessing: object expected");
                            message.preprocessing[i] = $root.CoreML.Specification.NeuralNetworkPreprocessing.fromObject(object.preprocessing[i]);
                        }
                    }
                    return message;
                };
    
                NeuralNetwork.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.layers = [];
                        object.preprocessing = [];
                    }
                    if (message.layers && message.layers.length) {
                        object.layers = [];
                        for (var j = 0; j < message.layers.length; ++j)
                            object.layers[j] = $root.CoreML.Specification.NeuralNetworkLayer.toObject(message.layers[j], options);
                    }
                    if (message.preprocessing && message.preprocessing.length) {
                        object.preprocessing = [];
                        for (var j = 0; j < message.preprocessing.length; ++j)
                            object.preprocessing[j] = $root.CoreML.Specification.NeuralNetworkPreprocessing.toObject(message.preprocessing[j], options);
                    }
                    return object;
                };
    
                NeuralNetwork.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetwork;
            })();
    
            Specification.NeuralNetworkImageScaler = (function() {
    
                function NeuralNetworkImageScaler(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetworkImageScaler.prototype.channelScale = 0;
                NeuralNetworkImageScaler.prototype.blueBias = 0;
                NeuralNetworkImageScaler.prototype.greenBias = 0;
                NeuralNetworkImageScaler.prototype.redBias = 0;
                NeuralNetworkImageScaler.prototype.grayBias = 0;
    
                NeuralNetworkImageScaler.create = function create(properties) {
                    return new NeuralNetworkImageScaler(properties);
                };
    
                NeuralNetworkImageScaler.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkImageScaler();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.channelScale = reader.float();
                            break;
                        case 20:
                            message.blueBias = reader.float();
                            break;
                        case 21:
                            message.greenBias = reader.float();
                            break;
                        case 22:
                            message.redBias = reader.float();
                            break;
                        case 30:
                            message.grayBias = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetworkImageScaler.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.channelScale != null && message.hasOwnProperty("channelScale"))
                        if (typeof message.channelScale !== "number")
                            return "channelScale: number expected";
                    if (message.blueBias != null && message.hasOwnProperty("blueBias"))
                        if (typeof message.blueBias !== "number")
                            return "blueBias: number expected";
                    if (message.greenBias != null && message.hasOwnProperty("greenBias"))
                        if (typeof message.greenBias !== "number")
                            return "greenBias: number expected";
                    if (message.redBias != null && message.hasOwnProperty("redBias"))
                        if (typeof message.redBias !== "number")
                            return "redBias: number expected";
                    if (message.grayBias != null && message.hasOwnProperty("grayBias"))
                        if (typeof message.grayBias !== "number")
                            return "grayBias: number expected";
                    return null;
                };
    
                NeuralNetworkImageScaler.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkImageScaler)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkImageScaler();
                    if (object.channelScale != null)
                        message.channelScale = Number(object.channelScale);
                    if (object.blueBias != null)
                        message.blueBias = Number(object.blueBias);
                    if (object.greenBias != null)
                        message.greenBias = Number(object.greenBias);
                    if (object.redBias != null)
                        message.redBias = Number(object.redBias);
                    if (object.grayBias != null)
                        message.grayBias = Number(object.grayBias);
                    return message;
                };
    
                NeuralNetworkImageScaler.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.channelScale = 0;
                        object.blueBias = 0;
                        object.greenBias = 0;
                        object.redBias = 0;
                        object.grayBias = 0;
                    }
                    if (message.channelScale != null && message.hasOwnProperty("channelScale"))
                        object.channelScale = options.json && !isFinite(message.channelScale) ? String(message.channelScale) : message.channelScale;
                    if (message.blueBias != null && message.hasOwnProperty("blueBias"))
                        object.blueBias = options.json && !isFinite(message.blueBias) ? String(message.blueBias) : message.blueBias;
                    if (message.greenBias != null && message.hasOwnProperty("greenBias"))
                        object.greenBias = options.json && !isFinite(message.greenBias) ? String(message.greenBias) : message.greenBias;
                    if (message.redBias != null && message.hasOwnProperty("redBias"))
                        object.redBias = options.json && !isFinite(message.redBias) ? String(message.redBias) : message.redBias;
                    if (message.grayBias != null && message.hasOwnProperty("grayBias"))
                        object.grayBias = options.json && !isFinite(message.grayBias) ? String(message.grayBias) : message.grayBias;
                    return object;
                };
    
                NeuralNetworkImageScaler.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkImageScaler;
            })();
    
            Specification.NeuralNetworkMeanImage = (function() {
    
                function NeuralNetworkMeanImage(properties) {
                    this.meanImage = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetworkMeanImage.prototype.meanImage = $util.emptyArray;
    
                NeuralNetworkMeanImage.create = function create(properties) {
                    return new NeuralNetworkMeanImage(properties);
                };
    
                NeuralNetworkMeanImage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkMeanImage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.meanImage && message.meanImage.length))
                                message.meanImage = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.meanImage.push(reader.float());
                            } else
                                message.meanImage.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetworkMeanImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meanImage != null && message.hasOwnProperty("meanImage")) {
                        if (!Array.isArray(message.meanImage))
                            return "meanImage: array expected";
                        for (var i = 0; i < message.meanImage.length; ++i)
                            if (typeof message.meanImage[i] !== "number")
                                return "meanImage: number[] expected";
                    }
                    return null;
                };
    
                NeuralNetworkMeanImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkMeanImage)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkMeanImage();
                    if (object.meanImage) {
                        if (!Array.isArray(object.meanImage))
                            throw TypeError(".CoreML.Specification.NeuralNetworkMeanImage.meanImage: array expected");
                        message.meanImage = [];
                        for (var i = 0; i < object.meanImage.length; ++i)
                            message.meanImage[i] = Number(object.meanImage[i]);
                    }
                    return message;
                };
    
                NeuralNetworkMeanImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.meanImage = [];
                    if (message.meanImage && message.meanImage.length) {
                        object.meanImage = [];
                        for (var j = 0; j < message.meanImage.length; ++j)
                            object.meanImage[j] = options.json && !isFinite(message.meanImage[j]) ? String(message.meanImage[j]) : message.meanImage[j];
                    }
                    return object;
                };
    
                NeuralNetworkMeanImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkMeanImage;
            })();
    
            Specification.NeuralNetworkPreprocessing = (function() {
    
                function NeuralNetworkPreprocessing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetworkPreprocessing.prototype.featureName = "";
                NeuralNetworkPreprocessing.prototype.scaler = null;
                NeuralNetworkPreprocessing.prototype.meanImage = null;
    
                var $oneOfFields;
    
                Object.defineProperty(NeuralNetworkPreprocessing.prototype, "preprocessor", {
                    get: $util.oneOfGetter($oneOfFields = ["scaler", "meanImage"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                NeuralNetworkPreprocessing.create = function create(properties) {
                    return new NeuralNetworkPreprocessing(properties);
                };
    
                NeuralNetworkPreprocessing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkPreprocessing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.featureName = reader.string();
                            break;
                        case 10:
                            message.scaler = $root.CoreML.Specification.NeuralNetworkImageScaler.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.meanImage = $root.CoreML.Specification.NeuralNetworkMeanImage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetworkPreprocessing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.featureName != null && message.hasOwnProperty("featureName"))
                        if (!$util.isString(message.featureName))
                            return "featureName: string expected";
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        properties.preprocessor = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkImageScaler.verify(message.scaler);
                            if (error)
                                return "scaler." + error;
                        }
                    }
                    if (message.meanImage != null && message.hasOwnProperty("meanImage")) {
                        if (properties.preprocessor === 1)
                            return "preprocessor: multiple values";
                        properties.preprocessor = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkMeanImage.verify(message.meanImage);
                            if (error)
                                return "meanImage." + error;
                        }
                    }
                    return null;
                };
    
                NeuralNetworkPreprocessing.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkPreprocessing)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkPreprocessing();
                    if (object.featureName != null)
                        message.featureName = String(object.featureName);
                    if (object.scaler != null) {
                        if (typeof object.scaler !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkPreprocessing.scaler: object expected");
                        message.scaler = $root.CoreML.Specification.NeuralNetworkImageScaler.fromObject(object.scaler);
                    }
                    if (object.meanImage != null) {
                        if (typeof object.meanImage !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkPreprocessing.meanImage: object expected");
                        message.meanImage = $root.CoreML.Specification.NeuralNetworkMeanImage.fromObject(object.meanImage);
                    }
                    return message;
                };
    
                NeuralNetworkPreprocessing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.featureName = "";
                    if (message.featureName != null && message.hasOwnProperty("featureName"))
                        object.featureName = message.featureName;
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        object.scaler = $root.CoreML.Specification.NeuralNetworkImageScaler.toObject(message.scaler, options);
                        if (options.oneofs)
                            object.preprocessor = "scaler";
                    }
                    if (message.meanImage != null && message.hasOwnProperty("meanImage")) {
                        object.meanImage = $root.CoreML.Specification.NeuralNetworkMeanImage.toObject(message.meanImage, options);
                        if (options.oneofs)
                            object.preprocessor = "meanImage";
                    }
                    return object;
                };
    
                NeuralNetworkPreprocessing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkPreprocessing;
            })();
    
            Specification.ActivationReLU = (function() {
    
                function ActivationReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationReLU.create = function create(properties) {
                    return new ActivationReLU(properties);
                };
    
                ActivationReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                ActivationReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationReLU)
                        return object;
                    return new $root.CoreML.Specification.ActivationReLU();
                };
    
                ActivationReLU.toObject = function toObject() {
                    return {};
                };
    
                ActivationReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationReLU;
            })();
    
            Specification.ActivationLeakyReLU = (function() {
    
                function ActivationLeakyReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationLeakyReLU.prototype.alpha = 0;
    
                ActivationLeakyReLU.create = function create(properties) {
                    return new ActivationLeakyReLU(properties);
                };
    
                ActivationLeakyReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationLeakyReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationLeakyReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                ActivationLeakyReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationLeakyReLU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationLeakyReLU();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                ActivationLeakyReLU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                ActivationLeakyReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationLeakyReLU;
            })();
    
            Specification.ActivationTanh = (function() {
    
                function ActivationTanh(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationTanh.create = function create(properties) {
                    return new ActivationTanh(properties);
                };
    
                ActivationTanh.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationTanh();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationTanh.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                ActivationTanh.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationTanh)
                        return object;
                    return new $root.CoreML.Specification.ActivationTanh();
                };
    
                ActivationTanh.toObject = function toObject() {
                    return {};
                };
    
                ActivationTanh.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationTanh;
            })();
    
            Specification.ActivationScaledTanh = (function() {
    
                function ActivationScaledTanh(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationScaledTanh.prototype.alpha = 0;
                ActivationScaledTanh.prototype.beta = 0;
    
                ActivationScaledTanh.create = function create(properties) {
                    return new ActivationScaledTanh(properties);
                };
    
                ActivationScaledTanh.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationScaledTanh();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationScaledTanh.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    return null;
                };
    
                ActivationScaledTanh.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationScaledTanh)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationScaledTanh();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    return message;
                };
    
                ActivationScaledTanh.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    return object;
                };
    
                ActivationScaledTanh.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationScaledTanh;
            })();
    
            Specification.ActivationSigmoid = (function() {
    
                function ActivationSigmoid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationSigmoid.create = function create(properties) {
                    return new ActivationSigmoid(properties);
                };
    
                ActivationSigmoid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSigmoid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationSigmoid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                ActivationSigmoid.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSigmoid)
                        return object;
                    return new $root.CoreML.Specification.ActivationSigmoid();
                };
    
                ActivationSigmoid.toObject = function toObject() {
                    return {};
                };
    
                ActivationSigmoid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSigmoid;
            })();
    
            Specification.ActivationLinear = (function() {
    
                function ActivationLinear(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationLinear.prototype.alpha = 0;
                ActivationLinear.prototype.beta = 0;
    
                ActivationLinear.create = function create(properties) {
                    return new ActivationLinear(properties);
                };
    
                ActivationLinear.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationLinear();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationLinear.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    return null;
                };
    
                ActivationLinear.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationLinear)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationLinear();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    return message;
                };
    
                ActivationLinear.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    return object;
                };
    
                ActivationLinear.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationLinear;
            })();
    
            Specification.ActivationSigmoidHard = (function() {
    
                function ActivationSigmoidHard(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationSigmoidHard.prototype.alpha = 0;
                ActivationSigmoidHard.prototype.beta = 0;
    
                ActivationSigmoidHard.create = function create(properties) {
                    return new ActivationSigmoidHard(properties);
                };
    
                ActivationSigmoidHard.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSigmoidHard();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationSigmoidHard.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    return null;
                };
    
                ActivationSigmoidHard.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSigmoidHard)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationSigmoidHard();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    return message;
                };
    
                ActivationSigmoidHard.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    return object;
                };
    
                ActivationSigmoidHard.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSigmoidHard;
            })();
    
            Specification.ActivationPReLU = (function() {
    
                function ActivationPReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationPReLU.prototype.alpha = null;
    
                ActivationPReLU.create = function create(properties) {
                    return new ActivationPReLU(properties);
                };
    
                ActivationPReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationPReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationPReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.alpha);
                        if (error)
                            return "alpha." + error;
                    }
                    return null;
                };
    
                ActivationPReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationPReLU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationPReLU();
                    if (object.alpha != null) {
                        if (typeof object.alpha !== "object")
                            throw TypeError(".CoreML.Specification.ActivationPReLU.alpha: object expected");
                        message.alpha = $root.CoreML.Specification.WeightParams.fromObject(object.alpha);
                    }
                    return message;
                };
    
                ActivationPReLU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = null;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = $root.CoreML.Specification.WeightParams.toObject(message.alpha, options);
                    return object;
                };
    
                ActivationPReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationPReLU;
            })();
    
            Specification.ActivationELU = (function() {
    
                function ActivationELU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationELU.prototype.alpha = 0;
    
                ActivationELU.create = function create(properties) {
                    return new ActivationELU(properties);
                };
    
                ActivationELU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationELU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationELU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                ActivationELU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationELU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationELU();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                ActivationELU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                ActivationELU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationELU;
            })();
    
            Specification.ActivationThresholdedReLU = (function() {
    
                function ActivationThresholdedReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationThresholdedReLU.prototype.alpha = 0;
    
                ActivationThresholdedReLU.create = function create(properties) {
                    return new ActivationThresholdedReLU(properties);
                };
    
                ActivationThresholdedReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationThresholdedReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationThresholdedReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                ActivationThresholdedReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationThresholdedReLU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationThresholdedReLU();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                ActivationThresholdedReLU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                ActivationThresholdedReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationThresholdedReLU;
            })();
    
            Specification.ActivationSoftsign = (function() {
    
                function ActivationSoftsign(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationSoftsign.create = function create(properties) {
                    return new ActivationSoftsign(properties);
                };
    
                ActivationSoftsign.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSoftsign();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationSoftsign.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                ActivationSoftsign.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSoftsign)
                        return object;
                    return new $root.CoreML.Specification.ActivationSoftsign();
                };
    
                ActivationSoftsign.toObject = function toObject() {
                    return {};
                };
    
                ActivationSoftsign.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSoftsign;
            })();
    
            Specification.ActivationSoftplus = (function() {
    
                function ActivationSoftplus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationSoftplus.create = function create(properties) {
                    return new ActivationSoftplus(properties);
                };
    
                ActivationSoftplus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSoftplus();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationSoftplus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                ActivationSoftplus.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSoftplus)
                        return object;
                    return new $root.CoreML.Specification.ActivationSoftplus();
                };
    
                ActivationSoftplus.toObject = function toObject() {
                    return {};
                };
    
                ActivationSoftplus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSoftplus;
            })();
    
            Specification.ActivationParametricSoftplus = (function() {
    
                function ActivationParametricSoftplus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationParametricSoftplus.prototype.alpha = null;
                ActivationParametricSoftplus.prototype.beta = null;
    
                ActivationParametricSoftplus.create = function create(properties) {
                    return new ActivationParametricSoftplus(properties);
                };
    
                ActivationParametricSoftplus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationParametricSoftplus();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.beta = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationParametricSoftplus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.alpha);
                        if (error)
                            return "alpha." + error;
                    }
                    if (message.beta != null && message.hasOwnProperty("beta")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.beta);
                        if (error)
                            return "beta." + error;
                    }
                    return null;
                };
    
                ActivationParametricSoftplus.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationParametricSoftplus)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationParametricSoftplus();
                    if (object.alpha != null) {
                        if (typeof object.alpha !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParametricSoftplus.alpha: object expected");
                        message.alpha = $root.CoreML.Specification.WeightParams.fromObject(object.alpha);
                    }
                    if (object.beta != null) {
                        if (typeof object.beta !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParametricSoftplus.beta: object expected");
                        message.beta = $root.CoreML.Specification.WeightParams.fromObject(object.beta);
                    }
                    return message;
                };
    
                ActivationParametricSoftplus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = null;
                        object.beta = null;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = $root.CoreML.Specification.WeightParams.toObject(message.alpha, options);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = $root.CoreML.Specification.WeightParams.toObject(message.beta, options);
                    return object;
                };
    
                ActivationParametricSoftplus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationParametricSoftplus;
            })();
    
            Specification.ActivationParams = (function() {
    
                function ActivationParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ActivationParams.prototype.linear = null;
                ActivationParams.prototype.ReLU = null;
                ActivationParams.prototype.leakyReLU = null;
                ActivationParams.prototype.thresholdedReLU = null;
                ActivationParams.prototype.PReLU = null;
                ActivationParams.prototype.tanh = null;
                ActivationParams.prototype.scaledTanh = null;
                ActivationParams.prototype.sigmoid = null;
                ActivationParams.prototype.sigmoidHard = null;
                ActivationParams.prototype.ELU = null;
                ActivationParams.prototype.softsign = null;
                ActivationParams.prototype.softplus = null;
                ActivationParams.prototype.parametricSoftplus = null;
    
                var $oneOfFields;
    
                Object.defineProperty(ActivationParams.prototype, "NonlinearityType", {
                    get: $util.oneOfGetter($oneOfFields = ["linear", "ReLU", "leakyReLU", "thresholdedReLU", "PReLU", "tanh", "scaledTanh", "sigmoid", "sigmoidHard", "ELU", "softsign", "softplus", "parametricSoftplus"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                ActivationParams.create = function create(properties) {
                    return new ActivationParams(properties);
                };
    
                ActivationParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 5:
                            message.linear = $root.CoreML.Specification.ActivationLinear.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.ReLU = $root.CoreML.Specification.ActivationReLU.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.leakyReLU = $root.CoreML.Specification.ActivationLeakyReLU.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.thresholdedReLU = $root.CoreML.Specification.ActivationThresholdedReLU.decode(reader, reader.uint32());
                            break;
                        case 25:
                            message.PReLU = $root.CoreML.Specification.ActivationPReLU.decode(reader, reader.uint32());
                            break;
                        case 30:
                            message.tanh = $root.CoreML.Specification.ActivationTanh.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.scaledTanh = $root.CoreML.Specification.ActivationScaledTanh.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.sigmoid = $root.CoreML.Specification.ActivationSigmoid.decode(reader, reader.uint32());
                            break;
                        case 41:
                            message.sigmoidHard = $root.CoreML.Specification.ActivationSigmoidHard.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.ELU = $root.CoreML.Specification.ActivationELU.decode(reader, reader.uint32());
                            break;
                        case 60:
                            message.softsign = $root.CoreML.Specification.ActivationSoftsign.decode(reader, reader.uint32());
                            break;
                        case 70:
                            message.softplus = $root.CoreML.Specification.ActivationSoftplus.decode(reader, reader.uint32());
                            break;
                        case 71:
                            message.parametricSoftplus = $root.CoreML.Specification.ActivationParametricSoftplus.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ActivationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.linear != null && message.hasOwnProperty("linear")) {
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationLinear.verify(message.linear);
                            if (error)
                                return "linear." + error;
                        }
                    }
                    if (message.ReLU != null && message.hasOwnProperty("ReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationReLU.verify(message.ReLU);
                            if (error)
                                return "ReLU." + error;
                        }
                    }
                    if (message.leakyReLU != null && message.hasOwnProperty("leakyReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationLeakyReLU.verify(message.leakyReLU);
                            if (error)
                                return "leakyReLU." + error;
                        }
                    }
                    if (message.thresholdedReLU != null && message.hasOwnProperty("thresholdedReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationThresholdedReLU.verify(message.thresholdedReLU);
                            if (error)
                                return "thresholdedReLU." + error;
                        }
                    }
                    if (message.PReLU != null && message.hasOwnProperty("PReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationPReLU.verify(message.PReLU);
                            if (error)
                                return "PReLU." + error;
                        }
                    }
                    if (message.tanh != null && message.hasOwnProperty("tanh")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationTanh.verify(message.tanh);
                            if (error)
                                return "tanh." + error;
                        }
                    }
                    if (message.scaledTanh != null && message.hasOwnProperty("scaledTanh")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationScaledTanh.verify(message.scaledTanh);
                            if (error)
                                return "scaledTanh." + error;
                        }
                    }
                    if (message.sigmoid != null && message.hasOwnProperty("sigmoid")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSigmoid.verify(message.sigmoid);
                            if (error)
                                return "sigmoid." + error;
                        }
                    }
                    if (message.sigmoidHard != null && message.hasOwnProperty("sigmoidHard")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSigmoidHard.verify(message.sigmoidHard);
                            if (error)
                                return "sigmoidHard." + error;
                        }
                    }
                    if (message.ELU != null && message.hasOwnProperty("ELU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationELU.verify(message.ELU);
                            if (error)
                                return "ELU." + error;
                        }
                    }
                    if (message.softsign != null && message.hasOwnProperty("softsign")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSoftsign.verify(message.softsign);
                            if (error)
                                return "softsign." + error;
                        }
                    }
                    if (message.softplus != null && message.hasOwnProperty("softplus")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSoftplus.verify(message.softplus);
                            if (error)
                                return "softplus." + error;
                        }
                    }
                    if (message.parametricSoftplus != null && message.hasOwnProperty("parametricSoftplus")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationParametricSoftplus.verify(message.parametricSoftplus);
                            if (error)
                                return "parametricSoftplus." + error;
                        }
                    }
                    return null;
                };
    
                ActivationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationParams)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationParams();
                    if (object.linear != null) {
                        if (typeof object.linear !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.linear: object expected");
                        message.linear = $root.CoreML.Specification.ActivationLinear.fromObject(object.linear);
                    }
                    if (object.ReLU != null) {
                        if (typeof object.ReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.ReLU: object expected");
                        message.ReLU = $root.CoreML.Specification.ActivationReLU.fromObject(object.ReLU);
                    }
                    if (object.leakyReLU != null) {
                        if (typeof object.leakyReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.leakyReLU: object expected");
                        message.leakyReLU = $root.CoreML.Specification.ActivationLeakyReLU.fromObject(object.leakyReLU);
                    }
                    if (object.thresholdedReLU != null) {
                        if (typeof object.thresholdedReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.thresholdedReLU: object expected");
                        message.thresholdedReLU = $root.CoreML.Specification.ActivationThresholdedReLU.fromObject(object.thresholdedReLU);
                    }
                    if (object.PReLU != null) {
                        if (typeof object.PReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.PReLU: object expected");
                        message.PReLU = $root.CoreML.Specification.ActivationPReLU.fromObject(object.PReLU);
                    }
                    if (object.tanh != null) {
                        if (typeof object.tanh !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.tanh: object expected");
                        message.tanh = $root.CoreML.Specification.ActivationTanh.fromObject(object.tanh);
                    }
                    if (object.scaledTanh != null) {
                        if (typeof object.scaledTanh !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.scaledTanh: object expected");
                        message.scaledTanh = $root.CoreML.Specification.ActivationScaledTanh.fromObject(object.scaledTanh);
                    }
                    if (object.sigmoid != null) {
                        if (typeof object.sigmoid !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.sigmoid: object expected");
                        message.sigmoid = $root.CoreML.Specification.ActivationSigmoid.fromObject(object.sigmoid);
                    }
                    if (object.sigmoidHard != null) {
                        if (typeof object.sigmoidHard !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.sigmoidHard: object expected");
                        message.sigmoidHard = $root.CoreML.Specification.ActivationSigmoidHard.fromObject(object.sigmoidHard);
                    }
                    if (object.ELU != null) {
                        if (typeof object.ELU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.ELU: object expected");
                        message.ELU = $root.CoreML.Specification.ActivationELU.fromObject(object.ELU);
                    }
                    if (object.softsign != null) {
                        if (typeof object.softsign !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.softsign: object expected");
                        message.softsign = $root.CoreML.Specification.ActivationSoftsign.fromObject(object.softsign);
                    }
                    if (object.softplus != null) {
                        if (typeof object.softplus !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.softplus: object expected");
                        message.softplus = $root.CoreML.Specification.ActivationSoftplus.fromObject(object.softplus);
                    }
                    if (object.parametricSoftplus != null) {
                        if (typeof object.parametricSoftplus !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.parametricSoftplus: object expected");
                        message.parametricSoftplus = $root.CoreML.Specification.ActivationParametricSoftplus.fromObject(object.parametricSoftplus);
                    }
                    return message;
                };
    
                ActivationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.linear != null && message.hasOwnProperty("linear")) {
                        object.linear = $root.CoreML.Specification.ActivationLinear.toObject(message.linear, options);
                        if (options.oneofs)
                            object.NonlinearityType = "linear";
                    }
                    if (message.ReLU != null && message.hasOwnProperty("ReLU")) {
                        object.ReLU = $root.CoreML.Specification.ActivationReLU.toObject(message.ReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "ReLU";
                    }
                    if (message.leakyReLU != null && message.hasOwnProperty("leakyReLU")) {
                        object.leakyReLU = $root.CoreML.Specification.ActivationLeakyReLU.toObject(message.leakyReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "leakyReLU";
                    }
                    if (message.thresholdedReLU != null && message.hasOwnProperty("thresholdedReLU")) {
                        object.thresholdedReLU = $root.CoreML.Specification.ActivationThresholdedReLU.toObject(message.thresholdedReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "thresholdedReLU";
                    }
                    if (message.PReLU != null && message.hasOwnProperty("PReLU")) {
                        object.PReLU = $root.CoreML.Specification.ActivationPReLU.toObject(message.PReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "PReLU";
                    }
                    if (message.tanh != null && message.hasOwnProperty("tanh")) {
                        object.tanh = $root.CoreML.Specification.ActivationTanh.toObject(message.tanh, options);
                        if (options.oneofs)
                            object.NonlinearityType = "tanh";
                    }
                    if (message.scaledTanh != null && message.hasOwnProperty("scaledTanh")) {
                        object.scaledTanh = $root.CoreML.Specification.ActivationScaledTanh.toObject(message.scaledTanh, options);
                        if (options.oneofs)
                            object.NonlinearityType = "scaledTanh";
                    }
                    if (message.sigmoid != null && message.hasOwnProperty("sigmoid")) {
                        object.sigmoid = $root.CoreML.Specification.ActivationSigmoid.toObject(message.sigmoid, options);
                        if (options.oneofs)
                            object.NonlinearityType = "sigmoid";
                    }
                    if (message.sigmoidHard != null && message.hasOwnProperty("sigmoidHard")) {
                        object.sigmoidHard = $root.CoreML.Specification.ActivationSigmoidHard.toObject(message.sigmoidHard, options);
                        if (options.oneofs)
                            object.NonlinearityType = "sigmoidHard";
                    }
                    if (message.ELU != null && message.hasOwnProperty("ELU")) {
                        object.ELU = $root.CoreML.Specification.ActivationELU.toObject(message.ELU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "ELU";
                    }
                    if (message.softsign != null && message.hasOwnProperty("softsign")) {
                        object.softsign = $root.CoreML.Specification.ActivationSoftsign.toObject(message.softsign, options);
                        if (options.oneofs)
                            object.NonlinearityType = "softsign";
                    }
                    if (message.softplus != null && message.hasOwnProperty("softplus")) {
                        object.softplus = $root.CoreML.Specification.ActivationSoftplus.toObject(message.softplus, options);
                        if (options.oneofs)
                            object.NonlinearityType = "softplus";
                    }
                    if (message.parametricSoftplus != null && message.hasOwnProperty("parametricSoftplus")) {
                        object.parametricSoftplus = $root.CoreML.Specification.ActivationParametricSoftplus.toObject(message.parametricSoftplus, options);
                        if (options.oneofs)
                            object.NonlinearityType = "parametricSoftplus";
                    }
                    return object;
                };
    
                ActivationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationParams;
            })();
    
            Specification.NeuralNetworkLayer = (function() {
    
                function NeuralNetworkLayer(properties) {
                    this.input = [];
                    this.output = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetworkLayer.prototype.name = "";
                NeuralNetworkLayer.prototype.input = $util.emptyArray;
                NeuralNetworkLayer.prototype.output = $util.emptyArray;
                NeuralNetworkLayer.prototype.convolution = null;
                NeuralNetworkLayer.prototype.pooling = null;
                NeuralNetworkLayer.prototype.activation = null;
                NeuralNetworkLayer.prototype.innerProduct = null;
                NeuralNetworkLayer.prototype.embedding = null;
                NeuralNetworkLayer.prototype.batchnorm = null;
                NeuralNetworkLayer.prototype.mvn = null;
                NeuralNetworkLayer.prototype.l2normalize = null;
                NeuralNetworkLayer.prototype.softmax = null;
                NeuralNetworkLayer.prototype.lrn = null;
                NeuralNetworkLayer.prototype.crop = null;
                NeuralNetworkLayer.prototype.padding = null;
                NeuralNetworkLayer.prototype.upsample = null;
                NeuralNetworkLayer.prototype.resizeBilinear = null;
                NeuralNetworkLayer.prototype.cropResize = null;
                NeuralNetworkLayer.prototype.unary = null;
                NeuralNetworkLayer.prototype.add = null;
                NeuralNetworkLayer.prototype.multiply = null;
                NeuralNetworkLayer.prototype.average = null;
                NeuralNetworkLayer.prototype.scale = null;
                NeuralNetworkLayer.prototype.bias = null;
                NeuralNetworkLayer.prototype.max = null;
                NeuralNetworkLayer.prototype.min = null;
                NeuralNetworkLayer.prototype.dot = null;
                NeuralNetworkLayer.prototype.reduce = null;
                NeuralNetworkLayer.prototype.loadConstant = null;
                NeuralNetworkLayer.prototype.reshape = null;
                NeuralNetworkLayer.prototype.flatten = null;
                NeuralNetworkLayer.prototype.permute = null;
                NeuralNetworkLayer.prototype.concat = null;
                NeuralNetworkLayer.prototype.split = null;
                NeuralNetworkLayer.prototype.sequenceRepeat = null;
                NeuralNetworkLayer.prototype.reorganizeData = null;
                NeuralNetworkLayer.prototype.slice = null;
                NeuralNetworkLayer.prototype.simpleRecurrent = null;
                NeuralNetworkLayer.prototype.gru = null;
                NeuralNetworkLayer.prototype.uniDirectionalLSTM = null;
                NeuralNetworkLayer.prototype.biDirectionalLSTM = null;
                NeuralNetworkLayer.prototype.custom = null;
    
                var $oneOfFields;
    
                Object.defineProperty(NeuralNetworkLayer.prototype, "layer", {
                    get: $util.oneOfGetter($oneOfFields = ["convolution", "pooling", "activation", "innerProduct", "embedding", "batchnorm", "mvn", "l2normalize", "softmax", "lrn", "crop", "padding", "upsample", "resizeBilinear", "cropResize", "unary", "add", "multiply", "average", "scale", "bias", "max", "min", "dot", "reduce", "loadConstant", "reshape", "flatten", "permute", "concat", "split", "sequenceRepeat", "reorganizeData", "slice", "simpleRecurrent", "gru", "uniDirectionalLSTM", "biDirectionalLSTM", "custom"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                NeuralNetworkLayer.create = function create(properties) {
                    return new NeuralNetworkLayer(properties);
                };
    
                NeuralNetworkLayer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkLayer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.input && message.input.length))
                                message.input = [];
                            message.input.push(reader.string());
                            break;
                        case 3:
                            if (!(message.output && message.output.length))
                                message.output = [];
                            message.output.push(reader.string());
                            break;
                        case 100:
                            message.convolution = $root.CoreML.Specification.ConvolutionLayerParams.decode(reader, reader.uint32());
                            break;
                        case 120:
                            message.pooling = $root.CoreML.Specification.PoolingLayerParams.decode(reader, reader.uint32());
                            break;
                        case 130:
                            message.activation = $root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32());
                            break;
                        case 140:
                            message.innerProduct = $root.CoreML.Specification.InnerProductLayerParams.decode(reader, reader.uint32());
                            break;
                        case 150:
                            message.embedding = $root.CoreML.Specification.EmbeddingLayerParams.decode(reader, reader.uint32());
                            break;
                        case 160:
                            message.batchnorm = $root.CoreML.Specification.BatchnormLayerParams.decode(reader, reader.uint32());
                            break;
                        case 165:
                            message.mvn = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 170:
                            message.l2normalize = $root.CoreML.Specification.L2NormalizeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 175:
                            message.softmax = $root.CoreML.Specification.SoftmaxLayerParams.decode(reader, reader.uint32());
                            break;
                        case 180:
                            message.lrn = $root.CoreML.Specification.LRNLayerParams.decode(reader, reader.uint32());
                            break;
                        case 190:
                            message.crop = $root.CoreML.Specification.CropLayerParams.decode(reader, reader.uint32());
                            break;
                        case 200:
                            message.padding = $root.CoreML.Specification.PaddingLayerParams.decode(reader, reader.uint32());
                            break;
                        case 210:
                            message.upsample = $root.CoreML.Specification.UpsampleLayerParams.decode(reader, reader.uint32());
                            break;
                        case 211:
                            message.resizeBilinear = $root.CoreML.Specification.ResizeBilinearLayerParams.decode(reader, reader.uint32());
                            break;
                        case 212:
                            message.cropResize = $root.CoreML.Specification.CropResizeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 220:
                            message.unary = $root.CoreML.Specification.UnaryFunctionLayerParams.decode(reader, reader.uint32());
                            break;
                        case 230:
                            message.add = $root.CoreML.Specification.AddLayerParams.decode(reader, reader.uint32());
                            break;
                        case 231:
                            message.multiply = $root.CoreML.Specification.MultiplyLayerParams.decode(reader, reader.uint32());
                            break;
                        case 240:
                            message.average = $root.CoreML.Specification.AverageLayerParams.decode(reader, reader.uint32());
                            break;
                        case 245:
                            message.scale = $root.CoreML.Specification.ScaleLayerParams.decode(reader, reader.uint32());
                            break;
                        case 250:
                            message.bias = $root.CoreML.Specification.BiasLayerParams.decode(reader, reader.uint32());
                            break;
                        case 260:
                            message.max = $root.CoreML.Specification.MaxLayerParams.decode(reader, reader.uint32());
                            break;
                        case 261:
                            message.min = $root.CoreML.Specification.MinLayerParams.decode(reader, reader.uint32());
                            break;
                        case 270:
                            message.dot = $root.CoreML.Specification.DotProductLayerParams.decode(reader, reader.uint32());
                            break;
                        case 280:
                            message.reduce = $root.CoreML.Specification.ReduceLayerParams.decode(reader, reader.uint32());
                            break;
                        case 290:
                            message.loadConstant = $root.CoreML.Specification.LoadConstantLayerParams.decode(reader, reader.uint32());
                            break;
                        case 300:
                            message.reshape = $root.CoreML.Specification.ReshapeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 301:
                            message.flatten = $root.CoreML.Specification.FlattenLayerParams.decode(reader, reader.uint32());
                            break;
                        case 310:
                            message.permute = $root.CoreML.Specification.PermuteLayerParams.decode(reader, reader.uint32());
                            break;
                        case 320:
                            message.concat = $root.CoreML.Specification.ConcatLayerParams.decode(reader, reader.uint32());
                            break;
                        case 330:
                            message.split = $root.CoreML.Specification.SplitLayerParams.decode(reader, reader.uint32());
                            break;
                        case 340:
                            message.sequenceRepeat = $root.CoreML.Specification.SequenceRepeatLayerParams.decode(reader, reader.uint32());
                            break;
                        case 345:
                            message.reorganizeData = $root.CoreML.Specification.ReorganizeDataLayerParams.decode(reader, reader.uint32());
                            break;
                        case 350:
                            message.slice = $root.CoreML.Specification.SliceLayerParams.decode(reader, reader.uint32());
                            break;
                        case 400:
                            message.simpleRecurrent = $root.CoreML.Specification.SimpleRecurrentLayerParams.decode(reader, reader.uint32());
                            break;
                        case 410:
                            message.gru = $root.CoreML.Specification.GRULayerParams.decode(reader, reader.uint32());
                            break;
                        case 420:
                            message.uniDirectionalLSTM = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.decode(reader, reader.uint32());
                            break;
                        case 430:
                            message.biDirectionalLSTM = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.decode(reader, reader.uint32());
                            break;
                        case 500:
                            message.custom = $root.CoreML.Specification.CustomLayerParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetworkLayer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input != null && message.hasOwnProperty("input")) {
                        if (!Array.isArray(message.input))
                            return "input: array expected";
                        for (var i = 0; i < message.input.length; ++i)
                            if (!$util.isString(message.input[i]))
                                return "input: string[] expected";
                    }
                    if (message.output != null && message.hasOwnProperty("output")) {
                        if (!Array.isArray(message.output))
                            return "output: array expected";
                        for (var i = 0; i < message.output.length; ++i)
                            if (!$util.isString(message.output[i]))
                                return "output: string[] expected";
                    }
                    if (message.convolution != null && message.hasOwnProperty("convolution")) {
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ConvolutionLayerParams.verify(message.convolution);
                            if (error)
                                return "convolution." + error;
                        }
                    }
                    if (message.pooling != null && message.hasOwnProperty("pooling")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.PoolingLayerParams.verify(message.pooling);
                            if (error)
                                return "pooling." + error;
                        }
                    }
                    if (message.activation != null && message.hasOwnProperty("activation")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activation);
                            if (error)
                                return "activation." + error;
                        }
                    }
                    if (message.innerProduct != null && message.hasOwnProperty("innerProduct")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.InnerProductLayerParams.verify(message.innerProduct);
                            if (error)
                                return "innerProduct." + error;
                        }
                    }
                    if (message.embedding != null && message.hasOwnProperty("embedding")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.EmbeddingLayerParams.verify(message.embedding);
                            if (error)
                                return "embedding." + error;
                        }
                    }
                    if (message.batchnorm != null && message.hasOwnProperty("batchnorm")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.BatchnormLayerParams.verify(message.batchnorm);
                            if (error)
                                return "batchnorm." + error;
                        }
                    }
                    if (message.mvn != null && message.hasOwnProperty("mvn")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.verify(message.mvn);
                            if (error)
                                return "mvn." + error;
                        }
                    }
                    if (message.l2normalize != null && message.hasOwnProperty("l2normalize")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.L2NormalizeLayerParams.verify(message.l2normalize);
                            if (error)
                                return "l2normalize." + error;
                        }
                    }
                    if (message.softmax != null && message.hasOwnProperty("softmax")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SoftmaxLayerParams.verify(message.softmax);
                            if (error)
                                return "softmax." + error;
                        }
                    }
                    if (message.lrn != null && message.hasOwnProperty("lrn")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.LRNLayerParams.verify(message.lrn);
                            if (error)
                                return "lrn." + error;
                        }
                    }
                    if (message.crop != null && message.hasOwnProperty("crop")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.CropLayerParams.verify(message.crop);
                            if (error)
                                return "crop." + error;
                        }
                    }
                    if (message.padding != null && message.hasOwnProperty("padding")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.verify(message.padding);
                            if (error)
                                return "padding." + error;
                        }
                    }
                    if (message.upsample != null && message.hasOwnProperty("upsample")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.UpsampleLayerParams.verify(message.upsample);
                            if (error)
                                return "upsample." + error;
                        }
                    }
                    if (message.resizeBilinear != null && message.hasOwnProperty("resizeBilinear")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ResizeBilinearLayerParams.verify(message.resizeBilinear);
                            if (error)
                                return "resizeBilinear." + error;
                        }
                    }
                    if (message.cropResize != null && message.hasOwnProperty("cropResize")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.CropResizeLayerParams.verify(message.cropResize);
                            if (error)
                                return "cropResize." + error;
                        }
                    }
                    if (message.unary != null && message.hasOwnProperty("unary")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.UnaryFunctionLayerParams.verify(message.unary);
                            if (error)
                                return "unary." + error;
                        }
                    }
                    if (message.add != null && message.hasOwnProperty("add")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.AddLayerParams.verify(message.add);
                            if (error)
                                return "add." + error;
                        }
                    }
                    if (message.multiply != null && message.hasOwnProperty("multiply")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MultiplyLayerParams.verify(message.multiply);
                            if (error)
                                return "multiply." + error;
                        }
                    }
                    if (message.average != null && message.hasOwnProperty("average")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.AverageLayerParams.verify(message.average);
                            if (error)
                                return "average." + error;
                        }
                    }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ScaleLayerParams.verify(message.scale);
                            if (error)
                                return "scale." + error;
                        }
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.BiasLayerParams.verify(message.bias);
                            if (error)
                                return "bias." + error;
                        }
                    }
                    if (message.max != null && message.hasOwnProperty("max")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MaxLayerParams.verify(message.max);
                            if (error)
                                return "max." + error;
                        }
                    }
                    if (message.min != null && message.hasOwnProperty("min")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MinLayerParams.verify(message.min);
                            if (error)
                                return "min." + error;
                        }
                    }
                    if (message.dot != null && message.hasOwnProperty("dot")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.DotProductLayerParams.verify(message.dot);
                            if (error)
                                return "dot." + error;
                        }
                    }
                    if (message.reduce != null && message.hasOwnProperty("reduce")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ReduceLayerParams.verify(message.reduce);
                            if (error)
                                return "reduce." + error;
                        }
                    }
                    if (message.loadConstant != null && message.hasOwnProperty("loadConstant")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.LoadConstantLayerParams.verify(message.loadConstant);
                            if (error)
                                return "loadConstant." + error;
                        }
                    }
                    if (message.reshape != null && message.hasOwnProperty("reshape")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ReshapeLayerParams.verify(message.reshape);
                            if (error)
                                return "reshape." + error;
                        }
                    }
                    if (message.flatten != null && message.hasOwnProperty("flatten")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.FlattenLayerParams.verify(message.flatten);
                            if (error)
                                return "flatten." + error;
                        }
                    }
                    if (message.permute != null && message.hasOwnProperty("permute")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.PermuteLayerParams.verify(message.permute);
                            if (error)
                                return "permute." + error;
                        }
                    }
                    if (message.concat != null && message.hasOwnProperty("concat")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ConcatLayerParams.verify(message.concat);
                            if (error)
                                return "concat." + error;
                        }
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SplitLayerParams.verify(message.split);
                            if (error)
                                return "split." + error;
                        }
                    }
                    if (message.sequenceRepeat != null && message.hasOwnProperty("sequenceRepeat")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SequenceRepeatLayerParams.verify(message.sequenceRepeat);
                            if (error)
                                return "sequenceRepeat." + error;
                        }
                    }
                    if (message.reorganizeData != null && message.hasOwnProperty("reorganizeData")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ReorganizeDataLayerParams.verify(message.reorganizeData);
                            if (error)
                                return "reorganizeData." + error;
                        }
                    }
                    if (message.slice != null && message.hasOwnProperty("slice")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SliceLayerParams.verify(message.slice);
                            if (error)
                                return "slice." + error;
                        }
                    }
                    if (message.simpleRecurrent != null && message.hasOwnProperty("simpleRecurrent")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SimpleRecurrentLayerParams.verify(message.simpleRecurrent);
                            if (error)
                                return "simpleRecurrent." + error;
                        }
                    }
                    if (message.gru != null && message.hasOwnProperty("gru")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.GRULayerParams.verify(message.gru);
                            if (error)
                                return "gru." + error;
                        }
                    }
                    if (message.uniDirectionalLSTM != null && message.hasOwnProperty("uniDirectionalLSTM")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.verify(message.uniDirectionalLSTM);
                            if (error)
                                return "uniDirectionalLSTM." + error;
                        }
                    }
                    if (message.biDirectionalLSTM != null && message.hasOwnProperty("biDirectionalLSTM")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.verify(message.biDirectionalLSTM);
                            if (error)
                                return "biDirectionalLSTM." + error;
                        }
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.CustomLayerParams.verify(message.custom);
                            if (error)
                                return "custom." + error;
                        }
                    }
                    return null;
                };
    
                NeuralNetworkLayer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkLayer)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkLayer();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input) {
                        if (!Array.isArray(object.input))
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.input: array expected");
                        message.input = [];
                        for (var i = 0; i < object.input.length; ++i)
                            message.input[i] = String(object.input[i]);
                    }
                    if (object.output) {
                        if (!Array.isArray(object.output))
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.output: array expected");
                        message.output = [];
                        for (var i = 0; i < object.output.length; ++i)
                            message.output[i] = String(object.output[i]);
                    }
                    if (object.convolution != null) {
                        if (typeof object.convolution !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.convolution: object expected");
                        message.convolution = $root.CoreML.Specification.ConvolutionLayerParams.fromObject(object.convolution);
                    }
                    if (object.pooling != null) {
                        if (typeof object.pooling !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.pooling: object expected");
                        message.pooling = $root.CoreML.Specification.PoolingLayerParams.fromObject(object.pooling);
                    }
                    if (object.activation != null) {
                        if (typeof object.activation !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.activation: object expected");
                        message.activation = $root.CoreML.Specification.ActivationParams.fromObject(object.activation);
                    }
                    if (object.innerProduct != null) {
                        if (typeof object.innerProduct !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.innerProduct: object expected");
                        message.innerProduct = $root.CoreML.Specification.InnerProductLayerParams.fromObject(object.innerProduct);
                    }
                    if (object.embedding != null) {
                        if (typeof object.embedding !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.embedding: object expected");
                        message.embedding = $root.CoreML.Specification.EmbeddingLayerParams.fromObject(object.embedding);
                    }
                    if (object.batchnorm != null) {
                        if (typeof object.batchnorm !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.batchnorm: object expected");
                        message.batchnorm = $root.CoreML.Specification.BatchnormLayerParams.fromObject(object.batchnorm);
                    }
                    if (object.mvn != null) {
                        if (typeof object.mvn !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.mvn: object expected");
                        message.mvn = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.fromObject(object.mvn);
                    }
                    if (object.l2normalize != null) {
                        if (typeof object.l2normalize !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.l2normalize: object expected");
                        message.l2normalize = $root.CoreML.Specification.L2NormalizeLayerParams.fromObject(object.l2normalize);
                    }
                    if (object.softmax != null) {
                        if (typeof object.softmax !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.softmax: object expected");
                        message.softmax = $root.CoreML.Specification.SoftmaxLayerParams.fromObject(object.softmax);
                    }
                    if (object.lrn != null) {
                        if (typeof object.lrn !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.lrn: object expected");
                        message.lrn = $root.CoreML.Specification.LRNLayerParams.fromObject(object.lrn);
                    }
                    if (object.crop != null) {
                        if (typeof object.crop !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.crop: object expected");
                        message.crop = $root.CoreML.Specification.CropLayerParams.fromObject(object.crop);
                    }
                    if (object.padding != null) {
                        if (typeof object.padding !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.padding: object expected");
                        message.padding = $root.CoreML.Specification.PaddingLayerParams.fromObject(object.padding);
                    }
                    if (object.upsample != null) {
                        if (typeof object.upsample !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.upsample: object expected");
                        message.upsample = $root.CoreML.Specification.UpsampleLayerParams.fromObject(object.upsample);
                    }
                    if (object.resizeBilinear != null) {
                        if (typeof object.resizeBilinear !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.resizeBilinear: object expected");
                        message.resizeBilinear = $root.CoreML.Specification.ResizeBilinearLayerParams.fromObject(object.resizeBilinear);
                    }
                    if (object.cropResize != null) {
                        if (typeof object.cropResize !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.cropResize: object expected");
                        message.cropResize = $root.CoreML.Specification.CropResizeLayerParams.fromObject(object.cropResize);
                    }
                    if (object.unary != null) {
                        if (typeof object.unary !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.unary: object expected");
                        message.unary = $root.CoreML.Specification.UnaryFunctionLayerParams.fromObject(object.unary);
                    }
                    if (object.add != null) {
                        if (typeof object.add !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.add: object expected");
                        message.add = $root.CoreML.Specification.AddLayerParams.fromObject(object.add);
                    }
                    if (object.multiply != null) {
                        if (typeof object.multiply !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.multiply: object expected");
                        message.multiply = $root.CoreML.Specification.MultiplyLayerParams.fromObject(object.multiply);
                    }
                    if (object.average != null) {
                        if (typeof object.average !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.average: object expected");
                        message.average = $root.CoreML.Specification.AverageLayerParams.fromObject(object.average);
                    }
                    if (object.scale != null) {
                        if (typeof object.scale !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.scale: object expected");
                        message.scale = $root.CoreML.Specification.ScaleLayerParams.fromObject(object.scale);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.bias: object expected");
                        message.bias = $root.CoreML.Specification.BiasLayerParams.fromObject(object.bias);
                    }
                    if (object.max != null) {
                        if (typeof object.max !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.max: object expected");
                        message.max = $root.CoreML.Specification.MaxLayerParams.fromObject(object.max);
                    }
                    if (object.min != null) {
                        if (typeof object.min !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.min: object expected");
                        message.min = $root.CoreML.Specification.MinLayerParams.fromObject(object.min);
                    }
                    if (object.dot != null) {
                        if (typeof object.dot !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.dot: object expected");
                        message.dot = $root.CoreML.Specification.DotProductLayerParams.fromObject(object.dot);
                    }
                    if (object.reduce != null) {
                        if (typeof object.reduce !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.reduce: object expected");
                        message.reduce = $root.CoreML.Specification.ReduceLayerParams.fromObject(object.reduce);
                    }
                    if (object.loadConstant != null) {
                        if (typeof object.loadConstant !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.loadConstant: object expected");
                        message.loadConstant = $root.CoreML.Specification.LoadConstantLayerParams.fromObject(object.loadConstant);
                    }
                    if (object.reshape != null) {
                        if (typeof object.reshape !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.reshape: object expected");
                        message.reshape = $root.CoreML.Specification.ReshapeLayerParams.fromObject(object.reshape);
                    }
                    if (object.flatten != null) {
                        if (typeof object.flatten !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.flatten: object expected");
                        message.flatten = $root.CoreML.Specification.FlattenLayerParams.fromObject(object.flatten);
                    }
                    if (object.permute != null) {
                        if (typeof object.permute !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.permute: object expected");
                        message.permute = $root.CoreML.Specification.PermuteLayerParams.fromObject(object.permute);
                    }
                    if (object.concat != null) {
                        if (typeof object.concat !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.concat: object expected");
                        message.concat = $root.CoreML.Specification.ConcatLayerParams.fromObject(object.concat);
                    }
                    if (object.split != null) {
                        if (typeof object.split !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.split: object expected");
                        message.split = $root.CoreML.Specification.SplitLayerParams.fromObject(object.split);
                    }
                    if (object.sequenceRepeat != null) {
                        if (typeof object.sequenceRepeat !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.sequenceRepeat: object expected");
                        message.sequenceRepeat = $root.CoreML.Specification.SequenceRepeatLayerParams.fromObject(object.sequenceRepeat);
                    }
                    if (object.reorganizeData != null) {
                        if (typeof object.reorganizeData !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.reorganizeData: object expected");
                        message.reorganizeData = $root.CoreML.Specification.ReorganizeDataLayerParams.fromObject(object.reorganizeData);
                    }
                    if (object.slice != null) {
                        if (typeof object.slice !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.slice: object expected");
                        message.slice = $root.CoreML.Specification.SliceLayerParams.fromObject(object.slice);
                    }
                    if (object.simpleRecurrent != null) {
                        if (typeof object.simpleRecurrent !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.simpleRecurrent: object expected");
                        message.simpleRecurrent = $root.CoreML.Specification.SimpleRecurrentLayerParams.fromObject(object.simpleRecurrent);
                    }
                    if (object.gru != null) {
                        if (typeof object.gru !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.gru: object expected");
                        message.gru = $root.CoreML.Specification.GRULayerParams.fromObject(object.gru);
                    }
                    if (object.uniDirectionalLSTM != null) {
                        if (typeof object.uniDirectionalLSTM !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM: object expected");
                        message.uniDirectionalLSTM = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.fromObject(object.uniDirectionalLSTM);
                    }
                    if (object.biDirectionalLSTM != null) {
                        if (typeof object.biDirectionalLSTM !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM: object expected");
                        message.biDirectionalLSTM = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.fromObject(object.biDirectionalLSTM);
                    }
                    if (object.custom != null) {
                        if (typeof object.custom !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.custom: object expected");
                        message.custom = $root.CoreML.Specification.CustomLayerParams.fromObject(object.custom);
                    }
                    return message;
                };
    
                NeuralNetworkLayer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.input = [];
                        object.output = [];
                    }
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input && message.input.length) {
                        object.input = [];
                        for (var j = 0; j < message.input.length; ++j)
                            object.input[j] = message.input[j];
                    }
                    if (message.output && message.output.length) {
                        object.output = [];
                        for (var j = 0; j < message.output.length; ++j)
                            object.output[j] = message.output[j];
                    }
                    if (message.convolution != null && message.hasOwnProperty("convolution")) {
                        object.convolution = $root.CoreML.Specification.ConvolutionLayerParams.toObject(message.convolution, options);
                        if (options.oneofs)
                            object.layer = "convolution";
                    }
                    if (message.pooling != null && message.hasOwnProperty("pooling")) {
                        object.pooling = $root.CoreML.Specification.PoolingLayerParams.toObject(message.pooling, options);
                        if (options.oneofs)
                            object.layer = "pooling";
                    }
                    if (message.activation != null && message.hasOwnProperty("activation")) {
                        object.activation = $root.CoreML.Specification.ActivationParams.toObject(message.activation, options);
                        if (options.oneofs)
                            object.layer = "activation";
                    }
                    if (message.innerProduct != null && message.hasOwnProperty("innerProduct")) {
                        object.innerProduct = $root.CoreML.Specification.InnerProductLayerParams.toObject(message.innerProduct, options);
                        if (options.oneofs)
                            object.layer = "innerProduct";
                    }
                    if (message.embedding != null && message.hasOwnProperty("embedding")) {
                        object.embedding = $root.CoreML.Specification.EmbeddingLayerParams.toObject(message.embedding, options);
                        if (options.oneofs)
                            object.layer = "embedding";
                    }
                    if (message.batchnorm != null && message.hasOwnProperty("batchnorm")) {
                        object.batchnorm = $root.CoreML.Specification.BatchnormLayerParams.toObject(message.batchnorm, options);
                        if (options.oneofs)
                            object.layer = "batchnorm";
                    }
                    if (message.mvn != null && message.hasOwnProperty("mvn")) {
                        object.mvn = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.toObject(message.mvn, options);
                        if (options.oneofs)
                            object.layer = "mvn";
                    }
                    if (message.l2normalize != null && message.hasOwnProperty("l2normalize")) {
                        object.l2normalize = $root.CoreML.Specification.L2NormalizeLayerParams.toObject(message.l2normalize, options);
                        if (options.oneofs)
                            object.layer = "l2normalize";
                    }
                    if (message.softmax != null && message.hasOwnProperty("softmax")) {
                        object.softmax = $root.CoreML.Specification.SoftmaxLayerParams.toObject(message.softmax, options);
                        if (options.oneofs)
                            object.layer = "softmax";
                    }
                    if (message.lrn != null && message.hasOwnProperty("lrn")) {
                        object.lrn = $root.CoreML.Specification.LRNLayerParams.toObject(message.lrn, options);
                        if (options.oneofs)
                            object.layer = "lrn";
                    }
                    if (message.crop != null && message.hasOwnProperty("crop")) {
                        object.crop = $root.CoreML.Specification.CropLayerParams.toObject(message.crop, options);
                        if (options.oneofs)
                            object.layer = "crop";
                    }
                    if (message.padding != null && message.hasOwnProperty("padding")) {
                        object.padding = $root.CoreML.Specification.PaddingLayerParams.toObject(message.padding, options);
                        if (options.oneofs)
                            object.layer = "padding";
                    }
                    if (message.upsample != null && message.hasOwnProperty("upsample")) {
                        object.upsample = $root.CoreML.Specification.UpsampleLayerParams.toObject(message.upsample, options);
                        if (options.oneofs)
                            object.layer = "upsample";
                    }
                    if (message.resizeBilinear != null && message.hasOwnProperty("resizeBilinear")) {
                        object.resizeBilinear = $root.CoreML.Specification.ResizeBilinearLayerParams.toObject(message.resizeBilinear, options);
                        if (options.oneofs)
                            object.layer = "resizeBilinear";
                    }
                    if (message.cropResize != null && message.hasOwnProperty("cropResize")) {
                        object.cropResize = $root.CoreML.Specification.CropResizeLayerParams.toObject(message.cropResize, options);
                        if (options.oneofs)
                            object.layer = "cropResize";
                    }
                    if (message.unary != null && message.hasOwnProperty("unary")) {
                        object.unary = $root.CoreML.Specification.UnaryFunctionLayerParams.toObject(message.unary, options);
                        if (options.oneofs)
                            object.layer = "unary";
                    }
                    if (message.add != null && message.hasOwnProperty("add")) {
                        object.add = $root.CoreML.Specification.AddLayerParams.toObject(message.add, options);
                        if (options.oneofs)
                            object.layer = "add";
                    }
                    if (message.multiply != null && message.hasOwnProperty("multiply")) {
                        object.multiply = $root.CoreML.Specification.MultiplyLayerParams.toObject(message.multiply, options);
                        if (options.oneofs)
                            object.layer = "multiply";
                    }
                    if (message.average != null && message.hasOwnProperty("average")) {
                        object.average = $root.CoreML.Specification.AverageLayerParams.toObject(message.average, options);
                        if (options.oneofs)
                            object.layer = "average";
                    }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        object.scale = $root.CoreML.Specification.ScaleLayerParams.toObject(message.scale, options);
                        if (options.oneofs)
                            object.layer = "scale";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        object.bias = $root.CoreML.Specification.BiasLayerParams.toObject(message.bias, options);
                        if (options.oneofs)
                            object.layer = "bias";
                    }
                    if (message.max != null && message.hasOwnProperty("max")) {
                        object.max = $root.CoreML.Specification.MaxLayerParams.toObject(message.max, options);
                        if (options.oneofs)
                            object.layer = "max";
                    }
                    if (message.min != null && message.hasOwnProperty("min")) {
                        object.min = $root.CoreML.Specification.MinLayerParams.toObject(message.min, options);
                        if (options.oneofs)
                            object.layer = "min";
                    }
                    if (message.dot != null && message.hasOwnProperty("dot")) {
                        object.dot = $root.CoreML.Specification.DotProductLayerParams.toObject(message.dot, options);
                        if (options.oneofs)
                            object.layer = "dot";
                    }
                    if (message.reduce != null && message.hasOwnProperty("reduce")) {
                        object.reduce = $root.CoreML.Specification.ReduceLayerParams.toObject(message.reduce, options);
                        if (options.oneofs)
                            object.layer = "reduce";
                    }
                    if (message.loadConstant != null && message.hasOwnProperty("loadConstant")) {
                        object.loadConstant = $root.CoreML.Specification.LoadConstantLayerParams.toObject(message.loadConstant, options);
                        if (options.oneofs)
                            object.layer = "loadConstant";
                    }
                    if (message.reshape != null && message.hasOwnProperty("reshape")) {
                        object.reshape = $root.CoreML.Specification.ReshapeLayerParams.toObject(message.reshape, options);
                        if (options.oneofs)
                            object.layer = "reshape";
                    }
                    if (message.flatten != null && message.hasOwnProperty("flatten")) {
                        object.flatten = $root.CoreML.Specification.FlattenLayerParams.toObject(message.flatten, options);
                        if (options.oneofs)
                            object.layer = "flatten";
                    }
                    if (message.permute != null && message.hasOwnProperty("permute")) {
                        object.permute = $root.CoreML.Specification.PermuteLayerParams.toObject(message.permute, options);
                        if (options.oneofs)
                            object.layer = "permute";
                    }
                    if (message.concat != null && message.hasOwnProperty("concat")) {
                        object.concat = $root.CoreML.Specification.ConcatLayerParams.toObject(message.concat, options);
                        if (options.oneofs)
                            object.layer = "concat";
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        object.split = $root.CoreML.Specification.SplitLayerParams.toObject(message.split, options);
                        if (options.oneofs)
                            object.layer = "split";
                    }
                    if (message.sequenceRepeat != null && message.hasOwnProperty("sequenceRepeat")) {
                        object.sequenceRepeat = $root.CoreML.Specification.SequenceRepeatLayerParams.toObject(message.sequenceRepeat, options);
                        if (options.oneofs)
                            object.layer = "sequenceRepeat";
                    }
                    if (message.reorganizeData != null && message.hasOwnProperty("reorganizeData")) {
                        object.reorganizeData = $root.CoreML.Specification.ReorganizeDataLayerParams.toObject(message.reorganizeData, options);
                        if (options.oneofs)
                            object.layer = "reorganizeData";
                    }
                    if (message.slice != null && message.hasOwnProperty("slice")) {
                        object.slice = $root.CoreML.Specification.SliceLayerParams.toObject(message.slice, options);
                        if (options.oneofs)
                            object.layer = "slice";
                    }
                    if (message.simpleRecurrent != null && message.hasOwnProperty("simpleRecurrent")) {
                        object.simpleRecurrent = $root.CoreML.Specification.SimpleRecurrentLayerParams.toObject(message.simpleRecurrent, options);
                        if (options.oneofs)
                            object.layer = "simpleRecurrent";
                    }
                    if (message.gru != null && message.hasOwnProperty("gru")) {
                        object.gru = $root.CoreML.Specification.GRULayerParams.toObject(message.gru, options);
                        if (options.oneofs)
                            object.layer = "gru";
                    }
                    if (message.uniDirectionalLSTM != null && message.hasOwnProperty("uniDirectionalLSTM")) {
                        object.uniDirectionalLSTM = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.toObject(message.uniDirectionalLSTM, options);
                        if (options.oneofs)
                            object.layer = "uniDirectionalLSTM";
                    }
                    if (message.biDirectionalLSTM != null && message.hasOwnProperty("biDirectionalLSTM")) {
                        object.biDirectionalLSTM = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.toObject(message.biDirectionalLSTM, options);
                        if (options.oneofs)
                            object.layer = "biDirectionalLSTM";
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        object.custom = $root.CoreML.Specification.CustomLayerParams.toObject(message.custom, options);
                        if (options.oneofs)
                            object.layer = "custom";
                    }
                    return object;
                };
    
                NeuralNetworkLayer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkLayer;
            })();
    
            Specification.BorderAmounts = (function() {
    
                function BorderAmounts(properties) {
                    this.borderAmounts = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                BorderAmounts.prototype.borderAmounts = $util.emptyArray;
    
                BorderAmounts.create = function create(properties) {
                    return new BorderAmounts(properties);
                };
    
                BorderAmounts.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BorderAmounts();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            if (!(message.borderAmounts && message.borderAmounts.length))
                                message.borderAmounts = [];
                            message.borderAmounts.push($root.CoreML.Specification.BorderAmounts.EdgeSizes.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                BorderAmounts.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.borderAmounts != null && message.hasOwnProperty("borderAmounts")) {
                        if (!Array.isArray(message.borderAmounts))
                            return "borderAmounts: array expected";
                        for (var i = 0; i < message.borderAmounts.length; ++i) {
                            var error = $root.CoreML.Specification.BorderAmounts.EdgeSizes.verify(message.borderAmounts[i]);
                            if (error)
                                return "borderAmounts." + error;
                        }
                    }
                    return null;
                };
    
                BorderAmounts.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BorderAmounts)
                        return object;
                    var message = new $root.CoreML.Specification.BorderAmounts();
                    if (object.borderAmounts) {
                        if (!Array.isArray(object.borderAmounts))
                            throw TypeError(".CoreML.Specification.BorderAmounts.borderAmounts: array expected");
                        message.borderAmounts = [];
                        for (var i = 0; i < object.borderAmounts.length; ++i) {
                            if (typeof object.borderAmounts[i] !== "object")
                                throw TypeError(".CoreML.Specification.BorderAmounts.borderAmounts: object expected");
                            message.borderAmounts[i] = $root.CoreML.Specification.BorderAmounts.EdgeSizes.fromObject(object.borderAmounts[i]);
                        }
                    }
                    return message;
                };
    
                BorderAmounts.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.borderAmounts = [];
                    if (message.borderAmounts && message.borderAmounts.length) {
                        object.borderAmounts = [];
                        for (var j = 0; j < message.borderAmounts.length; ++j)
                            object.borderAmounts[j] = $root.CoreML.Specification.BorderAmounts.EdgeSizes.toObject(message.borderAmounts[j], options);
                    }
                    return object;
                };
    
                BorderAmounts.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                BorderAmounts.EdgeSizes = (function() {
    
                    function EdgeSizes(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    EdgeSizes.prototype.startEdgeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    EdgeSizes.prototype.endEdgeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    EdgeSizes.create = function create(properties) {
                        return new EdgeSizes(properties);
                    };
    
                    EdgeSizes.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BorderAmounts.EdgeSizes();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.startEdgeSize = reader.uint64();
                                break;
                            case 2:
                                message.endEdgeSize = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    EdgeSizes.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.startEdgeSize != null && message.hasOwnProperty("startEdgeSize"))
                            if (!$util.isInteger(message.startEdgeSize) && !(message.startEdgeSize && $util.isInteger(message.startEdgeSize.low) && $util.isInteger(message.startEdgeSize.high)))
                                return "startEdgeSize: integer|Long expected";
                        if (message.endEdgeSize != null && message.hasOwnProperty("endEdgeSize"))
                            if (!$util.isInteger(message.endEdgeSize) && !(message.endEdgeSize && $util.isInteger(message.endEdgeSize.low) && $util.isInteger(message.endEdgeSize.high)))
                                return "endEdgeSize: integer|Long expected";
                        return null;
                    };
    
                    EdgeSizes.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.BorderAmounts.EdgeSizes)
                            return object;
                        var message = new $root.CoreML.Specification.BorderAmounts.EdgeSizes();
                        if (object.startEdgeSize != null)
                            if ($util.Long)
                                (message.startEdgeSize = $util.Long.fromValue(object.startEdgeSize)).unsigned = true;
                            else if (typeof object.startEdgeSize === "string")
                                message.startEdgeSize = parseInt(object.startEdgeSize, 10);
                            else if (typeof object.startEdgeSize === "number")
                                message.startEdgeSize = object.startEdgeSize;
                            else if (typeof object.startEdgeSize === "object")
                                message.startEdgeSize = new $util.LongBits(object.startEdgeSize.low >>> 0, object.startEdgeSize.high >>> 0).toNumber(true);
                        if (object.endEdgeSize != null)
                            if ($util.Long)
                                (message.endEdgeSize = $util.Long.fromValue(object.endEdgeSize)).unsigned = true;
                            else if (typeof object.endEdgeSize === "string")
                                message.endEdgeSize = parseInt(object.endEdgeSize, 10);
                            else if (typeof object.endEdgeSize === "number")
                                message.endEdgeSize = object.endEdgeSize;
                            else if (typeof object.endEdgeSize === "object")
                                message.endEdgeSize = new $util.LongBits(object.endEdgeSize.low >>> 0, object.endEdgeSize.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    EdgeSizes.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.startEdgeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.startEdgeSize = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.endEdgeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.endEdgeSize = options.longs === String ? "0" : 0;
                        }
                        if (message.startEdgeSize != null && message.hasOwnProperty("startEdgeSize"))
                            if (typeof message.startEdgeSize === "number")
                                object.startEdgeSize = options.longs === String ? String(message.startEdgeSize) : message.startEdgeSize;
                            else
                                object.startEdgeSize = options.longs === String ? $util.Long.prototype.toString.call(message.startEdgeSize) : options.longs === Number ? new $util.LongBits(message.startEdgeSize.low >>> 0, message.startEdgeSize.high >>> 0).toNumber(true) : message.startEdgeSize;
                        if (message.endEdgeSize != null && message.hasOwnProperty("endEdgeSize"))
                            if (typeof message.endEdgeSize === "number")
                                object.endEdgeSize = options.longs === String ? String(message.endEdgeSize) : message.endEdgeSize;
                            else
                                object.endEdgeSize = options.longs === String ? $util.Long.prototype.toString.call(message.endEdgeSize) : options.longs === Number ? new $util.LongBits(message.endEdgeSize.low >>> 0, message.endEdgeSize.high >>> 0).toNumber(true) : message.endEdgeSize;
                        return object;
                    };
    
                    EdgeSizes.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return EdgeSizes;
                })();
    
                return BorderAmounts;
            })();
    
            Specification.ValidPadding = (function() {
    
                function ValidPadding(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ValidPadding.prototype.paddingAmounts = null;
    
                ValidPadding.create = function create(properties) {
                    return new ValidPadding(properties);
                };
    
                ValidPadding.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ValidPadding();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ValidPadding.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts")) {
                        var error = $root.CoreML.Specification.BorderAmounts.verify(message.paddingAmounts);
                        if (error)
                            return "paddingAmounts." + error;
                    }
                    return null;
                };
    
                ValidPadding.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ValidPadding)
                        return object;
                    var message = new $root.CoreML.Specification.ValidPadding();
                    if (object.paddingAmounts != null) {
                        if (typeof object.paddingAmounts !== "object")
                            throw TypeError(".CoreML.Specification.ValidPadding.paddingAmounts: object expected");
                        message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.fromObject(object.paddingAmounts);
                    }
                    return message;
                };
    
                ValidPadding.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.paddingAmounts = null;
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts"))
                        object.paddingAmounts = $root.CoreML.Specification.BorderAmounts.toObject(message.paddingAmounts, options);
                    return object;
                };
    
                ValidPadding.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ValidPadding;
            })();
    
            Specification.SamePadding = (function() {
    
                function SamePadding(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SamePadding.prototype.asymmetryMode = 0;
    
                SamePadding.create = function create(properties) {
                    return new SamePadding(properties);
                };
    
                SamePadding.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SamePadding();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.asymmetryMode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SamePadding.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.asymmetryMode != null && message.hasOwnProperty("asymmetryMode"))
                        switch (message.asymmetryMode) {
                        default:
                            return "asymmetryMode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                SamePadding.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SamePadding)
                        return object;
                    var message = new $root.CoreML.Specification.SamePadding();
                    switch (object.asymmetryMode) {
                    case "BOTTOM_RIGHT_HEAVY":
                    case 0:
                        message.asymmetryMode = 0;
                        break;
                    case "TOP_LEFT_HEAVY":
                    case 1:
                        message.asymmetryMode = 1;
                        break;
                    }
                    return message;
                };
    
                SamePadding.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.asymmetryMode = options.enums === String ? "BOTTOM_RIGHT_HEAVY" : 0;
                    if (message.asymmetryMode != null && message.hasOwnProperty("asymmetryMode"))
                        object.asymmetryMode = options.enums === String ? $root.CoreML.Specification.SamePadding.SamePaddingMode[message.asymmetryMode] : message.asymmetryMode;
                    return object;
                };
    
                SamePadding.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SamePadding.SamePaddingMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BOTTOM_RIGHT_HEAVY"] = 0;
                    values[valuesById[1] = "TOP_LEFT_HEAVY"] = 1;
                    return values;
                })();
    
                return SamePadding;
            })();
    
            Specification.SamplingMode = (function() {
    
                function SamplingMode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SamplingMode.prototype.samplingMethod = 0;
    
                SamplingMode.create = function create(properties) {
                    return new SamplingMode(properties);
                };
    
                SamplingMode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SamplingMode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.samplingMethod = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SamplingMode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.samplingMethod != null && message.hasOwnProperty("samplingMethod"))
                        switch (message.samplingMethod) {
                        default:
                            return "samplingMethod: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };
    
                SamplingMode.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SamplingMode)
                        return object;
                    var message = new $root.CoreML.Specification.SamplingMode();
                    switch (object.samplingMethod) {
                    case "STRICT_ALIGN_ENDPOINTS_MODE":
                    case 0:
                        message.samplingMethod = 0;
                        break;
                    case "ALIGN_ENDPOINTS_MODE":
                    case 1:
                        message.samplingMethod = 1;
                        break;
                    case "UPSAMPLE_MODE":
                    case 2:
                        message.samplingMethod = 2;
                        break;
                    case "ROI_ALIGN_MODE":
                    case 3:
                        message.samplingMethod = 3;
                        break;
                    }
                    return message;
                };
    
                SamplingMode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.samplingMethod = options.enums === String ? "STRICT_ALIGN_ENDPOINTS_MODE" : 0;
                    if (message.samplingMethod != null && message.hasOwnProperty("samplingMethod"))
                        object.samplingMethod = options.enums === String ? $root.CoreML.Specification.SamplingMode.Method[message.samplingMethod] : message.samplingMethod;
                    return object;
                };
    
                SamplingMode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SamplingMode.Method = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STRICT_ALIGN_ENDPOINTS_MODE"] = 0;
                    values[valuesById[1] = "ALIGN_ENDPOINTS_MODE"] = 1;
                    values[valuesById[2] = "UPSAMPLE_MODE"] = 2;
                    values[valuesById[3] = "ROI_ALIGN_MODE"] = 3;
                    return values;
                })();
    
                return SamplingMode;
            })();
    
            Specification.BoxCoordinatesMode = (function() {
    
                function BoxCoordinatesMode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                BoxCoordinatesMode.prototype.boxMode = 0;
    
                BoxCoordinatesMode.create = function create(properties) {
                    return new BoxCoordinatesMode(properties);
                };
    
                BoxCoordinatesMode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BoxCoordinatesMode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.boxMode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                BoxCoordinatesMode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.boxMode != null && message.hasOwnProperty("boxMode"))
                        switch (message.boxMode) {
                        default:
                            return "boxMode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };
    
                BoxCoordinatesMode.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BoxCoordinatesMode)
                        return object;
                    var message = new $root.CoreML.Specification.BoxCoordinatesMode();
                    switch (object.boxMode) {
                    case "CORNERS_HEIGHT_FIRST":
                    case 0:
                        message.boxMode = 0;
                        break;
                    case "CORNERS_WIDTH_FIRST":
                    case 1:
                        message.boxMode = 1;
                        break;
                    case "CENTER_SIZE_HEIGHT_FIRST":
                    case 2:
                        message.boxMode = 2;
                        break;
                    case "CENTER_SIZE_WIDTH_FIRST":
                    case 3:
                        message.boxMode = 3;
                        break;
                    }
                    return message;
                };
    
                BoxCoordinatesMode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.boxMode = options.enums === String ? "CORNERS_HEIGHT_FIRST" : 0;
                    if (message.boxMode != null && message.hasOwnProperty("boxMode"))
                        object.boxMode = options.enums === String ? $root.CoreML.Specification.BoxCoordinatesMode.Coordinates[message.boxMode] : message.boxMode;
                    return object;
                };
    
                BoxCoordinatesMode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                BoxCoordinatesMode.Coordinates = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CORNERS_HEIGHT_FIRST"] = 0;
                    values[valuesById[1] = "CORNERS_WIDTH_FIRST"] = 1;
                    values[valuesById[2] = "CENTER_SIZE_HEIGHT_FIRST"] = 2;
                    values[valuesById[3] = "CENTER_SIZE_WIDTH_FIRST"] = 3;
                    return values;
                })();
    
                return BoxCoordinatesMode;
            })();
    
            Specification.WeightParams = (function() {
    
                function WeightParams(properties) {
                    this.floatValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                WeightParams.prototype.floatValue = $util.emptyArray;
                WeightParams.prototype.float16Value = $util.newBuffer([]);
                WeightParams.prototype.rawValue = $util.newBuffer([]);
                WeightParams.prototype.quantization = null;
    
                WeightParams.create = function create(properties) {
                    return new WeightParams(properties);
                };
    
                WeightParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.WeightParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.floatValue && message.floatValue.length))
                                message.floatValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                if (message.floatValue.length == 0 && (end2 - reader.pos) > 1048576) {
                                    var floatValueLength = end2 - reader.pos;
                                    var floatValueView = new DataView(reader.buf.buffer, reader.buf.byteOffset + reader.pos, floatValueLength);
                                    floatValueLength = floatValueLength >>> 2;
                                    var floatValue = new Float32Array(floatValueLength);
                                    for (var i = 0; i < floatValueLength; i++) {
                                        floatValue[i] = floatValueView.getFloat32(i << 2, true);
                                    }
                                    message.floatValue = floatValue;
                                    reader.pos = end2;
                                }
                                else {
                                    while (reader.pos < end2)
                                        message.floatValue.push(reader.float());
                                }
                            } else
                                message.floatValue.push(reader.float());
                            break;
                        case 2:
                            message.float16Value = reader.bytes();
                            break;
                        case 30:
                            message.rawValue = reader.bytes();
                            break;
                        case 40:
                            message.quantization = $root.CoreML.Specification.QuantizationParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                WeightParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        if (!Array.isArray(message.floatValue))
                            return "floatValue: array expected";
                        for (var i = 0; i < message.floatValue.length; ++i)
                            if (typeof message.floatValue[i] !== "number")
                                return "floatValue: number[] expected";
                    }
                    if (message.float16Value != null && message.hasOwnProperty("float16Value"))
                        if (!(message.float16Value && typeof message.float16Value.length === "number" || $util.isString(message.float16Value)))
                            return "float16Value: buffer expected";
                    if (message.rawValue != null && message.hasOwnProperty("rawValue"))
                        if (!(message.rawValue && typeof message.rawValue.length === "number" || $util.isString(message.rawValue)))
                            return "rawValue: buffer expected";
                    if (message.quantization != null && message.hasOwnProperty("quantization")) {
                        var error = $root.CoreML.Specification.QuantizationParams.verify(message.quantization);
                        if (error)
                            return "quantization." + error;
                    }
                    return null;
                };
    
                WeightParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.WeightParams)
                        return object;
                    var message = new $root.CoreML.Specification.WeightParams();
                    if (object.floatValue) {
                        if (!Array.isArray(object.floatValue))
                            throw TypeError(".CoreML.Specification.WeightParams.floatValue: array expected");
                        message.floatValue = [];
                        for (var i = 0; i < object.floatValue.length; ++i)
                            message.floatValue[i] = Number(object.floatValue[i]);
                    }
                    if (object.float16Value != null)
                        if (typeof object.float16Value === "string")
                            $util.base64.decode(object.float16Value, message.float16Value = $util.newBuffer($util.base64.length(object.float16Value)), 0);
                        else if (object.float16Value.length)
                            message.float16Value = object.float16Value;
                    if (object.rawValue != null)
                        if (typeof object.rawValue === "string")
                            $util.base64.decode(object.rawValue, message.rawValue = $util.newBuffer($util.base64.length(object.rawValue)), 0);
                        else if (object.rawValue.length)
                            message.rawValue = object.rawValue;
                    if (object.quantization != null) {
                        if (typeof object.quantization !== "object")
                            throw TypeError(".CoreML.Specification.WeightParams.quantization: object expected");
                        message.quantization = $root.CoreML.Specification.QuantizationParams.fromObject(object.quantization);
                    }
                    return message;
                };
    
                WeightParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.floatValue = [];
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.float16Value = "";
                        else {
                            object.float16Value = [];
                            if (options.bytes !== Array)
                                object.float16Value = $util.newBuffer(object.float16Value);
                        }
                        if (options.bytes === String)
                            object.rawValue = "";
                        else {
                            object.rawValue = [];
                            if (options.bytes !== Array)
                                object.rawValue = $util.newBuffer(object.rawValue);
                        }
                        object.quantization = null;
                    }
                    if (message.floatValue && message.floatValue.length) {
                        object.floatValue = [];
                        for (var j = 0; j < message.floatValue.length; ++j)
                            object.floatValue[j] = options.json && !isFinite(message.floatValue[j]) ? String(message.floatValue[j]) : message.floatValue[j];
                    }
                    if (message.float16Value != null && message.hasOwnProperty("float16Value"))
                        object.float16Value = options.bytes === String ? $util.base64.encode(message.float16Value, 0, message.float16Value.length) : options.bytes === Array ? Array.prototype.slice.call(message.float16Value) : message.float16Value;
                    if (message.rawValue != null && message.hasOwnProperty("rawValue"))
                        object.rawValue = options.bytes === String ? $util.base64.encode(message.rawValue, 0, message.rawValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawValue) : message.rawValue;
                    if (message.quantization != null && message.hasOwnProperty("quantization"))
                        object.quantization = $root.CoreML.Specification.QuantizationParams.toObject(message.quantization, options);
                    return object;
                };
    
                WeightParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return WeightParams;
            })();
    
            Specification.QuantizationParams = (function() {
    
                function QuantizationParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                QuantizationParams.prototype.numberOfBits = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                QuantizationParams.prototype.linearQuantization = null;
                QuantizationParams.prototype.lookupTableQuantization = null;
    
                var $oneOfFields;
    
                Object.defineProperty(QuantizationParams.prototype, "QuantizationType", {
                    get: $util.oneOfGetter($oneOfFields = ["linearQuantization", "lookupTableQuantization"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                QuantizationParams.create = function create(properties) {
                    return new QuantizationParams(properties);
                };
    
                QuantizationParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.QuantizationParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.numberOfBits = reader.uint64();
                            break;
                        case 101:
                            message.linearQuantization = $root.CoreML.Specification.LinearQuantizationParams.decode(reader, reader.uint32());
                            break;
                        case 102:
                            message.lookupTableQuantization = $root.CoreML.Specification.LookUpTableQuantizationParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                QuantizationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.numberOfBits != null && message.hasOwnProperty("numberOfBits"))
                        if (!$util.isInteger(message.numberOfBits) && !(message.numberOfBits && $util.isInteger(message.numberOfBits.low) && $util.isInteger(message.numberOfBits.high)))
                            return "numberOfBits: integer|Long expected";
                    if (message.linearQuantization != null && message.hasOwnProperty("linearQuantization")) {
                        properties.QuantizationType = 1;
                        {
                            var error = $root.CoreML.Specification.LinearQuantizationParams.verify(message.linearQuantization);
                            if (error)
                                return "linearQuantization." + error;
                        }
                    }
                    if (message.lookupTableQuantization != null && message.hasOwnProperty("lookupTableQuantization")) {
                        if (properties.QuantizationType === 1)
                            return "QuantizationType: multiple values";
                        properties.QuantizationType = 1;
                        {
                            var error = $root.CoreML.Specification.LookUpTableQuantizationParams.verify(message.lookupTableQuantization);
                            if (error)
                                return "lookupTableQuantization." + error;
                        }
                    }
                    return null;
                };
    
                QuantizationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.QuantizationParams)
                        return object;
                    var message = new $root.CoreML.Specification.QuantizationParams();
                    if (object.numberOfBits != null)
                        if ($util.Long)
                            (message.numberOfBits = $util.Long.fromValue(object.numberOfBits)).unsigned = true;
                        else if (typeof object.numberOfBits === "string")
                            message.numberOfBits = parseInt(object.numberOfBits, 10);
                        else if (typeof object.numberOfBits === "number")
                            message.numberOfBits = object.numberOfBits;
                        else if (typeof object.numberOfBits === "object")
                            message.numberOfBits = new $util.LongBits(object.numberOfBits.low >>> 0, object.numberOfBits.high >>> 0).toNumber(true);
                    if (object.linearQuantization != null) {
                        if (typeof object.linearQuantization !== "object")
                            throw TypeError(".CoreML.Specification.QuantizationParams.linearQuantization: object expected");
                        message.linearQuantization = $root.CoreML.Specification.LinearQuantizationParams.fromObject(object.linearQuantization);
                    }
                    if (object.lookupTableQuantization != null) {
                        if (typeof object.lookupTableQuantization !== "object")
                            throw TypeError(".CoreML.Specification.QuantizationParams.lookupTableQuantization: object expected");
                        message.lookupTableQuantization = $root.CoreML.Specification.LookUpTableQuantizationParams.fromObject(object.lookupTableQuantization);
                    }
                    return message;
                };
    
                QuantizationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.numberOfBits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.numberOfBits = options.longs === String ? "0" : 0;
                    if (message.numberOfBits != null && message.hasOwnProperty("numberOfBits"))
                        if (typeof message.numberOfBits === "number")
                            object.numberOfBits = options.longs === String ? String(message.numberOfBits) : message.numberOfBits;
                        else
                            object.numberOfBits = options.longs === String ? $util.Long.prototype.toString.call(message.numberOfBits) : options.longs === Number ? new $util.LongBits(message.numberOfBits.low >>> 0, message.numberOfBits.high >>> 0).toNumber(true) : message.numberOfBits;
                    if (message.linearQuantization != null && message.hasOwnProperty("linearQuantization")) {
                        object.linearQuantization = $root.CoreML.Specification.LinearQuantizationParams.toObject(message.linearQuantization, options);
                        if (options.oneofs)
                            object.QuantizationType = "linearQuantization";
                    }
                    if (message.lookupTableQuantization != null && message.hasOwnProperty("lookupTableQuantization")) {
                        object.lookupTableQuantization = $root.CoreML.Specification.LookUpTableQuantizationParams.toObject(message.lookupTableQuantization, options);
                        if (options.oneofs)
                            object.QuantizationType = "lookupTableQuantization";
                    }
                    return object;
                };
    
                QuantizationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return QuantizationParams;
            })();
    
            Specification.LinearQuantizationParams = (function() {
    
                function LinearQuantizationParams(properties) {
                    this.scale = [];
                    this.bias = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LinearQuantizationParams.prototype.scale = $util.emptyArray;
                LinearQuantizationParams.prototype.bias = $util.emptyArray;
    
                LinearQuantizationParams.create = function create(properties) {
                    return new LinearQuantizationParams(properties);
                };
    
                LinearQuantizationParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LinearQuantizationParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.scale && message.scale.length))
                                message.scale = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.scale.push(reader.float());
                            } else
                                message.scale.push(reader.float());
                            break;
                        case 2:
                            if (!(message.bias && message.bias.length))
                                message.bias = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.bias.push(reader.float());
                            } else
                                message.bias.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LinearQuantizationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        if (!Array.isArray(message.scale))
                            return "scale: array expected";
                        for (var i = 0; i < message.scale.length; ++i)
                            if (typeof message.scale[i] !== "number")
                                return "scale: number[] expected";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        if (!Array.isArray(message.bias))
                            return "bias: array expected";
                        for (var i = 0; i < message.bias.length; ++i)
                            if (typeof message.bias[i] !== "number")
                                return "bias: number[] expected";
                    }
                    return null;
                };
    
                LinearQuantizationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LinearQuantizationParams)
                        return object;
                    var message = new $root.CoreML.Specification.LinearQuantizationParams();
                    if (object.scale) {
                        if (!Array.isArray(object.scale))
                            throw TypeError(".CoreML.Specification.LinearQuantizationParams.scale: array expected");
                        message.scale = [];
                        for (var i = 0; i < object.scale.length; ++i)
                            message.scale[i] = Number(object.scale[i]);
                    }
                    if (object.bias) {
                        if (!Array.isArray(object.bias))
                            throw TypeError(".CoreML.Specification.LinearQuantizationParams.bias: array expected");
                        message.bias = [];
                        for (var i = 0; i < object.bias.length; ++i)
                            message.bias[i] = Number(object.bias[i]);
                    }
                    return message;
                };
    
                LinearQuantizationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.scale = [];
                        object.bias = [];
                    }
                    if (message.scale && message.scale.length) {
                        object.scale = [];
                        for (var j = 0; j < message.scale.length; ++j)
                            object.scale[j] = options.json && !isFinite(message.scale[j]) ? String(message.scale[j]) : message.scale[j];
                    }
                    if (message.bias && message.bias.length) {
                        object.bias = [];
                        for (var j = 0; j < message.bias.length; ++j)
                            object.bias[j] = options.json && !isFinite(message.bias[j]) ? String(message.bias[j]) : message.bias[j];
                    }
                    return object;
                };
    
                LinearQuantizationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LinearQuantizationParams;
            })();
    
            Specification.LookUpTableQuantizationParams = (function() {
    
                function LookUpTableQuantizationParams(properties) {
                    this.floatValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LookUpTableQuantizationParams.prototype.floatValue = $util.emptyArray;
    
                LookUpTableQuantizationParams.create = function create(properties) {
                    return new LookUpTableQuantizationParams(properties);
                };
    
                LookUpTableQuantizationParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LookUpTableQuantizationParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.floatValue && message.floatValue.length))
                                message.floatValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                if (message.floatValue.length == 0 && (end2 - reader.pos) > 1048576) {
                                    var floatValueLength = end2 - reader.pos;
                                    var floatValueView = new DataView(reader.buf.buffer, reader.buf.byteOffset + reader.pos, floatValueLength);
                                    floatValueLength = floatValueLength >>> 2;
                                    var floatValue = new Float32Array(floatValueLength);
                                    for (var i = 0; i < floatValueLength; i++) {
                                        floatValue[i] = floatValueView.getFloat32(i << 2, true);
                                    }
                                    message.floatValue = floatValue;
                                    reader.pos = end2;
                                }
                                else {
                                    while (reader.pos < end2)
                                        message.floatValue.push(reader.float());
                                }
                            } else
                                message.floatValue.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LookUpTableQuantizationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        if (!Array.isArray(message.floatValue))
                            return "floatValue: array expected";
                        for (var i = 0; i < message.floatValue.length; ++i)
                            if (typeof message.floatValue[i] !== "number")
                                return "floatValue: number[] expected";
                    }
                    return null;
                };
    
                LookUpTableQuantizationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LookUpTableQuantizationParams)
                        return object;
                    var message = new $root.CoreML.Specification.LookUpTableQuantizationParams();
                    if (object.floatValue) {
                        if (!Array.isArray(object.floatValue))
                            throw TypeError(".CoreML.Specification.LookUpTableQuantizationParams.floatValue: array expected");
                        message.floatValue = [];
                        for (var i = 0; i < object.floatValue.length; ++i)
                            message.floatValue[i] = Number(object.floatValue[i]);
                    }
                    return message;
                };
    
                LookUpTableQuantizationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.floatValue = [];
                    if (message.floatValue && message.floatValue.length) {
                        object.floatValue = [];
                        for (var j = 0; j < message.floatValue.length; ++j)
                            object.floatValue[j] = options.json && !isFinite(message.floatValue[j]) ? String(message.floatValue[j]) : message.floatValue[j];
                    }
                    return object;
                };
    
                LookUpTableQuantizationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LookUpTableQuantizationParams;
            })();
    
            Specification.ConvolutionLayerParams = (function() {
    
                function ConvolutionLayerParams(properties) {
                    this.kernelSize = [];
                    this.stride = [];
                    this.dilationFactor = [];
                    this.outputShape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ConvolutionLayerParams.prototype.outputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                ConvolutionLayerParams.prototype.kernelChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                ConvolutionLayerParams.prototype.nGroups = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                ConvolutionLayerParams.prototype.kernelSize = $util.emptyArray;
                ConvolutionLayerParams.prototype.stride = $util.emptyArray;
                ConvolutionLayerParams.prototype.dilationFactor = $util.emptyArray;
                ConvolutionLayerParams.prototype.valid = null;
                ConvolutionLayerParams.prototype.same = null;
                ConvolutionLayerParams.prototype.isDeconvolution = false;
                ConvolutionLayerParams.prototype.hasBias = false;
                ConvolutionLayerParams.prototype.weights = null;
                ConvolutionLayerParams.prototype.bias = null;
                ConvolutionLayerParams.prototype.outputShape = $util.emptyArray;
    
                var $oneOfFields;
    
                Object.defineProperty(ConvolutionLayerParams.prototype, "ConvolutionPaddingType", {
                    get: $util.oneOfGetter($oneOfFields = ["valid", "same"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                ConvolutionLayerParams.create = function create(properties) {
                    return new ConvolutionLayerParams(properties);
                };
    
                ConvolutionLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ConvolutionLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputChannels = reader.uint64();
                            break;
                        case 2:
                            message.kernelChannels = reader.uint64();
                            break;
                        case 10:
                            message.nGroups = reader.uint64();
                            break;
                        case 20:
                            if (!(message.kernelSize && message.kernelSize.length))
                                message.kernelSize = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.kernelSize.push(reader.uint64());
                            } else
                                message.kernelSize.push(reader.uint64());
                            break;
                        case 30:
                            if (!(message.stride && message.stride.length))
                                message.stride = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.stride.push(reader.uint64());
                            } else
                                message.stride.push(reader.uint64());
                            break;
                        case 40:
                            if (!(message.dilationFactor && message.dilationFactor.length))
                                message.dilationFactor = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.dilationFactor.push(reader.uint64());
                            } else
                                message.dilationFactor.push(reader.uint64());
                            break;
                        case 50:
                            message.valid = $root.CoreML.Specification.ValidPadding.decode(reader, reader.uint32());
                            break;
                        case 51:
                            message.same = $root.CoreML.Specification.SamePadding.decode(reader, reader.uint32());
                            break;
                        case 60:
                            message.isDeconvolution = reader.bool();
                            break;
                        case 70:
                            message.hasBias = reader.bool();
                            break;
                        case 90:
                            message.weights = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 91:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            if (!(message.outputShape && message.outputShape.length))
                                message.outputShape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.outputShape.push(reader.uint64());
                            } else
                                message.outputShape.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ConvolutionLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (!$util.isInteger(message.outputChannels) && !(message.outputChannels && $util.isInteger(message.outputChannels.low) && $util.isInteger(message.outputChannels.high)))
                            return "outputChannels: integer|Long expected";
                    if (message.kernelChannels != null && message.hasOwnProperty("kernelChannels"))
                        if (!$util.isInteger(message.kernelChannels) && !(message.kernelChannels && $util.isInteger(message.kernelChannels.low) && $util.isInteger(message.kernelChannels.high)))
                            return "kernelChannels: integer|Long expected";
                    if (message.nGroups != null && message.hasOwnProperty("nGroups"))
                        if (!$util.isInteger(message.nGroups) && !(message.nGroups && $util.isInteger(message.nGroups.low) && $util.isInteger(message.nGroups.high)))
                            return "nGroups: integer|Long expected";
                    if (message.kernelSize != null && message.hasOwnProperty("kernelSize")) {
                        if (!Array.isArray(message.kernelSize))
                            return "kernelSize: array expected";
                        for (var i = 0; i < message.kernelSize.length; ++i)
                            if (!$util.isInteger(message.kernelSize[i]) && !(message.kernelSize[i] && $util.isInteger(message.kernelSize[i].low) && $util.isInteger(message.kernelSize[i].high)))
                                return "kernelSize: integer|Long[] expected";
                    }
                    if (message.stride != null && message.hasOwnProperty("stride")) {
                        if (!Array.isArray(message.stride))
                            return "stride: array expected";
                        for (var i = 0; i < message.stride.length; ++i)
                            if (!$util.isInteger(message.stride[i]) && !(message.stride[i] && $util.isInteger(message.stride[i].low) && $util.isInteger(message.stride[i].high)))
                                return "stride: integer|Long[] expected";
                    }
                    if (message.dilationFactor != null && message.hasOwnProperty("dilationFactor")) {
                        if (!Array.isArray(message.dilationFactor))
                            return "dilationFactor: array expected";
                        for (var i = 0; i < message.dilationFactor.length; ++i)
                            if (!$util.isInteger(message.dilationFactor[i]) && !(message.dilationFactor[i] && $util.isInteger(message.dilationFactor[i].low) && $util.isInteger(message.dilationFactor[i].high)))
                                return "dilationFactor: integer|Long[] expected";
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        properties.ConvolutionPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.ValidPadding.verify(message.valid);
                            if (error)
                                return "valid." + error;
                        }
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        if (properties.ConvolutionPaddingType === 1)
                            return "ConvolutionPaddingType: multiple values";
                        properties.ConvolutionPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.SamePadding.verify(message.same);
                            if (error)
                                return "same." + error;
                        }
                    }
                    if (message.isDeconvolution != null && message.hasOwnProperty("isDeconvolution"))
                        if (typeof message.isDeconvolution !== "boolean")
                            return "isDeconvolution: boolean expected";
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weights);
                        if (error)
                            return "weights." + error;
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    if (message.outputShape != null && message.hasOwnProperty("outputShape")) {
                        if (!Array.isArray(message.outputShape))
                            return "outputShape: array expected";
                        for (var i = 0; i < message.outputShape.length; ++i)
                            if (!$util.isInteger(message.outputShape[i]) && !(message.outputShape[i] && $util.isInteger(message.outputShape[i].low) && $util.isInteger(message.outputShape[i].high)))
                                return "outputShape: integer|Long[] expected";
                    }
                    return null;
                };
    
                ConvolutionLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ConvolutionLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ConvolutionLayerParams();
                    if (object.outputChannels != null)
                        if ($util.Long)
                            (message.outputChannels = $util.Long.fromValue(object.outputChannels)).unsigned = true;
                        else if (typeof object.outputChannels === "string")
                            message.outputChannels = parseInt(object.outputChannels, 10);
                        else if (typeof object.outputChannels === "number")
                            message.outputChannels = object.outputChannels;
                        else if (typeof object.outputChannels === "object")
                            message.outputChannels = new $util.LongBits(object.outputChannels.low >>> 0, object.outputChannels.high >>> 0).toNumber(true);
                    if (object.kernelChannels != null)
                        if ($util.Long)
                            (message.kernelChannels = $util.Long.fromValue(object.kernelChannels)).unsigned = true;
                        else if (typeof object.kernelChannels === "string")
                            message.kernelChannels = parseInt(object.kernelChannels, 10);
                        else if (typeof object.kernelChannels === "number")
                            message.kernelChannels = object.kernelChannels;
                        else if (typeof object.kernelChannels === "object")
                            message.kernelChannels = new $util.LongBits(object.kernelChannels.low >>> 0, object.kernelChannels.high >>> 0).toNumber(true);
                    if (object.nGroups != null)
                        if ($util.Long)
                            (message.nGroups = $util.Long.fromValue(object.nGroups)).unsigned = true;
                        else if (typeof object.nGroups === "string")
                            message.nGroups = parseInt(object.nGroups, 10);
                        else if (typeof object.nGroups === "number")
                            message.nGroups = object.nGroups;
                        else if (typeof object.nGroups === "object")
                            message.nGroups = new $util.LongBits(object.nGroups.low >>> 0, object.nGroups.high >>> 0).toNumber(true);
                    if (object.kernelSize) {
                        if (!Array.isArray(object.kernelSize))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.kernelSize: array expected");
                        message.kernelSize = [];
                        for (var i = 0; i < object.kernelSize.length; ++i)
                            if ($util.Long)
                                (message.kernelSize[i] = $util.Long.fromValue(object.kernelSize[i])).unsigned = true;
                            else if (typeof object.kernelSize[i] === "string")
                                message.kernelSize[i] = parseInt(object.kernelSize[i], 10);
                            else if (typeof object.kernelSize[i] === "number")
                                message.kernelSize[i] = object.kernelSize[i];
                            else if (typeof object.kernelSize[i] === "object")
                                message.kernelSize[i] = new $util.LongBits(object.kernelSize[i].low >>> 0, object.kernelSize[i].high >>> 0).toNumber(true);
                    }
                    if (object.stride) {
                        if (!Array.isArray(object.stride))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.stride: array expected");
                        message.stride = [];
                        for (var i = 0; i < object.stride.length; ++i)
                            if ($util.Long)
                                (message.stride[i] = $util.Long.fromValue(object.stride[i])).unsigned = true;
                            else if (typeof object.stride[i] === "string")
                                message.stride[i] = parseInt(object.stride[i], 10);
                            else if (typeof object.stride[i] === "number")
                                message.stride[i] = object.stride[i];
                            else if (typeof object.stride[i] === "object")
                                message.stride[i] = new $util.LongBits(object.stride[i].low >>> 0, object.stride[i].high >>> 0).toNumber(true);
                    }
                    if (object.dilationFactor) {
                        if (!Array.isArray(object.dilationFactor))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.dilationFactor: array expected");
                        message.dilationFactor = [];
                        for (var i = 0; i < object.dilationFactor.length; ++i)
                            if ($util.Long)
                                (message.dilationFactor[i] = $util.Long.fromValue(object.dilationFactor[i])).unsigned = true;
                            else if (typeof object.dilationFactor[i] === "string")
                                message.dilationFactor[i] = parseInt(object.dilationFactor[i], 10);
                            else if (typeof object.dilationFactor[i] === "number")
                                message.dilationFactor[i] = object.dilationFactor[i];
                            else if (typeof object.dilationFactor[i] === "object")
                                message.dilationFactor[i] = new $util.LongBits(object.dilationFactor[i].low >>> 0, object.dilationFactor[i].high >>> 0).toNumber(true);
                    }
                    if (object.valid != null) {
                        if (typeof object.valid !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.valid: object expected");
                        message.valid = $root.CoreML.Specification.ValidPadding.fromObject(object.valid);
                    }
                    if (object.same != null) {
                        if (typeof object.same !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.same: object expected");
                        message.same = $root.CoreML.Specification.SamePadding.fromObject(object.same);
                    }
                    if (object.isDeconvolution != null)
                        message.isDeconvolution = Boolean(object.isDeconvolution);
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.weights != null) {
                        if (typeof object.weights !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.weights: object expected");
                        message.weights = $root.CoreML.Specification.WeightParams.fromObject(object.weights);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    if (object.outputShape) {
                        if (!Array.isArray(object.outputShape))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.outputShape: array expected");
                        message.outputShape = [];
                        for (var i = 0; i < object.outputShape.length; ++i)
                            if ($util.Long)
                                (message.outputShape[i] = $util.Long.fromValue(object.outputShape[i])).unsigned = true;
                            else if (typeof object.outputShape[i] === "string")
                                message.outputShape[i] = parseInt(object.outputShape[i], 10);
                            else if (typeof object.outputShape[i] === "number")
                                message.outputShape[i] = object.outputShape[i];
                            else if (typeof object.outputShape[i] === "object")
                                message.outputShape[i] = new $util.LongBits(object.outputShape[i].low >>> 0, object.outputShape[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                ConvolutionLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.kernelSize = [];
                        object.stride = [];
                        object.dilationFactor = [];
                        object.outputShape = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputChannels = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.kernelChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.kernelChannels = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nGroups = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nGroups = options.longs === String ? "0" : 0;
                        object.isDeconvolution = false;
                        object.hasBias = false;
                        object.weights = null;
                        object.bias = null;
                    }
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (typeof message.outputChannels === "number")
                            object.outputChannels = options.longs === String ? String(message.outputChannels) : message.outputChannels;
                        else
                            object.outputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.outputChannels) : options.longs === Number ? new $util.LongBits(message.outputChannels.low >>> 0, message.outputChannels.high >>> 0).toNumber(true) : message.outputChannels;
                    if (message.kernelChannels != null && message.hasOwnProperty("kernelChannels"))
                        if (typeof message.kernelChannels === "number")
                            object.kernelChannels = options.longs === String ? String(message.kernelChannels) : message.kernelChannels;
                        else
                            object.kernelChannels = options.longs === String ? $util.Long.prototype.toString.call(message.kernelChannels) : options.longs === Number ? new $util.LongBits(message.kernelChannels.low >>> 0, message.kernelChannels.high >>> 0).toNumber(true) : message.kernelChannels;
                    if (message.nGroups != null && message.hasOwnProperty("nGroups"))
                        if (typeof message.nGroups === "number")
                            object.nGroups = options.longs === String ? String(message.nGroups) : message.nGroups;
                        else
                            object.nGroups = options.longs === String ? $util.Long.prototype.toString.call(message.nGroups) : options.longs === Number ? new $util.LongBits(message.nGroups.low >>> 0, message.nGroups.high >>> 0).toNumber(true) : message.nGroups;
                    if (message.kernelSize && message.kernelSize.length) {
                        object.kernelSize = [];
                        for (var j = 0; j < message.kernelSize.length; ++j)
                            if (typeof message.kernelSize[j] === "number")
                                object.kernelSize[j] = options.longs === String ? String(message.kernelSize[j]) : message.kernelSize[j];
                            else
                                object.kernelSize[j] = options.longs === String ? $util.Long.prototype.toString.call(message.kernelSize[j]) : options.longs === Number ? new $util.LongBits(message.kernelSize[j].low >>> 0, message.kernelSize[j].high >>> 0).toNumber(true) : message.kernelSize[j];
                    }
                    if (message.stride && message.stride.length) {
                        object.stride = [];
                        for (var j = 0; j < message.stride.length; ++j)
                            if (typeof message.stride[j] === "number")
                                object.stride[j] = options.longs === String ? String(message.stride[j]) : message.stride[j];
                            else
                                object.stride[j] = options.longs === String ? $util.Long.prototype.toString.call(message.stride[j]) : options.longs === Number ? new $util.LongBits(message.stride[j].low >>> 0, message.stride[j].high >>> 0).toNumber(true) : message.stride[j];
                    }
                    if (message.dilationFactor && message.dilationFactor.length) {
                        object.dilationFactor = [];
                        for (var j = 0; j < message.dilationFactor.length; ++j)
                            if (typeof message.dilationFactor[j] === "number")
                                object.dilationFactor[j] = options.longs === String ? String(message.dilationFactor[j]) : message.dilationFactor[j];
                            else
                                object.dilationFactor[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dilationFactor[j]) : options.longs === Number ? new $util.LongBits(message.dilationFactor[j].low >>> 0, message.dilationFactor[j].high >>> 0).toNumber(true) : message.dilationFactor[j];
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        object.valid = $root.CoreML.Specification.ValidPadding.toObject(message.valid, options);
                        if (options.oneofs)
                            object.ConvolutionPaddingType = "valid";
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        object.same = $root.CoreML.Specification.SamePadding.toObject(message.same, options);
                        if (options.oneofs)
                            object.ConvolutionPaddingType = "same";
                    }
                    if (message.isDeconvolution != null && message.hasOwnProperty("isDeconvolution"))
                        object.isDeconvolution = message.isDeconvolution;
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        object.weights = $root.CoreML.Specification.WeightParams.toObject(message.weights, options);
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    if (message.outputShape && message.outputShape.length) {
                        object.outputShape = [];
                        for (var j = 0; j < message.outputShape.length; ++j)
                            if (typeof message.outputShape[j] === "number")
                                object.outputShape[j] = options.longs === String ? String(message.outputShape[j]) : message.outputShape[j];
                            else
                                object.outputShape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.outputShape[j]) : options.longs === Number ? new $util.LongBits(message.outputShape[j].low >>> 0, message.outputShape[j].high >>> 0).toNumber(true) : message.outputShape[j];
                    }
                    return object;
                };
    
                ConvolutionLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConvolutionLayerParams;
            })();
    
            Specification.InnerProductLayerParams = (function() {
    
                function InnerProductLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                InnerProductLayerParams.prototype.inputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                InnerProductLayerParams.prototype.outputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                InnerProductLayerParams.prototype.hasBias = false;
                InnerProductLayerParams.prototype.weights = null;
                InnerProductLayerParams.prototype.bias = null;
    
                InnerProductLayerParams.create = function create(properties) {
                    return new InnerProductLayerParams(properties);
                };
    
                InnerProductLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.InnerProductLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputChannels = reader.uint64();
                            break;
                        case 2:
                            message.outputChannels = reader.uint64();
                            break;
                        case 10:
                            message.hasBias = reader.bool();
                            break;
                        case 20:
                            message.weights = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                InnerProductLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputChannels != null && message.hasOwnProperty("inputChannels"))
                        if (!$util.isInteger(message.inputChannels) && !(message.inputChannels && $util.isInteger(message.inputChannels.low) && $util.isInteger(message.inputChannels.high)))
                            return "inputChannels: integer|Long expected";
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (!$util.isInteger(message.outputChannels) && !(message.outputChannels && $util.isInteger(message.outputChannels.low) && $util.isInteger(message.outputChannels.high)))
                            return "outputChannels: integer|Long expected";
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weights);
                        if (error)
                            return "weights." + error;
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                InnerProductLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.InnerProductLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.InnerProductLayerParams();
                    if (object.inputChannels != null)
                        if ($util.Long)
                            (message.inputChannels = $util.Long.fromValue(object.inputChannels)).unsigned = true;
                        else if (typeof object.inputChannels === "string")
                            message.inputChannels = parseInt(object.inputChannels, 10);
                        else if (typeof object.inputChannels === "number")
                            message.inputChannels = object.inputChannels;
                        else if (typeof object.inputChannels === "object")
                            message.inputChannels = new $util.LongBits(object.inputChannels.low >>> 0, object.inputChannels.high >>> 0).toNumber(true);
                    if (object.outputChannels != null)
                        if ($util.Long)
                            (message.outputChannels = $util.Long.fromValue(object.outputChannels)).unsigned = true;
                        else if (typeof object.outputChannels === "string")
                            message.outputChannels = parseInt(object.outputChannels, 10);
                        else if (typeof object.outputChannels === "number")
                            message.outputChannels = object.outputChannels;
                        else if (typeof object.outputChannels === "object")
                            message.outputChannels = new $util.LongBits(object.outputChannels.low >>> 0, object.outputChannels.high >>> 0).toNumber(true);
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.weights != null) {
                        if (typeof object.weights !== "object")
                            throw TypeError(".CoreML.Specification.InnerProductLayerParams.weights: object expected");
                        message.weights = $root.CoreML.Specification.WeightParams.fromObject(object.weights);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.InnerProductLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                InnerProductLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputChannels = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputChannels = options.longs === String ? "0" : 0;
                        object.hasBias = false;
                        object.weights = null;
                        object.bias = null;
                    }
                    if (message.inputChannels != null && message.hasOwnProperty("inputChannels"))
                        if (typeof message.inputChannels === "number")
                            object.inputChannels = options.longs === String ? String(message.inputChannels) : message.inputChannels;
                        else
                            object.inputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.inputChannels) : options.longs === Number ? new $util.LongBits(message.inputChannels.low >>> 0, message.inputChannels.high >>> 0).toNumber(true) : message.inputChannels;
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (typeof message.outputChannels === "number")
                            object.outputChannels = options.longs === String ? String(message.outputChannels) : message.outputChannels;
                        else
                            object.outputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.outputChannels) : options.longs === Number ? new $util.LongBits(message.outputChannels.low >>> 0, message.outputChannels.high >>> 0).toNumber(true) : message.outputChannels;
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        object.weights = $root.CoreML.Specification.WeightParams.toObject(message.weights, options);
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                InnerProductLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InnerProductLayerParams;
            })();
    
            Specification.EmbeddingLayerParams = (function() {
    
                function EmbeddingLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                EmbeddingLayerParams.prototype.inputDim = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                EmbeddingLayerParams.prototype.outputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                EmbeddingLayerParams.prototype.hasBias = false;
                EmbeddingLayerParams.prototype.weights = null;
                EmbeddingLayerParams.prototype.bias = null;
    
                EmbeddingLayerParams.create = function create(properties) {
                    return new EmbeddingLayerParams(properties);
                };
    
                EmbeddingLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.EmbeddingLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputDim = reader.uint64();
                            break;
                        case 2:
                            message.outputChannels = reader.uint64();
                            break;
                        case 10:
                            message.hasBias = reader.bool();
                            break;
                        case 20:
                            message.weights = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                EmbeddingLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputDim != null && message.hasOwnProperty("inputDim"))
                        if (!$util.isInteger(message.inputDim) && !(message.inputDim && $util.isInteger(message.inputDim.low) && $util.isInteger(message.inputDim.high)))
                            return "inputDim: integer|Long expected";
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (!$util.isInteger(message.outputChannels) && !(message.outputChannels && $util.isInteger(message.outputChannels.low) && $util.isInteger(message.outputChannels.high)))
                            return "outputChannels: integer|Long expected";
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weights);
                        if (error)
                            return "weights." + error;
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                EmbeddingLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.EmbeddingLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.EmbeddingLayerParams();
                    if (object.inputDim != null)
                        if ($util.Long)
                            (message.inputDim = $util.Long.fromValue(object.inputDim)).unsigned = true;
                        else if (typeof object.inputDim === "string")
                            message.inputDim = parseInt(object.inputDim, 10);
                        else if (typeof object.inputDim === "number")
                            message.inputDim = object.inputDim;
                        else if (typeof object.inputDim === "object")
                            message.inputDim = new $util.LongBits(object.inputDim.low >>> 0, object.inputDim.high >>> 0).toNumber(true);
                    if (object.outputChannels != null)
                        if ($util.Long)
                            (message.outputChannels = $util.Long.fromValue(object.outputChannels)).unsigned = true;
                        else if (typeof object.outputChannels === "string")
                            message.outputChannels = parseInt(object.outputChannels, 10);
                        else if (typeof object.outputChannels === "number")
                            message.outputChannels = object.outputChannels;
                        else if (typeof object.outputChannels === "object")
                            message.outputChannels = new $util.LongBits(object.outputChannels.low >>> 0, object.outputChannels.high >>> 0).toNumber(true);
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.weights != null) {
                        if (typeof object.weights !== "object")
                            throw TypeError(".CoreML.Specification.EmbeddingLayerParams.weights: object expected");
                        message.weights = $root.CoreML.Specification.WeightParams.fromObject(object.weights);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.EmbeddingLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                EmbeddingLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputDim = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputDim = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputChannels = options.longs === String ? "0" : 0;
                        object.hasBias = false;
                        object.weights = null;
                        object.bias = null;
                    }
                    if (message.inputDim != null && message.hasOwnProperty("inputDim"))
                        if (typeof message.inputDim === "number")
                            object.inputDim = options.longs === String ? String(message.inputDim) : message.inputDim;
                        else
                            object.inputDim = options.longs === String ? $util.Long.prototype.toString.call(message.inputDim) : options.longs === Number ? new $util.LongBits(message.inputDim.low >>> 0, message.inputDim.high >>> 0).toNumber(true) : message.inputDim;
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (typeof message.outputChannels === "number")
                            object.outputChannels = options.longs === String ? String(message.outputChannels) : message.outputChannels;
                        else
                            object.outputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.outputChannels) : options.longs === Number ? new $util.LongBits(message.outputChannels.low >>> 0, message.outputChannels.high >>> 0).toNumber(true) : message.outputChannels;
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        object.weights = $root.CoreML.Specification.WeightParams.toObject(message.weights, options);
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                EmbeddingLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EmbeddingLayerParams;
            })();
    
            Specification.BatchnormLayerParams = (function() {
    
                function BatchnormLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                BatchnormLayerParams.prototype.channels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                BatchnormLayerParams.prototype.computeMeanVar = false;
                BatchnormLayerParams.prototype.instanceNormalization = false;
                BatchnormLayerParams.prototype.epsilon = 0;
                BatchnormLayerParams.prototype.gamma = null;
                BatchnormLayerParams.prototype.beta = null;
                BatchnormLayerParams.prototype.mean = null;
                BatchnormLayerParams.prototype.variance = null;
    
                BatchnormLayerParams.create = function create(properties) {
                    return new BatchnormLayerParams(properties);
                };
    
                BatchnormLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BatchnormLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.channels = reader.uint64();
                            break;
                        case 5:
                            message.computeMeanVar = reader.bool();
                            break;
                        case 6:
                            message.instanceNormalization = reader.bool();
                            break;
                        case 10:
                            message.epsilon = reader.float();
                            break;
                        case 15:
                            message.gamma = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.beta = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.mean = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.variance = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                BatchnormLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.channels != null && message.hasOwnProperty("channels"))
                        if (!$util.isInteger(message.channels) && !(message.channels && $util.isInteger(message.channels.low) && $util.isInteger(message.channels.high)))
                            return "channels: integer|Long expected";
                    if (message.computeMeanVar != null && message.hasOwnProperty("computeMeanVar"))
                        if (typeof message.computeMeanVar !== "boolean")
                            return "computeMeanVar: boolean expected";
                    if (message.instanceNormalization != null && message.hasOwnProperty("instanceNormalization"))
                        if (typeof message.instanceNormalization !== "boolean")
                            return "instanceNormalization: boolean expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.gamma);
                        if (error)
                            return "gamma." + error;
                    }
                    if (message.beta != null && message.hasOwnProperty("beta")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.beta);
                        if (error)
                            return "beta." + error;
                    }
                    if (message.mean != null && message.hasOwnProperty("mean")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.mean);
                        if (error)
                            return "mean." + error;
                    }
                    if (message.variance != null && message.hasOwnProperty("variance")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.variance);
                        if (error)
                            return "variance." + error;
                    }
                    return null;
                };
    
                BatchnormLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BatchnormLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.BatchnormLayerParams();
                    if (object.channels != null)
                        if ($util.Long)
                            (message.channels = $util.Long.fromValue(object.channels)).unsigned = true;
                        else if (typeof object.channels === "string")
                            message.channels = parseInt(object.channels, 10);
                        else if (typeof object.channels === "number")
                            message.channels = object.channels;
                        else if (typeof object.channels === "object")
                            message.channels = new $util.LongBits(object.channels.low >>> 0, object.channels.high >>> 0).toNumber(true);
                    if (object.computeMeanVar != null)
                        message.computeMeanVar = Boolean(object.computeMeanVar);
                    if (object.instanceNormalization != null)
                        message.instanceNormalization = Boolean(object.instanceNormalization);
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    if (object.gamma != null) {
                        if (typeof object.gamma !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.gamma: object expected");
                        message.gamma = $root.CoreML.Specification.WeightParams.fromObject(object.gamma);
                    }
                    if (object.beta != null) {
                        if (typeof object.beta !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.beta: object expected");
                        message.beta = $root.CoreML.Specification.WeightParams.fromObject(object.beta);
                    }
                    if (object.mean != null) {
                        if (typeof object.mean !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.mean: object expected");
                        message.mean = $root.CoreML.Specification.WeightParams.fromObject(object.mean);
                    }
                    if (object.variance != null) {
                        if (typeof object.variance !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.variance: object expected");
                        message.variance = $root.CoreML.Specification.WeightParams.fromObject(object.variance);
                    }
                    return message;
                };
    
                BatchnormLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.channels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.channels = options.longs === String ? "0" : 0;
                        object.computeMeanVar = false;
                        object.instanceNormalization = false;
                        object.epsilon = 0;
                        object.gamma = null;
                        object.beta = null;
                        object.mean = null;
                        object.variance = null;
                    }
                    if (message.channels != null && message.hasOwnProperty("channels"))
                        if (typeof message.channels === "number")
                            object.channels = options.longs === String ? String(message.channels) : message.channels;
                        else
                            object.channels = options.longs === String ? $util.Long.prototype.toString.call(message.channels) : options.longs === Number ? new $util.LongBits(message.channels.low >>> 0, message.channels.high >>> 0).toNumber(true) : message.channels;
                    if (message.computeMeanVar != null && message.hasOwnProperty("computeMeanVar"))
                        object.computeMeanVar = message.computeMeanVar;
                    if (message.instanceNormalization != null && message.hasOwnProperty("instanceNormalization"))
                        object.instanceNormalization = message.instanceNormalization;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = $root.CoreML.Specification.WeightParams.toObject(message.gamma, options);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = $root.CoreML.Specification.WeightParams.toObject(message.beta, options);
                    if (message.mean != null && message.hasOwnProperty("mean"))
                        object.mean = $root.CoreML.Specification.WeightParams.toObject(message.mean, options);
                    if (message.variance != null && message.hasOwnProperty("variance"))
                        object.variance = $root.CoreML.Specification.WeightParams.toObject(message.variance, options);
                    return object;
                };
    
                BatchnormLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BatchnormLayerParams;
            })();
    
            Specification.PoolingLayerParams = (function() {
    
                function PoolingLayerParams(properties) {
                    this.kernelSize = [];
                    this.stride = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                PoolingLayerParams.prototype.type = 0;
                PoolingLayerParams.prototype.kernelSize = $util.emptyArray;
                PoolingLayerParams.prototype.stride = $util.emptyArray;
                PoolingLayerParams.prototype.valid = null;
                PoolingLayerParams.prototype.same = null;
                PoolingLayerParams.prototype.includeLastPixel = null;
                PoolingLayerParams.prototype.avgPoolExcludePadding = false;
                PoolingLayerParams.prototype.globalPooling = false;
    
                var $oneOfFields;
    
                Object.defineProperty(PoolingLayerParams.prototype, "PoolingPaddingType", {
                    get: $util.oneOfGetter($oneOfFields = ["valid", "same", "includeLastPixel"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                PoolingLayerParams.create = function create(properties) {
                    return new PoolingLayerParams(properties);
                };
    
                PoolingLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PoolingLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 10:
                            if (!(message.kernelSize && message.kernelSize.length))
                                message.kernelSize = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.kernelSize.push(reader.uint64());
                            } else
                                message.kernelSize.push(reader.uint64());
                            break;
                        case 20:
                            if (!(message.stride && message.stride.length))
                                message.stride = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.stride.push(reader.uint64());
                            } else
                                message.stride.push(reader.uint64());
                            break;
                        case 30:
                            message.valid = $root.CoreML.Specification.ValidPadding.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.same = $root.CoreML.Specification.SamePadding.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.includeLastPixel = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.avgPoolExcludePadding = reader.bool();
                            break;
                        case 60:
                            message.globalPooling = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                PoolingLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.kernelSize != null && message.hasOwnProperty("kernelSize")) {
                        if (!Array.isArray(message.kernelSize))
                            return "kernelSize: array expected";
                        for (var i = 0; i < message.kernelSize.length; ++i)
                            if (!$util.isInteger(message.kernelSize[i]) && !(message.kernelSize[i] && $util.isInteger(message.kernelSize[i].low) && $util.isInteger(message.kernelSize[i].high)))
                                return "kernelSize: integer|Long[] expected";
                    }
                    if (message.stride != null && message.hasOwnProperty("stride")) {
                        if (!Array.isArray(message.stride))
                            return "stride: array expected";
                        for (var i = 0; i < message.stride.length; ++i)
                            if (!$util.isInteger(message.stride[i]) && !(message.stride[i] && $util.isInteger(message.stride[i].low) && $util.isInteger(message.stride[i].high)))
                                return "stride: integer|Long[] expected";
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        properties.PoolingPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.ValidPadding.verify(message.valid);
                            if (error)
                                return "valid." + error;
                        }
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        if (properties.PoolingPaddingType === 1)
                            return "PoolingPaddingType: multiple values";
                        properties.PoolingPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.SamePadding.verify(message.same);
                            if (error)
                                return "same." + error;
                        }
                    }
                    if (message.includeLastPixel != null && message.hasOwnProperty("includeLastPixel")) {
                        if (properties.PoolingPaddingType === 1)
                            return "PoolingPaddingType: multiple values";
                        properties.PoolingPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.verify(message.includeLastPixel);
                            if (error)
                                return "includeLastPixel." + error;
                        }
                    }
                    if (message.avgPoolExcludePadding != null && message.hasOwnProperty("avgPoolExcludePadding"))
                        if (typeof message.avgPoolExcludePadding !== "boolean")
                            return "avgPoolExcludePadding: boolean expected";
                    if (message.globalPooling != null && message.hasOwnProperty("globalPooling"))
                        if (typeof message.globalPooling !== "boolean")
                            return "globalPooling: boolean expected";
                    return null;
                };
    
                PoolingLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PoolingLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.PoolingLayerParams();
                    switch (object.type) {
                    case "MAX":
                    case 0:
                        message.type = 0;
                        break;
                    case "AVERAGE":
                    case 1:
                        message.type = 1;
                        break;
                    case "L2":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.kernelSize) {
                        if (!Array.isArray(object.kernelSize))
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.kernelSize: array expected");
                        message.kernelSize = [];
                        for (var i = 0; i < object.kernelSize.length; ++i)
                            if ($util.Long)
                                (message.kernelSize[i] = $util.Long.fromValue(object.kernelSize[i])).unsigned = true;
                            else if (typeof object.kernelSize[i] === "string")
                                message.kernelSize[i] = parseInt(object.kernelSize[i], 10);
                            else if (typeof object.kernelSize[i] === "number")
                                message.kernelSize[i] = object.kernelSize[i];
                            else if (typeof object.kernelSize[i] === "object")
                                message.kernelSize[i] = new $util.LongBits(object.kernelSize[i].low >>> 0, object.kernelSize[i].high >>> 0).toNumber(true);
                    }
                    if (object.stride) {
                        if (!Array.isArray(object.stride))
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.stride: array expected");
                        message.stride = [];
                        for (var i = 0; i < object.stride.length; ++i)
                            if ($util.Long)
                                (message.stride[i] = $util.Long.fromValue(object.stride[i])).unsigned = true;
                            else if (typeof object.stride[i] === "string")
                                message.stride[i] = parseInt(object.stride[i], 10);
                            else if (typeof object.stride[i] === "number")
                                message.stride[i] = object.stride[i];
                            else if (typeof object.stride[i] === "object")
                                message.stride[i] = new $util.LongBits(object.stride[i].low >>> 0, object.stride[i].high >>> 0).toNumber(true);
                    }
                    if (object.valid != null) {
                        if (typeof object.valid !== "object")
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.valid: object expected");
                        message.valid = $root.CoreML.Specification.ValidPadding.fromObject(object.valid);
                    }
                    if (object.same != null) {
                        if (typeof object.same !== "object")
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.same: object expected");
                        message.same = $root.CoreML.Specification.SamePadding.fromObject(object.same);
                    }
                    if (object.includeLastPixel != null) {
                        if (typeof object.includeLastPixel !== "object")
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.includeLastPixel: object expected");
                        message.includeLastPixel = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.fromObject(object.includeLastPixel);
                    }
                    if (object.avgPoolExcludePadding != null)
                        message.avgPoolExcludePadding = Boolean(object.avgPoolExcludePadding);
                    if (object.globalPooling != null)
                        message.globalPooling = Boolean(object.globalPooling);
                    return message;
                };
    
                PoolingLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.kernelSize = [];
                        object.stride = [];
                    }
                    if (options.defaults) {
                        object.type = options.enums === String ? "MAX" : 0;
                        object.avgPoolExcludePadding = false;
                        object.globalPooling = false;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CoreML.Specification.PoolingLayerParams.PoolingType[message.type] : message.type;
                    if (message.kernelSize && message.kernelSize.length) {
                        object.kernelSize = [];
                        for (var j = 0; j < message.kernelSize.length; ++j)
                            if (typeof message.kernelSize[j] === "number")
                                object.kernelSize[j] = options.longs === String ? String(message.kernelSize[j]) : message.kernelSize[j];
                            else
                                object.kernelSize[j] = options.longs === String ? $util.Long.prototype.toString.call(message.kernelSize[j]) : options.longs === Number ? new $util.LongBits(message.kernelSize[j].low >>> 0, message.kernelSize[j].high >>> 0).toNumber(true) : message.kernelSize[j];
                    }
                    if (message.stride && message.stride.length) {
                        object.stride = [];
                        for (var j = 0; j < message.stride.length; ++j)
                            if (typeof message.stride[j] === "number")
                                object.stride[j] = options.longs === String ? String(message.stride[j]) : message.stride[j];
                            else
                                object.stride[j] = options.longs === String ? $util.Long.prototype.toString.call(message.stride[j]) : options.longs === Number ? new $util.LongBits(message.stride[j].low >>> 0, message.stride[j].high >>> 0).toNumber(true) : message.stride[j];
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        object.valid = $root.CoreML.Specification.ValidPadding.toObject(message.valid, options);
                        if (options.oneofs)
                            object.PoolingPaddingType = "valid";
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        object.same = $root.CoreML.Specification.SamePadding.toObject(message.same, options);
                        if (options.oneofs)
                            object.PoolingPaddingType = "same";
                    }
                    if (message.includeLastPixel != null && message.hasOwnProperty("includeLastPixel")) {
                        object.includeLastPixel = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.toObject(message.includeLastPixel, options);
                        if (options.oneofs)
                            object.PoolingPaddingType = "includeLastPixel";
                    }
                    if (message.avgPoolExcludePadding != null && message.hasOwnProperty("avgPoolExcludePadding"))
                        object.avgPoolExcludePadding = message.avgPoolExcludePadding;
                    if (message.globalPooling != null && message.hasOwnProperty("globalPooling"))
                        object.globalPooling = message.globalPooling;
                    return object;
                };
    
                PoolingLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                PoolingLayerParams.PoolingType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "MAX"] = 0;
                    values[valuesById[1] = "AVERAGE"] = 1;
                    values[valuesById[2] = "L2"] = 2;
                    return values;
                })();
    
                PoolingLayerParams.ValidCompletePadding = (function() {
    
                    function ValidCompletePadding(properties) {
                        this.paddingAmounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    ValidCompletePadding.prototype.paddingAmounts = $util.emptyArray;
    
                    ValidCompletePadding.create = function create(properties) {
                        return new ValidCompletePadding(properties);
                    };
    
                    ValidCompletePadding.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 10:
                                if (!(message.paddingAmounts && message.paddingAmounts.length))
                                    message.paddingAmounts = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.paddingAmounts.push(reader.uint64());
                                } else
                                    message.paddingAmounts.push(reader.uint64());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    ValidCompletePadding.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts")) {
                            if (!Array.isArray(message.paddingAmounts))
                                return "paddingAmounts: array expected";
                            for (var i = 0; i < message.paddingAmounts.length; ++i)
                                if (!$util.isInteger(message.paddingAmounts[i]) && !(message.paddingAmounts[i] && $util.isInteger(message.paddingAmounts[i].low) && $util.isInteger(message.paddingAmounts[i].high)))
                                    return "paddingAmounts: integer|Long[] expected";
                        }
                        return null;
                    };
    
                    ValidCompletePadding.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
                            return object;
                        var message = new $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding();
                        if (object.paddingAmounts) {
                            if (!Array.isArray(object.paddingAmounts))
                                throw TypeError(".CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts: array expected");
                            message.paddingAmounts = [];
                            for (var i = 0; i < object.paddingAmounts.length; ++i)
                                if ($util.Long)
                                    (message.paddingAmounts[i] = $util.Long.fromValue(object.paddingAmounts[i])).unsigned = true;
                                else if (typeof object.paddingAmounts[i] === "string")
                                    message.paddingAmounts[i] = parseInt(object.paddingAmounts[i], 10);
                                else if (typeof object.paddingAmounts[i] === "number")
                                    message.paddingAmounts[i] = object.paddingAmounts[i];
                                else if (typeof object.paddingAmounts[i] === "object")
                                    message.paddingAmounts[i] = new $util.LongBits(object.paddingAmounts[i].low >>> 0, object.paddingAmounts[i].high >>> 0).toNumber(true);
                        }
                        return message;
                    };
    
                    ValidCompletePadding.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.paddingAmounts = [];
                        if (message.paddingAmounts && message.paddingAmounts.length) {
                            object.paddingAmounts = [];
                            for (var j = 0; j < message.paddingAmounts.length; ++j)
                                if (typeof message.paddingAmounts[j] === "number")
                                    object.paddingAmounts[j] = options.longs === String ? String(message.paddingAmounts[j]) : message.paddingAmounts[j];
                                else
                                    object.paddingAmounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.paddingAmounts[j]) : options.longs === Number ? new $util.LongBits(message.paddingAmounts[j].low >>> 0, message.paddingAmounts[j].high >>> 0).toNumber(true) : message.paddingAmounts[j];
                        }
                        return object;
                    };
    
                    ValidCompletePadding.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ValidCompletePadding;
                })();
    
                return PoolingLayerParams;
            })();
    
            Specification.PaddingLayerParams = (function() {
    
                function PaddingLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                PaddingLayerParams.prototype.constant = null;
                PaddingLayerParams.prototype.reflection = null;
                PaddingLayerParams.prototype.replication = null;
                PaddingLayerParams.prototype.paddingAmounts = null;
    
                var $oneOfFields;
    
                Object.defineProperty(PaddingLayerParams.prototype, "PaddingType", {
                    get: $util.oneOfGetter($oneOfFields = ["constant", "reflection", "replication"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                PaddingLayerParams.create = function create(properties) {
                    return new PaddingLayerParams(properties);
                };
    
                PaddingLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.constant = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.reflection = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.replication = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                PaddingLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.constant != null && message.hasOwnProperty("constant")) {
                        properties.PaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.verify(message.constant);
                            if (error)
                                return "constant." + error;
                        }
                    }
                    if (message.reflection != null && message.hasOwnProperty("reflection")) {
                        if (properties.PaddingType === 1)
                            return "PaddingType: multiple values";
                        properties.PaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.verify(message.reflection);
                            if (error)
                                return "reflection." + error;
                        }
                    }
                    if (message.replication != null && message.hasOwnProperty("replication")) {
                        if (properties.PaddingType === 1)
                            return "PaddingType: multiple values";
                        properties.PaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.verify(message.replication);
                            if (error)
                                return "replication." + error;
                        }
                    }
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts")) {
                        var error = $root.CoreML.Specification.BorderAmounts.verify(message.paddingAmounts);
                        if (error)
                            return "paddingAmounts." + error;
                    }
                    return null;
                };
    
                PaddingLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PaddingLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.PaddingLayerParams();
                    if (object.constant != null) {
                        if (typeof object.constant !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.constant: object expected");
                        message.constant = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.fromObject(object.constant);
                    }
                    if (object.reflection != null) {
                        if (typeof object.reflection !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.reflection: object expected");
                        message.reflection = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.fromObject(object.reflection);
                    }
                    if (object.replication != null) {
                        if (typeof object.replication !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.replication: object expected");
                        message.replication = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.fromObject(object.replication);
                    }
                    if (object.paddingAmounts != null) {
                        if (typeof object.paddingAmounts !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.paddingAmounts: object expected");
                        message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.fromObject(object.paddingAmounts);
                    }
                    return message;
                };
    
                PaddingLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.paddingAmounts = null;
                    if (message.constant != null && message.hasOwnProperty("constant")) {
                        object.constant = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.toObject(message.constant, options);
                        if (options.oneofs)
                            object.PaddingType = "constant";
                    }
                    if (message.reflection != null && message.hasOwnProperty("reflection")) {
                        object.reflection = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.toObject(message.reflection, options);
                        if (options.oneofs)
                            object.PaddingType = "reflection";
                    }
                    if (message.replication != null && message.hasOwnProperty("replication")) {
                        object.replication = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.toObject(message.replication, options);
                        if (options.oneofs)
                            object.PaddingType = "replication";
                    }
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts"))
                        object.paddingAmounts = $root.CoreML.Specification.BorderAmounts.toObject(message.paddingAmounts, options);
                    return object;
                };
    
                PaddingLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                PaddingLayerParams.PaddingConstant = (function() {
    
                    function PaddingConstant(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    PaddingConstant.prototype.value = 0;
    
                    PaddingConstant.create = function create(properties) {
                        return new PaddingConstant(properties);
                    };
    
                    PaddingConstant.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams.PaddingConstant();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    PaddingConstant.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value !== "number")
                                return "value: number expected";
                        return null;
                    };
    
                    PaddingConstant.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PaddingLayerParams.PaddingConstant)
                            return object;
                        var message = new $root.CoreML.Specification.PaddingLayerParams.PaddingConstant();
                        if (object.value != null)
                            message.value = Number(object.value);
                        return message;
                    };
    
                    PaddingConstant.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = 0;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                        return object;
                    };
    
                    PaddingConstant.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PaddingConstant;
                })();
    
                PaddingLayerParams.PaddingReflection = (function() {
    
                    function PaddingReflection(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    PaddingReflection.create = function create(properties) {
                        return new PaddingReflection(properties);
                    };
    
                    PaddingReflection.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams.PaddingReflection();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    PaddingReflection.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    PaddingReflection.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PaddingLayerParams.PaddingReflection)
                            return object;
                        return new $root.CoreML.Specification.PaddingLayerParams.PaddingReflection();
                    };
    
                    PaddingReflection.toObject = function toObject() {
                        return {};
                    };
    
                    PaddingReflection.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PaddingReflection;
                })();
    
                PaddingLayerParams.PaddingReplication = (function() {
    
                    function PaddingReplication(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    PaddingReplication.create = function create(properties) {
                        return new PaddingReplication(properties);
                    };
    
                    PaddingReplication.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams.PaddingReplication();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    PaddingReplication.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    PaddingReplication.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PaddingLayerParams.PaddingReplication)
                            return object;
                        return new $root.CoreML.Specification.PaddingLayerParams.PaddingReplication();
                    };
    
                    PaddingReplication.toObject = function toObject() {
                        return {};
                    };
    
                    PaddingReplication.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PaddingReplication;
                })();
    
                return PaddingLayerParams;
            })();
    
            Specification.ConcatLayerParams = (function() {
    
                function ConcatLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ConcatLayerParams.prototype.sequenceConcat = false;
    
                ConcatLayerParams.create = function create(properties) {
                    return new ConcatLayerParams(properties);
                };
    
                ConcatLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ConcatLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 100:
                            message.sequenceConcat = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ConcatLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sequenceConcat != null && message.hasOwnProperty("sequenceConcat"))
                        if (typeof message.sequenceConcat !== "boolean")
                            return "sequenceConcat: boolean expected";
                    return null;
                };
    
                ConcatLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ConcatLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ConcatLayerParams();
                    if (object.sequenceConcat != null)
                        message.sequenceConcat = Boolean(object.sequenceConcat);
                    return message;
                };
    
                ConcatLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.sequenceConcat = false;
                    if (message.sequenceConcat != null && message.hasOwnProperty("sequenceConcat"))
                        object.sequenceConcat = message.sequenceConcat;
                    return object;
                };
    
                ConcatLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConcatLayerParams;
            })();
    
            Specification.LRNLayerParams = (function() {
    
                function LRNLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LRNLayerParams.prototype.alpha = 0;
                LRNLayerParams.prototype.beta = 0;
                LRNLayerParams.prototype.localSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                LRNLayerParams.prototype.k = 0;
    
                LRNLayerParams.create = function create(properties) {
                    return new LRNLayerParams(properties);
                };
    
                LRNLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LRNLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        case 3:
                            message.localSize = reader.uint64();
                            break;
                        case 4:
                            message.k = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LRNLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    if (message.localSize != null && message.hasOwnProperty("localSize"))
                        if (!$util.isInteger(message.localSize) && !(message.localSize && $util.isInteger(message.localSize.low) && $util.isInteger(message.localSize.high)))
                            return "localSize: integer|Long expected";
                    if (message.k != null && message.hasOwnProperty("k"))
                        if (typeof message.k !== "number")
                            return "k: number expected";
                    return null;
                };
    
                LRNLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LRNLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.LRNLayerParams();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    if (object.localSize != null)
                        if ($util.Long)
                            (message.localSize = $util.Long.fromValue(object.localSize)).unsigned = true;
                        else if (typeof object.localSize === "string")
                            message.localSize = parseInt(object.localSize, 10);
                        else if (typeof object.localSize === "number")
                            message.localSize = object.localSize;
                        else if (typeof object.localSize === "object")
                            message.localSize = new $util.LongBits(object.localSize.low >>> 0, object.localSize.high >>> 0).toNumber(true);
                    if (object.k != null)
                        message.k = Number(object.k);
                    return message;
                };
    
                LRNLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.localSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.localSize = options.longs === String ? "0" : 0;
                        object.k = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    if (message.localSize != null && message.hasOwnProperty("localSize"))
                        if (typeof message.localSize === "number")
                            object.localSize = options.longs === String ? String(message.localSize) : message.localSize;
                        else
                            object.localSize = options.longs === String ? $util.Long.prototype.toString.call(message.localSize) : options.longs === Number ? new $util.LongBits(message.localSize.low >>> 0, message.localSize.high >>> 0).toNumber(true) : message.localSize;
                    if (message.k != null && message.hasOwnProperty("k"))
                        object.k = options.json && !isFinite(message.k) ? String(message.k) : message.k;
                    return object;
                };
    
                LRNLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LRNLayerParams;
            })();
    
            Specification.SoftmaxLayerParams = (function() {
    
                function SoftmaxLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SoftmaxLayerParams.create = function create(properties) {
                    return new SoftmaxLayerParams(properties);
                };
    
                SoftmaxLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SoftmaxLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SoftmaxLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                SoftmaxLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SoftmaxLayerParams)
                        return object;
                    return new $root.CoreML.Specification.SoftmaxLayerParams();
                };
    
                SoftmaxLayerParams.toObject = function toObject() {
                    return {};
                };
    
                SoftmaxLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SoftmaxLayerParams;
            })();
    
            Specification.SplitLayerParams = (function() {
    
                function SplitLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SplitLayerParams.prototype.nOutputs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                SplitLayerParams.create = function create(properties) {
                    return new SplitLayerParams(properties);
                };
    
                SplitLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SplitLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nOutputs = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SplitLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nOutputs != null && message.hasOwnProperty("nOutputs"))
                        if (!$util.isInteger(message.nOutputs) && !(message.nOutputs && $util.isInteger(message.nOutputs.low) && $util.isInteger(message.nOutputs.high)))
                            return "nOutputs: integer|Long expected";
                    return null;
                };
    
                SplitLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SplitLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SplitLayerParams();
                    if (object.nOutputs != null)
                        if ($util.Long)
                            (message.nOutputs = $util.Long.fromValue(object.nOutputs)).unsigned = true;
                        else if (typeof object.nOutputs === "string")
                            message.nOutputs = parseInt(object.nOutputs, 10);
                        else if (typeof object.nOutputs === "number")
                            message.nOutputs = object.nOutputs;
                        else if (typeof object.nOutputs === "object")
                            message.nOutputs = new $util.LongBits(object.nOutputs.low >>> 0, object.nOutputs.high >>> 0).toNumber(true);
                    return message;
                };
    
                SplitLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nOutputs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nOutputs = options.longs === String ? "0" : 0;
                    if (message.nOutputs != null && message.hasOwnProperty("nOutputs"))
                        if (typeof message.nOutputs === "number")
                            object.nOutputs = options.longs === String ? String(message.nOutputs) : message.nOutputs;
                        else
                            object.nOutputs = options.longs === String ? $util.Long.prototype.toString.call(message.nOutputs) : options.longs === Number ? new $util.LongBits(message.nOutputs.low >>> 0, message.nOutputs.high >>> 0).toNumber(true) : message.nOutputs;
                    return object;
                };
    
                SplitLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SplitLayerParams;
            })();
    
            Specification.AddLayerParams = (function() {
    
                function AddLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                AddLayerParams.prototype.alpha = 0;
    
                AddLayerParams.create = function create(properties) {
                    return new AddLayerParams(properties);
                };
    
                AddLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.AddLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                AddLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                AddLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.AddLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.AddLayerParams();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                AddLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                AddLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return AddLayerParams;
            })();
    
            Specification.MultiplyLayerParams = (function() {
    
                function MultiplyLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                MultiplyLayerParams.prototype.alpha = 0;
    
                MultiplyLayerParams.create = function create(properties) {
                    return new MultiplyLayerParams(properties);
                };
    
                MultiplyLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MultiplyLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                MultiplyLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                MultiplyLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MultiplyLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.MultiplyLayerParams();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                MultiplyLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                MultiplyLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MultiplyLayerParams;
            })();
    
            Specification.UnaryFunctionLayerParams = (function() {
    
                function UnaryFunctionLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                UnaryFunctionLayerParams.prototype.type = 0;
                UnaryFunctionLayerParams.prototype.alpha = 0;
                UnaryFunctionLayerParams.prototype.epsilon = 0;
                UnaryFunctionLayerParams.prototype.shift = 0;
                UnaryFunctionLayerParams.prototype.scale = 0;
    
                UnaryFunctionLayerParams.create = function create(properties) {
                    return new UnaryFunctionLayerParams(properties);
                };
    
                UnaryFunctionLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.UnaryFunctionLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.alpha = reader.float();
                            break;
                        case 3:
                            message.epsilon = reader.float();
                            break;
                        case 4:
                            message.shift = reader.float();
                            break;
                        case 5:
                            message.scale = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                UnaryFunctionLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    if (message.shift != null && message.hasOwnProperty("shift"))
                        if (typeof message.shift !== "number")
                            return "shift: number expected";
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        if (typeof message.scale !== "number")
                            return "scale: number expected";
                    return null;
                };
    
                UnaryFunctionLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.UnaryFunctionLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.UnaryFunctionLayerParams();
                    switch (object.type) {
                    case "SQRT":
                    case 0:
                        message.type = 0;
                        break;
                    case "RSQRT":
                    case 1:
                        message.type = 1;
                        break;
                    case "INVERSE":
                    case 2:
                        message.type = 2;
                        break;
                    case "POWER":
                    case 3:
                        message.type = 3;
                        break;
                    case "EXP":
                    case 4:
                        message.type = 4;
                        break;
                    case "LOG":
                    case 5:
                        message.type = 5;
                        break;
                    case "ABS":
                    case 6:
                        message.type = 6;
                        break;
                    case "THRESHOLD":
                    case 7:
                        message.type = 7;
                        break;
                    }
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    if (object.shift != null)
                        message.shift = Number(object.shift);
                    if (object.scale != null)
                        message.scale = Number(object.scale);
                    return message;
                };
    
                UnaryFunctionLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "SQRT" : 0;
                        object.alpha = 0;
                        object.epsilon = 0;
                        object.shift = 0;
                        object.scale = 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CoreML.Specification.UnaryFunctionLayerParams.Operation[message.type] : message.type;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    if (message.shift != null && message.hasOwnProperty("shift"))
                        object.shift = options.json && !isFinite(message.shift) ? String(message.shift) : message.shift;
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
                    return object;
                };
    
                UnaryFunctionLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UnaryFunctionLayerParams.Operation = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SQRT"] = 0;
                    values[valuesById[1] = "RSQRT"] = 1;
                    values[valuesById[2] = "INVERSE"] = 2;
                    values[valuesById[3] = "POWER"] = 3;
                    values[valuesById[4] = "EXP"] = 4;
                    values[valuesById[5] = "LOG"] = 5;
                    values[valuesById[6] = "ABS"] = 6;
                    values[valuesById[7] = "THRESHOLD"] = 7;
                    return values;
                })();
    
                return UnaryFunctionLayerParams;
            })();
    
            Specification.UpsampleLayerParams = (function() {
    
                function UpsampleLayerParams(properties) {
                    this.scalingFactor = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                UpsampleLayerParams.prototype.scalingFactor = $util.emptyArray;
                UpsampleLayerParams.prototype.mode = 0;
    
                UpsampleLayerParams.create = function create(properties) {
                    return new UpsampleLayerParams(properties);
                };
    
                UpsampleLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.UpsampleLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.scalingFactor && message.scalingFactor.length))
                                message.scalingFactor = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.scalingFactor.push(reader.uint64());
                            } else
                                message.scalingFactor.push(reader.uint64());
                            break;
                        case 5:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                UpsampleLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.scalingFactor != null && message.hasOwnProperty("scalingFactor")) {
                        if (!Array.isArray(message.scalingFactor))
                            return "scalingFactor: array expected";
                        for (var i = 0; i < message.scalingFactor.length; ++i)
                            if (!$util.isInteger(message.scalingFactor[i]) && !(message.scalingFactor[i] && $util.isInteger(message.scalingFactor[i].low) && $util.isInteger(message.scalingFactor[i].high)))
                                return "scalingFactor: integer|Long[] expected";
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                UpsampleLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.UpsampleLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.UpsampleLayerParams();
                    if (object.scalingFactor) {
                        if (!Array.isArray(object.scalingFactor))
                            throw TypeError(".CoreML.Specification.UpsampleLayerParams.scalingFactor: array expected");
                        message.scalingFactor = [];
                        for (var i = 0; i < object.scalingFactor.length; ++i)
                            if ($util.Long)
                                (message.scalingFactor[i] = $util.Long.fromValue(object.scalingFactor[i])).unsigned = true;
                            else if (typeof object.scalingFactor[i] === "string")
                                message.scalingFactor[i] = parseInt(object.scalingFactor[i], 10);
                            else if (typeof object.scalingFactor[i] === "number")
                                message.scalingFactor[i] = object.scalingFactor[i];
                            else if (typeof object.scalingFactor[i] === "object")
                                message.scalingFactor[i] = new $util.LongBits(object.scalingFactor[i].low >>> 0, object.scalingFactor[i].high >>> 0).toNumber(true);
                    }
                    switch (object.mode) {
                    case "NN":
                    case 0:
                        message.mode = 0;
                        break;
                    case "BILINEAR":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    return message;
                };
    
                UpsampleLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.scalingFactor = [];
                    if (options.defaults)
                        object.mode = options.enums === String ? "NN" : 0;
                    if (message.scalingFactor && message.scalingFactor.length) {
                        object.scalingFactor = [];
                        for (var j = 0; j < message.scalingFactor.length; ++j)
                            if (typeof message.scalingFactor[j] === "number")
                                object.scalingFactor[j] = options.longs === String ? String(message.scalingFactor[j]) : message.scalingFactor[j];
                            else
                                object.scalingFactor[j] = options.longs === String ? $util.Long.prototype.toString.call(message.scalingFactor[j]) : options.longs === Number ? new $util.LongBits(message.scalingFactor[j].low >>> 0, message.scalingFactor[j].high >>> 0).toNumber(true) : message.scalingFactor[j];
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.UpsampleLayerParams.InterpolationMode[message.mode] : message.mode;
                    return object;
                };
    
                UpsampleLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                UpsampleLayerParams.InterpolationMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NN"] = 0;
                    values[valuesById[1] = "BILINEAR"] = 1;
                    return values;
                })();
    
                return UpsampleLayerParams;
            })();
    
            Specification.ResizeBilinearLayerParams = (function() {
    
                function ResizeBilinearLayerParams(properties) {
                    this.targetSize = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ResizeBilinearLayerParams.prototype.targetSize = $util.emptyArray;
                ResizeBilinearLayerParams.prototype.mode = null;
    
                ResizeBilinearLayerParams.create = function create(properties) {
                    return new ResizeBilinearLayerParams(properties);
                };
    
                ResizeBilinearLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ResizeBilinearLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.targetSize && message.targetSize.length))
                                message.targetSize = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetSize.push(reader.uint64());
                            } else
                                message.targetSize.push(reader.uint64());
                            break;
                        case 2:
                            message.mode = $root.CoreML.Specification.SamplingMode.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ResizeBilinearLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetSize != null && message.hasOwnProperty("targetSize")) {
                        if (!Array.isArray(message.targetSize))
                            return "targetSize: array expected";
                        for (var i = 0; i < message.targetSize.length; ++i)
                            if (!$util.isInteger(message.targetSize[i]) && !(message.targetSize[i] && $util.isInteger(message.targetSize[i].low) && $util.isInteger(message.targetSize[i].high)))
                                return "targetSize: integer|Long[] expected";
                    }
                    if (message.mode != null && message.hasOwnProperty("mode")) {
                        var error = $root.CoreML.Specification.SamplingMode.verify(message.mode);
                        if (error)
                            return "mode." + error;
                    }
                    return null;
                };
    
                ResizeBilinearLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ResizeBilinearLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ResizeBilinearLayerParams();
                    if (object.targetSize) {
                        if (!Array.isArray(object.targetSize))
                            throw TypeError(".CoreML.Specification.ResizeBilinearLayerParams.targetSize: array expected");
                        message.targetSize = [];
                        for (var i = 0; i < object.targetSize.length; ++i)
                            if ($util.Long)
                                (message.targetSize[i] = $util.Long.fromValue(object.targetSize[i])).unsigned = true;
                            else if (typeof object.targetSize[i] === "string")
                                message.targetSize[i] = parseInt(object.targetSize[i], 10);
                            else if (typeof object.targetSize[i] === "number")
                                message.targetSize[i] = object.targetSize[i];
                            else if (typeof object.targetSize[i] === "object")
                                message.targetSize[i] = new $util.LongBits(object.targetSize[i].low >>> 0, object.targetSize[i].high >>> 0).toNumber(true);
                    }
                    if (object.mode != null) {
                        if (typeof object.mode !== "object")
                            throw TypeError(".CoreML.Specification.ResizeBilinearLayerParams.mode: object expected");
                        message.mode = $root.CoreML.Specification.SamplingMode.fromObject(object.mode);
                    }
                    return message;
                };
    
                ResizeBilinearLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.targetSize = [];
                    if (options.defaults)
                        object.mode = null;
                    if (message.targetSize && message.targetSize.length) {
                        object.targetSize = [];
                        for (var j = 0; j < message.targetSize.length; ++j)
                            if (typeof message.targetSize[j] === "number")
                                object.targetSize[j] = options.longs === String ? String(message.targetSize[j]) : message.targetSize[j];
                            else
                                object.targetSize[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetSize[j]) : options.longs === Number ? new $util.LongBits(message.targetSize[j].low >>> 0, message.targetSize[j].high >>> 0).toNumber(true) : message.targetSize[j];
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = $root.CoreML.Specification.SamplingMode.toObject(message.mode, options);
                    return object;
                };
    
                ResizeBilinearLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ResizeBilinearLayerParams;
            })();
    
            Specification.CropResizeLayerParams = (function() {
    
                function CropResizeLayerParams(properties) {
                    this.targetSize = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                CropResizeLayerParams.prototype.targetSize = $util.emptyArray;
                CropResizeLayerParams.prototype.normalizedCoordinates = false;
                CropResizeLayerParams.prototype.mode = null;
                CropResizeLayerParams.prototype.boxIndicesMode = null;
                CropResizeLayerParams.prototype.spatialScale = 0;
    
                CropResizeLayerParams.create = function create(properties) {
                    return new CropResizeLayerParams(properties);
                };
    
                CropResizeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CropResizeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.targetSize && message.targetSize.length))
                                message.targetSize = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetSize.push(reader.uint64());
                            } else
                                message.targetSize.push(reader.uint64());
                            break;
                        case 2:
                            message.normalizedCoordinates = reader.bool();
                            break;
                        case 3:
                            message.mode = $root.CoreML.Specification.SamplingMode.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.boxIndicesMode = $root.CoreML.Specification.BoxCoordinatesMode.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.spatialScale = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                CropResizeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetSize != null && message.hasOwnProperty("targetSize")) {
                        if (!Array.isArray(message.targetSize))
                            return "targetSize: array expected";
                        for (var i = 0; i < message.targetSize.length; ++i)
                            if (!$util.isInteger(message.targetSize[i]) && !(message.targetSize[i] && $util.isInteger(message.targetSize[i].low) && $util.isInteger(message.targetSize[i].high)))
                                return "targetSize: integer|Long[] expected";
                    }
                    if (message.normalizedCoordinates != null && message.hasOwnProperty("normalizedCoordinates"))
                        if (typeof message.normalizedCoordinates !== "boolean")
                            return "normalizedCoordinates: boolean expected";
                    if (message.mode != null && message.hasOwnProperty("mode")) {
                        var error = $root.CoreML.Specification.SamplingMode.verify(message.mode);
                        if (error)
                            return "mode." + error;
                    }
                    if (message.boxIndicesMode != null && message.hasOwnProperty("boxIndicesMode")) {
                        var error = $root.CoreML.Specification.BoxCoordinatesMode.verify(message.boxIndicesMode);
                        if (error)
                            return "boxIndicesMode." + error;
                    }
                    if (message.spatialScale != null && message.hasOwnProperty("spatialScale"))
                        if (typeof message.spatialScale !== "number")
                            return "spatialScale: number expected";
                    return null;
                };
    
                CropResizeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CropResizeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.CropResizeLayerParams();
                    if (object.targetSize) {
                        if (!Array.isArray(object.targetSize))
                            throw TypeError(".CoreML.Specification.CropResizeLayerParams.targetSize: array expected");
                        message.targetSize = [];
                        for (var i = 0; i < object.targetSize.length; ++i)
                            if ($util.Long)
                                (message.targetSize[i] = $util.Long.fromValue(object.targetSize[i])).unsigned = true;
                            else if (typeof object.targetSize[i] === "string")
                                message.targetSize[i] = parseInt(object.targetSize[i], 10);
                            else if (typeof object.targetSize[i] === "number")
                                message.targetSize[i] = object.targetSize[i];
                            else if (typeof object.targetSize[i] === "object")
                                message.targetSize[i] = new $util.LongBits(object.targetSize[i].low >>> 0, object.targetSize[i].high >>> 0).toNumber(true);
                    }
                    if (object.normalizedCoordinates != null)
                        message.normalizedCoordinates = Boolean(object.normalizedCoordinates);
                    if (object.mode != null) {
                        if (typeof object.mode !== "object")
                            throw TypeError(".CoreML.Specification.CropResizeLayerParams.mode: object expected");
                        message.mode = $root.CoreML.Specification.SamplingMode.fromObject(object.mode);
                    }
                    if (object.boxIndicesMode != null) {
                        if (typeof object.boxIndicesMode !== "object")
                            throw TypeError(".CoreML.Specification.CropResizeLayerParams.boxIndicesMode: object expected");
                        message.boxIndicesMode = $root.CoreML.Specification.BoxCoordinatesMode.fromObject(object.boxIndicesMode);
                    }
                    if (object.spatialScale != null)
                        message.spatialScale = Number(object.spatialScale);
                    return message;
                };
    
                CropResizeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.targetSize = [];
                    if (options.defaults) {
                        object.normalizedCoordinates = false;
                        object.mode = null;
                        object.boxIndicesMode = null;
                        object.spatialScale = 0;
                    }
                    if (message.targetSize && message.targetSize.length) {
                        object.targetSize = [];
                        for (var j = 0; j < message.targetSize.length; ++j)
                            if (typeof message.targetSize[j] === "number")
                                object.targetSize[j] = options.longs === String ? String(message.targetSize[j]) : message.targetSize[j];
                            else
                                object.targetSize[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetSize[j]) : options.longs === Number ? new $util.LongBits(message.targetSize[j].low >>> 0, message.targetSize[j].high >>> 0).toNumber(true) : message.targetSize[j];
                    }
                    if (message.normalizedCoordinates != null && message.hasOwnProperty("normalizedCoordinates"))
                        object.normalizedCoordinates = message.normalizedCoordinates;
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = $root.CoreML.Specification.SamplingMode.toObject(message.mode, options);
                    if (message.boxIndicesMode != null && message.hasOwnProperty("boxIndicesMode"))
                        object.boxIndicesMode = $root.CoreML.Specification.BoxCoordinatesMode.toObject(message.boxIndicesMode, options);
                    if (message.spatialScale != null && message.hasOwnProperty("spatialScale"))
                        object.spatialScale = options.json && !isFinite(message.spatialScale) ? String(message.spatialScale) : message.spatialScale;
                    return object;
                };
    
                CropResizeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CropResizeLayerParams;
            })();
    
            Specification.BiasLayerParams = (function() {
    
                function BiasLayerParams(properties) {
                    this.shape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                BiasLayerParams.prototype.shape = $util.emptyArray;
                BiasLayerParams.prototype.bias = null;
    
                BiasLayerParams.create = function create(properties) {
                    return new BiasLayerParams(properties);
                };
    
                BiasLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BiasLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shape && message.shape.length))
                                message.shape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shape.push(reader.uint64());
                            } else
                                message.shape.push(reader.uint64());
                            break;
                        case 2:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                BiasLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        if (!Array.isArray(message.shape))
                            return "shape: array expected";
                        for (var i = 0; i < message.shape.length; ++i)
                            if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                return "shape: integer|Long[] expected";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                BiasLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BiasLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.BiasLayerParams();
                    if (object.shape) {
                        if (!Array.isArray(object.shape))
                            throw TypeError(".CoreML.Specification.BiasLayerParams.shape: array expected");
                        message.shape = [];
                        for (var i = 0; i < object.shape.length; ++i)
                            if ($util.Long)
                                (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = true;
                            else if (typeof object.shape[i] === "string")
                                message.shape[i] = parseInt(object.shape[i], 10);
                            else if (typeof object.shape[i] === "number")
                                message.shape[i] = object.shape[i];
                            else if (typeof object.shape[i] === "object")
                                message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber(true);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.BiasLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                BiasLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.shape = [];
                    if (options.defaults)
                        object.bias = null;
                    if (message.shape && message.shape.length) {
                        object.shape = [];
                        for (var j = 0; j < message.shape.length; ++j)
                            if (typeof message.shape[j] === "number")
                                object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                            else
                                object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber(true) : message.shape[j];
                    }
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                BiasLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BiasLayerParams;
            })();
    
            Specification.ScaleLayerParams = (function() {
    
                function ScaleLayerParams(properties) {
                    this.shapeScale = [];
                    this.shapeBias = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ScaleLayerParams.prototype.shapeScale = $util.emptyArray;
                ScaleLayerParams.prototype.scale = null;
                ScaleLayerParams.prototype.hasBias = false;
                ScaleLayerParams.prototype.shapeBias = $util.emptyArray;
                ScaleLayerParams.prototype.bias = null;
    
                ScaleLayerParams.create = function create(properties) {
                    return new ScaleLayerParams(properties);
                };
    
                ScaleLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ScaleLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shapeScale && message.shapeScale.length))
                                message.shapeScale = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shapeScale.push(reader.uint64());
                            } else
                                message.shapeScale.push(reader.uint64());
                            break;
                        case 2:
                            message.scale = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.hasBias = reader.bool();
                            break;
                        case 4:
                            if (!(message.shapeBias && message.shapeBias.length))
                                message.shapeBias = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shapeBias.push(reader.uint64());
                            } else
                                message.shapeBias.push(reader.uint64());
                            break;
                        case 5:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ScaleLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shapeScale != null && message.hasOwnProperty("shapeScale")) {
                        if (!Array.isArray(message.shapeScale))
                            return "shapeScale: array expected";
                        for (var i = 0; i < message.shapeScale.length; ++i)
                            if (!$util.isInteger(message.shapeScale[i]) && !(message.shapeScale[i] && $util.isInteger(message.shapeScale[i].low) && $util.isInteger(message.shapeScale[i].high)))
                                return "shapeScale: integer|Long[] expected";
                    }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.scale);
                        if (error)
                            return "scale." + error;
                    }
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.shapeBias != null && message.hasOwnProperty("shapeBias")) {
                        if (!Array.isArray(message.shapeBias))
                            return "shapeBias: array expected";
                        for (var i = 0; i < message.shapeBias.length; ++i)
                            if (!$util.isInteger(message.shapeBias[i]) && !(message.shapeBias[i] && $util.isInteger(message.shapeBias[i].low) && $util.isInteger(message.shapeBias[i].high)))
                                return "shapeBias: integer|Long[] expected";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                ScaleLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ScaleLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ScaleLayerParams();
                    if (object.shapeScale) {
                        if (!Array.isArray(object.shapeScale))
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.shapeScale: array expected");
                        message.shapeScale = [];
                        for (var i = 0; i < object.shapeScale.length; ++i)
                            if ($util.Long)
                                (message.shapeScale[i] = $util.Long.fromValue(object.shapeScale[i])).unsigned = true;
                            else if (typeof object.shapeScale[i] === "string")
                                message.shapeScale[i] = parseInt(object.shapeScale[i], 10);
                            else if (typeof object.shapeScale[i] === "number")
                                message.shapeScale[i] = object.shapeScale[i];
                            else if (typeof object.shapeScale[i] === "object")
                                message.shapeScale[i] = new $util.LongBits(object.shapeScale[i].low >>> 0, object.shapeScale[i].high >>> 0).toNumber(true);
                    }
                    if (object.scale != null) {
                        if (typeof object.scale !== "object")
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.scale: object expected");
                        message.scale = $root.CoreML.Specification.WeightParams.fromObject(object.scale);
                    }
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.shapeBias) {
                        if (!Array.isArray(object.shapeBias))
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.shapeBias: array expected");
                        message.shapeBias = [];
                        for (var i = 0; i < object.shapeBias.length; ++i)
                            if ($util.Long)
                                (message.shapeBias[i] = $util.Long.fromValue(object.shapeBias[i])).unsigned = true;
                            else if (typeof object.shapeBias[i] === "string")
                                message.shapeBias[i] = parseInt(object.shapeBias[i], 10);
                            else if (typeof object.shapeBias[i] === "number")
                                message.shapeBias[i] = object.shapeBias[i];
                            else if (typeof object.shapeBias[i] === "object")
                                message.shapeBias[i] = new $util.LongBits(object.shapeBias[i].low >>> 0, object.shapeBias[i].high >>> 0).toNumber(true);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                ScaleLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.shapeScale = [];
                        object.shapeBias = [];
                    }
                    if (options.defaults) {
                        object.scale = null;
                        object.hasBias = false;
                        object.bias = null;
                    }
                    if (message.shapeScale && message.shapeScale.length) {
                        object.shapeScale = [];
                        for (var j = 0; j < message.shapeScale.length; ++j)
                            if (typeof message.shapeScale[j] === "number")
                                object.shapeScale[j] = options.longs === String ? String(message.shapeScale[j]) : message.shapeScale[j];
                            else
                                object.shapeScale[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shapeScale[j]) : options.longs === Number ? new $util.LongBits(message.shapeScale[j].low >>> 0, message.shapeScale[j].high >>> 0).toNumber(true) : message.shapeScale[j];
                    }
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        object.scale = $root.CoreML.Specification.WeightParams.toObject(message.scale, options);
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.shapeBias && message.shapeBias.length) {
                        object.shapeBias = [];
                        for (var j = 0; j < message.shapeBias.length; ++j)
                            if (typeof message.shapeBias[j] === "number")
                                object.shapeBias[j] = options.longs === String ? String(message.shapeBias[j]) : message.shapeBias[j];
                            else
                                object.shapeBias[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shapeBias[j]) : options.longs === Number ? new $util.LongBits(message.shapeBias[j].low >>> 0, message.shapeBias[j].high >>> 0).toNumber(true) : message.shapeBias[j];
                    }
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                ScaleLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ScaleLayerParams;
            })();
    
            Specification.LoadConstantLayerParams = (function() {
    
                function LoadConstantLayerParams(properties) {
                    this.shape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LoadConstantLayerParams.prototype.shape = $util.emptyArray;
                LoadConstantLayerParams.prototype.data = null;
    
                LoadConstantLayerParams.create = function create(properties) {
                    return new LoadConstantLayerParams(properties);
                };
    
                LoadConstantLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LoadConstantLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shape && message.shape.length))
                                message.shape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shape.push(reader.uint64());
                            } else
                                message.shape.push(reader.uint64());
                            break;
                        case 2:
                            message.data = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LoadConstantLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        if (!Array.isArray(message.shape))
                            return "shape: array expected";
                        for (var i = 0; i < message.shape.length; ++i)
                            if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                return "shape: integer|Long[] expected";
                    }
                    if (message.data != null && message.hasOwnProperty("data")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.data);
                        if (error)
                            return "data." + error;
                    }
                    return null;
                };
    
                LoadConstantLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LoadConstantLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.LoadConstantLayerParams();
                    if (object.shape) {
                        if (!Array.isArray(object.shape))
                            throw TypeError(".CoreML.Specification.LoadConstantLayerParams.shape: array expected");
                        message.shape = [];
                        for (var i = 0; i < object.shape.length; ++i)
                            if ($util.Long)
                                (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = true;
                            else if (typeof object.shape[i] === "string")
                                message.shape[i] = parseInt(object.shape[i], 10);
                            else if (typeof object.shape[i] === "number")
                                message.shape[i] = object.shape[i];
                            else if (typeof object.shape[i] === "object")
                                message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber(true);
                    }
                    if (object.data != null) {
                        if (typeof object.data !== "object")
                            throw TypeError(".CoreML.Specification.LoadConstantLayerParams.data: object expected");
                        message.data = $root.CoreML.Specification.WeightParams.fromObject(object.data);
                    }
                    return message;
                };
    
                LoadConstantLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.shape = [];
                    if (options.defaults)
                        object.data = null;
                    if (message.shape && message.shape.length) {
                        object.shape = [];
                        for (var j = 0; j < message.shape.length; ++j)
                            if (typeof message.shape[j] === "number")
                                object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                            else
                                object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber(true) : message.shape[j];
                    }
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = $root.CoreML.Specification.WeightParams.toObject(message.data, options);
                    return object;
                };
    
                LoadConstantLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LoadConstantLayerParams;
            })();
    
            Specification.L2NormalizeLayerParams = (function() {
    
                function L2NormalizeLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                L2NormalizeLayerParams.prototype.epsilon = 0;
    
                L2NormalizeLayerParams.create = function create(properties) {
                    return new L2NormalizeLayerParams(properties);
                };
    
                L2NormalizeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.L2NormalizeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.epsilon = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                L2NormalizeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    return null;
                };
    
                L2NormalizeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.L2NormalizeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.L2NormalizeLayerParams();
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    return message;
                };
    
                L2NormalizeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.epsilon = 0;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    return object;
                };
    
                L2NormalizeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return L2NormalizeLayerParams;
            })();
    
            Specification.FlattenLayerParams = (function() {
    
                function FlattenLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                FlattenLayerParams.prototype.mode = 0;
    
                FlattenLayerParams.create = function create(properties) {
                    return new FlattenLayerParams(properties);
                };
    
                FlattenLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FlattenLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                FlattenLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                FlattenLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FlattenLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.FlattenLayerParams();
                    switch (object.mode) {
                    case "CHANNEL_FIRST":
                    case 0:
                        message.mode = 0;
                        break;
                    case "CHANNEL_LAST":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    return message;
                };
    
                FlattenLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.mode = options.enums === String ? "CHANNEL_FIRST" : 0;
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.FlattenLayerParams.FlattenOrder[message.mode] : message.mode;
                    return object;
                };
    
                FlattenLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                FlattenLayerParams.FlattenOrder = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHANNEL_FIRST"] = 0;
                    values[valuesById[1] = "CHANNEL_LAST"] = 1;
                    return values;
                })();
    
                return FlattenLayerParams;
            })();
    
            Specification.ReshapeLayerParams = (function() {
    
                function ReshapeLayerParams(properties) {
                    this.targetShape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ReshapeLayerParams.prototype.targetShape = $util.emptyArray;
                ReshapeLayerParams.prototype.mode = 0;
    
                ReshapeLayerParams.create = function create(properties) {
                    return new ReshapeLayerParams(properties);
                };
    
                ReshapeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ReshapeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.targetShape && message.targetShape.length))
                                message.targetShape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetShape.push(reader.int64());
                            } else
                                message.targetShape.push(reader.int64());
                            break;
                        case 2:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ReshapeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetShape != null && message.hasOwnProperty("targetShape")) {
                        if (!Array.isArray(message.targetShape))
                            return "targetShape: array expected";
                        for (var i = 0; i < message.targetShape.length; ++i)
                            if (!$util.isInteger(message.targetShape[i]) && !(message.targetShape[i] && $util.isInteger(message.targetShape[i].low) && $util.isInteger(message.targetShape[i].high)))
                                return "targetShape: integer|Long[] expected";
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                ReshapeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ReshapeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ReshapeLayerParams();
                    if (object.targetShape) {
                        if (!Array.isArray(object.targetShape))
                            throw TypeError(".CoreML.Specification.ReshapeLayerParams.targetShape: array expected");
                        message.targetShape = [];
                        for (var i = 0; i < object.targetShape.length; ++i)
                            if ($util.Long)
                                (message.targetShape[i] = $util.Long.fromValue(object.targetShape[i])).unsigned = false;
                            else if (typeof object.targetShape[i] === "string")
                                message.targetShape[i] = parseInt(object.targetShape[i], 10);
                            else if (typeof object.targetShape[i] === "number")
                                message.targetShape[i] = object.targetShape[i];
                            else if (typeof object.targetShape[i] === "object")
                                message.targetShape[i] = new $util.LongBits(object.targetShape[i].low >>> 0, object.targetShape[i].high >>> 0).toNumber();
                    }
                    switch (object.mode) {
                    case "CHANNEL_FIRST":
                    case 0:
                        message.mode = 0;
                        break;
                    case "CHANNEL_LAST":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    return message;
                };
    
                ReshapeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.targetShape = [];
                    if (options.defaults)
                        object.mode = options.enums === String ? "CHANNEL_FIRST" : 0;
                    if (message.targetShape && message.targetShape.length) {
                        object.targetShape = [];
                        for (var j = 0; j < message.targetShape.length; ++j)
                            if (typeof message.targetShape[j] === "number")
                                object.targetShape[j] = options.longs === String ? String(message.targetShape[j]) : message.targetShape[j];
                            else
                                object.targetShape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetShape[j]) : options.longs === Number ? new $util.LongBits(message.targetShape[j].low >>> 0, message.targetShape[j].high >>> 0).toNumber() : message.targetShape[j];
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.ReshapeLayerParams.ReshapeOrder[message.mode] : message.mode;
                    return object;
                };
    
                ReshapeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                ReshapeLayerParams.ReshapeOrder = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHANNEL_FIRST"] = 0;
                    values[valuesById[1] = "CHANNEL_LAST"] = 1;
                    return values;
                })();
    
                return ReshapeLayerParams;
            })();
    
            Specification.PermuteLayerParams = (function() {
    
                function PermuteLayerParams(properties) {
                    this.axis = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                PermuteLayerParams.prototype.axis = $util.emptyArray;
    
                PermuteLayerParams.create = function create(properties) {
                    return new PermuteLayerParams(properties);
                };
    
                PermuteLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PermuteLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.axis && message.axis.length))
                                message.axis = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.axis.push(reader.uint64());
                            } else
                                message.axis.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                PermuteLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.axis != null && message.hasOwnProperty("axis")) {
                        if (!Array.isArray(message.axis))
                            return "axis: array expected";
                        for (var i = 0; i < message.axis.length; ++i)
                            if (!$util.isInteger(message.axis[i]) && !(message.axis[i] && $util.isInteger(message.axis[i].low) && $util.isInteger(message.axis[i].high)))
                                return "axis: integer|Long[] expected";
                    }
                    return null;
                };
    
                PermuteLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PermuteLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.PermuteLayerParams();
                    if (object.axis) {
                        if (!Array.isArray(object.axis))
                            throw TypeError(".CoreML.Specification.PermuteLayerParams.axis: array expected");
                        message.axis = [];
                        for (var i = 0; i < object.axis.length; ++i)
                            if ($util.Long)
                                (message.axis[i] = $util.Long.fromValue(object.axis[i])).unsigned = true;
                            else if (typeof object.axis[i] === "string")
                                message.axis[i] = parseInt(object.axis[i], 10);
                            else if (typeof object.axis[i] === "number")
                                message.axis[i] = object.axis[i];
                            else if (typeof object.axis[i] === "object")
                                message.axis[i] = new $util.LongBits(object.axis[i].low >>> 0, object.axis[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                PermuteLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.axis = [];
                    if (message.axis && message.axis.length) {
                        object.axis = [];
                        for (var j = 0; j < message.axis.length; ++j)
                            if (typeof message.axis[j] === "number")
                                object.axis[j] = options.longs === String ? String(message.axis[j]) : message.axis[j];
                            else
                                object.axis[j] = options.longs === String ? $util.Long.prototype.toString.call(message.axis[j]) : options.longs === Number ? new $util.LongBits(message.axis[j].low >>> 0, message.axis[j].high >>> 0).toNumber(true) : message.axis[j];
                    }
                    return object;
                };
    
                PermuteLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PermuteLayerParams;
            })();
    
            Specification.ReorganizeDataLayerParams = (function() {
    
                function ReorganizeDataLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ReorganizeDataLayerParams.prototype.mode = 0;
                ReorganizeDataLayerParams.prototype.blockSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                ReorganizeDataLayerParams.create = function create(properties) {
                    return new ReorganizeDataLayerParams(properties);
                };
    
                ReorganizeDataLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ReorganizeDataLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        case 2:
                            message.blockSize = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ReorganizeDataLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                        if (!$util.isInteger(message.blockSize) && !(message.blockSize && $util.isInteger(message.blockSize.low) && $util.isInteger(message.blockSize.high)))
                            return "blockSize: integer|Long expected";
                    return null;
                };
    
                ReorganizeDataLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ReorganizeDataLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ReorganizeDataLayerParams();
                    switch (object.mode) {
                    case "SPACE_TO_DEPTH":
                    case 0:
                        message.mode = 0;
                        break;
                    case "DEPTH_TO_SPACE":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    if (object.blockSize != null)
                        if ($util.Long)
                            (message.blockSize = $util.Long.fromValue(object.blockSize)).unsigned = true;
                        else if (typeof object.blockSize === "string")
                            message.blockSize = parseInt(object.blockSize, 10);
                        else if (typeof object.blockSize === "number")
                            message.blockSize = object.blockSize;
                        else if (typeof object.blockSize === "object")
                            message.blockSize = new $util.LongBits(object.blockSize.low >>> 0, object.blockSize.high >>> 0).toNumber(true);
                    return message;
                };
    
                ReorganizeDataLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mode = options.enums === String ? "SPACE_TO_DEPTH" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.blockSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockSize = options.longs === String ? "0" : 0;
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType[message.mode] : message.mode;
                    if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                        if (typeof message.blockSize === "number")
                            object.blockSize = options.longs === String ? String(message.blockSize) : message.blockSize;
                        else
                            object.blockSize = options.longs === String ? $util.Long.prototype.toString.call(message.blockSize) : options.longs === Number ? new $util.LongBits(message.blockSize.low >>> 0, message.blockSize.high >>> 0).toNumber(true) : message.blockSize;
                    return object;
                };
    
                ReorganizeDataLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                ReorganizeDataLayerParams.ReorganizationType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SPACE_TO_DEPTH"] = 0;
                    values[valuesById[1] = "DEPTH_TO_SPACE"] = 1;
                    return values;
                })();
    
                return ReorganizeDataLayerParams;
            })();
    
            Specification.SliceLayerParams = (function() {
    
                function SliceLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SliceLayerParams.prototype.startIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                SliceLayerParams.prototype.endIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                SliceLayerParams.prototype.stride = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                SliceLayerParams.prototype.axis = 0;
    
                SliceLayerParams.create = function create(properties) {
                    return new SliceLayerParams(properties);
                };
    
                SliceLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SliceLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.startIndex = reader.int64();
                            break;
                        case 2:
                            message.endIndex = reader.int64();
                            break;
                        case 3:
                            message.stride = reader.uint64();
                            break;
                        case 4:
                            message.axis = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SliceLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        if (!$util.isInteger(message.startIndex) && !(message.startIndex && $util.isInteger(message.startIndex.low) && $util.isInteger(message.startIndex.high)))
                            return "startIndex: integer|Long expected";
                    if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                        if (!$util.isInteger(message.endIndex) && !(message.endIndex && $util.isInteger(message.endIndex.low) && $util.isInteger(message.endIndex.high)))
                            return "endIndex: integer|Long expected";
                    if (message.stride != null && message.hasOwnProperty("stride"))
                        if (!$util.isInteger(message.stride) && !(message.stride && $util.isInteger(message.stride.low) && $util.isInteger(message.stride.high)))
                            return "stride: integer|Long expected";
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        switch (message.axis) {
                        default:
                            return "axis: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                SliceLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SliceLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SliceLayerParams();
                    if (object.startIndex != null)
                        if ($util.Long)
                            (message.startIndex = $util.Long.fromValue(object.startIndex)).unsigned = false;
                        else if (typeof object.startIndex === "string")
                            message.startIndex = parseInt(object.startIndex, 10);
                        else if (typeof object.startIndex === "number")
                            message.startIndex = object.startIndex;
                        else if (typeof object.startIndex === "object")
                            message.startIndex = new $util.LongBits(object.startIndex.low >>> 0, object.startIndex.high >>> 0).toNumber();
                    if (object.endIndex != null)
                        if ($util.Long)
                            (message.endIndex = $util.Long.fromValue(object.endIndex)).unsigned = false;
                        else if (typeof object.endIndex === "string")
                            message.endIndex = parseInt(object.endIndex, 10);
                        else if (typeof object.endIndex === "number")
                            message.endIndex = object.endIndex;
                        else if (typeof object.endIndex === "object")
                            message.endIndex = new $util.LongBits(object.endIndex.low >>> 0, object.endIndex.high >>> 0).toNumber();
                    if (object.stride != null)
                        if ($util.Long)
                            (message.stride = $util.Long.fromValue(object.stride)).unsigned = true;
                        else if (typeof object.stride === "string")
                            message.stride = parseInt(object.stride, 10);
                        else if (typeof object.stride === "number")
                            message.stride = object.stride;
                        else if (typeof object.stride === "object")
                            message.stride = new $util.LongBits(object.stride.low >>> 0, object.stride.high >>> 0).toNumber(true);
                    switch (object.axis) {
                    case "CHANNEL_AXIS":
                    case 0:
                        message.axis = 0;
                        break;
                    case "HEIGHT_AXIS":
                    case 1:
                        message.axis = 1;
                        break;
                    case "WIDTH_AXIS":
                    case 2:
                        message.axis = 2;
                        break;
                    }
                    return message;
                };
    
                SliceLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.startIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.startIndex = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.endIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.endIndex = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.stride = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.stride = options.longs === String ? "0" : 0;
                        object.axis = options.enums === String ? "CHANNEL_AXIS" : 0;
                    }
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        if (typeof message.startIndex === "number")
                            object.startIndex = options.longs === String ? String(message.startIndex) : message.startIndex;
                        else
                            object.startIndex = options.longs === String ? $util.Long.prototype.toString.call(message.startIndex) : options.longs === Number ? new $util.LongBits(message.startIndex.low >>> 0, message.startIndex.high >>> 0).toNumber() : message.startIndex;
                    if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                        if (typeof message.endIndex === "number")
                            object.endIndex = options.longs === String ? String(message.endIndex) : message.endIndex;
                        else
                            object.endIndex = options.longs === String ? $util.Long.prototype.toString.call(message.endIndex) : options.longs === Number ? new $util.LongBits(message.endIndex.low >>> 0, message.endIndex.high >>> 0).toNumber() : message.endIndex;
                    if (message.stride != null && message.hasOwnProperty("stride"))
                        if (typeof message.stride === "number")
                            object.stride = options.longs === String ? String(message.stride) : message.stride;
                        else
                            object.stride = options.longs === String ? $util.Long.prototype.toString.call(message.stride) : options.longs === Number ? new $util.LongBits(message.stride.low >>> 0, message.stride.high >>> 0).toNumber(true) : message.stride;
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        object.axis = options.enums === String ? $root.CoreML.Specification.SliceLayerParams.SliceAxis[message.axis] : message.axis;
                    return object;
                };
    
                SliceLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                SliceLayerParams.SliceAxis = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHANNEL_AXIS"] = 0;
                    values[valuesById[1] = "HEIGHT_AXIS"] = 1;
                    values[valuesById[2] = "WIDTH_AXIS"] = 2;
                    return values;
                })();
    
                return SliceLayerParams;
            })();
    
            Specification.ReduceLayerParams = (function() {
    
                function ReduceLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                ReduceLayerParams.prototype.mode = 0;
                ReduceLayerParams.prototype.epsilon = 0;
                ReduceLayerParams.prototype.axis = 0;
    
                ReduceLayerParams.create = function create(properties) {
                    return new ReduceLayerParams(properties);
                };
    
                ReduceLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ReduceLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        case 2:
                            message.epsilon = reader.float();
                            break;
                        case 3:
                            message.axis = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                ReduceLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        switch (message.axis) {
                        default:
                            return "axis: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };
    
                ReduceLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ReduceLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ReduceLayerParams();
                    switch (object.mode) {
                    case "SUM":
                    case 0:
                        message.mode = 0;
                        break;
                    case "AVG":
                    case 1:
                        message.mode = 1;
                        break;
                    case "PROD":
                    case 2:
                        message.mode = 2;
                        break;
                    case "LOGSUM":
                    case 3:
                        message.mode = 3;
                        break;
                    case "SUMSQUARE":
                    case 4:
                        message.mode = 4;
                        break;
                    case "L1":
                    case 5:
                        message.mode = 5;
                        break;
                    case "L2":
                    case 6:
                        message.mode = 6;
                        break;
                    case "MAX":
                    case 7:
                        message.mode = 7;
                        break;
                    case "MIN":
                    case 8:
                        message.mode = 8;
                        break;
                    case "ARGMAX":
                    case 9:
                        message.mode = 9;
                        break;
                    }
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    switch (object.axis) {
                    case "CHW":
                    case 0:
                        message.axis = 0;
                        break;
                    case "HW":
                    case 1:
                        message.axis = 1;
                        break;
                    case "C":
                    case 2:
                        message.axis = 2;
                        break;
                    case "H":
                    case 3:
                        message.axis = 3;
                        break;
                    case "W":
                    case 4:
                        message.axis = 4;
                        break;
                    }
                    return message;
                };
    
                ReduceLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mode = options.enums === String ? "SUM" : 0;
                        object.epsilon = 0;
                        object.axis = options.enums === String ? "CHW" : 0;
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.ReduceLayerParams.ReduceOperation[message.mode] : message.mode;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        object.axis = options.enums === String ? $root.CoreML.Specification.ReduceLayerParams.ReduceAxis[message.axis] : message.axis;
                    return object;
                };
    
                ReduceLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                ReduceLayerParams.ReduceOperation = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SUM"] = 0;
                    values[valuesById[1] = "AVG"] = 1;
                    values[valuesById[2] = "PROD"] = 2;
                    values[valuesById[3] = "LOGSUM"] = 3;
                    values[valuesById[4] = "SUMSQUARE"] = 4;
                    values[valuesById[5] = "L1"] = 5;
                    values[valuesById[6] = "L2"] = 6;
                    values[valuesById[7] = "MAX"] = 7;
                    values[valuesById[8] = "MIN"] = 8;
                    values[valuesById[9] = "ARGMAX"] = 9;
                    return values;
                })();
    
                ReduceLayerParams.ReduceAxis = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHW"] = 0;
                    values[valuesById[1] = "HW"] = 1;
                    values[valuesById[2] = "C"] = 2;
                    values[valuesById[3] = "H"] = 3;
                    values[valuesById[4] = "W"] = 4;
                    return values;
                })();
    
                return ReduceLayerParams;
            })();
    
            Specification.CropLayerParams = (function() {
    
                function CropLayerParams(properties) {
                    this.offset = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                CropLayerParams.prototype.cropAmounts = null;
                CropLayerParams.prototype.offset = $util.emptyArray;
    
                CropLayerParams.create = function create(properties) {
                    return new CropLayerParams(properties);
                };
    
                CropLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CropLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cropAmounts = $root.CoreML.Specification.BorderAmounts.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.offset && message.offset.length))
                                message.offset = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.offset.push(reader.uint64());
                            } else
                                message.offset.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                CropLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cropAmounts != null && message.hasOwnProperty("cropAmounts")) {
                        var error = $root.CoreML.Specification.BorderAmounts.verify(message.cropAmounts);
                        if (error)
                            return "cropAmounts." + error;
                    }
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        if (!Array.isArray(message.offset))
                            return "offset: array expected";
                        for (var i = 0; i < message.offset.length; ++i)
                            if (!$util.isInteger(message.offset[i]) && !(message.offset[i] && $util.isInteger(message.offset[i].low) && $util.isInteger(message.offset[i].high)))
                                return "offset: integer|Long[] expected";
                    }
                    return null;
                };
    
                CropLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CropLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.CropLayerParams();
                    if (object.cropAmounts != null) {
                        if (typeof object.cropAmounts !== "object")
                            throw TypeError(".CoreML.Specification.CropLayerParams.cropAmounts: object expected");
                        message.cropAmounts = $root.CoreML.Specification.BorderAmounts.fromObject(object.cropAmounts);
                    }
                    if (object.offset) {
                        if (!Array.isArray(object.offset))
                            throw TypeError(".CoreML.Specification.CropLayerParams.offset: array expected");
                        message.offset = [];
                        for (var i = 0; i < object.offset.length; ++i)
                            if ($util.Long)
                                (message.offset[i] = $util.Long.fromValue(object.offset[i])).unsigned = true;
                            else if (typeof object.offset[i] === "string")
                                message.offset[i] = parseInt(object.offset[i], 10);
                            else if (typeof object.offset[i] === "number")
                                message.offset[i] = object.offset[i];
                            else if (typeof object.offset[i] === "object")
                                message.offset[i] = new $util.LongBits(object.offset[i].low >>> 0, object.offset[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                CropLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.offset = [];
                    if (options.defaults)
                        object.cropAmounts = null;
                    if (message.cropAmounts != null && message.hasOwnProperty("cropAmounts"))
                        object.cropAmounts = $root.CoreML.Specification.BorderAmounts.toObject(message.cropAmounts, options);
                    if (message.offset && message.offset.length) {
                        object.offset = [];
                        for (var j = 0; j < message.offset.length; ++j)
                            if (typeof message.offset[j] === "number")
                                object.offset[j] = options.longs === String ? String(message.offset[j]) : message.offset[j];
                            else
                                object.offset[j] = options.longs === String ? $util.Long.prototype.toString.call(message.offset[j]) : options.longs === Number ? new $util.LongBits(message.offset[j].low >>> 0, message.offset[j].high >>> 0).toNumber(true) : message.offset[j];
                    }
                    return object;
                };
    
                CropLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CropLayerParams;
            })();
    
            Specification.AverageLayerParams = (function() {
    
                function AverageLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                AverageLayerParams.create = function create(properties) {
                    return new AverageLayerParams(properties);
                };
    
                AverageLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.AverageLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                AverageLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                AverageLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.AverageLayerParams)
                        return object;
                    return new $root.CoreML.Specification.AverageLayerParams();
                };
    
                AverageLayerParams.toObject = function toObject() {
                    return {};
                };
    
                AverageLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return AverageLayerParams;
            })();
    
            Specification.MaxLayerParams = (function() {
    
                function MaxLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                MaxLayerParams.create = function create(properties) {
                    return new MaxLayerParams(properties);
                };
    
                MaxLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MaxLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                MaxLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                MaxLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MaxLayerParams)
                        return object;
                    return new $root.CoreML.Specification.MaxLayerParams();
                };
    
                MaxLayerParams.toObject = function toObject() {
                    return {};
                };
    
                MaxLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MaxLayerParams;
            })();
    
            Specification.MinLayerParams = (function() {
    
                function MinLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                MinLayerParams.create = function create(properties) {
                    return new MinLayerParams(properties);
                };
    
                MinLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MinLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                MinLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                MinLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MinLayerParams)
                        return object;
                    return new $root.CoreML.Specification.MinLayerParams();
                };
    
                MinLayerParams.toObject = function toObject() {
                    return {};
                };
    
                MinLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MinLayerParams;
            })();
    
            Specification.DotProductLayerParams = (function() {
    
                function DotProductLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DotProductLayerParams.prototype.cosineSimilarity = false;
    
                DotProductLayerParams.create = function create(properties) {
                    return new DotProductLayerParams(properties);
                };
    
                DotProductLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DotProductLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cosineSimilarity = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DotProductLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cosineSimilarity != null && message.hasOwnProperty("cosineSimilarity"))
                        if (typeof message.cosineSimilarity !== "boolean")
                            return "cosineSimilarity: boolean expected";
                    return null;
                };
    
                DotProductLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DotProductLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.DotProductLayerParams();
                    if (object.cosineSimilarity != null)
                        message.cosineSimilarity = Boolean(object.cosineSimilarity);
                    return message;
                };
    
                DotProductLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.cosineSimilarity = false;
                    if (message.cosineSimilarity != null && message.hasOwnProperty("cosineSimilarity"))
                        object.cosineSimilarity = message.cosineSimilarity;
                    return object;
                };
    
                DotProductLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DotProductLayerParams;
            })();
    
            Specification.MeanVarianceNormalizeLayerParams = (function() {
    
                function MeanVarianceNormalizeLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                MeanVarianceNormalizeLayerParams.prototype.acrossChannels = false;
                MeanVarianceNormalizeLayerParams.prototype.normalizeVariance = false;
                MeanVarianceNormalizeLayerParams.prototype.epsilon = 0;
    
                MeanVarianceNormalizeLayerParams.create = function create(properties) {
                    return new MeanVarianceNormalizeLayerParams(properties);
                };
    
                MeanVarianceNormalizeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MeanVarianceNormalizeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.acrossChannels = reader.bool();
                            break;
                        case 2:
                            message.normalizeVariance = reader.bool();
                            break;
                        case 3:
                            message.epsilon = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                MeanVarianceNormalizeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.acrossChannels != null && message.hasOwnProperty("acrossChannels"))
                        if (typeof message.acrossChannels !== "boolean")
                            return "acrossChannels: boolean expected";
                    if (message.normalizeVariance != null && message.hasOwnProperty("normalizeVariance"))
                        if (typeof message.normalizeVariance !== "boolean")
                            return "normalizeVariance: boolean expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    return null;
                };
    
                MeanVarianceNormalizeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MeanVarianceNormalizeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.MeanVarianceNormalizeLayerParams();
                    if (object.acrossChannels != null)
                        message.acrossChannels = Boolean(object.acrossChannels);
                    if (object.normalizeVariance != null)
                        message.normalizeVariance = Boolean(object.normalizeVariance);
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    return message;
                };
    
                MeanVarianceNormalizeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.acrossChannels = false;
                        object.normalizeVariance = false;
                        object.epsilon = 0;
                    }
                    if (message.acrossChannels != null && message.hasOwnProperty("acrossChannels"))
                        object.acrossChannels = message.acrossChannels;
                    if (message.normalizeVariance != null && message.hasOwnProperty("normalizeVariance"))
                        object.normalizeVariance = message.normalizeVariance;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    return object;
                };
    
                MeanVarianceNormalizeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MeanVarianceNormalizeLayerParams;
            })();
    
            Specification.SequenceRepeatLayerParams = (function() {
    
                function SequenceRepeatLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SequenceRepeatLayerParams.prototype.nRepetitions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                SequenceRepeatLayerParams.create = function create(properties) {
                    return new SequenceRepeatLayerParams(properties);
                };
    
                SequenceRepeatLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SequenceRepeatLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nRepetitions = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SequenceRepeatLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nRepetitions != null && message.hasOwnProperty("nRepetitions"))
                        if (!$util.isInteger(message.nRepetitions) && !(message.nRepetitions && $util.isInteger(message.nRepetitions.low) && $util.isInteger(message.nRepetitions.high)))
                            return "nRepetitions: integer|Long expected";
                    return null;
                };
    
                SequenceRepeatLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SequenceRepeatLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SequenceRepeatLayerParams();
                    if (object.nRepetitions != null)
                        if ($util.Long)
                            (message.nRepetitions = $util.Long.fromValue(object.nRepetitions)).unsigned = true;
                        else if (typeof object.nRepetitions === "string")
                            message.nRepetitions = parseInt(object.nRepetitions, 10);
                        else if (typeof object.nRepetitions === "number")
                            message.nRepetitions = object.nRepetitions;
                        else if (typeof object.nRepetitions === "object")
                            message.nRepetitions = new $util.LongBits(object.nRepetitions.low >>> 0, object.nRepetitions.high >>> 0).toNumber(true);
                    return message;
                };
    
                SequenceRepeatLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nRepetitions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nRepetitions = options.longs === String ? "0" : 0;
                    if (message.nRepetitions != null && message.hasOwnProperty("nRepetitions"))
                        if (typeof message.nRepetitions === "number")
                            object.nRepetitions = options.longs === String ? String(message.nRepetitions) : message.nRepetitions;
                        else
                            object.nRepetitions = options.longs === String ? $util.Long.prototype.toString.call(message.nRepetitions) : options.longs === Number ? new $util.LongBits(message.nRepetitions.low >>> 0, message.nRepetitions.high >>> 0).toNumber(true) : message.nRepetitions;
                    return object;
                };
    
                SequenceRepeatLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SequenceRepeatLayerParams;
            })();
    
            Specification.SimpleRecurrentLayerParams = (function() {
    
                function SimpleRecurrentLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SimpleRecurrentLayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                SimpleRecurrentLayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                SimpleRecurrentLayerParams.prototype.activation = null;
                SimpleRecurrentLayerParams.prototype.sequenceOutput = false;
                SimpleRecurrentLayerParams.prototype.hasBiasVector = false;
                SimpleRecurrentLayerParams.prototype.weightMatrix = null;
                SimpleRecurrentLayerParams.prototype.recursionMatrix = null;
                SimpleRecurrentLayerParams.prototype.biasVector = null;
                SimpleRecurrentLayerParams.prototype.reverseInput = false;
    
                SimpleRecurrentLayerParams.create = function create(properties) {
                    return new SimpleRecurrentLayerParams(properties);
                };
    
                SimpleRecurrentLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SimpleRecurrentLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            message.activation = $root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.sequenceOutput = reader.bool();
                            break;
                        case 20:
                            message.hasBiasVector = reader.bool();
                            break;
                        case 30:
                            message.weightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.recursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.biasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.reverseInput = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SimpleRecurrentLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activation != null && message.hasOwnProperty("activation")) {
                        var error = $root.CoreML.Specification.ActivationParams.verify(message.activation);
                        if (error)
                            return "activation." + error;
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        if (typeof message.sequenceOutput !== "boolean")
                            return "sequenceOutput: boolean expected";
                    if (message.hasBiasVector != null && message.hasOwnProperty("hasBiasVector"))
                        if (typeof message.hasBiasVector !== "boolean")
                            return "hasBiasVector: boolean expected";
                    if (message.weightMatrix != null && message.hasOwnProperty("weightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weightMatrix);
                        if (error)
                            return "weightMatrix." + error;
                    }
                    if (message.recursionMatrix != null && message.hasOwnProperty("recursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.recursionMatrix);
                        if (error)
                            return "recursionMatrix." + error;
                    }
                    if (message.biasVector != null && message.hasOwnProperty("biasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.biasVector);
                        if (error)
                            return "biasVector." + error;
                    }
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        if (typeof message.reverseInput !== "boolean")
                            return "reverseInput: boolean expected";
                    return null;
                };
    
                SimpleRecurrentLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SimpleRecurrentLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SimpleRecurrentLayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activation != null) {
                        if (typeof object.activation !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.activation: object expected");
                        message.activation = $root.CoreML.Specification.ActivationParams.fromObject(object.activation);
                    }
                    if (object.sequenceOutput != null)
                        message.sequenceOutput = Boolean(object.sequenceOutput);
                    if (object.hasBiasVector != null)
                        message.hasBiasVector = Boolean(object.hasBiasVector);
                    if (object.weightMatrix != null) {
                        if (typeof object.weightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.weightMatrix: object expected");
                        message.weightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.weightMatrix);
                    }
                    if (object.recursionMatrix != null) {
                        if (typeof object.recursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.recursionMatrix: object expected");
                        message.recursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.recursionMatrix);
                    }
                    if (object.biasVector != null) {
                        if (typeof object.biasVector !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.biasVector: object expected");
                        message.biasVector = $root.CoreML.Specification.WeightParams.fromObject(object.biasVector);
                    }
                    if (object.reverseInput != null)
                        message.reverseInput = Boolean(object.reverseInput);
                    return message;
                };
    
                SimpleRecurrentLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.activation = null;
                        object.sequenceOutput = false;
                        object.hasBiasVector = false;
                        object.weightMatrix = null;
                        object.recursionMatrix = null;
                        object.biasVector = null;
                        object.reverseInput = false;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activation != null && message.hasOwnProperty("activation"))
                        object.activation = $root.CoreML.Specification.ActivationParams.toObject(message.activation, options);
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        object.sequenceOutput = message.sequenceOutput;
                    if (message.hasBiasVector != null && message.hasOwnProperty("hasBiasVector"))
                        object.hasBiasVector = message.hasBiasVector;
                    if (message.weightMatrix != null && message.hasOwnProperty("weightMatrix"))
                        object.weightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.weightMatrix, options);
                    if (message.recursionMatrix != null && message.hasOwnProperty("recursionMatrix"))
                        object.recursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.recursionMatrix, options);
                    if (message.biasVector != null && message.hasOwnProperty("biasVector"))
                        object.biasVector = $root.CoreML.Specification.WeightParams.toObject(message.biasVector, options);
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        object.reverseInput = message.reverseInput;
                    return object;
                };
    
                SimpleRecurrentLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SimpleRecurrentLayerParams;
            })();
    
            Specification.GRULayerParams = (function() {
    
                function GRULayerParams(properties) {
                    this.activations = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                GRULayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                GRULayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                GRULayerParams.prototype.activations = $util.emptyArray;
                GRULayerParams.prototype.sequenceOutput = false;
                GRULayerParams.prototype.hasBiasVectors = false;
                GRULayerParams.prototype.updateGateWeightMatrix = null;
                GRULayerParams.prototype.resetGateWeightMatrix = null;
                GRULayerParams.prototype.outputGateWeightMatrix = null;
                GRULayerParams.prototype.updateGateRecursionMatrix = null;
                GRULayerParams.prototype.resetGateRecursionMatrix = null;
                GRULayerParams.prototype.outputGateRecursionMatrix = null;
                GRULayerParams.prototype.updateGateBiasVector = null;
                GRULayerParams.prototype.resetGateBiasVector = null;
                GRULayerParams.prototype.outputGateBiasVector = null;
                GRULayerParams.prototype.reverseInput = false;
    
                GRULayerParams.create = function create(properties) {
                    return new GRULayerParams(properties);
                };
    
                GRULayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GRULayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            if (!(message.activations && message.activations.length))
                                message.activations = [];
                            message.activations.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.sequenceOutput = reader.bool();
                            break;
                        case 20:
                            message.hasBiasVectors = reader.bool();
                            break;
                        case 30:
                            message.updateGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.resetGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.updateGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 51:
                            message.resetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 52:
                            message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 70:
                            message.updateGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 71:
                            message.resetGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 72:
                            message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.reverseInput = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                GRULayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activations != null && message.hasOwnProperty("activations")) {
                        if (!Array.isArray(message.activations))
                            return "activations: array expected";
                        for (var i = 0; i < message.activations.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activations[i]);
                            if (error)
                                return "activations." + error;
                        }
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        if (typeof message.sequenceOutput !== "boolean")
                            return "sequenceOutput: boolean expected";
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        if (typeof message.hasBiasVectors !== "boolean")
                            return "hasBiasVectors: boolean expected";
                    if (message.updateGateWeightMatrix != null && message.hasOwnProperty("updateGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.updateGateWeightMatrix);
                        if (error)
                            return "updateGateWeightMatrix." + error;
                    }
                    if (message.resetGateWeightMatrix != null && message.hasOwnProperty("resetGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.resetGateWeightMatrix);
                        if (error)
                            return "resetGateWeightMatrix." + error;
                    }
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateWeightMatrix);
                        if (error)
                            return "outputGateWeightMatrix." + error;
                    }
                    if (message.updateGateRecursionMatrix != null && message.hasOwnProperty("updateGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.updateGateRecursionMatrix);
                        if (error)
                            return "updateGateRecursionMatrix." + error;
                    }
                    if (message.resetGateRecursionMatrix != null && message.hasOwnProperty("resetGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.resetGateRecursionMatrix);
                        if (error)
                            return "resetGateRecursionMatrix." + error;
                    }
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateRecursionMatrix);
                        if (error)
                            return "outputGateRecursionMatrix." + error;
                    }
                    if (message.updateGateBiasVector != null && message.hasOwnProperty("updateGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.updateGateBiasVector);
                        if (error)
                            return "updateGateBiasVector." + error;
                    }
                    if (message.resetGateBiasVector != null && message.hasOwnProperty("resetGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.resetGateBiasVector);
                        if (error)
                            return "resetGateBiasVector." + error;
                    }
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateBiasVector);
                        if (error)
                            return "outputGateBiasVector." + error;
                    }
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        if (typeof message.reverseInput !== "boolean")
                            return "reverseInput: boolean expected";
                    return null;
                };
    
                GRULayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.GRULayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.GRULayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activations) {
                        if (!Array.isArray(object.activations))
                            throw TypeError(".CoreML.Specification.GRULayerParams.activations: array expected");
                        message.activations = [];
                        for (var i = 0; i < object.activations.length; ++i) {
                            if (typeof object.activations[i] !== "object")
                                throw TypeError(".CoreML.Specification.GRULayerParams.activations: object expected");
                            message.activations[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activations[i]);
                        }
                    }
                    if (object.sequenceOutput != null)
                        message.sequenceOutput = Boolean(object.sequenceOutput);
                    if (object.hasBiasVectors != null)
                        message.hasBiasVectors = Boolean(object.hasBiasVectors);
                    if (object.updateGateWeightMatrix != null) {
                        if (typeof object.updateGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.updateGateWeightMatrix: object expected");
                        message.updateGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.updateGateWeightMatrix);
                    }
                    if (object.resetGateWeightMatrix != null) {
                        if (typeof object.resetGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.resetGateWeightMatrix: object expected");
                        message.resetGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.resetGateWeightMatrix);
                    }
                    if (object.outputGateWeightMatrix != null) {
                        if (typeof object.outputGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.outputGateWeightMatrix: object expected");
                        message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateWeightMatrix);
                    }
                    if (object.updateGateRecursionMatrix != null) {
                        if (typeof object.updateGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.updateGateRecursionMatrix: object expected");
                        message.updateGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.updateGateRecursionMatrix);
                    }
                    if (object.resetGateRecursionMatrix != null) {
                        if (typeof object.resetGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.resetGateRecursionMatrix: object expected");
                        message.resetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.resetGateRecursionMatrix);
                    }
                    if (object.outputGateRecursionMatrix != null) {
                        if (typeof object.outputGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.outputGateRecursionMatrix: object expected");
                        message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateRecursionMatrix);
                    }
                    if (object.updateGateBiasVector != null) {
                        if (typeof object.updateGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.updateGateBiasVector: object expected");
                        message.updateGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.updateGateBiasVector);
                    }
                    if (object.resetGateBiasVector != null) {
                        if (typeof object.resetGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.resetGateBiasVector: object expected");
                        message.resetGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.resetGateBiasVector);
                    }
                    if (object.outputGateBiasVector != null) {
                        if (typeof object.outputGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.outputGateBiasVector: object expected");
                        message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateBiasVector);
                    }
                    if (object.reverseInput != null)
                        message.reverseInput = Boolean(object.reverseInput);
                    return message;
                };
    
                GRULayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.activations = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.sequenceOutput = false;
                        object.hasBiasVectors = false;
                        object.updateGateWeightMatrix = null;
                        object.resetGateWeightMatrix = null;
                        object.outputGateWeightMatrix = null;
                        object.updateGateRecursionMatrix = null;
                        object.resetGateRecursionMatrix = null;
                        object.outputGateRecursionMatrix = null;
                        object.updateGateBiasVector = null;
                        object.resetGateBiasVector = null;
                        object.outputGateBiasVector = null;
                        object.reverseInput = false;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activations && message.activations.length) {
                        object.activations = [];
                        for (var j = 0; j < message.activations.length; ++j)
                            object.activations[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activations[j], options);
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        object.sequenceOutput = message.sequenceOutput;
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        object.hasBiasVectors = message.hasBiasVectors;
                    if (message.updateGateWeightMatrix != null && message.hasOwnProperty("updateGateWeightMatrix"))
                        object.updateGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.updateGateWeightMatrix, options);
                    if (message.resetGateWeightMatrix != null && message.hasOwnProperty("resetGateWeightMatrix"))
                        object.resetGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.resetGateWeightMatrix, options);
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix"))
                        object.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateWeightMatrix, options);
                    if (message.updateGateRecursionMatrix != null && message.hasOwnProperty("updateGateRecursionMatrix"))
                        object.updateGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.updateGateRecursionMatrix, options);
                    if (message.resetGateRecursionMatrix != null && message.hasOwnProperty("resetGateRecursionMatrix"))
                        object.resetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.resetGateRecursionMatrix, options);
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix"))
                        object.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateRecursionMatrix, options);
                    if (message.updateGateBiasVector != null && message.hasOwnProperty("updateGateBiasVector"))
                        object.updateGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.updateGateBiasVector, options);
                    if (message.resetGateBiasVector != null && message.hasOwnProperty("resetGateBiasVector"))
                        object.resetGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.resetGateBiasVector, options);
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector"))
                        object.outputGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.outputGateBiasVector, options);
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        object.reverseInput = message.reverseInput;
                    return object;
                };
    
                GRULayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GRULayerParams;
            })();
    
            Specification.LSTMParams = (function() {
    
                function LSTMParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LSTMParams.prototype.sequenceOutput = false;
                LSTMParams.prototype.hasBiasVectors = false;
                LSTMParams.prototype.forgetBias = false;
                LSTMParams.prototype.hasPeepholeVectors = false;
                LSTMParams.prototype.coupledInputAndForgetGate = false;
                LSTMParams.prototype.cellClipThreshold = 0;
    
                LSTMParams.create = function create(properties) {
                    return new LSTMParams(properties);
                };
    
                LSTMParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LSTMParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.sequenceOutput = reader.bool();
                            break;
                        case 20:
                            message.hasBiasVectors = reader.bool();
                            break;
                        case 30:
                            message.forgetBias = reader.bool();
                            break;
                        case 40:
                            message.hasPeepholeVectors = reader.bool();
                            break;
                        case 50:
                            message.coupledInputAndForgetGate = reader.bool();
                            break;
                        case 60:
                            message.cellClipThreshold = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LSTMParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        if (typeof message.sequenceOutput !== "boolean")
                            return "sequenceOutput: boolean expected";
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        if (typeof message.hasBiasVectors !== "boolean")
                            return "hasBiasVectors: boolean expected";
                    if (message.forgetBias != null && message.hasOwnProperty("forgetBias"))
                        if (typeof message.forgetBias !== "boolean")
                            return "forgetBias: boolean expected";
                    if (message.hasPeepholeVectors != null && message.hasOwnProperty("hasPeepholeVectors"))
                        if (typeof message.hasPeepholeVectors !== "boolean")
                            return "hasPeepholeVectors: boolean expected";
                    if (message.coupledInputAndForgetGate != null && message.hasOwnProperty("coupledInputAndForgetGate"))
                        if (typeof message.coupledInputAndForgetGate !== "boolean")
                            return "coupledInputAndForgetGate: boolean expected";
                    if (message.cellClipThreshold != null && message.hasOwnProperty("cellClipThreshold"))
                        if (typeof message.cellClipThreshold !== "number")
                            return "cellClipThreshold: number expected";
                    return null;
                };
    
                LSTMParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LSTMParams)
                        return object;
                    var message = new $root.CoreML.Specification.LSTMParams();
                    if (object.sequenceOutput != null)
                        message.sequenceOutput = Boolean(object.sequenceOutput);
                    if (object.hasBiasVectors != null)
                        message.hasBiasVectors = Boolean(object.hasBiasVectors);
                    if (object.forgetBias != null)
                        message.forgetBias = Boolean(object.forgetBias);
                    if (object.hasPeepholeVectors != null)
                        message.hasPeepholeVectors = Boolean(object.hasPeepholeVectors);
                    if (object.coupledInputAndForgetGate != null)
                        message.coupledInputAndForgetGate = Boolean(object.coupledInputAndForgetGate);
                    if (object.cellClipThreshold != null)
                        message.cellClipThreshold = Number(object.cellClipThreshold);
                    return message;
                };
    
                LSTMParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sequenceOutput = false;
                        object.hasBiasVectors = false;
                        object.forgetBias = false;
                        object.hasPeepholeVectors = false;
                        object.coupledInputAndForgetGate = false;
                        object.cellClipThreshold = 0;
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        object.sequenceOutput = message.sequenceOutput;
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        object.hasBiasVectors = message.hasBiasVectors;
                    if (message.forgetBias != null && message.hasOwnProperty("forgetBias"))
                        object.forgetBias = message.forgetBias;
                    if (message.hasPeepholeVectors != null && message.hasOwnProperty("hasPeepholeVectors"))
                        object.hasPeepholeVectors = message.hasPeepholeVectors;
                    if (message.coupledInputAndForgetGate != null && message.hasOwnProperty("coupledInputAndForgetGate"))
                        object.coupledInputAndForgetGate = message.coupledInputAndForgetGate;
                    if (message.cellClipThreshold != null && message.hasOwnProperty("cellClipThreshold"))
                        object.cellClipThreshold = options.json && !isFinite(message.cellClipThreshold) ? String(message.cellClipThreshold) : message.cellClipThreshold;
                    return object;
                };
    
                LSTMParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LSTMParams;
            })();
    
            Specification.LSTMWeightParams = (function() {
    
                function LSTMWeightParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LSTMWeightParams.prototype.inputGateWeightMatrix = null;
                LSTMWeightParams.prototype.forgetGateWeightMatrix = null;
                LSTMWeightParams.prototype.blockInputWeightMatrix = null;
                LSTMWeightParams.prototype.outputGateWeightMatrix = null;
                LSTMWeightParams.prototype.inputGateRecursionMatrix = null;
                LSTMWeightParams.prototype.forgetGateRecursionMatrix = null;
                LSTMWeightParams.prototype.blockInputRecursionMatrix = null;
                LSTMWeightParams.prototype.outputGateRecursionMatrix = null;
                LSTMWeightParams.prototype.inputGateBiasVector = null;
                LSTMWeightParams.prototype.forgetGateBiasVector = null;
                LSTMWeightParams.prototype.blockInputBiasVector = null;
                LSTMWeightParams.prototype.outputGateBiasVector = null;
                LSTMWeightParams.prototype.inputGatePeepholeVector = null;
                LSTMWeightParams.prototype.forgetGatePeepholeVector = null;
                LSTMWeightParams.prototype.outputGatePeepholeVector = null;
    
                LSTMWeightParams.create = function create(properties) {
                    return new LSTMWeightParams(properties);
                };
    
                LSTMWeightParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LSTMWeightParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.forgetGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.blockInputWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.inputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.forgetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.blockInputRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 23:
                            message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.inputGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 41:
                            message.forgetGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 42:
                            message.blockInputBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 43:
                            message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 60:
                            message.inputGatePeepholeVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 61:
                            message.forgetGatePeepholeVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 62:
                            message.outputGatePeepholeVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LSTMWeightParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputGateWeightMatrix != null && message.hasOwnProperty("inputGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGateWeightMatrix);
                        if (error)
                            return "inputGateWeightMatrix." + error;
                    }
                    if (message.forgetGateWeightMatrix != null && message.hasOwnProperty("forgetGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGateWeightMatrix);
                        if (error)
                            return "forgetGateWeightMatrix." + error;
                    }
                    if (message.blockInputWeightMatrix != null && message.hasOwnProperty("blockInputWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.blockInputWeightMatrix);
                        if (error)
                            return "blockInputWeightMatrix." + error;
                    }
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateWeightMatrix);
                        if (error)
                            return "outputGateWeightMatrix." + error;
                    }
                    if (message.inputGateRecursionMatrix != null && message.hasOwnProperty("inputGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGateRecursionMatrix);
                        if (error)
                            return "inputGateRecursionMatrix." + error;
                    }
                    if (message.forgetGateRecursionMatrix != null && message.hasOwnProperty("forgetGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGateRecursionMatrix);
                        if (error)
                            return "forgetGateRecursionMatrix." + error;
                    }
                    if (message.blockInputRecursionMatrix != null && message.hasOwnProperty("blockInputRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.blockInputRecursionMatrix);
                        if (error)
                            return "blockInputRecursionMatrix." + error;
                    }
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateRecursionMatrix);
                        if (error)
                            return "outputGateRecursionMatrix." + error;
                    }
                    if (message.inputGateBiasVector != null && message.hasOwnProperty("inputGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGateBiasVector);
                        if (error)
                            return "inputGateBiasVector." + error;
                    }
                    if (message.forgetGateBiasVector != null && message.hasOwnProperty("forgetGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGateBiasVector);
                        if (error)
                            return "forgetGateBiasVector." + error;
                    }
                    if (message.blockInputBiasVector != null && message.hasOwnProperty("blockInputBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.blockInputBiasVector);
                        if (error)
                            return "blockInputBiasVector." + error;
                    }
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateBiasVector);
                        if (error)
                            return "outputGateBiasVector." + error;
                    }
                    if (message.inputGatePeepholeVector != null && message.hasOwnProperty("inputGatePeepholeVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGatePeepholeVector);
                        if (error)
                            return "inputGatePeepholeVector." + error;
                    }
                    if (message.forgetGatePeepholeVector != null && message.hasOwnProperty("forgetGatePeepholeVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGatePeepholeVector);
                        if (error)
                            return "forgetGatePeepholeVector." + error;
                    }
                    if (message.outputGatePeepholeVector != null && message.hasOwnProperty("outputGatePeepholeVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGatePeepholeVector);
                        if (error)
                            return "outputGatePeepholeVector." + error;
                    }
                    return null;
                };
    
                LSTMWeightParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LSTMWeightParams)
                        return object;
                    var message = new $root.CoreML.Specification.LSTMWeightParams();
                    if (object.inputGateWeightMatrix != null) {
                        if (typeof object.inputGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGateWeightMatrix: object expected");
                        message.inputGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.inputGateWeightMatrix);
                    }
                    if (object.forgetGateWeightMatrix != null) {
                        if (typeof object.forgetGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGateWeightMatrix: object expected");
                        message.forgetGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGateWeightMatrix);
                    }
                    if (object.blockInputWeightMatrix != null) {
                        if (typeof object.blockInputWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.blockInputWeightMatrix: object expected");
                        message.blockInputWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.blockInputWeightMatrix);
                    }
                    if (object.outputGateWeightMatrix != null) {
                        if (typeof object.outputGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGateWeightMatrix: object expected");
                        message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateWeightMatrix);
                    }
                    if (object.inputGateRecursionMatrix != null) {
                        if (typeof object.inputGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGateRecursionMatrix: object expected");
                        message.inputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.inputGateRecursionMatrix);
                    }
                    if (object.forgetGateRecursionMatrix != null) {
                        if (typeof object.forgetGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGateRecursionMatrix: object expected");
                        message.forgetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGateRecursionMatrix);
                    }
                    if (object.blockInputRecursionMatrix != null) {
                        if (typeof object.blockInputRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.blockInputRecursionMatrix: object expected");
                        message.blockInputRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.blockInputRecursionMatrix);
                    }
                    if (object.outputGateRecursionMatrix != null) {
                        if (typeof object.outputGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGateRecursionMatrix: object expected");
                        message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateRecursionMatrix);
                    }
                    if (object.inputGateBiasVector != null) {
                        if (typeof object.inputGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGateBiasVector: object expected");
                        message.inputGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.inputGateBiasVector);
                    }
                    if (object.forgetGateBiasVector != null) {
                        if (typeof object.forgetGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGateBiasVector: object expected");
                        message.forgetGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGateBiasVector);
                    }
                    if (object.blockInputBiasVector != null) {
                        if (typeof object.blockInputBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.blockInputBiasVector: object expected");
                        message.blockInputBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.blockInputBiasVector);
                    }
                    if (object.outputGateBiasVector != null) {
                        if (typeof object.outputGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGateBiasVector: object expected");
                        message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateBiasVector);
                    }
                    if (object.inputGatePeepholeVector != null) {
                        if (typeof object.inputGatePeepholeVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGatePeepholeVector: object expected");
                        message.inputGatePeepholeVector = $root.CoreML.Specification.WeightParams.fromObject(object.inputGatePeepholeVector);
                    }
                    if (object.forgetGatePeepholeVector != null) {
                        if (typeof object.forgetGatePeepholeVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGatePeepholeVector: object expected");
                        message.forgetGatePeepholeVector = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGatePeepholeVector);
                    }
                    if (object.outputGatePeepholeVector != null) {
                        if (typeof object.outputGatePeepholeVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGatePeepholeVector: object expected");
                        message.outputGatePeepholeVector = $root.CoreML.Specification.WeightParams.fromObject(object.outputGatePeepholeVector);
                    }
                    return message;
                };
    
                LSTMWeightParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.inputGateWeightMatrix = null;
                        object.forgetGateWeightMatrix = null;
                        object.blockInputWeightMatrix = null;
                        object.outputGateWeightMatrix = null;
                        object.inputGateRecursionMatrix = null;
                        object.forgetGateRecursionMatrix = null;
                        object.blockInputRecursionMatrix = null;
                        object.outputGateRecursionMatrix = null;
                        object.inputGateBiasVector = null;
                        object.forgetGateBiasVector = null;
                        object.blockInputBiasVector = null;
                        object.outputGateBiasVector = null;
                        object.inputGatePeepholeVector = null;
                        object.forgetGatePeepholeVector = null;
                        object.outputGatePeepholeVector = null;
                    }
                    if (message.inputGateWeightMatrix != null && message.hasOwnProperty("inputGateWeightMatrix"))
                        object.inputGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.inputGateWeightMatrix, options);
                    if (message.forgetGateWeightMatrix != null && message.hasOwnProperty("forgetGateWeightMatrix"))
                        object.forgetGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.forgetGateWeightMatrix, options);
                    if (message.blockInputWeightMatrix != null && message.hasOwnProperty("blockInputWeightMatrix"))
                        object.blockInputWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.blockInputWeightMatrix, options);
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix"))
                        object.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateWeightMatrix, options);
                    if (message.inputGateRecursionMatrix != null && message.hasOwnProperty("inputGateRecursionMatrix"))
                        object.inputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.inputGateRecursionMatrix, options);
                    if (message.forgetGateRecursionMatrix != null && message.hasOwnProperty("forgetGateRecursionMatrix"))
                        object.forgetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.forgetGateRecursionMatrix, options);
                    if (message.blockInputRecursionMatrix != null && message.hasOwnProperty("blockInputRecursionMatrix"))
                        object.blockInputRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.blockInputRecursionMatrix, options);
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix"))
                        object.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateRecursionMatrix, options);
                    if (message.inputGateBiasVector != null && message.hasOwnProperty("inputGateBiasVector"))
                        object.inputGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.inputGateBiasVector, options);
                    if (message.forgetGateBiasVector != null && message.hasOwnProperty("forgetGateBiasVector"))
                        object.forgetGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.forgetGateBiasVector, options);
                    if (message.blockInputBiasVector != null && message.hasOwnProperty("blockInputBiasVector"))
                        object.blockInputBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.blockInputBiasVector, options);
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector"))
                        object.outputGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.outputGateBiasVector, options);
                    if (message.inputGatePeepholeVector != null && message.hasOwnProperty("inputGatePeepholeVector"))
                        object.inputGatePeepholeVector = $root.CoreML.Specification.WeightParams.toObject(message.inputGatePeepholeVector, options);
                    if (message.forgetGatePeepholeVector != null && message.hasOwnProperty("forgetGatePeepholeVector"))
                        object.forgetGatePeepholeVector = $root.CoreML.Specification.WeightParams.toObject(message.forgetGatePeepholeVector, options);
                    if (message.outputGatePeepholeVector != null && message.hasOwnProperty("outputGatePeepholeVector"))
                        object.outputGatePeepholeVector = $root.CoreML.Specification.WeightParams.toObject(message.outputGatePeepholeVector, options);
                    return object;
                };
    
                LSTMWeightParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LSTMWeightParams;
            })();
    
            Specification.UniDirectionalLSTMLayerParams = (function() {
    
                function UniDirectionalLSTMLayerParams(properties) {
                    this.activations = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                UniDirectionalLSTMLayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                UniDirectionalLSTMLayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                UniDirectionalLSTMLayerParams.prototype.activations = $util.emptyArray;
                UniDirectionalLSTMLayerParams.prototype.params = null;
                UniDirectionalLSTMLayerParams.prototype.weightParams = null;
                UniDirectionalLSTMLayerParams.prototype.reverseInput = false;
    
                UniDirectionalLSTMLayerParams.create = function create(properties) {
                    return new UniDirectionalLSTMLayerParams(properties);
                };
    
                UniDirectionalLSTMLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.UniDirectionalLSTMLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            if (!(message.activations && message.activations.length))
                                message.activations = [];
                            message.activations.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.params = $root.CoreML.Specification.LSTMParams.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.weightParams = $root.CoreML.Specification.LSTMWeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.reverseInput = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                UniDirectionalLSTMLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activations != null && message.hasOwnProperty("activations")) {
                        if (!Array.isArray(message.activations))
                            return "activations: array expected";
                        for (var i = 0; i < message.activations.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activations[i]);
                            if (error)
                                return "activations." + error;
                        }
                    }
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.CoreML.Specification.LSTMParams.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.weightParams != null && message.hasOwnProperty("weightParams")) {
                        var error = $root.CoreML.Specification.LSTMWeightParams.verify(message.weightParams);
                        if (error)
                            return "weightParams." + error;
                    }
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        if (typeof message.reverseInput !== "boolean")
                            return "reverseInput: boolean expected";
                    return null;
                };
    
                UniDirectionalLSTMLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.UniDirectionalLSTMLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.UniDirectionalLSTMLayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activations) {
                        if (!Array.isArray(object.activations))
                            throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.activations: array expected");
                        message.activations = [];
                        for (var i = 0; i < object.activations.length; ++i) {
                            if (typeof object.activations[i] !== "object")
                                throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.activations: object expected");
                            message.activations[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activations[i]);
                        }
                    }
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.params: object expected");
                        message.params = $root.CoreML.Specification.LSTMParams.fromObject(object.params);
                    }
                    if (object.weightParams != null) {
                        if (typeof object.weightParams !== "object")
                            throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.weightParams: object expected");
                        message.weightParams = $root.CoreML.Specification.LSTMWeightParams.fromObject(object.weightParams);
                    }
                    if (object.reverseInput != null)
                        message.reverseInput = Boolean(object.reverseInput);
                    return message;
                };
    
                UniDirectionalLSTMLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.activations = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.params = null;
                        object.weightParams = null;
                        object.reverseInput = false;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activations && message.activations.length) {
                        object.activations = [];
                        for (var j = 0; j < message.activations.length; ++j)
                            object.activations[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activations[j], options);
                    }
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.CoreML.Specification.LSTMParams.toObject(message.params, options);
                    if (message.weightParams != null && message.hasOwnProperty("weightParams"))
                        object.weightParams = $root.CoreML.Specification.LSTMWeightParams.toObject(message.weightParams, options);
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        object.reverseInput = message.reverseInput;
                    return object;
                };
    
                UniDirectionalLSTMLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return UniDirectionalLSTMLayerParams;
            })();
    
            Specification.BiDirectionalLSTMLayerParams = (function() {
    
                function BiDirectionalLSTMLayerParams(properties) {
                    this.activationsForwardLSTM = [];
                    this.activationsBackwardLSTM = [];
                    this.weightParams = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                BiDirectionalLSTMLayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                BiDirectionalLSTMLayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                BiDirectionalLSTMLayerParams.prototype.activationsForwardLSTM = $util.emptyArray;
                BiDirectionalLSTMLayerParams.prototype.activationsBackwardLSTM = $util.emptyArray;
                BiDirectionalLSTMLayerParams.prototype.params = null;
                BiDirectionalLSTMLayerParams.prototype.weightParams = $util.emptyArray;
    
                BiDirectionalLSTMLayerParams.create = function create(properties) {
                    return new BiDirectionalLSTMLayerParams(properties);
                };
    
                BiDirectionalLSTMLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BiDirectionalLSTMLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            if (!(message.activationsForwardLSTM && message.activationsForwardLSTM.length))
                                message.activationsForwardLSTM = [];
                            message.activationsForwardLSTM.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            if (!(message.activationsBackwardLSTM && message.activationsBackwardLSTM.length))
                                message.activationsBackwardLSTM = [];
                            message.activationsBackwardLSTM.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.params = $root.CoreML.Specification.LSTMParams.decode(reader, reader.uint32());
                            break;
                        case 20:
                            if (!(message.weightParams && message.weightParams.length))
                                message.weightParams = [];
                            message.weightParams.push($root.CoreML.Specification.LSTMWeightParams.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                BiDirectionalLSTMLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activationsForwardLSTM != null && message.hasOwnProperty("activationsForwardLSTM")) {
                        if (!Array.isArray(message.activationsForwardLSTM))
                            return "activationsForwardLSTM: array expected";
                        for (var i = 0; i < message.activationsForwardLSTM.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activationsForwardLSTM[i]);
                            if (error)
                                return "activationsForwardLSTM." + error;
                        }
                    }
                    if (message.activationsBackwardLSTM != null && message.hasOwnProperty("activationsBackwardLSTM")) {
                        if (!Array.isArray(message.activationsBackwardLSTM))
                            return "activationsBackwardLSTM: array expected";
                        for (var i = 0; i < message.activationsBackwardLSTM.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activationsBackwardLSTM[i]);
                            if (error)
                                return "activationsBackwardLSTM." + error;
                        }
                    }
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.CoreML.Specification.LSTMParams.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.weightParams != null && message.hasOwnProperty("weightParams")) {
                        if (!Array.isArray(message.weightParams))
                            return "weightParams: array expected";
                        for (var i = 0; i < message.weightParams.length; ++i) {
                            var error = $root.CoreML.Specification.LSTMWeightParams.verify(message.weightParams[i]);
                            if (error)
                                return "weightParams." + error;
                        }
                    }
                    return null;
                };
    
                BiDirectionalLSTMLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BiDirectionalLSTMLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.BiDirectionalLSTMLayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activationsForwardLSTM) {
                        if (!Array.isArray(object.activationsForwardLSTM))
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM: array expected");
                        message.activationsForwardLSTM = [];
                        for (var i = 0; i < object.activationsForwardLSTM.length; ++i) {
                            if (typeof object.activationsForwardLSTM[i] !== "object")
                                throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM: object expected");
                            message.activationsForwardLSTM[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activationsForwardLSTM[i]);
                        }
                    }
                    if (object.activationsBackwardLSTM) {
                        if (!Array.isArray(object.activationsBackwardLSTM))
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM: array expected");
                        message.activationsBackwardLSTM = [];
                        for (var i = 0; i < object.activationsBackwardLSTM.length; ++i) {
                            if (typeof object.activationsBackwardLSTM[i] !== "object")
                                throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM: object expected");
                            message.activationsBackwardLSTM[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activationsBackwardLSTM[i]);
                        }
                    }
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.params: object expected");
                        message.params = $root.CoreML.Specification.LSTMParams.fromObject(object.params);
                    }
                    if (object.weightParams) {
                        if (!Array.isArray(object.weightParams))
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams: array expected");
                        message.weightParams = [];
                        for (var i = 0; i < object.weightParams.length; ++i) {
                            if (typeof object.weightParams[i] !== "object")
                                throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams: object expected");
                            message.weightParams[i] = $root.CoreML.Specification.LSTMWeightParams.fromObject(object.weightParams[i]);
                        }
                    }
                    return message;
                };
    
                BiDirectionalLSTMLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.activationsForwardLSTM = [];
                        object.activationsBackwardLSTM = [];
                        object.weightParams = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.params = null;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activationsForwardLSTM && message.activationsForwardLSTM.length) {
                        object.activationsForwardLSTM = [];
                        for (var j = 0; j < message.activationsForwardLSTM.length; ++j)
                            object.activationsForwardLSTM[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activationsForwardLSTM[j], options);
                    }
                    if (message.activationsBackwardLSTM && message.activationsBackwardLSTM.length) {
                        object.activationsBackwardLSTM = [];
                        for (var j = 0; j < message.activationsBackwardLSTM.length; ++j)
                            object.activationsBackwardLSTM[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activationsBackwardLSTM[j], options);
                    }
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.CoreML.Specification.LSTMParams.toObject(message.params, options);
                    if (message.weightParams && message.weightParams.length) {
                        object.weightParams = [];
                        for (var j = 0; j < message.weightParams.length; ++j)
                            object.weightParams[j] = $root.CoreML.Specification.LSTMWeightParams.toObject(message.weightParams[j], options);
                    }
                    return object;
                };
    
                BiDirectionalLSTMLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BiDirectionalLSTMLayerParams;
            })();
    
            Specification.CustomLayerParams = (function() {
    
                function CustomLayerParams(properties) {
                    this.weights = [];
                    this.parameters = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                CustomLayerParams.prototype.className = "";
                CustomLayerParams.prototype.weights = $util.emptyArray;
                CustomLayerParams.prototype.parameters = $util.emptyObject;
                CustomLayerParams.prototype.description = "";
    
                CustomLayerParams.create = function create(properties) {
                    return new CustomLayerParams(properties);
                };
    
                CustomLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CustomLayerParams(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.className = reader.string();
                            break;
                        case 20:
                            if (!(message.weights && message.weights.length))
                                message.weights = [];
                            message.weights.push($root.CoreML.Specification.WeightParams.decode(reader, reader.uint32()));
                            break;
                        case 30:
                            reader.skip().pos++;
                            if (message.parameters === $util.emptyObject)
                                message.parameters = {};
                            key = reader.string();
                            reader.pos++;
                            message.parameters[key] = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                CustomLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.className != null && message.hasOwnProperty("className"))
                        if (!$util.isString(message.className))
                            return "className: string expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        if (!Array.isArray(message.weights))
                            return "weights: array expected";
                        for (var i = 0; i < message.weights.length; ++i) {
                            var error = $root.CoreML.Specification.WeightParams.verify(message.weights[i]);
                            if (error)
                                return "weights." + error;
                        }
                    }
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!$util.isObject(message.parameters))
                            return "parameters: object expected";
                        var key = Object.keys(message.parameters);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.verify(message.parameters[key[i]]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };
    
                CustomLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CustomLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.CustomLayerParams();
                    if (object.className != null)
                        message.className = String(object.className);
                    if (object.weights) {
                        if (!Array.isArray(object.weights))
                            throw TypeError(".CoreML.Specification.CustomLayerParams.weights: array expected");
                        message.weights = [];
                        for (var i = 0; i < object.weights.length; ++i) {
                            if (typeof object.weights[i] !== "object")
                                throw TypeError(".CoreML.Specification.CustomLayerParams.weights: object expected");
                            message.weights[i] = $root.CoreML.Specification.WeightParams.fromObject(object.weights[i]);
                        }
                    }
                    if (object.parameters) {
                        if (typeof object.parameters !== "object")
                            throw TypeError(".CoreML.Specification.CustomLayerParams.parameters: object expected");
                        message.parameters = {};
                        for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                            if (typeof object.parameters[keys[i]] !== "object")
                                throw TypeError(".CoreML.Specification.CustomLayerParams.parameters: object expected");
                            message.parameters[keys[i]] = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.fromObject(object.parameters[keys[i]]);
                        }
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };
    
                CustomLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.weights = [];
                    if (options.objects || options.defaults)
                        object.parameters = {};
                    if (options.defaults) {
                        object.className = "";
                        object.description = "";
                    }
                    if (message.className != null && message.hasOwnProperty("className"))
                        object.className = message.className;
                    if (message.weights && message.weights.length) {
                        object.weights = [];
                        for (var j = 0; j < message.weights.length; ++j)
                            object.weights[j] = $root.CoreML.Specification.WeightParams.toObject(message.weights[j], options);
                    }
                    var keys2;
                    if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                        object.parameters = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.parameters[keys2[j]] = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.toObject(message.parameters[keys2[j]], options);
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };
    
                CustomLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                CustomLayerParams.CustomLayerParamValue = (function() {
    
                    function CustomLayerParamValue(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    CustomLayerParamValue.prototype.doubleValue = 0;
                    CustomLayerParamValue.prototype.stringValue = "";
                    CustomLayerParamValue.prototype.intValue = 0;
                    CustomLayerParamValue.prototype.longValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
                    CustomLayerParamValue.prototype.boolValue = false;
    
                    var $oneOfFields;
    
                    Object.defineProperty(CustomLayerParamValue.prototype, "value", {
                        get: $util.oneOfGetter($oneOfFields = ["doubleValue", "stringValue", "intValue", "longValue", "boolValue"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    CustomLayerParamValue.create = function create(properties) {
                        return new CustomLayerParamValue(properties);
                    };
    
                    CustomLayerParamValue.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 10:
                                message.doubleValue = reader.double();
                                break;
                            case 20:
                                message.stringValue = reader.string();
                                break;
                            case 30:
                                message.intValue = reader.int32();
                                break;
                            case 40:
                                message.longValue = reader.int64();
                                break;
                            case 50:
                                message.boolValue = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    CustomLayerParamValue.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                            properties.value = 1;
                            if (typeof message.doubleValue !== "number")
                                return "doubleValue: number expected";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isString(message.stringValue))
                                return "stringValue: string expected";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.intValue))
                                return "intValue: integer expected";
                        }
                        if (message.longValue != null && message.hasOwnProperty("longValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.longValue) && !(message.longValue && $util.isInteger(message.longValue.low) && $util.isInteger(message.longValue.high)))
                                return "longValue: integer|Long expected";
                        }
                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (typeof message.boolValue !== "boolean")
                                return "boolValue: boolean expected";
                        }
                        return null;
                    };
    
                    CustomLayerParamValue.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
                            return object;
                        var message = new $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue();
                        if (object.doubleValue != null)
                            message.doubleValue = Number(object.doubleValue);
                        if (object.stringValue != null)
                            message.stringValue = String(object.stringValue);
                        if (object.intValue != null)
                            message.intValue = object.intValue | 0;
                        if (object.longValue != null)
                            if ($util.Long)
                                (message.longValue = $util.Long.fromValue(object.longValue)).unsigned = false;
                            else if (typeof object.longValue === "string")
                                message.longValue = parseInt(object.longValue, 10);
                            else if (typeof object.longValue === "number")
                                message.longValue = object.longValue;
                            else if (typeof object.longValue === "object")
                                message.longValue = new $util.LongBits(object.longValue.low >>> 0, object.longValue.high >>> 0).toNumber();
                        if (object.boolValue != null)
                            message.boolValue = Boolean(object.boolValue);
                        return message;
                    };
    
                    CustomLayerParamValue.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                            if (options.oneofs)
                                object.value = "doubleValue";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            object.stringValue = message.stringValue;
                            if (options.oneofs)
                                object.value = "stringValue";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            object.intValue = message.intValue;
                            if (options.oneofs)
                                object.value = "intValue";
                        }
                        if (message.longValue != null && message.hasOwnProperty("longValue")) {
                            if (typeof message.longValue === "number")
                                object.longValue = options.longs === String ? String(message.longValue) : message.longValue;
                            else
                                object.longValue = options.longs === String ? $util.Long.prototype.toString.call(message.longValue) : options.longs === Number ? new $util.LongBits(message.longValue.low >>> 0, message.longValue.high >>> 0).toNumber() : message.longValue;
                            if (options.oneofs)
                                object.value = "longValue";
                        }
                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                            object.boolValue = message.boolValue;
                            if (options.oneofs)
                                object.value = "boolValue";
                        }
                        return object;
                    };
    
                    CustomLayerParamValue.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CustomLayerParamValue;
                })();
    
                return CustomLayerParams;
            })();
    
            Specification.NeuralNetworkClassifier = (function() {
    
                function NeuralNetworkClassifier(properties) {
                    this.layers = [];
                    this.preprocessing = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetworkClassifier.prototype.layers = $util.emptyArray;
                NeuralNetworkClassifier.prototype.preprocessing = $util.emptyArray;
                NeuralNetworkClassifier.prototype.stringClassLabels = null;
                NeuralNetworkClassifier.prototype.int64ClassLabels = null;
                NeuralNetworkClassifier.prototype.labelProbabilityLayerName = "";
    
                var $oneOfFields;
    
                Object.defineProperty(NeuralNetworkClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                NeuralNetworkClassifier.create = function create(properties) {
                    return new NeuralNetworkClassifier(properties);
                };
    
                NeuralNetworkClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.layers && message.layers.length))
                                message.layers = [];
                            message.layers.push($root.CoreML.Specification.NeuralNetworkLayer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.preprocessing && message.preprocessing.length))
                                message.preprocessing = [];
                            message.preprocessing.push($root.CoreML.Specification.NeuralNetworkPreprocessing.decode(reader, reader.uint32()));
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 200:
                            message.labelProbabilityLayerName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetworkClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.layers != null && message.hasOwnProperty("layers")) {
                        if (!Array.isArray(message.layers))
                            return "layers: array expected";
                        for (var i = 0; i < message.layers.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkLayer.verify(message.layers[i]);
                            if (error)
                                return "layers." + error;
                        }
                    }
                    if (message.preprocessing != null && message.hasOwnProperty("preprocessing")) {
                        if (!Array.isArray(message.preprocessing))
                            return "preprocessing: array expected";
                        for (var i = 0; i < message.preprocessing.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkPreprocessing.verify(message.preprocessing[i]);
                            if (error)
                                return "preprocessing." + error;
                        }
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    if (message.labelProbabilityLayerName != null && message.hasOwnProperty("labelProbabilityLayerName"))
                        if (!$util.isString(message.labelProbabilityLayerName))
                            return "labelProbabilityLayerName: string expected";
                    return null;
                };
    
                NeuralNetworkClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkClassifier();
                    if (object.layers) {
                        if (!Array.isArray(object.layers))
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.layers: array expected");
                        message.layers = [];
                        for (var i = 0; i < object.layers.length; ++i) {
                            if (typeof object.layers[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.layers: object expected");
                            message.layers[i] = $root.CoreML.Specification.NeuralNetworkLayer.fromObject(object.layers[i]);
                        }
                    }
                    if (object.preprocessing) {
                        if (!Array.isArray(object.preprocessing))
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.preprocessing: array expected");
                        message.preprocessing = [];
                        for (var i = 0; i < object.preprocessing.length; ++i) {
                            if (typeof object.preprocessing[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.preprocessing: object expected");
                            message.preprocessing[i] = $root.CoreML.Specification.NeuralNetworkPreprocessing.fromObject(object.preprocessing[i]);
                        }
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    if (object.labelProbabilityLayerName != null)
                        message.labelProbabilityLayerName = String(object.labelProbabilityLayerName);
                    return message;
                };
    
                NeuralNetworkClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.layers = [];
                        object.preprocessing = [];
                    }
                    if (options.defaults)
                        object.labelProbabilityLayerName = "";
                    if (message.layers && message.layers.length) {
                        object.layers = [];
                        for (var j = 0; j < message.layers.length; ++j)
                            object.layers[j] = $root.CoreML.Specification.NeuralNetworkLayer.toObject(message.layers[j], options);
                    }
                    if (message.preprocessing && message.preprocessing.length) {
                        object.preprocessing = [];
                        for (var j = 0; j < message.preprocessing.length; ++j)
                            object.preprocessing[j] = $root.CoreML.Specification.NeuralNetworkPreprocessing.toObject(message.preprocessing[j], options);
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    if (message.labelProbabilityLayerName != null && message.hasOwnProperty("labelProbabilityLayerName"))
                        object.labelProbabilityLayerName = message.labelProbabilityLayerName;
                    return object;
                };
    
                NeuralNetworkClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkClassifier;
            })();
    
            Specification.NeuralNetworkRegressor = (function() {
    
                function NeuralNetworkRegressor(properties) {
                    this.layers = [];
                    this.preprocessing = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NeuralNetworkRegressor.prototype.layers = $util.emptyArray;
                NeuralNetworkRegressor.prototype.preprocessing = $util.emptyArray;
    
                NeuralNetworkRegressor.create = function create(properties) {
                    return new NeuralNetworkRegressor(properties);
                };
    
                NeuralNetworkRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.layers && message.layers.length))
                                message.layers = [];
                            message.layers.push($root.CoreML.Specification.NeuralNetworkLayer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.preprocessing && message.preprocessing.length))
                                message.preprocessing = [];
                            message.preprocessing.push($root.CoreML.Specification.NeuralNetworkPreprocessing.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NeuralNetworkRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.layers != null && message.hasOwnProperty("layers")) {
                        if (!Array.isArray(message.layers))
                            return "layers: array expected";
                        for (var i = 0; i < message.layers.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkLayer.verify(message.layers[i]);
                            if (error)
                                return "layers." + error;
                        }
                    }
                    if (message.preprocessing != null && message.hasOwnProperty("preprocessing")) {
                        if (!Array.isArray(message.preprocessing))
                            return "preprocessing: array expected";
                        for (var i = 0; i < message.preprocessing.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkPreprocessing.verify(message.preprocessing[i]);
                            if (error)
                                return "preprocessing." + error;
                        }
                    }
                    return null;
                };
    
                NeuralNetworkRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkRegressor();
                    if (object.layers) {
                        if (!Array.isArray(object.layers))
                            throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.layers: array expected");
                        message.layers = [];
                        for (var i = 0; i < object.layers.length; ++i) {
                            if (typeof object.layers[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.layers: object expected");
                            message.layers[i] = $root.CoreML.Specification.NeuralNetworkLayer.fromObject(object.layers[i]);
                        }
                    }
                    if (object.preprocessing) {
                        if (!Array.isArray(object.preprocessing))
                            throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.preprocessing: array expected");
                        message.preprocessing = [];
                        for (var i = 0; i < object.preprocessing.length; ++i) {
                            if (typeof object.preprocessing[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.preprocessing: object expected");
                            message.preprocessing[i] = $root.CoreML.Specification.NeuralNetworkPreprocessing.fromObject(object.preprocessing[i]);
                        }
                    }
                    return message;
                };
    
                NeuralNetworkRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.layers = [];
                        object.preprocessing = [];
                    }
                    if (message.layers && message.layers.length) {
                        object.layers = [];
                        for (var j = 0; j < message.layers.length; ++j)
                            object.layers[j] = $root.CoreML.Specification.NeuralNetworkLayer.toObject(message.layers[j], options);
                    }
                    if (message.preprocessing && message.preprocessing.length) {
                        object.preprocessing = [];
                        for (var j = 0; j < message.preprocessing.length; ++j)
                            object.preprocessing[j] = $root.CoreML.Specification.NeuralNetworkPreprocessing.toObject(message.preprocessing[j], options);
                    }
                    return object;
                };
    
                NeuralNetworkRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkRegressor;
            })();
    
            Specification.Normalizer = (function() {
    
                function Normalizer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Normalizer.prototype.normType = 0;
    
                Normalizer.create = function create(properties) {
                    return new Normalizer(properties);
                };
    
                Normalizer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Normalizer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.normType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Normalizer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.normType != null && message.hasOwnProperty("normType"))
                        switch (message.normType) {
                        default:
                            return "normType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                Normalizer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Normalizer)
                        return object;
                    var message = new $root.CoreML.Specification.Normalizer();
                    switch (object.normType) {
                    case "LMax":
                    case 0:
                        message.normType = 0;
                        break;
                    case "L1":
                    case 1:
                        message.normType = 1;
                        break;
                    case "L2":
                    case 2:
                        message.normType = 2;
                        break;
                    }
                    return message;
                };
    
                Normalizer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.normType = options.enums === String ? "LMax" : 0;
                    if (message.normType != null && message.hasOwnProperty("normType"))
                        object.normType = options.enums === String ? $root.CoreML.Specification.Normalizer.NormType[message.normType] : message.normType;
                    return object;
                };
    
                Normalizer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                Normalizer.NormType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "LMax"] = 0;
                    values[valuesById[1] = "L1"] = 1;
                    values[valuesById[2] = "L2"] = 2;
                    return values;
                })();
    
                return Normalizer;
            })();
    
            Specification.OneHotEncoder = (function() {
    
                function OneHotEncoder(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                OneHotEncoder.prototype.stringCategories = null;
                OneHotEncoder.prototype.int64Categories = null;
                OneHotEncoder.prototype.outputSparse = false;
                OneHotEncoder.prototype.handleUnknown = 0;
    
                var $oneOfFields;
    
                Object.defineProperty(OneHotEncoder.prototype, "CategoryType", {
                    get: $util.oneOfGetter($oneOfFields = ["stringCategories", "int64Categories"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                OneHotEncoder.create = function create(properties) {
                    return new OneHotEncoder(properties);
                };
    
                OneHotEncoder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.OneHotEncoder();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringCategories = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.int64Categories = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.outputSparse = reader.bool();
                            break;
                        case 11:
                            message.handleUnknown = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                OneHotEncoder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringCategories != null && message.hasOwnProperty("stringCategories")) {
                        properties.CategoryType = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringCategories);
                            if (error)
                                return "stringCategories." + error;
                        }
                    }
                    if (message.int64Categories != null && message.hasOwnProperty("int64Categories")) {
                        if (properties.CategoryType === 1)
                            return "CategoryType: multiple values";
                        properties.CategoryType = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64Categories);
                            if (error)
                                return "int64Categories." + error;
                        }
                    }
                    if (message.outputSparse != null && message.hasOwnProperty("outputSparse"))
                        if (typeof message.outputSparse !== "boolean")
                            return "outputSparse: boolean expected";
                    if (message.handleUnknown != null && message.hasOwnProperty("handleUnknown"))
                        switch (message.handleUnknown) {
                        default:
                            return "handleUnknown: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                OneHotEncoder.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.OneHotEncoder)
                        return object;
                    var message = new $root.CoreML.Specification.OneHotEncoder();
                    if (object.stringCategories != null) {
                        if (typeof object.stringCategories !== "object")
                            throw TypeError(".CoreML.Specification.OneHotEncoder.stringCategories: object expected");
                        message.stringCategories = $root.CoreML.Specification.StringVector.fromObject(object.stringCategories);
                    }
                    if (object.int64Categories != null) {
                        if (typeof object.int64Categories !== "object")
                            throw TypeError(".CoreML.Specification.OneHotEncoder.int64Categories: object expected");
                        message.int64Categories = $root.CoreML.Specification.Int64Vector.fromObject(object.int64Categories);
                    }
                    if (object.outputSparse != null)
                        message.outputSparse = Boolean(object.outputSparse);
                    switch (object.handleUnknown) {
                    case "ErrorOnUnknown":
                    case 0:
                        message.handleUnknown = 0;
                        break;
                    case "IgnoreUnknown":
                    case 1:
                        message.handleUnknown = 1;
                        break;
                    }
                    return message;
                };
    
                OneHotEncoder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.outputSparse = false;
                        object.handleUnknown = options.enums === String ? "ErrorOnUnknown" : 0;
                    }
                    if (message.stringCategories != null && message.hasOwnProperty("stringCategories")) {
                        object.stringCategories = $root.CoreML.Specification.StringVector.toObject(message.stringCategories, options);
                        if (options.oneofs)
                            object.CategoryType = "stringCategories";
                    }
                    if (message.int64Categories != null && message.hasOwnProperty("int64Categories")) {
                        object.int64Categories = $root.CoreML.Specification.Int64Vector.toObject(message.int64Categories, options);
                        if (options.oneofs)
                            object.CategoryType = "int64Categories";
                    }
                    if (message.outputSparse != null && message.hasOwnProperty("outputSparse"))
                        object.outputSparse = message.outputSparse;
                    if (message.handleUnknown != null && message.hasOwnProperty("handleUnknown"))
                        object.handleUnknown = options.enums === String ? $root.CoreML.Specification.OneHotEncoder.HandleUnknown[message.handleUnknown] : message.handleUnknown;
                    return object;
                };
    
                OneHotEncoder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                OneHotEncoder.HandleUnknown = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ErrorOnUnknown"] = 0;
                    values[valuesById[1] = "IgnoreUnknown"] = 1;
                    return values;
                })();
    
                return OneHotEncoder;
            })();
    
            Specification.Scaler = (function() {
    
                function Scaler(properties) {
                    this.shiftValue = [];
                    this.scaleValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Scaler.prototype.shiftValue = $util.emptyArray;
                Scaler.prototype.scaleValue = $util.emptyArray;
    
                Scaler.create = function create(properties) {
                    return new Scaler(properties);
                };
    
                Scaler.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Scaler();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shiftValue && message.shiftValue.length))
                                message.shiftValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shiftValue.push(reader.double());
                            } else
                                message.shiftValue.push(reader.double());
                            break;
                        case 2:
                            if (!(message.scaleValue && message.scaleValue.length))
                                message.scaleValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.scaleValue.push(reader.double());
                            } else
                                message.scaleValue.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Scaler.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shiftValue != null && message.hasOwnProperty("shiftValue")) {
                        if (!Array.isArray(message.shiftValue))
                            return "shiftValue: array expected";
                        for (var i = 0; i < message.shiftValue.length; ++i)
                            if (typeof message.shiftValue[i] !== "number")
                                return "shiftValue: number[] expected";
                    }
                    if (message.scaleValue != null && message.hasOwnProperty("scaleValue")) {
                        if (!Array.isArray(message.scaleValue))
                            return "scaleValue: array expected";
                        for (var i = 0; i < message.scaleValue.length; ++i)
                            if (typeof message.scaleValue[i] !== "number")
                                return "scaleValue: number[] expected";
                    }
                    return null;
                };
    
                Scaler.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Scaler)
                        return object;
                    var message = new $root.CoreML.Specification.Scaler();
                    if (object.shiftValue) {
                        if (!Array.isArray(object.shiftValue))
                            throw TypeError(".CoreML.Specification.Scaler.shiftValue: array expected");
                        message.shiftValue = [];
                        for (var i = 0; i < object.shiftValue.length; ++i)
                            message.shiftValue[i] = Number(object.shiftValue[i]);
                    }
                    if (object.scaleValue) {
                        if (!Array.isArray(object.scaleValue))
                            throw TypeError(".CoreML.Specification.Scaler.scaleValue: array expected");
                        message.scaleValue = [];
                        for (var i = 0; i < object.scaleValue.length; ++i)
                            message.scaleValue[i] = Number(object.scaleValue[i]);
                    }
                    return message;
                };
    
                Scaler.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.shiftValue = [];
                        object.scaleValue = [];
                    }
                    if (message.shiftValue && message.shiftValue.length) {
                        object.shiftValue = [];
                        for (var j = 0; j < message.shiftValue.length; ++j)
                            object.shiftValue[j] = options.json && !isFinite(message.shiftValue[j]) ? String(message.shiftValue[j]) : message.shiftValue[j];
                    }
                    if (message.scaleValue && message.scaleValue.length) {
                        object.scaleValue = [];
                        for (var j = 0; j < message.scaleValue.length; ++j)
                            object.scaleValue[j] = options.json && !isFinite(message.scaleValue[j]) ? String(message.scaleValue[j]) : message.scaleValue[j];
                    }
                    return object;
                };
    
                Scaler.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Scaler;
            })();
    
            Specification.NonMaximumSuppression = (function() {
    
                function NonMaximumSuppression(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                NonMaximumSuppression.prototype.pickTop = null;
                NonMaximumSuppression.prototype.stringClassLabels = null;
                NonMaximumSuppression.prototype.int64ClassLabels = null;
                NonMaximumSuppression.prototype.iouThreshold = 0;
                NonMaximumSuppression.prototype.confidenceThreshold = 0;
                NonMaximumSuppression.prototype.confidenceInputFeatureName = "";
                NonMaximumSuppression.prototype.coordinatesInputFeatureName = "";
                NonMaximumSuppression.prototype.iouThresholdInputFeatureName = "";
                NonMaximumSuppression.prototype.confidenceThresholdInputFeatureName = "";
                NonMaximumSuppression.prototype.confidenceOutputFeatureName = "";
                NonMaximumSuppression.prototype.coordinatesOutputFeatureName = "";
    
                var $oneOfFields;
    
                Object.defineProperty(NonMaximumSuppression.prototype, "SuppressionMethod", {
                    get: $util.oneOfGetter($oneOfFields = ["pickTop"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Object.defineProperty(NonMaximumSuppression.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                NonMaximumSuppression.create = function create(properties) {
                    return new NonMaximumSuppression(properties);
                };
    
                NonMaximumSuppression.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NonMaximumSuppression();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pickTop = $root.CoreML.Specification.NonMaximumSuppression.PickTop.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 110:
                            message.iouThreshold = reader.double();
                            break;
                        case 111:
                            message.confidenceThreshold = reader.double();
                            break;
                        case 200:
                            message.confidenceInputFeatureName = reader.string();
                            break;
                        case 201:
                            message.coordinatesInputFeatureName = reader.string();
                            break;
                        case 202:
                            message.iouThresholdInputFeatureName = reader.string();
                            break;
                        case 203:
                            message.confidenceThresholdInputFeatureName = reader.string();
                            break;
                        case 210:
                            message.confidenceOutputFeatureName = reader.string();
                            break;
                        case 211:
                            message.coordinatesOutputFeatureName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                NonMaximumSuppression.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.pickTop != null && message.hasOwnProperty("pickTop")) {
                        properties.SuppressionMethod = 1;
                        {
                            var error = $root.CoreML.Specification.NonMaximumSuppression.PickTop.verify(message.pickTop);
                            if (error)
                                return "pickTop." + error;
                        }
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    if (message.iouThreshold != null && message.hasOwnProperty("iouThreshold"))
                        if (typeof message.iouThreshold !== "number")
                            return "iouThreshold: number expected";
                    if (message.confidenceThreshold != null && message.hasOwnProperty("confidenceThreshold"))
                        if (typeof message.confidenceThreshold !== "number")
                            return "confidenceThreshold: number expected";
                    if (message.confidenceInputFeatureName != null && message.hasOwnProperty("confidenceInputFeatureName"))
                        if (!$util.isString(message.confidenceInputFeatureName))
                            return "confidenceInputFeatureName: string expected";
                    if (message.coordinatesInputFeatureName != null && message.hasOwnProperty("coordinatesInputFeatureName"))
                        if (!$util.isString(message.coordinatesInputFeatureName))
                            return "coordinatesInputFeatureName: string expected";
                    if (message.iouThresholdInputFeatureName != null && message.hasOwnProperty("iouThresholdInputFeatureName"))
                        if (!$util.isString(message.iouThresholdInputFeatureName))
                            return "iouThresholdInputFeatureName: string expected";
                    if (message.confidenceThresholdInputFeatureName != null && message.hasOwnProperty("confidenceThresholdInputFeatureName"))
                        if (!$util.isString(message.confidenceThresholdInputFeatureName))
                            return "confidenceThresholdInputFeatureName: string expected";
                    if (message.confidenceOutputFeatureName != null && message.hasOwnProperty("confidenceOutputFeatureName"))
                        if (!$util.isString(message.confidenceOutputFeatureName))
                            return "confidenceOutputFeatureName: string expected";
                    if (message.coordinatesOutputFeatureName != null && message.hasOwnProperty("coordinatesOutputFeatureName"))
                        if (!$util.isString(message.coordinatesOutputFeatureName))
                            return "coordinatesOutputFeatureName: string expected";
                    return null;
                };
    
                NonMaximumSuppression.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NonMaximumSuppression)
                        return object;
                    var message = new $root.CoreML.Specification.NonMaximumSuppression();
                    if (object.pickTop != null) {
                        if (typeof object.pickTop !== "object")
                            throw TypeError(".CoreML.Specification.NonMaximumSuppression.pickTop: object expected");
                        message.pickTop = $root.CoreML.Specification.NonMaximumSuppression.PickTop.fromObject(object.pickTop);
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.NonMaximumSuppression.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.NonMaximumSuppression.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    if (object.iouThreshold != null)
                        message.iouThreshold = Number(object.iouThreshold);
                    if (object.confidenceThreshold != null)
                        message.confidenceThreshold = Number(object.confidenceThreshold);
                    if (object.confidenceInputFeatureName != null)
                        message.confidenceInputFeatureName = String(object.confidenceInputFeatureName);
                    if (object.coordinatesInputFeatureName != null)
                        message.coordinatesInputFeatureName = String(object.coordinatesInputFeatureName);
                    if (object.iouThresholdInputFeatureName != null)
                        message.iouThresholdInputFeatureName = String(object.iouThresholdInputFeatureName);
                    if (object.confidenceThresholdInputFeatureName != null)
                        message.confidenceThresholdInputFeatureName = String(object.confidenceThresholdInputFeatureName);
                    if (object.confidenceOutputFeatureName != null)
                        message.confidenceOutputFeatureName = String(object.confidenceOutputFeatureName);
                    if (object.coordinatesOutputFeatureName != null)
                        message.coordinatesOutputFeatureName = String(object.coordinatesOutputFeatureName);
                    return message;
                };
    
                NonMaximumSuppression.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.iouThreshold = 0;
                        object.confidenceThreshold = 0;
                        object.confidenceInputFeatureName = "";
                        object.coordinatesInputFeatureName = "";
                        object.iouThresholdInputFeatureName = "";
                        object.confidenceThresholdInputFeatureName = "";
                        object.confidenceOutputFeatureName = "";
                        object.coordinatesOutputFeatureName = "";
                    }
                    if (message.pickTop != null && message.hasOwnProperty("pickTop")) {
                        object.pickTop = $root.CoreML.Specification.NonMaximumSuppression.PickTop.toObject(message.pickTop, options);
                        if (options.oneofs)
                            object.SuppressionMethod = "pickTop";
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    if (message.iouThreshold != null && message.hasOwnProperty("iouThreshold"))
                        object.iouThreshold = options.json && !isFinite(message.iouThreshold) ? String(message.iouThreshold) : message.iouThreshold;
                    if (message.confidenceThreshold != null && message.hasOwnProperty("confidenceThreshold"))
                        object.confidenceThreshold = options.json && !isFinite(message.confidenceThreshold) ? String(message.confidenceThreshold) : message.confidenceThreshold;
                    if (message.confidenceInputFeatureName != null && message.hasOwnProperty("confidenceInputFeatureName"))
                        object.confidenceInputFeatureName = message.confidenceInputFeatureName;
                    if (message.coordinatesInputFeatureName != null && message.hasOwnProperty("coordinatesInputFeatureName"))
                        object.coordinatesInputFeatureName = message.coordinatesInputFeatureName;
                    if (message.iouThresholdInputFeatureName != null && message.hasOwnProperty("iouThresholdInputFeatureName"))
                        object.iouThresholdInputFeatureName = message.iouThresholdInputFeatureName;
                    if (message.confidenceThresholdInputFeatureName != null && message.hasOwnProperty("confidenceThresholdInputFeatureName"))
                        object.confidenceThresholdInputFeatureName = message.confidenceThresholdInputFeatureName;
                    if (message.confidenceOutputFeatureName != null && message.hasOwnProperty("confidenceOutputFeatureName"))
                        object.confidenceOutputFeatureName = message.confidenceOutputFeatureName;
                    if (message.coordinatesOutputFeatureName != null && message.hasOwnProperty("coordinatesOutputFeatureName"))
                        object.coordinatesOutputFeatureName = message.coordinatesOutputFeatureName;
                    return object;
                };
    
                NonMaximumSuppression.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                NonMaximumSuppression.PickTop = (function() {
    
                    function PickTop(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    PickTop.prototype.perClass = false;
    
                    PickTop.create = function create(properties) {
                        return new PickTop(properties);
                    };
    
                    PickTop.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NonMaximumSuppression.PickTop();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.perClass = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    PickTop.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.perClass != null && message.hasOwnProperty("perClass"))
                            if (typeof message.perClass !== "boolean")
                                return "perClass: boolean expected";
                        return null;
                    };
    
                    PickTop.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.NonMaximumSuppression.PickTop)
                            return object;
                        var message = new $root.CoreML.Specification.NonMaximumSuppression.PickTop();
                        if (object.perClass != null)
                            message.perClass = Boolean(object.perClass);
                        return message;
                    };
    
                    PickTop.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.perClass = false;
                        if (message.perClass != null && message.hasOwnProperty("perClass"))
                            object.perClass = message.perClass;
                        return object;
                    };
    
                    PickTop.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PickTop;
                })();
    
                return NonMaximumSuppression;
            })();
    
            Specification.LinearKernel = (function() {
    
                function LinearKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                LinearKernel.create = function create(properties) {
                    return new LinearKernel(properties);
                };
    
                LinearKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LinearKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                LinearKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                LinearKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LinearKernel)
                        return object;
                    return new $root.CoreML.Specification.LinearKernel();
                };
    
                LinearKernel.toObject = function toObject() {
                    return {};
                };
    
                LinearKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LinearKernel;
            })();
    
            Specification.RBFKernel = (function() {
    
                function RBFKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                RBFKernel.prototype.gamma = 0;
    
                RBFKernel.create = function create(properties) {
                    return new RBFKernel(properties);
                };
    
                RBFKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.RBFKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.gamma = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                RBFKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        if (typeof message.gamma !== "number")
                            return "gamma: number expected";
                    return null;
                };
    
                RBFKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.RBFKernel)
                        return object;
                    var message = new $root.CoreML.Specification.RBFKernel();
                    if (object.gamma != null)
                        message.gamma = Number(object.gamma);
                    return message;
                };
    
                RBFKernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.gamma = 0;
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
                    return object;
                };
    
                RBFKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RBFKernel;
            })();
    
            Specification.PolyKernel = (function() {
    
                function PolyKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                PolyKernel.prototype.degree = 0;
                PolyKernel.prototype.c = 0;
                PolyKernel.prototype.gamma = 0;
    
                PolyKernel.create = function create(properties) {
                    return new PolyKernel(properties);
                };
    
                PolyKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PolyKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.degree = reader.int32();
                            break;
                        case 2:
                            message.c = reader.double();
                            break;
                        case 3:
                            message.gamma = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                PolyKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.degree != null && message.hasOwnProperty("degree"))
                        if (!$util.isInteger(message.degree))
                            return "degree: integer expected";
                    if (message.c != null && message.hasOwnProperty("c"))
                        if (typeof message.c !== "number")
                            return "c: number expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        if (typeof message.gamma !== "number")
                            return "gamma: number expected";
                    return null;
                };
    
                PolyKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PolyKernel)
                        return object;
                    var message = new $root.CoreML.Specification.PolyKernel();
                    if (object.degree != null)
                        message.degree = object.degree | 0;
                    if (object.c != null)
                        message.c = Number(object.c);
                    if (object.gamma != null)
                        message.gamma = Number(object.gamma);
                    return message;
                };
    
                PolyKernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.degree = 0;
                        object.c = 0;
                        object.gamma = 0;
                    }
                    if (message.degree != null && message.hasOwnProperty("degree"))
                        object.degree = message.degree;
                    if (message.c != null && message.hasOwnProperty("c"))
                        object.c = options.json && !isFinite(message.c) ? String(message.c) : message.c;
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
                    return object;
                };
    
                PolyKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PolyKernel;
            })();
    
            Specification.SigmoidKernel = (function() {
    
                function SigmoidKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SigmoidKernel.prototype.gamma = 0;
                SigmoidKernel.prototype.c = 0;
    
                SigmoidKernel.create = function create(properties) {
                    return new SigmoidKernel(properties);
                };
    
                SigmoidKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SigmoidKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.gamma = reader.double();
                            break;
                        case 2:
                            message.c = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SigmoidKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        if (typeof message.gamma !== "number")
                            return "gamma: number expected";
                    if (message.c != null && message.hasOwnProperty("c"))
                        if (typeof message.c !== "number")
                            return "c: number expected";
                    return null;
                };
    
                SigmoidKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SigmoidKernel)
                        return object;
                    var message = new $root.CoreML.Specification.SigmoidKernel();
                    if (object.gamma != null)
                        message.gamma = Number(object.gamma);
                    if (object.c != null)
                        message.c = Number(object.c);
                    return message;
                };
    
                SigmoidKernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.gamma = 0;
                        object.c = 0;
                    }
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
                    if (message.c != null && message.hasOwnProperty("c"))
                        object.c = options.json && !isFinite(message.c) ? String(message.c) : message.c;
                    return object;
                };
    
                SigmoidKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SigmoidKernel;
            })();
    
            Specification.Kernel = (function() {
    
                function Kernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Kernel.prototype.linearKernel = null;
                Kernel.prototype.rbfKernel = null;
                Kernel.prototype.polyKernel = null;
                Kernel.prototype.sigmoidKernel = null;
    
                var $oneOfFields;
    
                Object.defineProperty(Kernel.prototype, "kernel", {
                    get: $util.oneOfGetter($oneOfFields = ["linearKernel", "rbfKernel", "polyKernel", "sigmoidKernel"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Kernel.create = function create(properties) {
                    return new Kernel(properties);
                };
    
                Kernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Kernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.linearKernel = $root.CoreML.Specification.LinearKernel.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.rbfKernel = $root.CoreML.Specification.RBFKernel.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.polyKernel = $root.CoreML.Specification.PolyKernel.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.sigmoidKernel = $root.CoreML.Specification.SigmoidKernel.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Kernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.linearKernel != null && message.hasOwnProperty("linearKernel")) {
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.LinearKernel.verify(message.linearKernel);
                            if (error)
                                return "linearKernel." + error;
                        }
                    }
                    if (message.rbfKernel != null && message.hasOwnProperty("rbfKernel")) {
                        if (properties.kernel === 1)
                            return "kernel: multiple values";
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.RBFKernel.verify(message.rbfKernel);
                            if (error)
                                return "rbfKernel." + error;
                        }
                    }
                    if (message.polyKernel != null && message.hasOwnProperty("polyKernel")) {
                        if (properties.kernel === 1)
                            return "kernel: multiple values";
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.PolyKernel.verify(message.polyKernel);
                            if (error)
                                return "polyKernel." + error;
                        }
                    }
                    if (message.sigmoidKernel != null && message.hasOwnProperty("sigmoidKernel")) {
                        if (properties.kernel === 1)
                            return "kernel: multiple values";
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.SigmoidKernel.verify(message.sigmoidKernel);
                            if (error)
                                return "sigmoidKernel." + error;
                        }
                    }
                    return null;
                };
    
                Kernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Kernel)
                        return object;
                    var message = new $root.CoreML.Specification.Kernel();
                    if (object.linearKernel != null) {
                        if (typeof object.linearKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.linearKernel: object expected");
                        message.linearKernel = $root.CoreML.Specification.LinearKernel.fromObject(object.linearKernel);
                    }
                    if (object.rbfKernel != null) {
                        if (typeof object.rbfKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.rbfKernel: object expected");
                        message.rbfKernel = $root.CoreML.Specification.RBFKernel.fromObject(object.rbfKernel);
                    }
                    if (object.polyKernel != null) {
                        if (typeof object.polyKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.polyKernel: object expected");
                        message.polyKernel = $root.CoreML.Specification.PolyKernel.fromObject(object.polyKernel);
                    }
                    if (object.sigmoidKernel != null) {
                        if (typeof object.sigmoidKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.sigmoidKernel: object expected");
                        message.sigmoidKernel = $root.CoreML.Specification.SigmoidKernel.fromObject(object.sigmoidKernel);
                    }
                    return message;
                };
    
                Kernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.linearKernel != null && message.hasOwnProperty("linearKernel")) {
                        object.linearKernel = $root.CoreML.Specification.LinearKernel.toObject(message.linearKernel, options);
                        if (options.oneofs)
                            object.kernel = "linearKernel";
                    }
                    if (message.rbfKernel != null && message.hasOwnProperty("rbfKernel")) {
                        object.rbfKernel = $root.CoreML.Specification.RBFKernel.toObject(message.rbfKernel, options);
                        if (options.oneofs)
                            object.kernel = "rbfKernel";
                    }
                    if (message.polyKernel != null && message.hasOwnProperty("polyKernel")) {
                        object.polyKernel = $root.CoreML.Specification.PolyKernel.toObject(message.polyKernel, options);
                        if (options.oneofs)
                            object.kernel = "polyKernel";
                    }
                    if (message.sigmoidKernel != null && message.hasOwnProperty("sigmoidKernel")) {
                        object.sigmoidKernel = $root.CoreML.Specification.SigmoidKernel.toObject(message.sigmoidKernel, options);
                        if (options.oneofs)
                            object.kernel = "sigmoidKernel";
                    }
                    return object;
                };
    
                Kernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Kernel;
            })();
    
            Specification.SparseNode = (function() {
    
                function SparseNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SparseNode.prototype.index = 0;
                SparseNode.prototype.value = 0;
    
                SparseNode.create = function create(properties) {
                    return new SparseNode(properties);
                };
    
                SparseNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SparseNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.int32();
                            break;
                        case 2:
                            message.value = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SparseNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };
    
                SparseNode.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SparseNode)
                        return object;
                    var message = new $root.CoreML.Specification.SparseNode();
                    if (object.index != null)
                        message.index = object.index | 0;
                    if (object.value != null)
                        message.value = Number(object.value);
                    return message;
                };
    
                SparseNode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.index = 0;
                        object.value = 0;
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    return object;
                };
    
                SparseNode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SparseNode;
            })();
    
            Specification.SparseVector = (function() {
    
                function SparseVector(properties) {
                    this.nodes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SparseVector.prototype.nodes = $util.emptyArray;
    
                SparseVector.create = function create(properties) {
                    return new SparseVector(properties);
                };
    
                SparseVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SparseVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.CoreML.Specification.SparseNode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SparseVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (var i = 0; i < message.nodes.length; ++i) {
                            var error = $root.CoreML.Specification.SparseNode.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    return null;
                };
    
                SparseVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SparseVector)
                        return object;
                    var message = new $root.CoreML.Specification.SparseVector();
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".CoreML.Specification.SparseVector.nodes: array expected");
                        message.nodes = [];
                        for (var i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".CoreML.Specification.SparseVector.nodes: object expected");
                            message.nodes[i] = $root.CoreML.Specification.SparseNode.fromObject(object.nodes[i]);
                        }
                    }
                    return message;
                };
    
                SparseVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.nodes = [];
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (var j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.CoreML.Specification.SparseNode.toObject(message.nodes[j], options);
                    }
                    return object;
                };
    
                SparseVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SparseVector;
            })();
    
            Specification.SparseSupportVectors = (function() {
    
                function SparseSupportVectors(properties) {
                    this.vectors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SparseSupportVectors.prototype.vectors = $util.emptyArray;
    
                SparseSupportVectors.create = function create(properties) {
                    return new SparseSupportVectors(properties);
                };
    
                SparseSupportVectors.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SparseSupportVectors();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vectors && message.vectors.length))
                                message.vectors = [];
                            message.vectors.push($root.CoreML.Specification.SparseVector.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SparseSupportVectors.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vectors != null && message.hasOwnProperty("vectors")) {
                        if (!Array.isArray(message.vectors))
                            return "vectors: array expected";
                        for (var i = 0; i < message.vectors.length; ++i) {
                            var error = $root.CoreML.Specification.SparseVector.verify(message.vectors[i]);
                            if (error)
                                return "vectors." + error;
                        }
                    }
                    return null;
                };
    
                SparseSupportVectors.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SparseSupportVectors)
                        return object;
                    var message = new $root.CoreML.Specification.SparseSupportVectors();
                    if (object.vectors) {
                        if (!Array.isArray(object.vectors))
                            throw TypeError(".CoreML.Specification.SparseSupportVectors.vectors: array expected");
                        message.vectors = [];
                        for (var i = 0; i < object.vectors.length; ++i) {
                            if (typeof object.vectors[i] !== "object")
                                throw TypeError(".CoreML.Specification.SparseSupportVectors.vectors: object expected");
                            message.vectors[i] = $root.CoreML.Specification.SparseVector.fromObject(object.vectors[i]);
                        }
                    }
                    return message;
                };
    
                SparseSupportVectors.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vectors = [];
                    if (message.vectors && message.vectors.length) {
                        object.vectors = [];
                        for (var j = 0; j < message.vectors.length; ++j)
                            object.vectors[j] = $root.CoreML.Specification.SparseVector.toObject(message.vectors[j], options);
                    }
                    return object;
                };
    
                SparseSupportVectors.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SparseSupportVectors;
            })();
    
            Specification.DenseVector = (function() {
    
                function DenseVector(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DenseVector.prototype.values = $util.emptyArray;
    
                DenseVector.create = function create(properties) {
                    return new DenseVector(properties);
                };
    
                DenseVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DenseVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.double());
                            } else
                                message.values.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DenseVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i)
                            if (typeof message.values[i] !== "number")
                                return "values: number[] expected";
                    }
                    return null;
                };
    
                DenseVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DenseVector)
                        return object;
                    var message = new $root.CoreML.Specification.DenseVector();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".CoreML.Specification.DenseVector.values: array expected");
                        message.values = [];
                        for (var i = 0; i < object.values.length; ++i)
                            message.values[i] = Number(object.values[i]);
                    }
                    return message;
                };
    
                DenseVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (var j = 0; j < message.values.length; ++j)
                            object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
                    }
                    return object;
                };
    
                DenseVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DenseVector;
            })();
    
            Specification.DenseSupportVectors = (function() {
    
                function DenseSupportVectors(properties) {
                    this.vectors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                DenseSupportVectors.prototype.vectors = $util.emptyArray;
    
                DenseSupportVectors.create = function create(properties) {
                    return new DenseSupportVectors(properties);
                };
    
                DenseSupportVectors.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DenseSupportVectors();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vectors && message.vectors.length))
                                message.vectors = [];
                            message.vectors.push($root.CoreML.Specification.DenseVector.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                DenseSupportVectors.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vectors != null && message.hasOwnProperty("vectors")) {
                        if (!Array.isArray(message.vectors))
                            return "vectors: array expected";
                        for (var i = 0; i < message.vectors.length; ++i) {
                            var error = $root.CoreML.Specification.DenseVector.verify(message.vectors[i]);
                            if (error)
                                return "vectors." + error;
                        }
                    }
                    return null;
                };
    
                DenseSupportVectors.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DenseSupportVectors)
                        return object;
                    var message = new $root.CoreML.Specification.DenseSupportVectors();
                    if (object.vectors) {
                        if (!Array.isArray(object.vectors))
                            throw TypeError(".CoreML.Specification.DenseSupportVectors.vectors: array expected");
                        message.vectors = [];
                        for (var i = 0; i < object.vectors.length; ++i) {
                            if (typeof object.vectors[i] !== "object")
                                throw TypeError(".CoreML.Specification.DenseSupportVectors.vectors: object expected");
                            message.vectors[i] = $root.CoreML.Specification.DenseVector.fromObject(object.vectors[i]);
                        }
                    }
                    return message;
                };
    
                DenseSupportVectors.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vectors = [];
                    if (message.vectors && message.vectors.length) {
                        object.vectors = [];
                        for (var j = 0; j < message.vectors.length; ++j)
                            object.vectors[j] = $root.CoreML.Specification.DenseVector.toObject(message.vectors[j], options);
                    }
                    return object;
                };
    
                DenseSupportVectors.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DenseSupportVectors;
            })();
    
            Specification.Coefficients = (function() {
    
                function Coefficients(properties) {
                    this.alpha = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                Coefficients.prototype.alpha = $util.emptyArray;
    
                Coefficients.create = function create(properties) {
                    return new Coefficients(properties);
                };
    
                Coefficients.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Coefficients();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.alpha && message.alpha.length))
                                message.alpha = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.alpha.push(reader.double());
                            } else
                                message.alpha.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                Coefficients.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha")) {
                        if (!Array.isArray(message.alpha))
                            return "alpha: array expected";
                        for (var i = 0; i < message.alpha.length; ++i)
                            if (typeof message.alpha[i] !== "number")
                                return "alpha: number[] expected";
                    }
                    return null;
                };
    
                Coefficients.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Coefficients)
                        return object;
                    var message = new $root.CoreML.Specification.Coefficients();
                    if (object.alpha) {
                        if (!Array.isArray(object.alpha))
                            throw TypeError(".CoreML.Specification.Coefficients.alpha: array expected");
                        message.alpha = [];
                        for (var i = 0; i < object.alpha.length; ++i)
                            message.alpha[i] = Number(object.alpha[i]);
                    }
                    return message;
                };
    
                Coefficients.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.alpha = [];
                    if (message.alpha && message.alpha.length) {
                        object.alpha = [];
                        for (var j = 0; j < message.alpha.length; ++j)
                            object.alpha[j] = options.json && !isFinite(message.alpha[j]) ? String(message.alpha[j]) : message.alpha[j];
                    }
                    return object;
                };
    
                Coefficients.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Coefficients;
            })();
    
            Specification.SupportVectorRegressor = (function() {
    
                function SupportVectorRegressor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SupportVectorRegressor.prototype.kernel = null;
                SupportVectorRegressor.prototype.sparseSupportVectors = null;
                SupportVectorRegressor.prototype.denseSupportVectors = null;
                SupportVectorRegressor.prototype.coefficients = null;
                SupportVectorRegressor.prototype.rho = 0;
    
                var $oneOfFields;
    
                Object.defineProperty(SupportVectorRegressor.prototype, "supportVectors", {
                    get: $util.oneOfGetter($oneOfFields = ["sparseSupportVectors", "denseSupportVectors"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                SupportVectorRegressor.create = function create(properties) {
                    return new SupportVectorRegressor(properties);
                };
    
                SupportVectorRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SupportVectorRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kernel = $root.CoreML.Specification.Kernel.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.coefficients = $root.CoreML.Specification.Coefficients.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.rho = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SupportVectorRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.kernel != null && message.hasOwnProperty("kernel")) {
                        var error = $root.CoreML.Specification.Kernel.verify(message.kernel);
                        if (error)
                            return "kernel." + error;
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.SparseSupportVectors.verify(message.sparseSupportVectors);
                            if (error)
                                return "sparseSupportVectors." + error;
                        }
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        if (properties.supportVectors === 1)
                            return "supportVectors: multiple values";
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.DenseSupportVectors.verify(message.denseSupportVectors);
                            if (error)
                                return "denseSupportVectors." + error;
                        }
                    }
                    if (message.coefficients != null && message.hasOwnProperty("coefficients")) {
                        var error = $root.CoreML.Specification.Coefficients.verify(message.coefficients);
                        if (error)
                            return "coefficients." + error;
                    }
                    if (message.rho != null && message.hasOwnProperty("rho"))
                        if (typeof message.rho !== "number")
                            return "rho: number expected";
                    return null;
                };
    
                SupportVectorRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SupportVectorRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.SupportVectorRegressor();
                    if (object.kernel != null) {
                        if (typeof object.kernel !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.kernel: object expected");
                        message.kernel = $root.CoreML.Specification.Kernel.fromObject(object.kernel);
                    }
                    if (object.sparseSupportVectors != null) {
                        if (typeof object.sparseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.sparseSupportVectors: object expected");
                        message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.fromObject(object.sparseSupportVectors);
                    }
                    if (object.denseSupportVectors != null) {
                        if (typeof object.denseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.denseSupportVectors: object expected");
                        message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.fromObject(object.denseSupportVectors);
                    }
                    if (object.coefficients != null) {
                        if (typeof object.coefficients !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.coefficients: object expected");
                        message.coefficients = $root.CoreML.Specification.Coefficients.fromObject(object.coefficients);
                    }
                    if (object.rho != null)
                        message.rho = Number(object.rho);
                    return message;
                };
    
                SupportVectorRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.kernel = null;
                        object.coefficients = null;
                        object.rho = 0;
                    }
                    if (message.kernel != null && message.hasOwnProperty("kernel"))
                        object.kernel = $root.CoreML.Specification.Kernel.toObject(message.kernel, options);
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        object.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.toObject(message.sparseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "sparseSupportVectors";
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        object.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.toObject(message.denseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "denseSupportVectors";
                    }
                    if (message.coefficients != null && message.hasOwnProperty("coefficients"))
                        object.coefficients = $root.CoreML.Specification.Coefficients.toObject(message.coefficients, options);
                    if (message.rho != null && message.hasOwnProperty("rho"))
                        object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
                    return object;
                };
    
                SupportVectorRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SupportVectorRegressor;
            })();
    
            Specification.SupportVectorClassifier = (function() {
    
                function SupportVectorClassifier(properties) {
                    this.numberOfSupportVectorsPerClass = [];
                    this.coefficients = [];
                    this.rho = [];
                    this.probA = [];
                    this.probB = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                SupportVectorClassifier.prototype.kernel = null;
                SupportVectorClassifier.prototype.numberOfSupportVectorsPerClass = $util.emptyArray;
                SupportVectorClassifier.prototype.sparseSupportVectors = null;
                SupportVectorClassifier.prototype.denseSupportVectors = null;
                SupportVectorClassifier.prototype.coefficients = $util.emptyArray;
                SupportVectorClassifier.prototype.rho = $util.emptyArray;
                SupportVectorClassifier.prototype.probA = $util.emptyArray;
                SupportVectorClassifier.prototype.probB = $util.emptyArray;
                SupportVectorClassifier.prototype.stringClassLabels = null;
                SupportVectorClassifier.prototype.int64ClassLabels = null;
    
                var $oneOfFields;
    
                Object.defineProperty(SupportVectorClassifier.prototype, "supportVectors", {
                    get: $util.oneOfGetter($oneOfFields = ["sparseSupportVectors", "denseSupportVectors"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                Object.defineProperty(SupportVectorClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                SupportVectorClassifier.create = function create(properties) {
                    return new SupportVectorClassifier(properties);
                };
    
                SupportVectorClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SupportVectorClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kernel = $root.CoreML.Specification.Kernel.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.numberOfSupportVectorsPerClass && message.numberOfSupportVectorsPerClass.length))
                                message.numberOfSupportVectorsPerClass = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.numberOfSupportVectorsPerClass.push(reader.int32());
                            } else
                                message.numberOfSupportVectorsPerClass.push(reader.int32());
                            break;
                        case 3:
                            message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.coefficients && message.coefficients.length))
                                message.coefficients = [];
                            message.coefficients.push($root.CoreML.Specification.Coefficients.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.rho && message.rho.length))
                                message.rho = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.rho.push(reader.double());
                            } else
                                message.rho.push(reader.double());
                            break;
                        case 7:
                            if (!(message.probA && message.probA.length))
                                message.probA = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.probA.push(reader.double());
                            } else
                                message.probA.push(reader.double());
                            break;
                        case 8:
                            if (!(message.probB && message.probB.length))
                                message.probB = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.probB.push(reader.double());
                            } else
                                message.probB.push(reader.double());
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                SupportVectorClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.kernel != null && message.hasOwnProperty("kernel")) {
                        var error = $root.CoreML.Specification.Kernel.verify(message.kernel);
                        if (error)
                            return "kernel." + error;
                    }
                    if (message.numberOfSupportVectorsPerClass != null && message.hasOwnProperty("numberOfSupportVectorsPerClass")) {
                        if (!Array.isArray(message.numberOfSupportVectorsPerClass))
                            return "numberOfSupportVectorsPerClass: array expected";
                        for (var i = 0; i < message.numberOfSupportVectorsPerClass.length; ++i)
                            if (!$util.isInteger(message.numberOfSupportVectorsPerClass[i]))
                                return "numberOfSupportVectorsPerClass: integer[] expected";
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.SparseSupportVectors.verify(message.sparseSupportVectors);
                            if (error)
                                return "sparseSupportVectors." + error;
                        }
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        if (properties.supportVectors === 1)
                            return "supportVectors: multiple values";
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.DenseSupportVectors.verify(message.denseSupportVectors);
                            if (error)
                                return "denseSupportVectors." + error;
                        }
                    }
                    if (message.coefficients != null && message.hasOwnProperty("coefficients")) {
                        if (!Array.isArray(message.coefficients))
                            return "coefficients: array expected";
                        for (var i = 0; i < message.coefficients.length; ++i) {
                            var error = $root.CoreML.Specification.Coefficients.verify(message.coefficients[i]);
                            if (error)
                                return "coefficients." + error;
                        }
                    }
                    if (message.rho != null && message.hasOwnProperty("rho")) {
                        if (!Array.isArray(message.rho))
                            return "rho: array expected";
                        for (var i = 0; i < message.rho.length; ++i)
                            if (typeof message.rho[i] !== "number")
                                return "rho: number[] expected";
                    }
                    if (message.probA != null && message.hasOwnProperty("probA")) {
                        if (!Array.isArray(message.probA))
                            return "probA: array expected";
                        for (var i = 0; i < message.probA.length; ++i)
                            if (typeof message.probA[i] !== "number")
                                return "probA: number[] expected";
                    }
                    if (message.probB != null && message.hasOwnProperty("probB")) {
                        if (!Array.isArray(message.probB))
                            return "probB: array expected";
                        for (var i = 0; i < message.probB.length; ++i)
                            if (typeof message.probB[i] !== "number")
                                return "probB: number[] expected";
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    return null;
                };
    
                SupportVectorClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SupportVectorClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.SupportVectorClassifier();
                    if (object.kernel != null) {
                        if (typeof object.kernel !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.kernel: object expected");
                        message.kernel = $root.CoreML.Specification.Kernel.fromObject(object.kernel);
                    }
                    if (object.numberOfSupportVectorsPerClass) {
                        if (!Array.isArray(object.numberOfSupportVectorsPerClass))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass: array expected");
                        message.numberOfSupportVectorsPerClass = [];
                        for (var i = 0; i < object.numberOfSupportVectorsPerClass.length; ++i)
                            message.numberOfSupportVectorsPerClass[i] = object.numberOfSupportVectorsPerClass[i] | 0;
                    }
                    if (object.sparseSupportVectors != null) {
                        if (typeof object.sparseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.sparseSupportVectors: object expected");
                        message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.fromObject(object.sparseSupportVectors);
                    }
                    if (object.denseSupportVectors != null) {
                        if (typeof object.denseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.denseSupportVectors: object expected");
                        message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.fromObject(object.denseSupportVectors);
                    }
                    if (object.coefficients) {
                        if (!Array.isArray(object.coefficients))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.coefficients: array expected");
                        message.coefficients = [];
                        for (var i = 0; i < object.coefficients.length; ++i) {
                            if (typeof object.coefficients[i] !== "object")
                                throw TypeError(".CoreML.Specification.SupportVectorClassifier.coefficients: object expected");
                            message.coefficients[i] = $root.CoreML.Specification.Coefficients.fromObject(object.coefficients[i]);
                        }
                    }
                    if (object.rho) {
                        if (!Array.isArray(object.rho))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.rho: array expected");
                        message.rho = [];
                        for (var i = 0; i < object.rho.length; ++i)
                            message.rho[i] = Number(object.rho[i]);
                    }
                    if (object.probA) {
                        if (!Array.isArray(object.probA))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.probA: array expected");
                        message.probA = [];
                        for (var i = 0; i < object.probA.length; ++i)
                            message.probA[i] = Number(object.probA[i]);
                    }
                    if (object.probB) {
                        if (!Array.isArray(object.probB))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.probB: array expected");
                        message.probB = [];
                        for (var i = 0; i < object.probB.length; ++i)
                            message.probB[i] = Number(object.probB[i]);
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    return message;
                };
    
                SupportVectorClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.numberOfSupportVectorsPerClass = [];
                        object.coefficients = [];
                        object.rho = [];
                        object.probA = [];
                        object.probB = [];
                    }
                    if (options.defaults)
                        object.kernel = null;
                    if (message.kernel != null && message.hasOwnProperty("kernel"))
                        object.kernel = $root.CoreML.Specification.Kernel.toObject(message.kernel, options);
                    if (message.numberOfSupportVectorsPerClass && message.numberOfSupportVectorsPerClass.length) {
                        object.numberOfSupportVectorsPerClass = [];
                        for (var j = 0; j < message.numberOfSupportVectorsPerClass.length; ++j)
                            object.numberOfSupportVectorsPerClass[j] = message.numberOfSupportVectorsPerClass[j];
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        object.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.toObject(message.sparseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "sparseSupportVectors";
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        object.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.toObject(message.denseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "denseSupportVectors";
                    }
                    if (message.coefficients && message.coefficients.length) {
                        object.coefficients = [];
                        for (var j = 0; j < message.coefficients.length; ++j)
                            object.coefficients[j] = $root.CoreML.Specification.Coefficients.toObject(message.coefficients[j], options);
                    }
                    if (message.rho && message.rho.length) {
                        object.rho = [];
                        for (var j = 0; j < message.rho.length; ++j)
                            object.rho[j] = options.json && !isFinite(message.rho[j]) ? String(message.rho[j]) : message.rho[j];
                    }
                    if (message.probA && message.probA.length) {
                        object.probA = [];
                        for (var j = 0; j < message.probA.length; ++j)
                            object.probA[j] = options.json && !isFinite(message.probA[j]) ? String(message.probA[j]) : message.probA[j];
                    }
                    if (message.probB && message.probB.length) {
                        object.probB = [];
                        for (var j = 0; j < message.probB.length; ++j)
                            object.probB[j] = options.json && !isFinite(message.probB[j]) ? String(message.probB[j]) : message.probB[j];
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    return object;
                };
    
                SupportVectorClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SupportVectorClassifier;
            })();
    
            Specification.TreeEnsemblePostEvaluationTransform = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NoTransform"] = 0;
                values[valuesById[1] = "Classification_SoftMax"] = 1;
                values[valuesById[2] = "Regression_Logistic"] = 2;
                values[valuesById[3] = "Classification_SoftMaxWithZeroClassReference"] = 3;
                return values;
            })();
    
            Specification.TreeEnsembleParameters = (function() {
    
                function TreeEnsembleParameters(properties) {
                    this.nodes = [];
                    this.basePredictionValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                TreeEnsembleParameters.prototype.nodes = $util.emptyArray;
                TreeEnsembleParameters.prototype.numPredictionDimensions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                TreeEnsembleParameters.prototype.basePredictionValue = $util.emptyArray;
    
                TreeEnsembleParameters.create = function create(properties) {
                    return new TreeEnsembleParameters(properties);
                };
    
                TreeEnsembleParameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleParameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.CoreML.Specification.TreeEnsembleParameters.TreeNode.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.numPredictionDimensions = reader.uint64();
                            break;
                        case 3:
                            if (!(message.basePredictionValue && message.basePredictionValue.length))
                                message.basePredictionValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.basePredictionValue.push(reader.double());
                            } else
                                message.basePredictionValue.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                TreeEnsembleParameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (var i = 0; i < message.nodes.length; ++i) {
                            var error = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    if (message.numPredictionDimensions != null && message.hasOwnProperty("numPredictionDimensions"))
                        if (!$util.isInteger(message.numPredictionDimensions) && !(message.numPredictionDimensions && $util.isInteger(message.numPredictionDimensions.low) && $util.isInteger(message.numPredictionDimensions.high)))
                            return "numPredictionDimensions: integer|Long expected";
                    if (message.basePredictionValue != null && message.hasOwnProperty("basePredictionValue")) {
                        if (!Array.isArray(message.basePredictionValue))
                            return "basePredictionValue: array expected";
                        for (var i = 0; i < message.basePredictionValue.length; ++i)
                            if (typeof message.basePredictionValue[i] !== "number")
                                return "basePredictionValue: number[] expected";
                    }
                    return null;
                };
    
                TreeEnsembleParameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.TreeEnsembleParameters)
                        return object;
                    var message = new $root.CoreML.Specification.TreeEnsembleParameters();
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".CoreML.Specification.TreeEnsembleParameters.nodes: array expected");
                        message.nodes = [];
                        for (var i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".CoreML.Specification.TreeEnsembleParameters.nodes: object expected");
                            message.nodes[i] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.fromObject(object.nodes[i]);
                        }
                    }
                    if (object.numPredictionDimensions != null)
                        if ($util.Long)
                            (message.numPredictionDimensions = $util.Long.fromValue(object.numPredictionDimensions)).unsigned = true;
                        else if (typeof object.numPredictionDimensions === "string")
                            message.numPredictionDimensions = parseInt(object.numPredictionDimensions, 10);
                        else if (typeof object.numPredictionDimensions === "number")
                            message.numPredictionDimensions = object.numPredictionDimensions;
                        else if (typeof object.numPredictionDimensions === "object")
                            message.numPredictionDimensions = new $util.LongBits(object.numPredictionDimensions.low >>> 0, object.numPredictionDimensions.high >>> 0).toNumber(true);
                    if (object.basePredictionValue) {
                        if (!Array.isArray(object.basePredictionValue))
                            throw TypeError(".CoreML.Specification.TreeEnsembleParameters.basePredictionValue: array expected");
                        message.basePredictionValue = [];
                        for (var i = 0; i < object.basePredictionValue.length; ++i)
                            message.basePredictionValue[i] = Number(object.basePredictionValue[i]);
                    }
                    return message;
                };
    
                TreeEnsembleParameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.nodes = [];
                        object.basePredictionValue = [];
                    }
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.numPredictionDimensions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.numPredictionDimensions = options.longs === String ? "0" : 0;
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (var j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.toObject(message.nodes[j], options);
                    }
                    if (message.numPredictionDimensions != null && message.hasOwnProperty("numPredictionDimensions"))
                        if (typeof message.numPredictionDimensions === "number")
                            object.numPredictionDimensions = options.longs === String ? String(message.numPredictionDimensions) : message.numPredictionDimensions;
                        else
                            object.numPredictionDimensions = options.longs === String ? $util.Long.prototype.toString.call(message.numPredictionDimensions) : options.longs === Number ? new $util.LongBits(message.numPredictionDimensions.low >>> 0, message.numPredictionDimensions.high >>> 0).toNumber(true) : message.numPredictionDimensions;
                    if (message.basePredictionValue && message.basePredictionValue.length) {
                        object.basePredictionValue = [];
                        for (var j = 0; j < message.basePredictionValue.length; ++j)
                            object.basePredictionValue[j] = options.json && !isFinite(message.basePredictionValue[j]) ? String(message.basePredictionValue[j]) : message.basePredictionValue[j];
                    }
                    return object;
                };
    
                TreeEnsembleParameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                TreeEnsembleParameters.TreeNode = (function() {
    
                    function TreeNode(properties) {
                        this.evaluationInfo = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    TreeNode.prototype.treeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    TreeNode.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    TreeNode.prototype.nodeBehavior = 0;
                    TreeNode.prototype.branchFeatureIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    TreeNode.prototype.branchFeatureValue = 0;
                    TreeNode.prototype.trueChildNodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    TreeNode.prototype.falseChildNodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                    TreeNode.prototype.missingValueTracksTrueChild = false;
                    TreeNode.prototype.evaluationInfo = $util.emptyArray;
                    TreeNode.prototype.relativeHitRate = 0;
    
                    TreeNode.create = function create(properties) {
                        return new TreeNode(properties);
                    };
    
                    TreeNode.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.treeId = reader.uint64();
                                break;
                            case 2:
                                message.nodeId = reader.uint64();
                                break;
                            case 3:
                                message.nodeBehavior = reader.int32();
                                break;
                            case 10:
                                message.branchFeatureIndex = reader.uint64();
                                break;
                            case 11:
                                message.branchFeatureValue = reader.double();
                                break;
                            case 12:
                                message.trueChildNodeId = reader.uint64();
                                break;
                            case 13:
                                message.falseChildNodeId = reader.uint64();
                                break;
                            case 14:
                                message.missingValueTracksTrueChild = reader.bool();
                                break;
                            case 20:
                                if (!(message.evaluationInfo && message.evaluationInfo.length))
                                    message.evaluationInfo = [];
                                message.evaluationInfo.push($root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.decode(reader, reader.uint32()));
                                break;
                            case 30:
                                message.relativeHitRate = reader.double();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    TreeNode.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.treeId != null && message.hasOwnProperty("treeId"))
                            if (!$util.isInteger(message.treeId) && !(message.treeId && $util.isInteger(message.treeId.low) && $util.isInteger(message.treeId.high)))
                                return "treeId: integer|Long expected";
                        if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                            if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
                                return "nodeId: integer|Long expected";
                        if (message.nodeBehavior != null && message.hasOwnProperty("nodeBehavior"))
                            switch (message.nodeBehavior) {
                            default:
                                return "nodeBehavior: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.branchFeatureIndex != null && message.hasOwnProperty("branchFeatureIndex"))
                            if (!$util.isInteger(message.branchFeatureIndex) && !(message.branchFeatureIndex && $util.isInteger(message.branchFeatureIndex.low) && $util.isInteger(message.branchFeatureIndex.high)))
                                return "branchFeatureIndex: integer|Long expected";
                        if (message.branchFeatureValue != null && message.hasOwnProperty("branchFeatureValue"))
                            if (typeof message.branchFeatureValue !== "number")
                                return "branchFeatureValue: number expected";
                        if (message.trueChildNodeId != null && message.hasOwnProperty("trueChildNodeId"))
                            if (!$util.isInteger(message.trueChildNodeId) && !(message.trueChildNodeId && $util.isInteger(message.trueChildNodeId.low) && $util.isInteger(message.trueChildNodeId.high)))
                                return "trueChildNodeId: integer|Long expected";
                        if (message.falseChildNodeId != null && message.hasOwnProperty("falseChildNodeId"))
                            if (!$util.isInteger(message.falseChildNodeId) && !(message.falseChildNodeId && $util.isInteger(message.falseChildNodeId.low) && $util.isInteger(message.falseChildNodeId.high)))
                                return "falseChildNodeId: integer|Long expected";
                        if (message.missingValueTracksTrueChild != null && message.hasOwnProperty("missingValueTracksTrueChild"))
                            if (typeof message.missingValueTracksTrueChild !== "boolean")
                                return "missingValueTracksTrueChild: boolean expected";
                        if (message.evaluationInfo != null && message.hasOwnProperty("evaluationInfo")) {
                            if (!Array.isArray(message.evaluationInfo))
                                return "evaluationInfo: array expected";
                            for (var i = 0; i < message.evaluationInfo.length; ++i) {
                                var error = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.verify(message.evaluationInfo[i]);
                                if (error)
                                    return "evaluationInfo." + error;
                            }
                        }
                        if (message.relativeHitRate != null && message.hasOwnProperty("relativeHitRate"))
                            if (typeof message.relativeHitRate !== "number")
                                return "relativeHitRate: number expected";
                        return null;
                    };
    
                    TreeNode.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.TreeEnsembleParameters.TreeNode)
                            return object;
                        var message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode();
                        if (object.treeId != null)
                            if ($util.Long)
                                (message.treeId = $util.Long.fromValue(object.treeId)).unsigned = true;
                            else if (typeof object.treeId === "string")
                                message.treeId = parseInt(object.treeId, 10);
                            else if (typeof object.treeId === "number")
                                message.treeId = object.treeId;
                            else if (typeof object.treeId === "object")
                                message.treeId = new $util.LongBits(object.treeId.low >>> 0, object.treeId.high >>> 0).toNumber(true);
                        if (object.nodeId != null)
                            if ($util.Long)
                                (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = true;
                            else if (typeof object.nodeId === "string")
                                message.nodeId = parseInt(object.nodeId, 10);
                            else if (typeof object.nodeId === "number")
                                message.nodeId = object.nodeId;
                            else if (typeof object.nodeId === "object")
                                message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber(true);
                        switch (object.nodeBehavior) {
                        case "BranchOnValueLessThanEqual":
                        case 0:
                            message.nodeBehavior = 0;
                            break;
                        case "BranchOnValueLessThan":
                        case 1:
                            message.nodeBehavior = 1;
                            break;
                        case "BranchOnValueGreaterThanEqual":
                        case 2:
                            message.nodeBehavior = 2;
                            break;
                        case "BranchOnValueGreaterThan":
                        case 3:
                            message.nodeBehavior = 3;
                            break;
                        case "BranchOnValueEqual":
                        case 4:
                            message.nodeBehavior = 4;
                            break;
                        case "BranchOnValueNotEqual":
                        case 5:
                            message.nodeBehavior = 5;
                            break;
                        case "LeafNode":
                        case 6:
                            message.nodeBehavior = 6;
                            break;
                        }
                        if (object.branchFeatureIndex != null)
                            if ($util.Long)
                                (message.branchFeatureIndex = $util.Long.fromValue(object.branchFeatureIndex)).unsigned = true;
                            else if (typeof object.branchFeatureIndex === "string")
                                message.branchFeatureIndex = parseInt(object.branchFeatureIndex, 10);
                            else if (typeof object.branchFeatureIndex === "number")
                                message.branchFeatureIndex = object.branchFeatureIndex;
                            else if (typeof object.branchFeatureIndex === "object")
                                message.branchFeatureIndex = new $util.LongBits(object.branchFeatureIndex.low >>> 0, object.branchFeatureIndex.high >>> 0).toNumber(true);
                        if (object.branchFeatureValue != null)
                            message.branchFeatureValue = Number(object.branchFeatureValue);
                        if (object.trueChildNodeId != null)
                            if ($util.Long)
                                (message.trueChildNodeId = $util.Long.fromValue(object.trueChildNodeId)).unsigned = true;
                            else if (typeof object.trueChildNodeId === "string")
                                message.trueChildNodeId = parseInt(object.trueChildNodeId, 10);
                            else if (typeof object.trueChildNodeId === "number")
                                message.trueChildNodeId = object.trueChildNodeId;
                            else if (typeof object.trueChildNodeId === "object")
                                message.trueChildNodeId = new $util.LongBits(object.trueChildNodeId.low >>> 0, object.trueChildNodeId.high >>> 0).toNumber(true);
                        if (object.falseChildNodeId != null)
                            if ($util.Long)
                                (message.falseChildNodeId = $util.Long.fromValue(object.falseChildNodeId)).unsigned = true;
                            else if (typeof object.falseChildNodeId === "string")
                                message.falseChildNodeId = parseInt(object.falseChildNodeId, 10);
                            else if (typeof object.falseChildNodeId === "number")
                                message.falseChildNodeId = object.falseChildNodeId;
                            else if (typeof object.falseChildNodeId === "object")
                                message.falseChildNodeId = new $util.LongBits(object.falseChildNodeId.low >>> 0, object.falseChildNodeId.high >>> 0).toNumber(true);
                        if (object.missingValueTracksTrueChild != null)
                            message.missingValueTracksTrueChild = Boolean(object.missingValueTracksTrueChild);
                        if (object.evaluationInfo) {
                            if (!Array.isArray(object.evaluationInfo))
                                throw TypeError(".CoreML.Specification.TreeEnsembleParameters.TreeNode.evaluationInfo: array expected");
                            message.evaluationInfo = [];
                            for (var i = 0; i < object.evaluationInfo.length; ++i) {
                                if (typeof object.evaluationInfo[i] !== "object")
                                    throw TypeError(".CoreML.Specification.TreeEnsembleParameters.TreeNode.evaluationInfo: object expected");
                                message.evaluationInfo[i] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.fromObject(object.evaluationInfo[i]);
                            }
                        }
                        if (object.relativeHitRate != null)
                            message.relativeHitRate = Number(object.relativeHitRate);
                        return message;
                    };
    
                    TreeNode.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.evaluationInfo = [];
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.treeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.treeId = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nodeId = options.longs === String ? "0" : 0;
                            object.nodeBehavior = options.enums === String ? "BranchOnValueLessThanEqual" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.branchFeatureIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.branchFeatureIndex = options.longs === String ? "0" : 0;
                            object.branchFeatureValue = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.trueChildNodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.trueChildNodeId = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.falseChildNodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.falseChildNodeId = options.longs === String ? "0" : 0;
                            object.missingValueTracksTrueChild = false;
                            object.relativeHitRate = 0;
                        }
                        if (message.treeId != null && message.hasOwnProperty("treeId"))
                            if (typeof message.treeId === "number")
                                object.treeId = options.longs === String ? String(message.treeId) : message.treeId;
                            else
                                object.treeId = options.longs === String ? $util.Long.prototype.toString.call(message.treeId) : options.longs === Number ? new $util.LongBits(message.treeId.low >>> 0, message.treeId.high >>> 0).toNumber(true) : message.treeId;
                        if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                            if (typeof message.nodeId === "number")
                                object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
                            else
                                object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber(true) : message.nodeId;
                        if (message.nodeBehavior != null && message.hasOwnProperty("nodeBehavior"))
                            object.nodeBehavior = options.enums === String ? $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.TreeNodeBehavior[message.nodeBehavior] : message.nodeBehavior;
                        if (message.branchFeatureIndex != null && message.hasOwnProperty("branchFeatureIndex"))
                            if (typeof message.branchFeatureIndex === "number")
                                object.branchFeatureIndex = options.longs === String ? String(message.branchFeatureIndex) : message.branchFeatureIndex;
                            else
                                object.branchFeatureIndex = options.longs === String ? $util.Long.prototype.toString.call(message.branchFeatureIndex) : options.longs === Number ? new $util.LongBits(message.branchFeatureIndex.low >>> 0, message.branchFeatureIndex.high >>> 0).toNumber(true) : message.branchFeatureIndex;
                        if (message.branchFeatureValue != null && message.hasOwnProperty("branchFeatureValue"))
                            object.branchFeatureValue = options.json && !isFinite(message.branchFeatureValue) ? String(message.branchFeatureValue) : message.branchFeatureValue;
                        if (message.trueChildNodeId != null && message.hasOwnProperty("trueChildNodeId"))
                            if (typeof message.trueChildNodeId === "number")
                                object.trueChildNodeId = options.longs === String ? String(message.trueChildNodeId) : message.trueChildNodeId;
                            else
                                object.trueChildNodeId = options.longs === String ? $util.Long.prototype.toString.call(message.trueChildNodeId) : options.longs === Number ? new $util.LongBits(message.trueChildNodeId.low >>> 0, message.trueChildNodeId.high >>> 0).toNumber(true) : message.trueChildNodeId;
                        if (message.falseChildNodeId != null && message.hasOwnProperty("falseChildNodeId"))
                            if (typeof message.falseChildNodeId === "number")
                                object.falseChildNodeId = options.longs === String ? String(message.falseChildNodeId) : message.falseChildNodeId;
                            else
                                object.falseChildNodeId = options.longs === String ? $util.Long.prototype.toString.call(message.falseChildNodeId) : options.longs === Number ? new $util.LongBits(message.falseChildNodeId.low >>> 0, message.falseChildNodeId.high >>> 0).toNumber(true) : message.falseChildNodeId;
                        if (message.missingValueTracksTrueChild != null && message.hasOwnProperty("missingValueTracksTrueChild"))
                            object.missingValueTracksTrueChild = message.missingValueTracksTrueChild;
                        if (message.evaluationInfo && message.evaluationInfo.length) {
                            object.evaluationInfo = [];
                            for (var j = 0; j < message.evaluationInfo.length; ++j)
                                object.evaluationInfo[j] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.toObject(message.evaluationInfo[j], options);
                        }
                        if (message.relativeHitRate != null && message.hasOwnProperty("relativeHitRate"))
                            object.relativeHitRate = options.json && !isFinite(message.relativeHitRate) ? String(message.relativeHitRate) : message.relativeHitRate;
                        return object;
                    };
    
                    TreeNode.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    TreeNode.TreeNodeBehavior = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "BranchOnValueLessThanEqual"] = 0;
                        values[valuesById[1] = "BranchOnValueLessThan"] = 1;
                        values[valuesById[2] = "BranchOnValueGreaterThanEqual"] = 2;
                        values[valuesById[3] = "BranchOnValueGreaterThan"] = 3;
                        values[valuesById[4] = "BranchOnValueEqual"] = 4;
                        values[valuesById[5] = "BranchOnValueNotEqual"] = 5;
                        values[valuesById[6] = "LeafNode"] = 6;
                        return values;
                    })();
    
                    TreeNode.EvaluationInfo = (function() {
    
                        function EvaluationInfo(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        EvaluationInfo.prototype.evaluationIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
                        EvaluationInfo.prototype.evaluationValue = 0;
    
                        EvaluationInfo.create = function create(properties) {
                            return new EvaluationInfo(properties);
                        };
    
                        EvaluationInfo.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.evaluationIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.evaluationValue = reader.double();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        EvaluationInfo.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.evaluationIndex != null && message.hasOwnProperty("evaluationIndex"))
                                if (!$util.isInteger(message.evaluationIndex) && !(message.evaluationIndex && $util.isInteger(message.evaluationIndex.low) && $util.isInteger(message.evaluationIndex.high)))
                                    return "evaluationIndex: integer|Long expected";
                            if (message.evaluationValue != null && message.hasOwnProperty("evaluationValue"))
                                if (typeof message.evaluationValue !== "number")
                                    return "evaluationValue: number expected";
                            return null;
                        };
    
                        EvaluationInfo.fromObject = function fromObject(object) {
                            if (object instanceof $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo)
                                return object;
                            var message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo();
                            if (object.evaluationIndex != null)
                                if ($util.Long)
                                    (message.evaluationIndex = $util.Long.fromValue(object.evaluationIndex)).unsigned = true;
                                else if (typeof object.evaluationIndex === "string")
                                    message.evaluationIndex = parseInt(object.evaluationIndex, 10);
                                else if (typeof object.evaluationIndex === "number")
                                    message.evaluationIndex = object.evaluationIndex;
                                else if (typeof object.evaluationIndex === "object")
                                    message.evaluationIndex = new $util.LongBits(object.evaluationIndex.low >>> 0, object.evaluationIndex.high >>> 0).toNumber(true);
                            if (object.evaluationValue != null)
                                message.evaluationValue = Number(object.evaluationValue);
                            return message;
                        };
    
                        EvaluationInfo.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.evaluationIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.evaluationIndex = options.longs === String ? "0" : 0;
                                object.evaluationValue = 0;
                            }
                            if (message.evaluationIndex != null && message.hasOwnProperty("evaluationIndex"))
                                if (typeof message.evaluationIndex === "number")
                                    object.evaluationIndex = options.longs === String ? String(message.evaluationIndex) : message.evaluationIndex;
                                else
                                    object.evaluationIndex = options.longs === String ? $util.Long.prototype.toString.call(message.evaluationIndex) : options.longs === Number ? new $util.LongBits(message.evaluationIndex.low >>> 0, message.evaluationIndex.high >>> 0).toNumber(true) : message.evaluationIndex;
                            if (message.evaluationValue != null && message.hasOwnProperty("evaluationValue"))
                                object.evaluationValue = options.json && !isFinite(message.evaluationValue) ? String(message.evaluationValue) : message.evaluationValue;
                            return object;
                        };
    
                        EvaluationInfo.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return EvaluationInfo;
                    })();
    
                    return TreeNode;
                })();
    
                return TreeEnsembleParameters;
            })();
    
            Specification.TreeEnsembleClassifier = (function() {
    
                function TreeEnsembleClassifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                TreeEnsembleClassifier.prototype.treeEnsemble = null;
                TreeEnsembleClassifier.prototype.postEvaluationTransform = 0;
                TreeEnsembleClassifier.prototype.stringClassLabels = null;
                TreeEnsembleClassifier.prototype.int64ClassLabels = null;
    
                var $oneOfFields;
    
                Object.defineProperty(TreeEnsembleClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                TreeEnsembleClassifier.create = function create(properties) {
                    return new TreeEnsembleClassifier(properties);
                };
    
                TreeEnsembleClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                TreeEnsembleClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble")) {
                        var error = $root.CoreML.Specification.TreeEnsembleParameters.verify(message.treeEnsemble);
                        if (error)
                            return "treeEnsemble." + error;
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    return null;
                };
    
                TreeEnsembleClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.TreeEnsembleClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.TreeEnsembleClassifier();
                    if (object.treeEnsemble != null) {
                        if (typeof object.treeEnsemble !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleClassifier.treeEnsemble: object expected");
                        message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.fromObject(object.treeEnsemble);
                    }
                    switch (object.postEvaluationTransform) {
                    case "NoTransform":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Classification_SoftMax":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    case "Regression_Logistic":
                    case 2:
                        message.postEvaluationTransform = 2;
                        break;
                    case "Classification_SoftMaxWithZeroClassReference":
                    case 3:
                        message.postEvaluationTransform = 3;
                        break;
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    return message;
                };
    
                TreeEnsembleClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.treeEnsemble = null;
                        object.postEvaluationTransform = options.enums === String ? "NoTransform" : 0;
                    }
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble"))
                        object.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.toObject(message.treeEnsemble, options);
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.TreeEnsemblePostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    return object;
                };
    
                TreeEnsembleClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return TreeEnsembleClassifier;
            })();
    
            Specification.TreeEnsembleRegressor = (function() {
    
                function TreeEnsembleRegressor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                TreeEnsembleRegressor.prototype.treeEnsemble = null;
                TreeEnsembleRegressor.prototype.postEvaluationTransform = 0;
    
                TreeEnsembleRegressor.create = function create(properties) {
                    return new TreeEnsembleRegressor(properties);
                };
    
                TreeEnsembleRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                TreeEnsembleRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble")) {
                        var error = $root.CoreML.Specification.TreeEnsembleParameters.verify(message.treeEnsemble);
                        if (error)
                            return "treeEnsemble." + error;
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };
    
                TreeEnsembleRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.TreeEnsembleRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.TreeEnsembleRegressor();
                    if (object.treeEnsemble != null) {
                        if (typeof object.treeEnsemble !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleRegressor.treeEnsemble: object expected");
                        message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.fromObject(object.treeEnsemble);
                    }
                    switch (object.postEvaluationTransform) {
                    case "NoTransform":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Classification_SoftMax":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    case "Regression_Logistic":
                    case 2:
                        message.postEvaluationTransform = 2;
                        break;
                    case "Classification_SoftMaxWithZeroClassReference":
                    case 3:
                        message.postEvaluationTransform = 3;
                        break;
                    }
                    return message;
                };
    
                TreeEnsembleRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.treeEnsemble = null;
                        object.postEvaluationTransform = options.enums === String ? "NoTransform" : 0;
                    }
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble"))
                        object.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.toObject(message.treeEnsemble, options);
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.TreeEnsemblePostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    return object;
                };
    
                TreeEnsembleRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return TreeEnsembleRegressor;
            })();
    
            return Specification;
        })();
    
        return CoreML;
    })();

    return $root;
})(protobuf);
