[
  {
    "name": "Abort",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "A string which is the message associated with the exception.",
          "name": "error_msg",
          "type": "string"
        },
        {
          "default": false,
          "name": "exit_without_error",
          "type": "bool"
        }
      ],
      "description": "If exit_without_error is true, the process will exit normally,\notherwise it will exit with a SIGABORT signal.\n\nReturns nothing but an exception.",
      "summary": "Raise a exception to abort the process when called."
    }
  },
  {
    "name": "Abs",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `x`, this operation returns a tensor containing the absolute\nvalue of each element in `x`. For example, if x is an input element and y is\nan output element, this operation computes \\\\(y = |x|\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the absolute value of a tensor."
    }
  },
  {
    "name": "AccumulateNV2",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "Shape of elements of `inputs`.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "`tf.accumulate_n_v2` performs the same operation as `tf.add_n`, but does not\nwait for all of its inputs to be ready before beginning to sum. This can\nsave memory if inputs are ready at different times, since minimum temporary\nstorage is proportional to the output size rather than the inputs size.\n\nUnlike the original `accumulate_n`, `accumulate_n_v2` is differentiable.\n\nReturns a `Tensor` of same shape and type as the elements of `inputs`.",
      "inputs": [
        {
          "description": "A list of `Tensor` objects, each with same shape and type.",
          "name": "inputs",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "sum",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the element-wise sum of a list of tensors."
    }
  },
  {
    "name": "AccumulatorApplyGradient",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Does not add if local_step is lesser than the accumulator's global_step.",
      "inputs": [
        {
          "description": "The handle to a accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "The local_step value at which the gradient was computed.",
          "name": "local_step",
          "type": 9
        },
        {
          "description": "A tensor of the gradient to be accumulated.",
          "name": "gradient",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Applies a gradient to a given accumulator."
    }
  },
  {
    "name": "AccumulatorNumAccumulated",
    "schema": {
      "inputs": [
        {
          "description": "The handle to an accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of gradients aggregated in the given accumulator.",
          "name": "num_accumulated",
          "type": 3
        }
      ],
      "summary": "Returns the number of gradients aggregated in the given accumulators."
    }
  },
  {
    "name": "AccumulatorSetGlobalStep",
    "schema": {
      "description": "Logs warning if the accumulator's value is already higher than\nnew_global_step.",
      "inputs": [
        {
          "description": "The handle to an accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "The new global_step value to set.",
          "name": "new_global_step",
          "type": 9
        }
      ],
      "summary": "Updates the accumulator with a new value for global_step."
    }
  },
  {
    "name": "AccumulatorTakeGradient",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The op blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated.  If the accumulator has already\naggregated more than num_required gradients, it returns the average of\nthe accumulated gradients.  Also automatically increments the recorded\nglobal_step in the accumulator by 1, and resets the aggregate to 0.",
      "inputs": [
        {
          "description": "The handle to an accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "Number of gradients required before we return an aggregate.",
          "name": "num_required",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The average of the accumulated gradients.",
          "name": "average",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Extracts the average gradient in the given ConditionalAccumulator."
    }
  },
  {
    "name": "Acos",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes acos of x element-wise."
    }
  },
  {
    "name": "Acosh",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes inverse hyperbolic cosine of x element-wise."
    }
  },
  {
    "name": "Add",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x + y element-wise."
    }
  },
  {
    "name": "AddManySparseToTensorsMap",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "description": "The container name for the `SparseTensorsMap` created by this op.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "The shared name for the `SparseTensorsMap` created by this op.\nIf blank, the new Operation's unique name is used.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A `SparseTensor` of rank `R` is represented by three tensors: `sparse_indices`,\n`sparse_values`, and `sparse_shape`, where\n\n```sparse_indices.shape[1] == sparse_shape.shape[0] == R```\n\nAn `N`-minibatch of `SparseTensor` objects is represented as a `SparseTensor`\nhaving a first `sparse_indices` column taking values between `[0, N)`, where\nthe minibatch size `N == sparse_shape[0]`.\n\nThe input `SparseTensor` must have rank `R` greater than 1, and the first\ndimension is treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The stored\n`SparseTensor` objects pointed to by each row of the output `sparse_handles`\nwill have rank `R-1`.\n\nThe `SparseTensor` values can then be read out as part of a minibatch by passing\nthe given keys as vector elements to `TakeManySparseFromTensorsMap`.  To ensure\nthe correct `SparseTensorsMap` is accessed, ensure that the same\n`container` and `shared_name` are passed to that Op.  If no `shared_name`\nis provided here, instead use the *name* of the Operation created by calling\n`AddManySparseToTensorsMap` as the `shared_name` passed to\n`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the minibatch `SparseTensor`.\n`sparse_indices[:, 0]` must be ordered values in `[0, N)`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
          "name": "sparse_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the minibatch `SparseTensor`.\nThe minibatch size `N == sparse_shape[0]`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The handles of the `SparseTensor` now stored in the\n`SparseTensorsMap`.  Shape: `[N]`.",
          "name": "sparse_handles",
          "type": 9
        }
      ],
      "summary": "Add an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N` handles."
    }
  },
  {
    "name": "AddN",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            },
            {
              "type": "type",
              "value": 21
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Must all be the same size and shape.",
          "name": "inputs",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "sum",
          "typeAttr": "T"
        }
      ],
      "summary": "Add all input tensors element wise."
    }
  },
  {
    "name": "AddSparseToTensorsMap",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "description": "The container name for the `SparseTensorsMap` created by this op.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "The shared name for the `SparseTensorsMap` created by this op.\nIf blank, the new Operation's unique name is used.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A `SparseTensor` is represented by three tensors: `sparse_indices`,\n`sparse_values`, and `sparse_shape`.\n\nThis operator takes the given `SparseTensor` and adds it to a container\nobject (a `SparseTensorsMap`).  A unique key within this container is generated\nin the form of an `int64`, and this is the value that is returned.\n\nThe `SparseTensor` can then be read out as part of a minibatch by passing\nthe key as a vector element to `TakeManySparseFromTensorsMap`.  To ensure\nthe correct `SparseTensorsMap` is accessed, ensure that the same\n`container` and `shared_name` are passed to that Op.  If no `shared_name`\nis provided here, instead use the *name* of the Operation created by calling\n`AddSparseToTensorsMap` as the `shared_name` passed to\n`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`.",
          "name": "sparse_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "0-D.  The handle of the `SparseTensor` now stored in the\n`SparseTensorsMap`.",
          "name": "sparse_handle",
          "type": 9
        }
      ],
      "summary": "Add a `SparseTensor` to a `SparseTensorsMap` return its handle."
    }
  },
  {
    "name": "AddV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x + y element-wise."
    }
  },
  {
    "name": "AdjustContrast",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "images",
          "typeAttr": "T"
        },
        {
          "name": "contrast_factor",
          "type": 1
        },
        {
          "name": "min_value",
          "type": 1
        },
        {
          "name": "max_value",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Deprecated. Disallowed in GraphDef version >= 2."
    }
  },
  {
    "name": "AdjustContrastv2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`images` is a tensor of at least 3 dimensions.  The last 3 dimensions are\ninterpreted as `[height, width, channels]`.  The other dimensions only\nrepresent a collection of images, such as `[batch, height, width, channels].`\n\nContrast is adjusted independently for each channel of each image.\n\nFor each channel, the Op first computes the mean of the image pixels in the\nchannel and then adjusts each component of each pixel to\n`(x - mean) * contrast_factor + mean`.",
      "inputs": [
        {
          "description": "Images to adjust.  At least 3-D.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "A float multiplier for adjusting contrast.",
          "name": "contrast_factor",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The contrast-adjusted image or images.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adjust the contrast of one or more images."
    }
  },
  {
    "name": "AdjustHue",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`images` is a tensor of at least 3 dimensions.  The last dimension is\ninterpretted as channels, and must be three.\n\nThe input image is considered in the RGB colorspace. Conceptually, the RGB\ncolors are first mapped into HSV. A delta is then applied all the hue values,\nand then remapped back to RGB colorspace.",
      "inputs": [
        {
          "description": "Images to adjust.  At least 3-D.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "A float delta to add to the hue.",
          "name": "delta",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The hue-adjusted image or images.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adjust the hue of one or more images."
    }
  },
  {
    "name": "AdjustSaturation",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`images` is a tensor of at least 3 dimensions.  The last dimension is\ninterpretted as channels, and must be three.\n\nThe input image is considered in the RGB colorspace. Conceptually, the RGB\ncolors are first mapped into HSV. A scale is then applied all the saturation\nvalues, and then remapped back to RGB colorspace.",
      "inputs": [
        {
          "description": "Images to adjust.  At least 3-D.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "A float scale to add to the saturation.",
          "name": "scale",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The hue-adjusted image or images.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adjust the saturation of one or more images."
    }
  },
  {
    "name": "All",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 10
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Computes the \"logical and\" of elements across dimensions of a tensor."
    }
  },
  {
    "name": "AllCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "minimum": 1,
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to produce.",
          "minimum": 1,
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "Angle",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the argument of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part.\n\nThe argument returned by this operation is of the form \\\\(atan2(b, a)\\\\).\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.angle(input) ==> [2.0132, 1.056]\n```\n\n@compatibility(numpy)\nEquivalent to np.angle.\n@end_compatibility",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Returns the argument of a complex number."
    }
  },
  {
    "name": "AnonymousIterator",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "outputs": [
        {
          "description": "A handle to the iterator that can be passed to a \"MakeIterator\" or\n\"IteratorGetNext\" op. In contrast to Iterator, AnonymousIterator prevents\nresource sharing by name, and does not keep a reference to the resource\ncontainer.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A container for an iterator resource."
    }
  },
  {
    "name": "Any",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 10
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Computes the \"logical or\" of elements across dimensions of a tensor."
    }
  },
  {
    "name": "ApplyAdaMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nv_t <- max(beta2 * v_{t-1}, abs(g))\nvariable <- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "m",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "v",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the AdaMax algorithm."
    }
  },
  {
    "name": "ApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum_update",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the adadelta scheme."
    }
  },
  {
    "name": "ApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": true,
          "name": "update_slots",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the adagrad scheme."
    }
  },
  {
    "name": "ApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "gradient_accumulator",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "gradient_squared_accumulator",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "ApplyAdam",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, uses the nesterov update.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "$$lr_t := \\text{learning\\_rate} * \\sqrt{1 - beta_2^t} / (1 - beta_1^t)$$\n$$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$\n$$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$\n$$variable := variable - lr_t * m_t / (\\sqrt{v_t} + \\epsilon)$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "m",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "v",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta2_power",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Adam algorithm."
    }
  },
  {
    "name": "ApplyAddSign",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- (alpha + sign_decay * sign(g) *sign(m)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "m",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\n\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nmg <- rho * mg_{t-1} + (1-rho) * grad\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "mg",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "ms",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "mom",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "ApplyFtrl",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "linear",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regulariation. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "grad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "linear",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "name": "l2_shrinkage",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ApplyGradientDescent",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "The change.",
          "name": "delta",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' by subtracting 'alpha' * 'delta' from it."
    }
  },
  {
    "name": "ApplyMomentum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "want to use Nesterov momentum.\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the momentum scheme. Set use_nesterov = True if you"
    }
  },
  {
    "name": "ApplyPowerSign",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "m",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "logbase",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nprox_v = var - lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' and '*accum' according to FOBOS with Adagrad learning rate."
    }
  },
  {
    "name": "ApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "prox_v = var - alpha * delta\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The change.",
          "name": "delta",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "ApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "ms",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "mom",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "ApproximateEqual",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": 9.999999747378752e-06,
          "name": "tolerance",
          "type": "float"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of abs(x-y) < tolerance element-wise."
    }
  },
  {
    "name": "ArgMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "output_type",
          "type": "type"
        }
      ],
      "description": "Note that in case of ties the identity of the return value is not guaranteed.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "int32 or int64, must be in the range `[-rank(input), rank(input))`.\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0.",
          "name": "dimension",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "output_type"
        }
      ],
      "summary": "Returns the index with the largest value across dimensions of a tensor."
    }
  },
  {
    "name": "ArgMin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "output_type",
          "type": "type"
        }
      ],
      "description": "Note that in case of ties the identity of the return value is not guaranteed.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "int32 or int64, must be in the range `[-rank(input), rank(input))`.\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0.",
          "name": "dimension",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "output_type"
        }
      ],
      "summary": "Returns the index with the smallest value across dimensions of a tensor."
    }
  },
  {
    "name": "AsString",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 10
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": -1,
          "description": "The post-decimal precision to use for floating point numbers.\nOnly used if precision > -1.",
          "name": "precision",
          "type": "int"
        },
        {
          "default": false,
          "description": "Use scientific notation for floating point numbers.",
          "name": "scientific",
          "type": "bool"
        },
        {
          "default": false,
          "description": "Use shortest representation (either scientific or standard) for\nfloating point numbers.",
          "name": "shortest",
          "type": "bool"
        },
        {
          "default": -1,
          "description": "Pad pre-decimal numbers to this width.\nApplies to both floating point and integer numbers.\nOnly used if width > -1.",
          "name": "width",
          "type": "int"
        },
        {
          "default": "",
          "description": "The value to pad if width > -1.  If empty, pads with spaces.\nAnother typical value is '0'.  String cannot be longer than 1 character.",
          "name": "fill",
          "type": "string"
        }
      ],
      "description": "types and boolean.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Converts each entry in the given tensor to strings.  Supports many numeric"
    }
  },
  {
    "name": "Asin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes asin of x element-wise."
    }
  },
  {
    "name": "Asinh",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes inverse hyperbolic sine of x element-wise."
    }
  },
  {
    "name": "Assert",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "T",
          "type": "list(type)"
        },
        {
          "default": 3,
          "description": "Print this many entries of each tensor.",
          "name": "summarize",
          "type": "int"
        }
      ],
      "description": "If `condition` evaluates to false, print the list of tensors in `data`.\n`summarize` determines how many entries of the tensors to print.",
      "inputs": [
        {
          "description": "The condition to evaluate.",
          "name": "condition",
          "type": 10
        },
        {
          "description": "The tensors to print out when condition is false.",
          "name": "data",
          "typeListAttr": "T"
        }
      ],
      "summary": "Asserts that the given condition is true."
    }
  },
  {
    "name": "Assign",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": true,
          "description": "If true, the operation will validate that the shape\nof 'value' matches the shape of the Tensor being assigned to.  If false,\n'ref' will take on the shape of 'value'.",
          "name": "validate_shape",
          "type": "bool"
        },
        {
          "default": true,
          "description": "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "category": "Control",
      "description": "This operation outputs \"ref\" after the assignment is done.\nThis makes it easier to chain operations that need to use the reset value.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node. May be uninitialized.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "The value to be assigned to the variable.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been reset.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Update 'ref' by assigning 'value' to it."
    }
  },
  {
    "name": "AssignAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "The value to be added to the variable.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Update 'ref' by adding 'value' to it."
    }
  },
  {
    "name": "AssignAddVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to\nsee the incremented value or a subsequent newer one.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "the value by which the variable will be incremented.",
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Adds a value to the current value of a variable."
    }
  },
  {
    "name": "AssignSub",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "The value to be subtracted to the variable.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Update 'ref' by subtracting 'value' from it."
    }
  },
  {
    "name": "AssignSubVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to\nsee the decremented value or a subsequent newer one.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "the value by which the variable will be incremented.",
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Subtracts a value from the current value of a variable."
    }
  },
  {
    "name": "AssignVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to return\nthis value or a subsequent newer value of the variable.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "the value to set the new tensor to use.",
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Assigns a new value to a variable."
    }
  },
  {
    "name": "Atan",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes atan of x element-wise."
    }
  },
  {
    "name": "Atan2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is the angle \\( \\theta \\in [-\\pi, \\pi] \\) such that\n\\[ x = r \\cos(\\theta) \\]\nand\n\\[ y = r \\sin(\\theta) \\]\nwhere \\(r = \\sqrt(x^2 + y^2) \\).",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes arctangent of `y/x` element-wise, respecting signs of the arguments."
    }
  },
  {
    "name": "Atanh",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes inverse hyperbolic tangent of x element-wise."
    }
  },
  {
    "name": "AudioSpectrogram",
    "schema": {
      "attributes": [
        {
          "description": "How wide the input window is in samples. For the highest efficiency\nthis should be a power of two, but other values are accepted.",
          "name": "window_size",
          "type": "int"
        },
        {
          "description": "How widely apart the center of adjacent sample windows should be.",
          "name": "stride",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether to return the squared magnitude or just the\nmagnitude. Using squared magnitude can avoid extra calculations.",
          "name": "magnitude_squared",
          "type": "bool"
        }
      ],
      "description": "Spectrograms are a standard way of representing audio information as a series of\nslices of frequency information, one slice for each window of time. By joining\nthese together into a sequence, they form a distinctive fingerprint of the sound\nover time.\n\nThis op expects to receive audio data as an input, stored as floats in the range\n-1 to 1, together with a window width in samples, and a stride specifying how\nfar to move the window between slices. From this it generates a three\ndimensional output. The lowest dimension has an amplitude value for each\nfrequency during that time slice. The next dimension is time, with successive\nfrequency slices. The final dimension is for the channels in the input, so a\nstereo audio input would have two here for example.\n\nThis means the layout when converted and saved as an image is rotated 90 degrees\nclockwise from a typical spectrogram. Time is descending down the Y axis, and\nthe frequency decreases from left to right.\n\nEach value in the result represents the square root of the sum of the real and\nimaginary parts of an FFT on the current window of samples. In this way, the\nlowest dimension represents the power of each frequency in the current window,\nand adjacent windows are concatenated in the next dimension.\n\nTo get a more intuitive and visual look at what this operation does, you can run\ntensorflow/examples/wav_to_spectrogram to read in an audio file and save out the\nresulting spectrogram as a PNG image.",
      "inputs": [
        {
          "description": "Float representation of audio data.",
          "name": "input",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "3D representation of the audio frequencies as an image.",
          "name": "spectrogram",
          "type": 1
        }
      ],
      "summary": "Produces a visualization of audio data over time."
    }
  },
  {
    "name": "AudioSummary",
    "schema": {
      "attributes": [
        {
          "description": "The sample rate of the signal in hertz.",
          "name": "sample_rate",
          "type": "float"
        },
        {
          "default": 3,
          "description": "Max number of batch elements to generate audio for.",
          "minimum": 1,
          "name": "max_outputs",
          "type": "int"
        }
      ],
      "description": "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.",
      "inputs": [
        {
          "description": "Scalar. Used to build the `tag` attribute of the summary values.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "2-D of shape `[batch_size, frames]`.",
          "name": "tensor",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with audio."
    }
  },
  {
    "name": "AudioSummaryV2",
    "schema": {
      "attributes": [
        {
          "default": 3,
          "description": "Max number of batch elements to generate audio for.",
          "minimum": 1,
          "name": "max_outputs",
          "type": "int"
        }
      ],
      "description": "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.",
      "inputs": [
        {
          "description": "Scalar. Used to build the `tag` attribute of the summary values.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "2-D of shape `[batch_size, frames]`.",
          "name": "tensor",
          "type": 1
        },
        {
          "description": "The sample rate of the signal in hertz.",
          "name": "sample_rate",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with audio."
    }
  },
  {
    "name": "AvgPool",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of `value`.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of `value`.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Pool",
      "description": "Each entry in `output` is the mean of the corresponding size `ksize`\nwindow in `value`.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The average pooled output tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs average pooling on the input."
    }
  },
  {
    "name": "AvgPool3D",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "minimum": 5,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, channels]` tensor to pool over.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The average pooled output tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs 3D average pooling on the input."
    }
  },
  {
    "name": "AvgPool3DGrad",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "minimum": 5,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input dimensions.",
          "name": "orig_input_shape",
          "type": 3
        },
        {
          "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The backprop for input.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients of average pooling function."
    }
  },
  {
    "name": "AvgPoolGrad",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of the input.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "1-D.  Shape of the original input to `avg_pool`.",
          "name": "orig_input_shape",
          "type": 3
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t.\nthe output of `avg_pool`.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D.  Gradients w.r.t. the input of `avg_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients of the average pooling function."
    }
  },
  {
    "name": "Barrier",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. Each shape must be 1 in the\nfirst dimension. The length of this attr must be the same as the length of\ncomponent_types.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The capacity of the barrier.  The default capacity is MAX_INT32,\nwhich is the largest capacity of the underlying queue.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this barrier is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this barrier will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A barrier represents a key-value map, where each key is a string, and\neach value is a tuple of tensors.\n\nAt runtime, the barrier contains 'complete' and 'incomplete'\nelements. A complete element has defined tensors for all components of\nits value tuple, and may be accessed using BarrierTakeMany. An\nincomplete element has some undefined components in its value tuple,\nand may be updated using BarrierInsertMany.",
      "outputs": [
        {
          "description": "The handle to the barrier.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Defines a barrier that persists across different graph executions."
    }
  },
  {
    "name": "BarrierClose",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, all pending enqueue requests that are\nblocked on the barrier's queue will be canceled. InsertMany will fail, even\nif no new key is introduced.",
          "name": "cancel_pending_enqueues",
          "type": "bool"
        }
      ],
      "description": "This operation signals that no more new elements will be inserted in the\ngiven barrier. Subsequent InsertMany that try to introduce a new key will fail.\nSubsequent InsertMany operations that just add missing components to already\nexisting elements will continue to succeed. Subsequent TakeMany operations will\ncontinue to succeed if sufficient completed elements remain in the barrier.\nSubsequent TakeMany operations that would block will fail immediately.",
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Closes the given barrier."
    }
  },
  {
    "name": "BarrierIncompleteSize",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of incomplete elements (i.e. those with some of their value\ncomponents not set) in the barrier.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of incomplete elements in the given barrier."
    }
  },
  {
    "name": "BarrierInsertMany",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "The component of the barrier elements that is being assigned.",
          "name": "component_index",
          "type": "int"
        }
      ],
      "description": "If a key is not found in the barrier, this operation will create a new\nincomplete element. If a key is found in the barrier, and the element\nalready has a value at component_index, this operation will fail with\nINVALID_ARGUMENT, and leave the barrier in an undefined state.",
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "A one-dimensional tensor of keys, with length n.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "An any-dimensional tensor of values, which are associated with the\nrespective keys. The 0th dimension must have length n.",
          "name": "values",
          "typeAttr": "T"
        }
      ],
      "summary": "For each key, assigns the respective value to the specified component."
    }
  },
  {
    "name": "BarrierReadySize",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of complete elements (i.e. those with all of their value\ncomponents set) in the barrier.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of complete elements in the given barrier."
    }
  },
  {
    "name": "BarrierTakeMany",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": false,
          "description": "Allow to return less than num_elements items if barrier is\nalready closed.",
          "name": "allow_small_batch",
          "type": "bool"
        },
        {
          "default": false,
          "name": "wait_for_incomplete",
          "type": "bool"
        },
        {
          "default": -1,
          "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation concatenates completed-element component tensors along\nthe 0th dimension to make a single component tensor.\n\nElements come out of the barrier when they are complete, and in the order\nin which they were placed into the barrier.  The indices output provides\ninformation about the batch in which each element was originally inserted\ninto the barrier.",
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "A single-element tensor containing the number of elements to\ntake.",
          "name": "num_elements",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A one-dimensional tensor of indices, with length num_elems.\nThese indices refer to the batch in which the values were placed into the\nbarrier (starting with MIN_LONG and increasing with each BarrierInsertMany).",
          "name": "indices",
          "type": 9
        },
        {
          "description": "A one-dimensional tensor of keys, with length num_elements.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "One any-dimensional tensor per component in a barrier element. All\nvalues have length num_elements in the 0th dimension.",
          "name": "values",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Takes the given number of completed elements from a barrier."
    }
  },
  {
    "name": "Batch",
    "schema": {
      "attributes": [
        {
          "name": "num_batch_threads",
          "type": "int"
        },
        {
          "name": "max_batch_size",
          "type": "int"
        },
        {
          "default": 10,
          "name": "max_enqueued_batches",
          "type": "int"
        },
        {
          "name": "batch_timeout_micros",
          "type": "int"
        },
        {
          "default": [],
          "name": "allowed_batch_sizes",
          "type": "list(int)"
        },
        {
          "name": "grad_timeout_micros",
          "type": "int"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "batching_queue",
          "type": "string"
        },
        {
          "minimum": 1,
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "When many instances of this Op are being run concurrently with the same\ncontainer/shared_name in the same device, some will output zero-shaped Tensors\nand others will output Tensors of size up to max_batch_size.\n\nAll Tensors in in_tensors are batched together (so, for example, labels and\nfeatures should be batched with a single instance of this operation.\n\nEach invocation of batch emits an `id` scalar which will be used to identify\nthis particular invocation when doing unbatch or its gradient.\n\nEach op which emits a non-empty batch will also emit a non-empty batch_index\nTensor, which, is a [K, 3] matrix where each row contains the invocation's id,\nstart, and length of elements of each set of Tensors present in batched_tensors.\n\nBatched tensors are concatenated along the first dimension, and all tensors in\nin_tensors must have the first dimension of the same size.\n\nin_tensors: The tensors to be batched.\nnum_batch_threads: Number of scheduling threads for processing batches of work.\n Determines the number of batches processed in parallel.\nmax_batch_size: Batch sizes will never be bigger than this.\nbatch_timeout_micros: Maximum number of microseconds to wait before outputting\n an incomplete batch.\nallowed_batch_sizes: Optional list of allowed batch sizes. If left empty, does\n nothing. Otherwise, supplies a list of batch sizes, causing the op to pad\n batches up to one of those sizes. The entries must increase monotonically, and\n the final entry must equal max_batch_size.\ngrad_timeout_micros: The timeout to use for the gradient. See Unbatch.\nbatched_tensors: Either empty tensors or a batch of concatenated Tensors.\nbatch_index: If out_tensors is non-empty, has information to invert it.\ncontainer: Controls the scope of sharing of this batch.\nid: always contains a scalar with a unique ID for this invocation of Batch.\nshared_name: Concurrently running instances of batch in the same device with the\n same container and shared_name will batch their elements together. If left\n empty, the op name will be used as the shared name.\nT: the types of tensors to be batched.",
      "inputs": [
        {
          "name": "in_tensors",
          "typeListAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "batched_tensors",
          "typeListAttr": "T"
        },
        {
          "name": "batch_index",
          "type": 9
        },
        {
          "name": "id",
          "type": 9
        }
      ],
      "summary": "Batches all input tensors nondeterministically."
    }
  },
  {
    "name": "BatchCholesky",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchCholeskyGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "l",
          "typeAttr": "T"
        },
        {
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches `batch_size` elements from `input_dataset`."
    }
  },
  {
    "name": "BatchDatasetV2",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a batch.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
          "name": "drop_remainder",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches `batch_size` elements from `input_dataset`."
    }
  },
  {
    "name": "BatchFFT",
    "schema": {
      "inputs": [
        {
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchFFT2D",
    "schema": {
      "inputs": [
        {
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchFFT3D",
    "schema": {
      "inputs": [
        {
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchFunction",
    "schema": {
      "attributes": [
        {
          "name": "f",
          "type": "func"
        },
        {
          "description": "Number of scheduling threads for processing batches of work.\nDetermines the number of batches processed in parallel.",
          "name": "num_batch_threads",
          "type": "int"
        },
        {
          "description": "Batch sizes will never be bigger than this.",
          "name": "max_batch_size",
          "type": "int"
        },
        {
          "description": "Maximum number of microseconds to wait before outputting\nan incomplete batch.",
          "name": "batch_timeout_micros",
          "type": "int"
        },
        {
          "default": 10,
          "description": "Maximum number of batches enqueued. Default: 10.",
          "name": "max_enqueued_batches",
          "type": "int"
        },
        {
          "default": [],
          "description": "Optional list of allowed batch sizes. If left empty, does\nnothing. Otherwise, supplies a list of batch sizes, causing the op to pad\nbatches up to one of those sizes. The entries must increase monotonically, and\nthe final entry must equal max_batch_size.",
          "name": "allowed_batch_sizes",
          "type": "list(int)"
        },
        {
          "default": "",
          "description": "Controls the scope of sharing of this batch.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "Concurrently running instances of batch in the same device with the\nsame container and shared_name will batch their elements together. If left\nempty, the op name will be used as the shared name.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "batching_queue",
          "type": "string"
        },
        {
          "description": "the types of tensors to be batched.",
          "minimum": 1,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "the types of the captured tensors.",
          "minimum": 0,
          "name": "Tcaptured",
          "type": "list(type)"
        },
        {
          "description": "the types of the output tensors.",
          "minimum": 1,
          "name": "Tout",
          "type": "list(type)"
        }
      ],
      "description": "So, for example, in the following code\n\n  ```python\n\n  # This input will be captured.\n  y = tf.placeholder_with_default(1.0, shape=[])\n\n  @tf.Defun(tf.float32)\n  def computation(a):\n    return tf.matmul(a, a) + y\n\n  b = gen_batch_ops.batch_function(\n          f=computation\n          in_tensors=[a],\n          captured_tensors=computation.captured_inputs,\n          Tout=[o.type for o in computation.definition.signature.output_arg],\n          num_batch_threads=1,\n          max_batch_size=10,\n          batch_timeout_micros=100000,  # 100ms\n          allowed_batch_sizes=[3, 10],\n          batching_queue=\"\")\n\nIf more than one session.run call is simultaneously trying to compute `b`\nthe values of `a` will be gathered, non-deterministically concatenated\nalong the first axis, and only one thread will run the computation.\n\nAssumes that all arguments of the function are Tensors which will be batched\nalong their first dimension.\n\nArguments that are captured, are not batched. The session.run call which does\nthe concatenation, will use the values of the captured tensors available to it.\nTherefore, typical uses of captured tensors should involve values which remain\nunchanged across session.run calls. Inference is a good example of this.\n\nSparseTensor is not supported. The return value of the decorated function\nmust be a Tensor or a list/tuple of Tensors.",
      "inputs": [
        {
          "description": "The tensors to be batched.",
          "name": "in_tensors",
          "typeListAttr": "Tin"
        },
        {
          "description": "The tensors which are captured in the function, and don't need\nto be batched.",
          "name": "captured_tensors",
          "typeListAttr": "Tcaptured"
        }
      ],
      "outputs": [
        {
          "description": "The output tensors.",
          "name": "out_tensors",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "Batches all the inputs tensors to the computation done by the function."
    }
  },
  {
    "name": "BatchIFFT",
    "schema": {
      "inputs": [
        {
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchIFFT2D",
    "schema": {
      "inputs": [
        {
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchIFFT3D",
    "schema": {
      "inputs": [
        {
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchMatMul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, adjoint the slices of `x`. Defaults to `False`.",
          "name": "adj_x",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, adjoint the slices of `y`. Defaults to `False`.",
          "name": "adj_y",
          "type": "bool"
        }
      ],
      "description": "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 2-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 2-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])",
      "inputs": [
        {
          "description": "2-D or higher with shape `[..., r_x, c_x]`.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "2-D or higher with shape `[..., r_y, c_y]`.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "3-D or higher with shape `[..., r_o, c_o]`",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Multiplies slices of two tensors in batches."
    }
  },
  {
    "name": "BatchMatrixBandPart",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "num_lower",
          "type": 9
        },
        {
          "name": "num_upper",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "band",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixDeterminant",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixDiag",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixDiagPart",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "diagonal",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixInverse",
    "schema": {
      "attributes": [
        {
          "default": false,
          "name": "adjoint",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixSetDiag",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixSolve",
    "schema": {
      "attributes": [
        {
          "default": false,
          "name": "adjoint",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "matrix",
          "typeAttr": "T"
        },
        {
          "name": "rhs",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixSolveLs",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": true,
          "name": "fast",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "matrix",
          "typeAttr": "T"
        },
        {
          "name": "rhs",
          "typeAttr": "T"
        },
        {
          "name": "l2_regularizer",
          "type": 2
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchMatrixTriangularSolve",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "lower",
          "type": "bool"
        },
        {
          "default": false,
          "name": "adjoint",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "matrix",
          "typeAttr": "T"
        },
        {
          "name": "rhs",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchNormWithGlobalNormalization",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma.",
          "name": "scale_after_normalization",
          "type": "bool"
        }
      ],
      "category": "Normalization",
      "description": "This op is deprecated. Prefer `tf.nn.batch_normalization`.",
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "t",
          "typeAttr": "T"
        },
        {
          "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "m",
          "typeAttr": "T"
        },
        {
          "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "v",
          "typeAttr": "T"
        },
        {
          "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor.",
          "name": "beta",
          "typeAttr": "T"
        },
        {
          "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor.",
          "name": "gamma",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "result",
          "typeAttr": "T"
        }
      ],
      "summary": "Batch normalization."
    }
  },
  {
    "name": "BatchNormWithGlobalNormalizationGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma.",
          "name": "scale_after_normalization",
          "type": "bool"
        }
      ],
      "description": "This op is deprecated. See `tf.nn.batch_normalization`.",
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "t",
          "typeAttr": "T"
        },
        {
          "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "m",
          "typeAttr": "T"
        },
        {
          "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "v",
          "typeAttr": "T"
        },
        {
          "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this Tensor will be multiplied\nwith the normalized Tensor.",
          "name": "gamma",
          "typeAttr": "T"
        },
        {
          "description": "4D backprop Tensor.",
          "name": "backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4D backprop tensor for input.",
          "name": "dx",
          "typeAttr": "T"
        },
        {
          "description": "1D backprop tensor for mean.",
          "name": "dm",
          "typeAttr": "T"
        },
        {
          "description": "1D backprop tensor for variance.",
          "name": "dv",
          "typeAttr": "T"
        },
        {
          "description": "1D backprop tensor for beta.",
          "name": "db",
          "typeAttr": "T"
        },
        {
          "description": "1D backprop tensor for gamma.",
          "name": "dg",
          "typeAttr": "T"
        }
      ],
      "summary": "Gradients for batch normalization."
    }
  },
  {
    "name": "BatchSelfAdjointEig",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchSelfAdjointEigV2",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "compute_v",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "e",
          "typeAttr": "T"
        },
        {
          "name": "v",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchSvd",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "compute_uv",
          "type": "bool"
        },
        {
          "default": false,
          "name": "full_matrices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "s",
          "typeAttr": "T"
        },
        {
          "name": "u",
          "typeAttr": "T"
        },
        {
          "name": "v",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "BatchToSpace",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 2,
          "name": "block_size",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "This is a legacy version of the more general BatchToSpaceND.\n\nRearranges (permutes) data from batch into blocks of spatial data, followed by\ncropping. This is the reverse transformation of SpaceToBatch. More specifically,\nthis op outputs a copy of the input tensor where values from the `batch`\ndimension are moved in spatial blocks to the `height` and `width` dimensions,\nfollowed by cropping along the `height` and `width` dimensions.",
      "inputs": [
        {
          "description": "4-D tensor with shape\n`[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n  depth]`. Note that the batch size of the input tensor must be divisible by\n`block_size * block_size`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\nhow many elements to crop from the intermediate result across the spatial\ndimensions as follows:\n\n    crops = [[crop_top, crop_bottom], [crop_left, crop_right]]",
          "name": "crops",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, height, width, depth]`, where:\n\n      height = height_pad - crop_top - crop_bottom\n      width = width_pad - crop_left - crop_right\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\nSome examples:\n\n(1) For the following input of shape `[4, 1, 1, 1]` and block_size of 2:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\n(2) For the following input of shape `[4, 1, 1, 3]` and block_size of 2:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 3]` and value:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[4, 2, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\nThe output tensor has shape `[1, 4, 4, 1]` and value:\n\n```\nx = [[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]\n```\n\n(4) For the following input of shape `[8, 1, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n```\n\nThe output tensor has shape `[2, 2, 4, 1]` and value:\n\n```\nx = [[[[1], [3]], [[5], [7]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "BatchToSpace for 4-D tensors of type T."
    }
  },
  {
    "name": "BatchToSpaceND",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tblock_shape",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tcrops",
          "type": "type"
        }
      ],
      "description": "This operation reshapes the \"batch\" dimension 0 into `M + 1` dimensions of shape\n`block_shape + [batch]`, interleaves these blocks back into the grid defined by\nthe spatial dimensions `[1, ..., M]`, to obtain a result with the same rank as\nthe input.  The spatial dimensions of this intermediate result are then\noptionally cropped according to `crops` to produce the output.  This is the\nreverse of SpaceToBatch.  See below for a precise description.",
      "inputs": [
        {
          "description": "N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,\nwhere spatial_shape has M dimensions.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "1-D with shape `[M]`, all values must be >= 1.",
          "name": "block_shape",
          "typeAttr": "Tblock_shape"
        },
        {
          "description": "2-D with shape `[M, 2]`, all values must be >= 0.\n  `crops[i] = [crop_start, crop_end]` specifies the amount to crop from input\n  dimension `i + 1`, which corresponds to spatial dimension `i`.  It is\n  required that\n  `crop_start[i] + crop_end[i] <= block_shape[i] * input_shape[i + 1]`.\n\nThis operation is equivalent to the following steps:\n\n1. Reshape `input` to `reshaped` of shape:\n     [block_shape[0], ..., block_shape[M-1],\n      batch / prod(block_shape),\n      input_shape[1], ..., input_shape[N-1]]\n\n2. Permute dimensions of `reshaped` to produce `permuted` of shape\n     [batch / prod(block_shape),\n\n      input_shape[1], block_shape[0],\n      ...,\n      input_shape[M], block_shape[M-1],\n\n      input_shape[M+1], ..., input_shape[N-1]]\n\n3. Reshape `permuted` to produce `reshaped_permuted` of shape\n     [batch / prod(block_shape),\n\n      input_shape[1] * block_shape[0],\n      ...,\n      input_shape[M] * block_shape[M-1],\n\n      input_shape[M+1],\n      ...,\n      input_shape[N-1]]\n\n4. Crop the start and end of dimensions `[1, ..., M]` of\n   `reshaped_permuted` according to `crops` to produce the output of shape:\n     [batch / prod(block_shape),\n\n      input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],\n      ...,\n      input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],\n\n      input_shape[M+1], ..., input_shape[N-1]]\n\nSome examples:\n\n(1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\n(2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 3]` and value:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\nThe output tensor has shape `[1, 4, 4, 1]` and value:\n\n```\nx = [[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]\n```\n\n(4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [2, 0]]`:\n\n```\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n```\n\nThe output tensor has shape `[2, 2, 4, 1]` and value:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```",
          "name": "crops",
          "typeAttr": "Tcrops"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "BatchToSpace for N-D tensors of type T."
    }
  },
  {
    "name": "BesselI0e",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Exponentially scaled modified Bessel function of order 0 defined as\n`bessel_i0e(x) = exp(-abs(x)) bessel_i0(x)`.\n\nThis function is faster and numerically stabler than `bessel_i0(x)`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the Bessel i0e function of `x` element-wise."
    }
  },
  {
    "name": "BesselI1e",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Exponentially scaled modified Bessel function of order 0 defined as\n`bessel_i1e(x) = exp(-abs(x)) bessel_i1(x)`.\n\nThis function is faster and numerically stabler than `bessel_i1(x)`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the Bessel i1e function of `x` element-wise."
    }
  },
  {
    "name": "Betainc",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The regularized incomplete beta integral is defined as:\n\n\n\\\\(I_x(a, b) = \\frac{B(x; a, b)}{B(a, b)}\\\\)\n\nwhere\n\n\n\\\\(B(x; a, b) = \\int_0^x t^{a-1} (1 - t)^{b-1} dt\\\\)\n\n\nis the incomplete beta function and \\\\(B(a, b)\\\\) is the *complete*\nbeta function.",
      "inputs": [
        {
          "name": "a",
          "typeAttr": "T"
        },
        {
          "name": "b",
          "typeAttr": "T"
        },
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the regularized incomplete beta integral \\\\(I_x(a, b)\\\\)."
    }
  },
  {
    "name": "BiasAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension.",
          "name": "data_format",
          "type": "string"
        }
      ],
      "category": "Layer",
      "description": "This is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions.",
      "inputs": [
        {
          "description": "Any number of dimensions.",
          "name": "value",
          "typeAttr": "T"
        },
        {
          "description": "1-D with size the last dimension of `value`.",
          "name": "bias",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Broadcasted sum of `value` and `bias`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adds `bias` to `value`."
    }
  },
  {
    "name": "BiasAddGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension.",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "It accumulates all the values from out_backprop into the feature dimension.\nFor NHWC data format, the feature dimension is the last. For NCHW data format,\nthe feature dimension is the third-to-last.",
      "inputs": [
        {
          "description": "Any number of dimensions.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D with size the feature dimension of `out_backprop`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "The backward operation for \"BiasAdd\" on the \"bias\" tensor."
    }
  },
  {
    "name": "BiasAddV1",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is a deprecated version of BiasAdd and will be soon removed.\n\nThis is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions.",
      "inputs": [
        {
          "description": "Any number of dimensions.",
          "name": "value",
          "typeAttr": "T"
        },
        {
          "description": "1-D with size the last dimension of `value`.",
          "name": "bias",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Broadcasted sum of `value` and `bias`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adds `bias` to `value`."
    }
  },
  {
    "name": "Bincount",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a vector with length `size` and the same dtype as `weights`. If\n`weights` are empty, then index `i` stores the number of times the value `i` is\ncounted in `arr`. If `weights` are non-empty, then index `i` stores the sum of\nthe value in `weights` at each index where the corresponding value in `arr` is\n`i`.\n\nValues in `arr` outside of the range [0, size) are ignored.",
      "inputs": [
        {
          "description": "int32 `Tensor`.",
          "name": "arr",
          "type": 3
        },
        {
          "description": "non-negative int32 scalar `Tensor`.",
          "name": "size",
          "type": 3
        },
        {
          "description": "is an int32, int64, float32, or float64 `Tensor` with the same\nshape as `arr`, or a length-0 `Tensor`, in which case it acts as all weights\nequal to 1.",
          "name": "weights",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1D `Tensor` with length equal to `size`. The counts or summed weights for\neach value in the range [0, size).",
          "name": "bins",
          "typeAttr": "T"
        }
      ],
      "summary": "Counts the number of occurrences of each value in an integer array."
    }
  },
  {
    "name": "Bitcast",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            },
            {
              "type": "type",
              "value": 13
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            },
            {
              "type": "type",
              "value": 13
            }
          ],
          "name": "type",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input`, this operation returns a tensor that has the same buffer\ndata as `input` with datatype `type`.\n\nIf the input datatype `T` is larger than the output datatype `type` then the\nshape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].\n\nIf `T` is smaller than `type`, the operator requires that the rightmost\ndimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from\n[..., sizeof(`type`)/sizeof(`T`)] to [...].\n\n*NOTE*: Bitcast is implemented as a low-level cast, so machines with different\nendian orderings will give different results.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "type"
        }
      ],
      "summary": "Bitcasts a tensor from one type to another without copying data."
    }
  },
  {
    "name": "BitwiseAnd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have those bits set, that are set in both `x` and `y`. The\ncomputation is performed on the underlying representations of `x` and `y`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Elementwise computes the bitwise AND of `x` and `y`."
    }
  },
  {
    "name": "BitwiseOr",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have those bits set, that are set in `x`, `y` or both. The\ncomputation is performed on the underlying representations of `x` and `y`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Elementwise computes the bitwise OR of `x` and `y`."
    }
  },
  {
    "name": "BitwiseXor",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have those bits set, that are different in `x` and `y`. The\ncomputation is performed on the underlying representations of `x` and `y`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Elementwise computes the bitwise XOR of `x` and `y`."
    }
  },
  {
    "name": "BoostedTreesBucketize",
    "schema": {
      "attributes": [
        {
          "description": "inferred int; number of features.",
          "minimum": 0,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "An op that returns a list of float tensors, where each tensor represents the\nbucketized values for a single feature.",
      "inputs": [
        {
          "description": "float; List of Rank 1 Tensor each containing float values for a single feature.",
          "name": "float_values",
          "numberAttr": "num_features",
          "type": 1
        },
        {
          "description": "float; List of Rank 1 Tensors each containing the bucket boundaries for a single\nfeature.",
          "name": "bucket_boundaries",
          "numberAttr": "num_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "int; List of Rank 1 Tensors each containing the bucketized values for a single feature.",
          "name": "buckets",
          "type": 3
        }
      ],
      "summary": "Bucketize each feature based on bucket boundaries."
    }
  },
  {
    "name": "BoostedTreesCalculateBestGainsPerFeature",
    "schema": {
      "attributes": [
        {
          "description": "the number of nodes that can be split in the whole tree. Used as a dimension of output tensors.",
          "minimum": 1,
          "name": "max_splits",
          "type": "int"
        },
        {
          "description": "inferred from the size of `stats_summary_list`; the number of total features.",
          "minimum": 1,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "The split information is the best threshold (bucket id), gains and left/right node contributions per node for each feature.\n\nIt is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return `node_ids_list` for each feature, containing the list of nodes that this feature can be used to split.\n\nIn this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).\n\nThe length of output lists are all of the same length, `num_features`.\nThe output shapes are compatible in a way that the first dimension of all tensors of all lists are the same and equal to the number of possible split nodes for each feature.",
      "inputs": [
        {
          "description": "A Rank 1 tensor (shape=[2]) to specify the range [first, last) of node ids to process within `stats_summary_list`. The nodes are iterated between the two nodes specified by the tensor, as like `for node_id in range(node_id_range[0], node_id_range[1])` (Note that the last index node_id_range[1] is exclusive).",
          "name": "node_id_range",
          "type": 3
        },
        {
          "description": "A list of Rank 3 tensor (#shape=[max_splits, bucket, 2]) for accumulated stats summary (gradient/hessian) per node per buckets for each feature. The first dimension of the tensor is the maximum number of splits, and thus not all elements of it will be used, but only the indexes specified by node_ids will be used.",
          "name": "stats_summary_list",
          "numberAttr": "num_features",
          "type": 1
        },
        {
          "description": "l1 regularization factor on leaf weights, per instance based.",
          "name": "l1",
          "type": 1
        },
        {
          "description": "l2 regularization factor on leaf weights, per instance based.",
          "name": "l2",
          "type": 1
        },
        {
          "description": "adjustment to the gain, per leaf based.",
          "name": "tree_complexity",
          "type": 1
        },
        {
          "description": "mininum avg of hessians in a node before required for the node to be considered for splitting.",
          "name": "min_node_weight",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "An output list of Rank 1 tensors indicating possible split node ids for each feature. The length of the list is num_features, but each tensor has different size as each feature provides different possible nodes. See above for details like shapes and sizes.",
          "name": "node_ids_list",
          "type": 3
        },
        {
          "description": "An output list of Rank 1 tensors indicating the best gains for each feature to split for certain nodes. See above for details like shapes and sizes.",
          "name": "gains_list",
          "type": 1
        },
        {
          "description": "An output list of Rank 1 tensors indicating the bucket id to compare with (as a threshold) for split in each node. See above for details like shapes and sizes.",
          "name": "thresholds_list",
          "type": 3
        },
        {
          "description": "A list of Rank 2 tensors indicating the contribution of the left nodes when branching from parent nodes (given by the tensor element in the output node_ids_list) to the left direction by the given threshold for each feature. This value will be used to make the left node value by adding to the parent node value. Second dimension size is 1 for 1-dimensional logits, but would be larger for multi-class problems. See above for details like shapes and sizes.",
          "name": "left_node_contribs_list",
          "type": 1
        },
        {
          "description": "A list of Rank 2 tensors, with the same shape/conditions as left_node_contribs_list, but just that the value is for the right node.",
          "name": "right_node_contribs_list",
          "type": 1
        }
      ],
      "summary": "Calculates gains for each feature and returns the best possible split information for the feature."
    }
  },
  {
    "name": "BoostedTreesCenterBias",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree ensemble.",
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "A tensor with shape=[logits_dimension] with mean of gradients for a first node.",
          "name": "mean_gradients",
          "type": 1
        },
        {
          "description": "A tensor with shape=[logits_dimension] mean of hessians for a first node.",
          "name": "mean_hessians",
          "type": 1
        },
        {
          "description": "l1 regularization factor on leaf weights, per instance based.",
          "name": "l1",
          "type": 1
        },
        {
          "description": "l2 regularization factor on leaf weights, per instance based.",
          "name": "l2",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Bool, whether to continue bias centering.",
          "name": "continue_centering",
          "type": 10
        }
      ],
      "summary": "Calculates the prior from the training data (the bias) and fills in the first node with the logits' prior. Returns a boolean indicating whether to continue centering."
    }
  },
  {
    "name": "BoostedTreesCreateEnsemble",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree ensemble resource to be created.",
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "Token to use as the initial value of the resource stamp.",
          "name": "stamp_token",
          "type": 9
        },
        {
          "description": "Serialized proto of the tree ensemble.",
          "name": "tree_ensemble_serialized",
          "type": 7
        }
      ],
      "summary": "Creates a tree ensemble model and returns a handle to it."
    }
  },
  {
    "name": "BoostedTreesCreateQuantileStreamResource",
    "schema": {
      "attributes": [
        {
          "default": 1099511627776,
          "description": "int; The maximum number of data points that can be fed to the stream.",
          "name": "max_elements",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "resource; Handle to quantile stream resource.",
          "name": "quantile_stream_resource_handle",
          "type": 20
        },
        {
          "description": "float; The required approximation error of the stream resource.",
          "name": "epsilon",
          "type": 1
        },
        {
          "description": "int; The number of streams managed by the resource that shares the same epsilon.",
          "name": "num_streams",
          "type": 9
        }
      ],
      "summary": "Create the Resource for Quantile Streams."
    }
  },
  {
    "name": "BoostedTreesDeserializeEnsemble",
    "schema": {
      "description": "ensemble.",
      "inputs": [
        {
          "description": "Handle to the tree ensemble.",
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "Token to use as the new value of the resource stamp.",
          "name": "stamp_token",
          "type": 9
        },
        {
          "description": "Serialized proto of the ensemble.",
          "name": "tree_ensemble_serialized",
          "type": 7
        }
      ],
      "summary": "Deserializes a serialized tree ensemble config and replaces current tree"
    }
  },
  {
    "name": "BoostedTreesEnsembleResourceHandleOp",
    "schema": {
      "attributes": [
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Creates a handle to a BoostedTreesEnsembleResource"
    }
  },
  {
    "name": "BoostedTreesExampleDebugOutputs",
    "schema": {
      "attributes": [
        {
          "description": "Inferred.",
          "minimum": 1,
          "name": "num_bucketized_features",
          "type": "int"
        },
        {
          "description": "scalar, dimension of the logits, to be used for constructing the protos in\nexamples_debug_outputs_serialized.",
          "name": "logits_dimension",
          "type": "int"
        }
      ],
      "description": "It traverses all the trees and computes debug metrics for individual examples, \nsuch as getting split feature ids and logits after each split along the decision\npath used to compute directional feature contributions.",
      "inputs": [
        {
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "A list of rank 1 Tensors containing bucket id for each\nfeature.",
          "name": "bucketized_features",
          "numberAttr": "num_bucketized_features",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Output rank 1 Tensor containing a proto serialized as a string for each example.",
          "name": "examples_debug_outputs_serialized",
          "type": 7
        }
      ],
      "summary": "Debugging/model interpretability outputs for each example."
    }
  },
  {
    "name": "BoostedTreesGetEnsembleStates",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree ensemble.",
          "name": "tree_ensemble_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Stamp token of the tree ensemble resource.",
          "name": "stamp_token",
          "type": 9
        },
        {
          "description": "The number of trees in the tree ensemble resource.",
          "name": "num_trees",
          "type": 3
        },
        {
          "description": "The number of trees that were finished successfully.",
          "name": "num_finalized_trees",
          "type": 3
        },
        {
          "description": "The number of layers we attempted to build (but not necessarily succeeded).",
          "name": "num_attempted_layers",
          "type": 3
        },
        {
          "description": "Rank size 2 tensor that contains start and end ids of the nodes in the latest\nlayer.",
          "name": "last_layer_nodes_range",
          "type": 3
        }
      ],
      "summary": "Retrieves the tree ensemble resource stamp token, number of trees and growing statistics."
    }
  },
  {
    "name": "BoostedTreesMakeQuantileSummaries",
    "schema": {
      "attributes": [
        {
          "description": "int; Inferred from the size of float_values.\nThe number of float features.",
          "minimum": 0,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "An op that takes a list of tensors (one tensor per feature) and outputs the\nquantile summaries for each tensor.",
      "inputs": [
        {
          "description": "float; List of Rank 1 Tensors each containing values for a single feature.",
          "name": "float_values",
          "numberAttr": "num_features",
          "type": 1
        },
        {
          "description": "float; Rank 1 Tensor with weights per instance.",
          "name": "example_weights",
          "type": 1
        },
        {
          "description": "float; The required maximum approximation error.",
          "name": "epsilon",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "float; List of Rank 2 Tensors each containing the quantile summary\n(value, weight, min_rank, max_rank) of a single feature.",
          "name": "summaries",
          "type": 1
        }
      ],
      "summary": "Makes the summary of quantiles for the batch."
    }
  },
  {
    "name": "BoostedTreesMakeStatsSummary",
    "schema": {
      "attributes": [
        {
          "description": "int; the maximum number of splits possible in the whole tree.",
          "minimum": 1,
          "name": "max_splits",
          "type": "int"
        },
        {
          "description": "int; equals to the maximum possible value of bucketized feature.",
          "minimum": 1,
          "name": "num_buckets",
          "type": "int"
        },
        {
          "description": "int; inferred from the size of bucketized_features_list; the number of features.",
          "minimum": 1,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "The summary stats contains gradients and hessians accumulated into the corresponding node and bucket for each example.",
      "inputs": [
        {
          "description": "int32 Rank 1 Tensor containing node ids, which each example falls into for the requested layer.",
          "name": "node_ids",
          "type": 3
        },
        {
          "description": "float32; Rank 2 Tensor (shape=[#examples, 1]) for gradients.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "float32; Rank 2 Tensor (shape=[#examples, 1]) for hessians.",
          "name": "hessians",
          "type": 1
        },
        {
          "description": "int32 list of Rank 1 Tensors, each containing the bucketized feature (for each feature column).",
          "name": "bucketized_features_list",
          "numberAttr": "num_features",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "output Rank 4 Tensor (shape=[#features, #splits, #buckets, 2]) containing accumulated stats put into the corresponding node and bucket. The first index of 4th dimension refers to gradients, and the second to hessians.",
          "name": "stats_summary",
          "type": 1
        }
      ],
      "summary": "Makes the summary of accumulated stats for the batch."
    }
  },
  {
    "name": "BoostedTreesPredict",
    "schema": {
      "attributes": [
        {
          "description": "Inferred.",
          "minimum": 1,
          "name": "num_bucketized_features",
          "type": "int"
        },
        {
          "description": "scalar, dimension of the logits, to be used for partial logits\nshape.",
          "name": "logits_dimension",
          "type": "int"
        }
      ],
      "description": "computes the logits. It is designed to be used during prediction.\nIt traverses all the trees and calculates the final score for each instance.",
      "inputs": [
        {
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "A list of rank 1 Tensors containing bucket id for each\nfeature.",
          "name": "bucketized_features",
          "numberAttr": "num_bucketized_features",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Output rank 2 Tensor containing logits for each example.",
          "name": "logits",
          "type": 1
        }
      ],
      "summary": "Runs multiple additive regression ensemble predictors on input instances and"
    }
  },
  {
    "name": "BoostedTreesQuantileStreamResourceAddSummaries",
    "schema": {
      "attributes": [
        {
          "minimum": 0,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "An op that adds a list of quantile summaries to a quantile stream resource. Each\nsummary Tensor is rank 2, containing summaries (value, weight, min_rank, max_rank)\nfor a single feature.",
      "inputs": [
        {
          "description": "resource handle referring to a QuantileStreamResource.",
          "name": "quantile_stream_resource_handle",
          "type": 20
        },
        {
          "description": "string; List of Rank 2 Tensor each containing the summaries for a single feature.",
          "name": "summaries",
          "numberAttr": "num_features",
          "type": 1
        }
      ],
      "summary": "Add the quantile summaries to each quantile stream resource."
    }
  },
  {
    "name": "BoostedTreesQuantileStreamResourceDeserialize",
    "schema": {
      "attributes": [
        {
          "description": "inferred int; number of features to get bucket boundaries for.",
          "minimum": 1,
          "name": "num_streams",
          "type": "int"
        }
      ],
      "description": "An op that deserializes bucket boundaries and are boundaries ready flag into current QuantileAccumulator.",
      "inputs": [
        {
          "description": "resource handle referring to a QuantileStreamResource.",
          "name": "quantile_stream_resource_handle",
          "type": 20
        },
        {
          "description": "float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.",
          "name": "bucket_boundaries",
          "numberAttr": "num_streams",
          "type": 1
        }
      ],
      "summary": "Deserialize bucket boundaries and ready flag into current QuantileAccumulator."
    }
  },
  {
    "name": "BoostedTreesQuantileStreamResourceFlush",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "bool; If True, the output will be the num_quantiles for each stream where the ith\nentry is the ith quantile of the input with an approximation error of epsilon.\nDuplicate values may be present.\nIf False, the output will be the points in the histogram that we got which roughly\ntranslates to 1/epsilon boundaries and without any duplicates.\nDefault to False.",
          "name": "generate_quantiles",
          "type": "bool"
        }
      ],
      "description": "An op that flushes the summaries for a quantile stream resource.",
      "inputs": [
        {
          "description": "resource handle referring to a QuantileStreamResource.",
          "name": "quantile_stream_resource_handle",
          "type": 20
        },
        {
          "description": "int; approximate number of buckets unless using generate_quantiles.",
          "name": "num_buckets",
          "type": 9
        }
      ],
      "summary": "Flush the summaries for a quantile stream resource."
    }
  },
  {
    "name": "BoostedTreesQuantileStreamResourceGetBucketBoundaries",
    "schema": {
      "attributes": [
        {
          "description": "inferred int; number of features to get bucket boundaries for.",
          "minimum": 0,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "An op that returns a list of float tensors for a quantile stream resource. Each\ntensor is Rank 1 containing bucket boundaries for a single feature.",
      "inputs": [
        {
          "description": "resource handle referring to a QuantileStreamResource.",
          "name": "quantile_stream_resource_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "float; List of Rank 1 Tensors each containing the bucket boundaries for a feature.",
          "name": "bucket_boundaries",
          "type": 1
        }
      ],
      "summary": "Generate the bucket boundaries for each feature based on accumulated summaries."
    }
  },
  {
    "name": "BoostedTreesQuantileStreamResourceHandleOp",
    "schema": {
      "attributes": [
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Creates a handle to a BoostedTreesQuantileStreamResource."
    }
  },
  {
    "name": "BoostedTreesSerializeEnsemble",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree ensemble.",
          "name": "tree_ensemble_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Stamp token of the tree ensemble resource.",
          "name": "stamp_token",
          "type": 9
        },
        {
          "description": "Serialized proto of the ensemble.",
          "name": "tree_ensemble_serialized",
          "type": 7
        }
      ],
      "summary": "Serializes the tree ensemble to a proto."
    }
  },
  {
    "name": "BoostedTreesTrainingPredict",
    "schema": {
      "attributes": [
        {
          "description": "Inferred.",
          "minimum": 1,
          "name": "num_bucketized_features",
          "type": "int"
        },
        {
          "description": "scalar, dimension of the logits, to be used for partial logits\nshape.",
          "name": "logits_dimension",
          "type": "int"
        }
      ],
      "description": "computes the update to cached logits. It is designed to be used during training.\nIt traverses the trees starting from cached tree id and cached node id and\ncalculates the updates to be pushed to the cache.",
      "inputs": [
        {
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "Rank 1 Tensor containing cached tree ids which is the starting\ntree of prediction.",
          "name": "cached_tree_ids",
          "type": 3
        },
        {
          "description": "Rank 1 Tensor containing cached node id which is the starting\nnode of prediction.",
          "name": "cached_node_ids",
          "type": 3
        },
        {
          "description": "A list of rank 1 Tensors containing bucket id for each\nfeature.",
          "name": "bucketized_features",
          "numberAttr": "num_bucketized_features",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Rank 2 Tensor containing logits update (with respect to cached\nvalues stored) for each example.",
          "name": "partial_logits",
          "type": 1
        },
        {
          "description": "Rank 1 Tensor containing new tree ids for each example.",
          "name": "tree_ids",
          "type": 3
        },
        {
          "description": "Rank 1 Tensor containing new node ids in the new tree_ids.",
          "name": "node_ids",
          "type": 3
        }
      ],
      "summary": "Runs multiple additive regression ensemble predictors on input instances and"
    }
  },
  {
    "name": "BoostedTreesUpdateEnsemble",
    "schema": {
      "attributes": [
        {
          "description": "0-No pruning, 1-Pre-pruning, 2-Post-pruning.",
          "minimum": 0,
          "name": "pruning_mode",
          "type": "int"
        },
        {
          "description": "Number of features that have best splits returned. INFERRED.",
          "minimum": 0,
          "name": "num_features",
          "type": "int"
        }
      ],
      "description": "or by starting a new tree.",
      "inputs": [
        {
          "description": "Handle to the ensemble variable.",
          "name": "tree_ensemble_handle",
          "type": 20
        },
        {
          "description": "Rank 1 tensor with ids for each feature. This is the real id of\nthe feature that will be used in the split.",
          "name": "feature_ids",
          "type": 3
        },
        {
          "description": "List of rank 1 tensors representing the nodes for which this feature\nhas a split.",
          "name": "node_ids",
          "numberAttr": "num_features",
          "type": 3
        },
        {
          "description": "List of rank 1 tensors representing the gains for each of the feature's\nsplit.",
          "name": "gains",
          "numberAttr": "num_features",
          "type": 1
        },
        {
          "description": "List of rank 1 tensors representing the thesholds for each of the\nfeature's split.",
          "name": "thresholds",
          "numberAttr": "num_features",
          "type": 3
        },
        {
          "description": "List of rank 2 tensors with left leaf contribs for each of\nthe feature's splits. Will be added to the previous node values to constitute\nthe values of the left nodes.",
          "name": "left_node_contribs",
          "numberAttr": "num_features",
          "type": 1
        },
        {
          "description": "List of rank 2 tensors with right leaf contribs for each\nof the feature's splits. Will be added to the previous node values to constitute\nthe values of the right nodes.",
          "name": "right_node_contribs",
          "numberAttr": "num_features",
          "type": 1
        },
        {
          "description": "Max depth of the tree to build.",
          "name": "max_depth",
          "type": 3
        },
        {
          "description": "shrinkage const for each new tree.",
          "name": "learning_rate",
          "type": 1
        }
      ],
      "summary": "Updates the tree ensemble by either adding a layer to the last tree being grown"
    }
  },
  {
    "name": "BroadcastArgs",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given `s0` and `s1`, tensors that represent shapes, compute `r0`, the\nbroadcasted shape. `s0`, `s1` and `r0` are all integer vectors.",
      "inputs": [
        {
          "name": "s0",
          "typeAttr": "T"
        },
        {
          "name": "s1",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "r0",
          "typeAttr": "T"
        }
      ],
      "summary": "Return the shape of s0 op s1 with broadcast."
    }
  },
  {
    "name": "BroadcastGradientArgs",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is typically used by gradient computations for a broadcasting operation.",
      "inputs": [
        {
          "name": "s0",
          "typeAttr": "T"
        },
        {
          "name": "s1",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "r0",
          "typeAttr": "T"
        },
        {
          "name": "r1",
          "typeAttr": "T"
        }
      ],
      "summary": "Return the reduction indices for computing gradients of s0 op s1 with broadcast."
    }
  },
  {
    "name": "BroadcastTo",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Broadcasting is the process of making arrays to have compatible shapes\nfor arithmetic operations. Two shapes are compatible if for each\ndimension pair they are either equal or one of them is one. When trying\nto broadcast a Tensor to a shape, it starts with the trailing dimensions,\nand works its way forward.\n\nFor example,\n```\n>>> x = tf.constant([1, 2, 3])\n>>> y = tf.broadcast_to(x, [3, 3])\n>>> sess.run(y)\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]], dtype=int32)\n```\nIn the above example, the input Tensor with the shape of `[1, 3]`\nis broadcasted to output Tensor with shape of `[3, 3]`.",
      "inputs": [
        {
          "description": "A Tensor to broadcast.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "An 1-D `int` Tensor. The shape of the desired output.",
          "name": "shape",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "A Tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Broadcast an array for a compatible shape."
    }
  },
  {
    "name": "Bucketize",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "A sorted list of floats gives the boundary of the buckets.",
          "name": "boundaries",
          "type": "list(float)"
        }
      ],
      "description": "For example, if the inputs are\n    boundaries = [0, 10, 100]\n    input = [[-5, 10000]\n             [150,   10]\n             [5,    100]]\n\nthen the output will be\n    output = [[0, 3]\n              [3, 2]\n              [1, 3]]",
      "inputs": [
        {
          "description": "Any shape of Tensor contains with int or float type.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same shape with 'input', each value of input replaced with bucket index.\n\n@compatibility(numpy)\nEquivalent to np.digitize.\n@end_compatibility",
          "name": "output",
          "type": 3
        }
      ],
      "summary": "Bucketizes 'input' based on 'boundaries'."
    }
  },
  {
    "name": "CTCBeamSearchDecoder",
    "schema": {
      "attributes": [
        {
          "description": "A scalar >= 0 (beam search beam width).",
          "minimum": 1,
          "name": "beam_width",
          "type": "int"
        },
        {
          "description": "A scalar >= 0, <= beam_width (controls output size).",
          "minimum": 1,
          "name": "top_paths",
          "type": "int"
        },
        {
          "default": true,
          "description": "If true, merge repeated classes in output.",
          "name": "merge_repeated",
          "type": "bool"
        }
      ],
      "description": "A note about the attribute merge_repeated: For the beam search decoder,\nthis means that if consecutive entries in a beam are the same, only\nthe first of these is emitted.  That is, when the top path is \"A B B B B\",\n\"A B\" is returned if merge_repeated = True but \"A B B B B\" is\nreturned if merge_repeated = False.",
      "inputs": [
        {
          "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "A vector containing sequence lengths, size `(batch)`.",
          "name": "sequence_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A list (length: top_paths) of indices matrices.  Matrix j,\nsize `(total_decoded_outputs[j] x 2)`, has indices of a\n`SparseTensor<int64, 2>`.  The rows store: [batch, time].",
          "name": "decoded_indices",
          "type": 9
        },
        {
          "description": "A list (length: top_paths) of values vectors.  Vector j,\nsize `(length total_decoded_outputs[j])`, has the values of a\n`SparseTensor<int64, 2>`.  The vector stores the decoded classes for beam j.",
          "name": "decoded_values",
          "type": 9
        },
        {
          "description": "A list (length: top_paths) of shape vector.  Vector j,\nsize `(2)`, stores the shape of the decoded `SparseTensor[j]`.\nIts values are: `[batch_size, max_decoded_length[j]]`.",
          "name": "decoded_shape",
          "type": 9
        },
        {
          "description": "A matrix, shaped: `(batch_size x top_paths)`.  The\nsequence log-probabilities.",
          "name": "log_probability",
          "type": 1
        }
      ],
      "summary": "Performs beam search decoding on the logits given in input."
    }
  },
  {
    "name": "CTCGreedyDecoder",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If True, merge repeated classes in output.",
          "name": "merge_repeated",
          "type": "bool"
        }
      ],
      "description": "A note about the attribute merge_repeated: if enabled, when\nconsecutive logits' maximum indices are the same, only the first of\nthese is emitted.  Labeling the blank '*', the sequence \"A B B * B B\"\nbecomes \"A B B\" if merge_repeated = True and \"A B B B B\" if\nmerge_repeated = False.\n\nRegardless of the value of merge_repeated, if the maximum index of a given\ntime and batch corresponds to the blank, index `(num_classes - 1)`, no new\nelement is emitted.",
      "inputs": [
        {
          "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "A vector containing sequence lengths, size `(batch_size)`.",
          "name": "sequence_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Indices matrix, size `(total_decoded_outputs x 2)`,\nof a `SparseTensor<int64, 2>`.  The rows store: [batch, time].",
          "name": "decoded_indices",
          "type": 9
        },
        {
          "description": "Values vector, size: `(total_decoded_outputs)`,\nof a `SparseTensor<int64, 2>`.  The vector stores the decoded classes.",
          "name": "decoded_values",
          "type": 9
        },
        {
          "description": "Shape vector, size `(2)`, of the decoded SparseTensor.\nValues are: `[batch_size, max_decoded_length]`.",
          "name": "decoded_shape",
          "type": 9
        },
        {
          "description": "Matrix, size `(batch_size x 1)`, containing sequence\nlog-probabilities.",
          "name": "log_probability",
          "type": 1
        }
      ],
      "summary": "Performs greedy decoding on the logits given in inputs."
    }
  },
  {
    "name": "CTCLoss",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "Scalar, if true then repeated labels are\ncollapsed prior to the CTC calculation.",
          "name": "preprocess_collapse_repeated",
          "type": "bool"
        },
        {
          "default": true,
          "description": "Scalar.  If set to false, *during* CTC calculation\nrepeated non-blank labels will not be merged and are interpreted as\nindividual labels.  This is a simplified version of CTC.",
          "name": "ctc_merge_repeated",
          "type": "bool"
        },
        {
          "default": false,
          "description": "Scalar. If set to true, during CTC\ncalculation, items that have longer output sequences than input sequences\nare skipped: they don't contribute to the loss term and have zero-gradient.",
          "name": "ignore_longer_outputs_than_inputs",
          "type": "bool"
        }
      ],
      "description": "the gradient.  This class performs the softmax operation for you, so inputs\nshould be e.g. linear projections of outputs by an LSTM.",
      "inputs": [
        {
          "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "The indices of a `SparseTensor<int32, 2>`.\n`labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for\n`(batch b, time t)`.",
          "name": "labels_indices",
          "type": 9
        },
        {
          "description": "The values (labels) associated with the given batch and time.",
          "name": "labels_values",
          "type": 3
        },
        {
          "description": "A vector containing sequence lengths (batch).",
          "name": "sequence_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A vector (batch) containing log-probabilities.",
          "name": "loss",
          "type": 1
        },
        {
          "description": "The gradient of `loss`.  3-D, shape:\n`(max_time x batch_size x num_classes)`.",
          "name": "gradient",
          "type": 1
        }
      ],
      "summary": "Calculates the CTC Loss (log probability) for each batch entry.  Also calculates"
    }
  },
  {
    "name": "CacheDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "A CacheDataset will iterate over the input_dataset, and store tensors. If the\ncache already exists, the cache will be used. If the cache is inappropriate\n(e.g. cannot be opened, contains tensors of the wrong shape / size), an error\nwill the returned when used.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A path on the filesystem where we should cache the dataset. Note: this\nwill be a directory.",
          "name": "filename",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that caches elements from `input_dataset`."
    }
  },
  {
    "name": "Cast",
    "schema": {
      "attributes": [
        {
          "name": "SrcT",
          "type": "type"
        },
        {
          "name": "DstT",
          "type": "type"
        },
        {
          "default": false,
          "name": "Truncate",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "SrcT"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "DstT"
        }
      ],
      "summary": "Cast x of type SrcT to y of DstT."
    }
  },
  {
    "name": "Ceil",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns element-wise smallest integer not less than x."
    }
  },
  {
    "name": "CheckNumerics",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "Prefix of the error message.",
          "name": "message",
          "type": "string"
        }
      ],
      "description": "When run, reports an `InvalidArgument` error if `tensor` has any values\nthat are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is.",
      "inputs": [
        {
          "name": "tensor",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Checks a tensor for NaN and Inf values."
    }
  },
  {
    "name": "Cholesky",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices.\n\nThe input has to be symmetric and positive definite. Only the lower-triangular\npart of the input will be used for this operation. The upper-triangular part\nwill not be read.\n\nThe output is a tensor of the same shape as the input\ncontaining the Cholesky decompositions for all input submatrices `[..., :, :]`.\n\n**Note**: The gradient computation on GPU is faster for large matrices but\nnot for large batch dimensions when the submatrices are small. In this\ncase it might be faster to use the CPU.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the Cholesky decomposition of one or more square matrices."
    }
  },
  {
    "name": "CholeskyGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For an explanation see \"Differentiation of the Cholesky algorithm\" by\nIain Murray http://arxiv.org/abs/1602.07527.",
      "inputs": [
        {
          "description": "Output of batch Cholesky algorithm l = cholesky(A). Shape is `[..., M, M]`.\nAlgorithm depends only on lower triangular part of the innermost matrices of\nthis tensor.",
          "name": "l",
          "typeAttr": "T"
        },
        {
          "description": "df/dl where f is some scalar function. Shape is `[..., M, M]`.\nAlgorithm depends only on lower triangular part of the innermost matrices of\nthis tensor.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Symmetrized version of df/dA . Shape is `[..., M, M]`",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the reverse mode backpropagated gradient of the Cholesky algorithm."
    }
  },
  {
    "name": "ClipByValue",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `t`, this operation returns a tensor of the same type and\nshape as `t` with its values clipped to `clip_value_min` and `clip_value_max`.\nAny values less than `clip_value_min` are set to `clip_value_min`. Any values\ngreater than `clip_value_max` are set to `clip_value_max`.",
      "inputs": [
        {
          "description": "A `Tensor`.",
          "name": "t",
          "typeAttr": "T"
        },
        {
          "description": "A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape\nas `t`. The minimum value to clip by.",
          "name": "clip_value_min",
          "typeAttr": "T"
        },
        {
          "description": "A 0-D (scalar) `Tensor`, or a `Tensor` with the same shape\nas `t`. The maximum value to clip by.",
          "name": "clip_value_max",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A clipped `Tensor` with the same shape as input 't'.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Clips tensor values to a specified min and max."
    }
  },
  {
    "name": "CloseSummaryWriter",
    "schema": {
      "inputs": [
        {
          "name": "writer",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "CollectiveBcastRecv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "name": "group_size",
          "type": "int"
        },
        {
          "name": "group_key",
          "type": "int"
        },
        {
          "name": "instance_key",
          "type": "int"
        },
        {
          "name": "shape",
          "type": "shape"
        }
      ],
      "outputs": [
        {
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "summary": "Receives a tensor value broadcast from another device."
    }
  },
  {
    "name": "CollectiveBcastSend",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "name": "group_size",
          "type": "int"
        },
        {
          "name": "group_key",
          "type": "int"
        },
        {
          "name": "instance_key",
          "type": "int"
        },
        {
          "name": "shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "summary": "Broadcasts a tensor value to one or more other devices."
    }
  },
  {
    "name": "CollectiveReduce",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "name": "group_size",
          "type": "int"
        },
        {
          "name": "group_key",
          "type": "int"
        },
        {
          "name": "instance_key",
          "type": "int"
        },
        {
          "allowedValues": [
            "Min",
            "Max",
            "Mul",
            "Add"
          ],
          "name": "merge_op",
          "type": "string"
        },
        {
          "allowedValues": [
            "Id",
            "Div"
          ],
          "name": "final_op",
          "type": "string"
        },
        {
          "name": "subdiv_offsets",
          "type": "list(int)"
        },
        {
          "default": [],
          "name": "wait_for",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "summary": "Mutually reduces multiple tensors of identical type and shape."
    }
  },
  {
    "name": "CompareAndBitpack",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 10
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "description": "The type of the input and threshold.",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Each comparison returns a boolean `true` (if `input_value > threshold`)\nor and `false` otherwise.\n\nThis operation is useful for Locality-Sensitive-Hashing (LSH) and other\nalgorithms that use hashing approximations of cosine and `L2` distances;\ncodes can be generated from an input via:\n\n```python\ncodebook_size = 50\ncodebook_bits = codebook_size * 32\ncodebook = tf.get_variable('codebook', [x.shape[-1].value, codebook_bits],\n                           dtype=x.dtype,\n                           initializer=tf.orthogonal_initializer())\ncodes = compare_and_threshold(tf.matmul(x, codebook), threshold=0.)\ncodes = tf.bitcast(codes, tf.int32)  # go from uint8 to int32\n# now codes has shape x.shape[:-1] + [codebook_size]\n```\n\n**NOTE**: Currently, the innermost dimension of the tensor must be divisible\nby 8.\n\nGiven an `input` shaped `[s0, s1, ..., s_n]`, the output is\na `uint8` tensor shaped `[s0, s1, ..., s_n / 8]`.",
      "inputs": [
        {
          "description": "Values to compare against `threshold` and bitpack.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "Threshold to compare against.",
          "name": "threshold",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The bitpacked comparisons.",
          "name": "output",
          "type": 4
        }
      ],
      "summary": "Compare values of `input` to `threshold` and pack resulting bits into a `uint8`."
    }
  },
  {
    "name": "Complex",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `real` representing the real part of a complex number, and a\ntensor `imag` representing the imaginary part of a complex number, this\noperation returns complex numbers elementwise of the form \\\\(a + bj\\\\), where\n*a* represents the `real` part and *b* represents the `imag` part.\n\nThe input tensors `real` and `imag` must have the same shape.\n\nFor example:\n\n```\n# tensor 'real' is [2.25, 3.25]\n# tensor `imag` is [4.75, 5.75]\ntf.complex(real, imag) ==> [[2.25 + 4.75j], [3.25 + 5.75j]]\n```",
      "inputs": [
        {
          "name": "real",
          "typeAttr": "T"
        },
        {
          "name": "imag",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Converts two real numbers to a complex number."
    }
  },
  {
    "name": "ComplexAbs",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `x` of complex numbers, this operation returns a tensor of type\n`float` or `double` that is the absolute value of each element in `x`. All\nelements in `x` must be complex numbers of the form \\\\(a + bj\\\\). The absolute\nvalue is computed as \\\\( \\sqrt{a^2 + b^2}\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Computes the complex absolute value of a tensor."
    }
  },
  {
    "name": "ComputeAccidentalHits",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "When doing log-odds NCE, the result of this op should be passed through a\nSparseToDense op, then added to the logits of the sampled candidates. This has\nthe effect of 'removing' the sampled labels that match the true labels by\nmaking the classifier sure that they are sampled labels.",
      "inputs": [
        {
          "description": "The true_classes output of UnpackSparseLabels.",
          "name": "true_classes",
          "type": 9
        },
        {
          "description": "The sampled_candidates output of CandidateSampler.",
          "name": "sampled_candidates",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of indices corresponding to rows of true_candidates.",
          "name": "indices",
          "type": 3
        },
        {
          "description": "A vector of IDs of positions in sampled_candidates that match a true_label\nfor the row with the corresponding index in indices.",
          "name": "ids",
          "type": 9
        },
        {
          "description": "A vector of the same length as indices and ids, in which each element\nis -FLOAT_MAX.",
          "name": "weights",
          "type": 1
        }
      ],
      "summary": "Computes the ids of the positions in sampled_candidates that match true_labels."
    }
  },
  {
    "name": "Concat",
    "schema": {
      "attributes": [
        {
          "minimum": 2,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values)).",
          "name": "concat_dim",
          "type": 3
        },
        {
          "description": "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
          "name": "values",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Concatenates tensors along one dimension."
    }
  },
  {
    "name": "ConcatOffset",
    "schema": {
      "attributes": [
        {
          "minimum": 2,
          "name": "N",
          "type": "int"
        }
      ],
      "description": "For example:\n\n```\n# 'x' is [2, 2, 7]\n# 'y' is [2, 3, 7]\n# 'z' is [2, 5, 7]\nconcat_offset(2, [x, y, z]) => [0, 0, 0], [0, 2, 0], [0, 5, 0]\n```\n\nThis is typically used by gradient computations for a concat operation.",
      "inputs": [
        {
          "description": "The dimension along which to concatenate.",
          "name": "concat_dim",
          "type": 3
        },
        {
          "description": "The `N` int32 vectors representing shape of tensors being concatenated.",
          "name": "shape",
          "numberAttr": "N",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The `N` int32 vectors representing the starting offset\nof input tensors within the concatenated output.",
          "name": "offset",
          "type": 3
        }
      ],
      "summary": "Computes offsets of concat inputs within its output."
    }
  },
  {
    "name": "ConcatV2",
    "schema": {
      "attributes": [
        {
          "minimum": 2,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "category": "Tensor",
      "inputs": [
        {
          "description": "List of `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
          "name": "values",
          "numberAttr": "N",
          "typeAttr": "T"
        },
        {
          "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [-rank(values), rank(values)).",
          "name": "axis",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Concatenates tensors along one dimension."
    }
  },
  {
    "name": "ConcatenateDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "another_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that concatenates `input_dataset` with `another_dataset`."
    }
  },
  {
    "name": "ConditionalAccumulator",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "description": "The type of the value being accumulated.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The shape of the values, can be [], in which case shape is unknown.",
          "name": "shape",
          "type": "shape"
        },
        {
          "default": "",
          "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this accumulator will be shared under the\ngiven name across multiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "allowedValues": [
            "MEAN",
            "SUM"
          ],
          "default": "MEAN",
          "name": "reduction_type",
          "type": "string"
        }
      ],
      "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.",
      "outputs": [
        {
          "description": "The handle to the accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A conditional accumulator for aggregating gradients."
    }
  },
  {
    "name": "Conj",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 21
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ncomplex numbers that are the complex conjugate of each element in `input`. The\ncomplex numbers in `input` must be of the form \\\\(a + bj\\\\), where *a* is the\nreal part and *b* is the imaginary part.\n\nThe complex conjugate returned by this operation is of the form \\\\(a - bj\\\\).\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.conj(input) ==> [-2.25 - 4.75j, 3.25 - 5.75j]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the complex conjugate of a complex number."
    }
  },
  {
    "name": "ConjugateTranspose",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tperm",
          "type": "type"
        }
      ],
      "description": "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`\n  `y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])`",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "perm",
          "typeAttr": "Tperm"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Shuffle dimensions of x according to a permutation and conjugate the result."
    }
  },
  {
    "name": "Const",
    "schema": {
      "attributes": [
        {
          "description": "Attr `value` is the tensor to return.",
          "name": "value",
          "type": "tensor"
        },
        {
          "name": "dtype",
          "type": "type"
        }
      ],
      "category": "Constant",
      "outputs": [
        {
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Returns a constant tensor."
    }
  },
  {
    "name": "ConsumeMutexLock",
    "schema": {
      "description": "This op exists to consume a tensor created by `MutexLock` (other than\ndirect control dependencies).  It should be the only that consumes the tensor,\nand will raise an error if it is not.  Its only purpose is to keep the\nmutex lock tensor alive until it is consumed by this op.\n\n**NOTE**: This operation must run on the same device as its input.  This may\nbe enforced via the `colocate_with` mechanism.",
      "inputs": [
        {
          "description": "A tensor returned by `MutexLock`.",
          "name": "mutex_lock",
          "type": 21
        }
      ],
      "summary": "This op consumes a lock created by `MutexLock`."
    }
  },
  {
    "name": "ControlTrigger",
    "schema": {
      "description": "Only useful as a placeholder for control edges.",
      "summary": "Does nothing. Serves as a control trigger for scheduling."
    }
  },
  {
    "name": "Conv2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 4.  The stride of the sliding window for each\ndimension of `input`. The dimension order is determined by the value of\n`data_format`, see below for details.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "default": true,
          "name": "use_cudnn_on_gpu",
          "type": "bool"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID",
            "EXPLICIT"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "default": [],
          "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
          "name": "explicit_paddings",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "category": "Layer",
      "description": "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`, this op\nperforms the following:\n\n1. Flattens the filter to a 2-D matrix with shape\n   `[filter_height * filter_width * in_channels, output_channels]`.\n2. Extracts image patches from the input tensor to form a *virtual*\n   tensor of shape `[batch, out_height, out_width,\n   filter_height * filter_width * in_channels]`.\n3. For each patch, right-multiplies the filter matrix and the image patch\n   vector.\n\nIn detail, with the default NHWC format,\n\n    output[b, i, j, k] =\n        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *\n                        filter[di, dj, q, k]\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`.",
      "inputs": [
        {
          "description": "A 4-D tensor. The dimension order is interpreted according to the value\nof `data_format`, see below for details.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A 4-D tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`",
          "name": "filter",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A 4-D tensor. The dimension order is determined by the value of\n`data_format`, see below for details.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes a 2-D convolution given 4-D `input` and `filter` tensors."
    }
  },
  {
    "name": "Conv2DBackpropFilter",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "default": true,
          "name": "use_cudnn_on_gpu",
          "type": "bool"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID",
            "EXPLICIT"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "default": [],
          "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
          "name": "explicit_paddings",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, out_channels]` tensor.",
          "name": "filter_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of convolution with respect to the filter."
    }
  },
  {
    "name": "Conv2DBackpropInput",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "default": true,
          "name": "use_cudnn_on_gpu",
          "type": "bool"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID",
            "EXPLICIT"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "default": [],
          "description": "If `padding` is `\"EXPLICIT\"`, the list of explicit padding amounts. For the ith\ndimension, the amount of padding inserted before and after the dimension is\n`explicit_paddings[2 * i]` and `explicit_paddings[2 * i + 1]`, respectively. If\n`padding` is not `\"EXPLICIT\"`, `explicit_paddings` must be empty.",
          "name": "explicit_paddings",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "An integer vector representing the shape of `input`,\nwhere `input` is a 4-D `[batch, height, width, channels]` tensor.",
          "name": "input_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of convolution with respect to the input."
    }
  },
  {
    "name": "Conv3D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 5.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "description": "In signal processing, cross-correlation is a measure of similarity of\ntwo waveforms as a function of a time-lag applied to one of them. This\nis also known as a sliding dot product or sliding inner-product.\n\nOur Conv3D implements a form of cross-correlation.",
      "inputs": [
        {
          "description": "Shape `[batch, in_depth, in_height, in_width, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "Shape `[filter_depth, filter_height, filter_width, in_channels,\nout_channels]`. `in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes a 3-D convolution given 5-D `input` and `filter` tensors."
    }
  },
  {
    "name": "Conv3DBackpropFilter",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1,
            1
          ],
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the filter."
    }
  },
  {
    "name": "Conv3DBackpropFilterV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 5.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 5-D\n`[filter_depth, filter_height, filter_width, in_channels, out_channels]`\ntensor.",
          "name": "filter_sizes",
          "type": 3
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the filter."
    }
  },
  {
    "name": "Conv3DBackpropInput",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1,
            1
          ],
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the input."
    }
  },
  {
    "name": "Conv3DBackpropInputV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 5.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tshape",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "An integer vector representing the tensor shape of `input`,\nwhere `input` is a 5-D\n`[batch, depth, rows, cols, in_channels]` tensor.",
          "name": "input_sizes",
          "typeAttr": "Tshape"
        },
        {
          "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the input."
    }
  },
  {
    "name": "Copy",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "default": [],
          "name": "debug_ops_spec",
          "type": "list(string)"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "CopyHost",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "default": [],
          "name": "debug_ops_spec",
          "type": "list(string)"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "Cos",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes cos of x element-wise."
    }
  },
  {
    "name": "Cosh",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes hyperbolic cosine of x element-wise."
    }
  },
  {
    "name": "CountUpTo",
    "schema": {
      "attributes": [
        {
          "description": "If incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error.",
          "name": "limit",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a scalar `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Increments 'ref' until it reaches 'limit'."
    }
  },
  {
    "name": "CreateSummaryDbWriter",
    "schema": {
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "db_uri",
          "type": 7
        },
        {
          "name": "experiment_name",
          "type": 7
        },
        {
          "name": "run_name",
          "type": 7
        },
        {
          "name": "user_name",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "CreateSummaryFileWriter",
    "schema": {
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "logdir",
          "type": 7
        },
        {
          "name": "max_queue",
          "type": 3
        },
        {
          "name": "flush_millis",
          "type": 3
        },
        {
          "name": "filename_suffix",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "CropAndResize",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "bilinear",
            "nearest"
          ],
          "default": "bilinear",
          "description": "A string specifying the sampling method for resizing. It can be either\n`\"bilinear\"` or `\"nearest\"` and default to `\"bilinear\"`. Currently two sampling\nmethods are supported: Bilinear and Nearest Neighbor.",
          "name": "method",
          "type": "string"
        },
        {
          "default": 0.0,
          "description": "Value used for extrapolation, when applicable.",
          "name": "extrapolation_value",
          "type": "float"
        }
      ],
      "description": "Extracts crops from the input image tensor and resizes them using bilinear\nsampling or nearest neighbor sampling (possibly with aspect ratio change) to a\ncommon output size specified by `crop_size`. This is more general than the\n`crop_to_bounding_box` op which extracts a fixed size slice from the input image\nand does not allow resizing or aspect ratio change.\n\nReturns a tensor with `crops` from the input `image` at positions defined at the\nbounding box locations in `boxes`. The cropped boxes are all resized (with\nbilinear or nearest neighbor interpolation) to a fixed\n`size = [crop_height, crop_width]`. The result is a 4-D tensor\n`[num_boxes, crop_height, crop_width, depth]`. The resizing is corner aligned.\nIn particular, if `boxes = [[0, 0, 1, 1]]`, the method will give identical\nresults to using `tf.image.resize_bilinear()` or\n`tf.image.resize_nearest_neighbor()`(depends on the `method` argument) with\n`align_corners=True`.",
      "inputs": [
        {
          "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.\nBoth `image_height` and `image_width` need to be positive.",
          "name": "image",
          "typeAttr": "T"
        },
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
          "name": "box_ind",
          "type": 3
        },
        {
          "description": "A 1-D tensor of 2 elements, `size = [crop_height, crop_width]`. All\ncropped image patches are resized to this size. The aspect ratio of the image\ncontent is not preserved. Both `crop_height` and `crop_width` need to be\npositive.",
          "name": "crop_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
          "name": "crops",
          "type": 1
        }
      ],
      "summary": "Extracts crops from the input image tensor and resizes them."
    }
  },
  {
    "name": "CropAndResizeGradBoxes",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "bilinear"
          ],
          "default": "bilinear",
          "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now.",
          "name": "method",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.\nBoth `image_height` and `image_width` need to be positive.",
          "name": "image",
          "typeAttr": "T"
        },
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1] in image height coordinates. We do allow y1 > y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
          "name": "box_ind",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`.",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Computes the gradient of the crop_and_resize op wrt the input boxes tensor."
    }
  },
  {
    "name": "CropAndResizeGradImage",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "bilinear",
            "nearest"
          ],
          "default": "bilinear",
          "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now.",
          "name": "method",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1] in image height coordinates. We do allow y1 > y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
          "name": "box_ind",
          "type": 3
        },
        {
          "description": "A 1-D tensor with value `[batch, image_height, image_width, depth]`\ncontaining the original image size. Both `image_height` and `image_width` need\nto be positive.",
          "name": "image_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of the crop_and_resize op wrt the input image tensor."
    }
  },
  {
    "name": "Cross",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`a` and `b` must be the same shape; they can either be simple 3-element vectors,\nor any shape where the innermost dimension is 3. In the latter case, each pair\nof corresponding 3-element vectors is cross-multiplied independently.",
      "inputs": [
        {
          "description": "A tensor containing 3-element vectors.",
          "name": "a",
          "typeAttr": "T"
        },
        {
          "description": "Another tensor, of same type and shape as `a`.",
          "name": "b",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Pairwise cross product of the vectors in `a` and `b`.",
          "name": "product",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the pairwise cross product."
    }
  },
  {
    "name": "CudnnRNN",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        },
        {
          "default": true,
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Computes the RNN from the input and initial states, with respect to the params\nbuffer.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n  the actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\nis_training: Indicates whether this operation is used for inferenece or\n  training.\nreserve_space: An opaque tensor that can be used in backprop calculation. It\n  is only produced if is_training is false.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_h",
          "typeAttr": "T"
        },
        {
          "name": "input_c",
          "typeAttr": "T"
        },
        {
          "name": "params",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "name": "output_h",
          "typeAttr": "T"
        },
        {
          "name": "output_c",
          "typeAttr": "T"
        },
        {
          "name": "reserve_space",
          "typeAttr": "T"
        }
      ],
      "summary": "A RNN backed by cuDNN."
    }
  },
  {
    "name": "CudnnRNNBackprop",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "Compute the backprop of both data and weights in a RNN.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    the actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\noutput_backprop: A 3-D tensor with the same shape as output in the forward pass.\noutput_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n    pass.\noutput_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n    pass.\nreserve_space: The same reserve_space produced in for forward operation.\ninput_backprop: The backprop to input in the forward pass. Has the same shape\n    as input.\ninput_h_backprop: The backprop to input_h in the forward pass. Has the same\n    shape as input_h.\ninput_c_backprop: The backprop to input_c in the forward pass. Has the same\n    shape as input_c.\nparams_backprop: The backprop to the params buffer in the forward pass. Has the\n    same shape as params.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_h",
          "typeAttr": "T"
        },
        {
          "name": "input_c",
          "typeAttr": "T"
        },
        {
          "name": "params",
          "typeAttr": "T"
        },
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "name": "output_h",
          "typeAttr": "T"
        },
        {
          "name": "output_c",
          "typeAttr": "T"
        },
        {
          "name": "output_backprop",
          "typeAttr": "T"
        },
        {
          "name": "output_h_backprop",
          "typeAttr": "T"
        },
        {
          "name": "output_c_backprop",
          "typeAttr": "T"
        },
        {
          "name": "reserve_space",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "input_backprop",
          "typeAttr": "T"
        },
        {
          "name": "input_h_backprop",
          "typeAttr": "T"
        },
        {
          "name": "input_c_backprop",
          "typeAttr": "T"
        },
        {
          "name": "params_backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Backprop step of CudnnRNN."
    }
  },
  {
    "name": "CudnnRNNBackpropV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "Compute the backprop of both data and weights in a RNN. Takes an extra\n    \"host_reserved\" inupt than CudnnRNNBackprop, which is used to determine RNN\n    cudnnRNNAlgo_t and cudnnMathType_t.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n    the actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\noutput_backprop: A 3-D tensor with the same shape as output in the forward pass.\noutput_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n    pass.\noutput_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n    pass.\nreserve_space: The same reserve_space produced in the forward operation.\nhost_reserved: The same host_reserved produced in the forward operation.\ninput_backprop: The backprop to input in the forward pass. Has the same shape\n    as input.\ninput_h_backprop: The backprop to input_h in the forward pass. Has the same\n    shape as input_h.\ninput_c_backprop: The backprop to input_c in the forward pass. Has the same\n    shape as input_c.\nparams_backprop: The backprop to the params buffer in the forward pass. Has the\n    same shape as params.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_h",
          "typeAttr": "T"
        },
        {
          "name": "input_c",
          "typeAttr": "T"
        },
        {
          "name": "params",
          "typeAttr": "T"
        },
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "name": "output_h",
          "typeAttr": "T"
        },
        {
          "name": "output_c",
          "typeAttr": "T"
        },
        {
          "name": "output_backprop",
          "typeAttr": "T"
        },
        {
          "name": "output_h_backprop",
          "typeAttr": "T"
        },
        {
          "name": "output_c_backprop",
          "typeAttr": "T"
        },
        {
          "name": "reserve_space",
          "typeAttr": "T"
        },
        {
          "name": "host_reserved",
          "type": 6
        }
      ],
      "outputs": [
        {
          "name": "input_backprop",
          "typeAttr": "T"
        },
        {
          "name": "input_h_backprop",
          "typeAttr": "T"
        },
        {
          "name": "input_c_backprop",
          "typeAttr": "T"
        },
        {
          "name": "params_backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Backprop step of CudnnRNN."
    }
  },
  {
    "name": "CudnnRNNBackpropV3",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "Compute the backprop of both data and weights in a RNN. Takes an extra\n    \"sequence_lengths\" input than CudnnRNNBackprop.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n    the actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\nsequence_lengths: a vector of lengths of each input sequence.\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\noutput_backprop: A 3-D tensor with the same shape as output in the forward pass.\noutput_h_backprop: A 3-D tensor with the same shape as output_h in the forward\n    pass.\noutput_c_backprop: A 3-D tensor with the same shape as output_c in the forward\n    pass.\nreserve_space: The same reserve_space produced in the forward operation.\ninput_backprop: The backprop to input in the forward pass. Has the same shape\n    as input.\ninput_h_backprop: The backprop to input_h in the forward pass. Has the same\n    shape as input_h.\ninput_c_backprop: The backprop to input_c in the forward pass. Has the same\n    shape as input_c.\nparams_backprop: The backprop to the params buffer in the forward pass. Has the\n    same shape as params.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_h",
          "typeAttr": "T"
        },
        {
          "name": "input_c",
          "typeAttr": "T"
        },
        {
          "name": "params",
          "typeAttr": "T"
        },
        {
          "name": "sequence_lengths",
          "type": 3
        },
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "name": "output_h",
          "typeAttr": "T"
        },
        {
          "name": "output_c",
          "typeAttr": "T"
        },
        {
          "name": "output_backprop",
          "typeAttr": "T"
        },
        {
          "name": "output_h_backprop",
          "typeAttr": "T"
        },
        {
          "name": "output_c_backprop",
          "typeAttr": "T"
        },
        {
          "name": "reserve_space",
          "typeAttr": "T"
        },
        {
          "name": "host_reserved",
          "type": 6
        }
      ],
      "outputs": [
        {
          "name": "input_backprop",
          "typeAttr": "T"
        },
        {
          "name": "input_h_backprop",
          "typeAttr": "T"
        },
        {
          "name": "input_c_backprop",
          "typeAttr": "T"
        },
        {
          "name": "params_backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Backprop step of CudnnRNNV3."
    }
  },
  {
    "name": "CudnnRNNCanonicalToParams",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 1,
          "name": "num_params",
          "type": "int"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "Writes a set of weights into the opaque params buffer so they can be used in\nupcoming training or inferences.\n\nNote that the params buffer may not be compatible across different GPUs. So any\nsave and restoration should be converted to and from the canonical weights and\nbiases.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nweights: the canonical form of weights that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nbiases: the canonical form of biases that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nnum_params: number of parameter sets for all layers.\n    Each layer may contain multiple parameter sets, with each set consisting of\n    a weight matrix and a bias vector.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    The actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n    dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.",
      "inputs": [
        {
          "name": "num_layers",
          "type": 3
        },
        {
          "name": "num_units",
          "type": 3
        },
        {
          "name": "input_size",
          "type": 3
        },
        {
          "name": "weights",
          "numberAttr": "num_params",
          "typeAttr": "T"
        },
        {
          "name": "biases",
          "numberAttr": "num_params",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "params",
          "typeAttr": "T"
        }
      ],
      "summary": "Converts CudnnRNN params from canonical form to usable form."
    }
  },
  {
    "name": "CudnnRNNParamsSize",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "S",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "Return the params size that can be used by the Cudnn RNN model. Subsequent\nweight allocation and initialization should use this size.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n  The actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n  dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.\nparams_size: The size of the params buffer that should be allocated and\n  initialized for this RNN model. Note that this params buffer may not be\n  compatible across GPUs. Please use CudnnRNNParamsWeights and\n  CudnnRNNParamsBiases to save and restore them in a way that is compatible\n  across different runs.",
      "inputs": [
        {
          "name": "num_layers",
          "type": 3
        },
        {
          "name": "num_units",
          "type": 3
        },
        {
          "name": "input_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "params_size",
          "typeAttr": "S"
        }
      ],
      "summary": "Computes size of weights that can be used by a Cudnn RNN model."
    }
  },
  {
    "name": "CudnnRNNParamsToCanonical",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 1,
          "name": "num_params",
          "type": "int"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "Retrieves a set of weights from the opaque params buffer that can be saved and\nrestored in a way compatible with future runs.\n\nNote that the params buffer may not be compatible across different GPUs. So any\nsave and restoration should be converted to and from the canonical weights and\nbiases.\n\nnum_layers: Specifies the number of layers in the RNN model.\nnum_units: Specifies the size of the hidden state.\ninput_size: Specifies the size of the input state.\nnum_params: number of parameter sets for all layers.\n    Each layer may contain multiple parameter sets, with each set consisting of\n    a weight matrix and a bias vector.\nweights: the canonical form of weights that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nbiases: the canonical form of biases that can be used for saving\n    and restoration. They are more likely to be compatible across different\n    generations.\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicate whether there is a linear projection between the input and\n    The actual computation before the first layer. 'skip_input' is only allowed\n    when input_size == num_units; 'auto_select' implies 'skip_input' when\n    input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used.\n    dir = (direction == bidirectional) ? 2 : 1\ndropout: dropout probability. When set to 0., dropout is disabled.\nseed: the 1st part of a seed to initialize dropout.\nseed2: the 2nd part of a seed to initialize dropout.",
      "inputs": [
        {
          "name": "num_layers",
          "type": 3
        },
        {
          "name": "num_units",
          "type": 3
        },
        {
          "name": "input_size",
          "type": 3
        },
        {
          "name": "params",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "weights",
          "typeAttr": "T"
        },
        {
          "name": "biases",
          "typeAttr": "T"
        }
      ],
      "summary": "Retrieves CudnnRNN params in canonical form."
    }
  },
  {
    "name": "CudnnRNNV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        },
        {
          "default": true,
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Computes the RNN from the input and initial states, with respect to the params\nbuffer. Produces one extra output \"host_reserved\" than CudnnRNN.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n  the actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\nis_training: Indicates whether this operation is used for inferenece or\n  training.\nreserve_space: An opaque tensor that can be used in backprop calculation. It\n  is only produced if is_training is true.\nhost_reserved: An opaque tensor that can be used in backprop calculation. It is\n  only produced if is_training is true. It is output on host memory rather than\n  device memory.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_h",
          "typeAttr": "T"
        },
        {
          "name": "input_c",
          "typeAttr": "T"
        },
        {
          "name": "params",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "name": "output_h",
          "typeAttr": "T"
        },
        {
          "name": "output_c",
          "typeAttr": "T"
        },
        {
          "name": "reserve_space",
          "typeAttr": "T"
        },
        {
          "name": "host_reserved",
          "type": 6
        }
      ],
      "summary": "A RNN backed by cuDNN."
    }
  },
  {
    "name": "CudnnRNNV3",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "rnn_relu",
            "rnn_tanh",
            "lstm",
            "gru"
          ],
          "default": "lstm",
          "name": "rnn_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "linear_input",
            "skip_input",
            "auto_select"
          ],
          "default": "linear_input",
          "name": "input_mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "unidirectional",
            "bidirectional"
          ],
          "default": "unidirectional",
          "name": "direction",
          "type": "string"
        },
        {
          "default": 0.0,
          "name": "dropout",
          "type": "float"
        },
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        },
        {
          "default": true,
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Computes the RNN from the input and initial states, with respect to the params\nbuffer. Accepts one extra input \"sequence_lengths\" than CudnnRNN.\n\nrnn_mode: Indicates the type of the RNN model.\ninput_mode: Indicates whether there is a linear projection between the input and\n  the actual computation before the first layer. 'skip_input' is only allowed\n  when input_size == num_units; 'auto_select' implies 'skip_input' when\n  input_size == num_units; otherwise, it implies 'linear_input'.\ndirection: Indicates whether a bidirectional model will be used. Should be\n  \"unidirectional\" or \"bidirectional\".\ndropout: Dropout probability. When set to 0., dropout is disabled.\nseed: The 1st part of a seed to initialize dropout.\nseed2: The 2nd part of a seed to initialize dropout.\ninput: A 3-D tensor with the shape of [seq_length, batch_size, input_size].\ninput_h: A 3-D tensor with the shape of [num_layer * dir, batch_size,\n    num_units].\ninput_c: For LSTM, a 3-D tensor with the shape of\n    [num_layer * dir, batch, num_units]. For other models, it is ignored.\nparams: A 1-D tensor that contains the weights and biases in an opaque layout.\n    The size must be created through CudnnRNNParamsSize, and initialized\n    separately. Note that they might not be compatible across different\n    generations. So it is a good idea to save and restore\nsequence_lengths: a vector of lengths of each input sequence.\noutput: A 3-D tensor with the shape of [seq_length, batch_size,\n    dir * num_units].\noutput_h: The same shape has input_h.\noutput_c: The same shape as input_c for LSTM. An empty tensor for other models.\nis_training: Indicates whether this operation is used for inferenece or\n  training.\nreserve_space: An opaque tensor that can be used in backprop calculation. It\n  is only produced if is_training is true.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_h",
          "typeAttr": "T"
        },
        {
          "name": "input_c",
          "typeAttr": "T"
        },
        {
          "name": "params",
          "typeAttr": "T"
        },
        {
          "name": "sequence_lengths",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "name": "output_h",
          "typeAttr": "T"
        },
        {
          "name": "output_c",
          "typeAttr": "T"
        },
        {
          "name": "reserve_space",
          "typeAttr": "T"
        },
        {
          "name": "host_reserved",
          "type": 6
        }
      ],
      "summary": "A RNN backed by cuDNN."
    }
  },
  {
    "name": "Cumprod",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If `True`, perform exclusive cumprod.",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "default": false,
          "description": "A `bool` (default: False).",
          "name": "reverse",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "By default, this op performs an inclusive cumprod, which means that the first\nelement of the input is identical to the first element of the output:\n\n```python\ntf.cumprod([a, b, c])  # => [a, a * b, a * b * c]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumprod is\nperformed instead:\n\n```python\ntf.cumprod([a, b, c], exclusive=True)  # => [1, a, a * b]\n```\n\nBy setting the `reverse` kwarg to `True`, the cumprod is performed in the\nopposite direction:\n\n```python\ntf.cumprod([a, b, c], reverse=True)  # => [a * b * c, b * c, c]\n```\n\nThis is more efficient than using separate `tf.reverse` ops.\n\nThe `reverse` and `exclusive` kwargs can also be combined:\n\n```python\ntf.cumprod([a, b, c], exclusive=True, reverse=True)  # => [b * c, c, 1]\n```",
      "inputs": [
        {
          "description": "A `Tensor`. Must be one of the following types: `float32`, `float64`,\n`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,\n`complex128`, `qint8`, `quint8`, `qint32`, `half`.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
          "name": "axis",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the cumulative product of the tensor `x` along `axis`."
    }
  },
  {
    "name": "Cumsum",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If `True`, perform exclusive cumsum.",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "default": false,
          "description": "A `bool` (default: False).",
          "name": "reverse",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "By default, this op performs an inclusive cumsum, which means that the first\nelement of the input is identical to the first element of the output:\n\n```python\ntf.cumsum([a, b, c])  # => [a, a + b, a + b + c]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumsum is\nperformed instead:\n\n```python\ntf.cumsum([a, b, c], exclusive=True)  # => [0, a, a + b]\n```\n\nBy setting the `reverse` kwarg to `True`, the cumsum is performed in the\nopposite direction:\n\n```python\ntf.cumsum([a, b, c], reverse=True)  # => [a + b + c, b + c, c]\n```\n\nThis is more efficient than using separate `tf.reverse` ops.\n\nThe `reverse` and `exclusive` kwargs can also be combined:\n\n```python\ntf.cumsum([a, b, c], exclusive=True, reverse=True)  # => [b + c, c, 0]\n```",
      "inputs": [
        {
          "description": "A `Tensor`. Must be one of the following types: `float32`, `float64`,\n`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,\n`complex128`, `qint8`, `quint8`, `qint32`, `half`.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
          "name": "axis",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the cumulative sum of the tensor `x` along `axis`."
    }
  },
  {
    "name": "DataFormatDimMap",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        },
        {
          "default": "NHWC",
          "description": "source data format.",
          "name": "src_format",
          "type": "string"
        },
        {
          "default": "NCHW",
          "description": "destination data format.",
          "name": "dst_format",
          "type": "string"
        }
      ],
      "description": "the source data format.",
      "inputs": [
        {
          "description": "A Tensor with each element as a dimension index in source data format.\nMust be in the range [-4, 4).",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A Tensor with each element as a dimension index in destination data format.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the dimension index in the destination data format given the one in"
    }
  },
  {
    "name": "DataFormatVecPermute",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        },
        {
          "default": "NHWC",
          "description": "source data format.",
          "name": "src_format",
          "type": "string"
        },
        {
          "default": "NCHW",
          "description": "destination data format.",
          "name": "dst_format",
          "type": "string"
        }
      ],
      "description": "one in the source data format.",
      "inputs": [
        {
          "description": "Vector of size 4 or Tensor of shape (4, 2) in source data format.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Vector of size 4 or Tensor of shape (4, 2) in destination data format.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the permuted vector/tensor in the destination data format given the"
    }
  },
  {
    "name": "DatasetToGraph",
    "schema": {
      "description": "Returns a graph representation for `input_dataset`.",
      "inputs": [
        {
          "description": "A variant tensor representing the dataset to return the graph representation for.",
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "The graph representation of the dataset (as serialized GraphDef).",
          "name": "graph",
          "type": 7
        }
      ],
      "summary": "Returns a serialized GraphDef representing `input_dataset`."
    }
  },
  {
    "name": "DatasetToSingleElement",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A handle to a dataset that contains a single element.",
          "name": "dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "The components of the single element of `input`.",
          "name": "components",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "Outputs the single element from the given dataset."
    }
  },
  {
    "name": "DebugGradientIdentity",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op is hidden from public in Python. It is used by TensorFlow Debugger to\nregister gradient tensors for gradient debugging.\nThis op operates on non-reference-type tensors.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Identity op for gradient debugging."
    }
  },
  {
    "name": "DebugGradientRefIdentity",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op is hidden from public in Python. It is used by TensorFlow Debugger to\nregister gradient tensors for gradient debugging.\nThis op operates on reference-type tensors.",
      "inputs": [
        {
          "isRef": true,
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Identity op for gradient debugging."
    }
  },
  {
    "name": "DebugIdentity",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "name": "device_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "default": [],
          "name": "debug_urls",
          "type": "list(string)"
        },
        {
          "default": false,
          "name": "gated_grpc",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "DebugNanCount",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "name": "device_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "default": [],
          "name": "debug_urls",
          "type": "list(string)"
        },
        {
          "default": false,
          "name": "gated_grpc",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 9
        }
      ]
    }
  },
  {
    "name": "DebugNumericSummary",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "name": "device_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "default": [],
          "name": "debug_urls",
          "type": "list(string)"
        },
        {
          "default": "-NaN",
          "name": "lower_bound",
          "type": "float"
        },
        {
          "default": "NaN",
          "name": "upper_bound",
          "type": "float"
        },
        {
          "default": false,
          "name": "mute_if_healthy",
          "type": "bool"
        },
        {
          "default": false,
          "name": "gated_grpc",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 2
        }
      ]
    }
  },
  {
    "name": "DecodeAndCropJpeg",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of color channels for the decoded image.",
          "name": "channels",
          "type": "int"
        },
        {
          "default": 1,
          "description": "Downscaling ratio.",
          "name": "ratio",
          "type": "int"
        },
        {
          "default": true,
          "description": "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only).",
          "name": "fancy_upscaling",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If true try to recover an image from truncated input.",
          "name": "try_recover_truncated",
          "type": "bool"
        },
        {
          "default": 1.0,
          "description": "The minimum required fraction of lines before a truncated\ninput is accepted.",
          "name": "acceptable_fraction",
          "type": "float"
        },
        {
          "default": "",
          "description": "string specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)",
          "name": "dct_method",
          "type": "string"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later.\n\n\nIt is equivalent to a combination of decode and crop, but much faster by only\ndecoding partial jpeg image.",
      "inputs": [
        {
          "description": "0-D.  The JPEG-encoded image.",
          "name": "contents",
          "type": 7
        },
        {
          "description": "1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].",
          "name": "crop_window",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`..",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode and Crop a JPEG-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodeBase64",
    "schema": {
      "description": "Input may or may not have padding at the end. See EncodeBase64 for padding.\nWeb-safe means that input must use - and _ instead of + and /.",
      "inputs": [
        {
          "description": "Base64 strings to decode.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Decoded strings.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Decode web-safe base64-encoded strings."
    }
  },
  {
    "name": "DecodeBmp",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "name": "channels",
          "type": "int"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the BMP-encoded image.\n*   3: output an RGB image.\n*   4: output an RGBA image.",
      "inputs": [
        {
          "description": "0-D.  The BMP-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`. RGB order",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode the first frame of a BMP-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodeCSV",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "minimum": 1,
          "name": "OUT_TYPE",
          "type": "list(type)"
        },
        {
          "default": ",",
          "description": "char delimiter to separate fields in a record.",
          "name": "field_delim",
          "type": "string"
        },
        {
          "default": true,
          "description": "If false, treats double quotation marks as regular\ncharacters inside of the string fields (ignoring RFC 4180, Section 2,\nBullet 5).",
          "name": "use_quote_delim",
          "type": "bool"
        },
        {
          "default": "",
          "description": "Additional string to recognize as NA/NaN.",
          "name": "na_value",
          "type": "string"
        },
        {
          "default": [],
          "name": "select_cols",
          "type": "list(int)"
        }
      ],
      "description": "RFC 4180 format is expected for the CSV records.\n(https://tools.ietf.org/html/rfc4180)\nNote that we allow leading and trailing spaces with int or float field.",
      "inputs": [
        {
          "description": "Each string is a record/row in the csv and all records should have\nthe same format.",
          "name": "records",
          "type": 7
        },
        {
          "description": "One tensor per column of the input record, with either a\nscalar default value for that column or an empty vector if the column is\nrequired.",
          "name": "record_defaults",
          "typeListAttr": "OUT_TYPE"
        }
      ],
      "outputs": [
        {
          "description": "Each tensor will have the same shape as records.",
          "name": "output",
          "typeListAttr": "OUT_TYPE"
        }
      ],
      "summary": "Convert CSV records to tensors. Each column maps to one tensor."
    }
  },
  {
    "name": "DecodeCompressed",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
          "name": "compression_type",
          "type": "string"
        }
      ],
      "description": "This op decompresses each element of the `bytes` input `Tensor`, which\nis assumed to be compressed using the given `compression_type`.\n\nThe `output` is a string `Tensor` of the same shape as `bytes`,\neach element containing the decompressed data from the corresponding\nelement in `bytes`.",
      "inputs": [
        {
          "description": "A Tensor of string which is compressed.",
          "name": "bytes",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor with the same shape as input `bytes`, uncompressed\nfrom bytes.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Decompress strings."
    }
  },
  {
    "name": "DecodeGif",
    "schema": {
      "description": "GIF with frame or transparency compression are not supported\nconvert animated GIF from compressed to uncompressed by:\n\n    convert $src.gif -coalesce $dst.gif\n\nThis op also supports decoding JPEGs and PNGs, though it is cleaner to use\n`tf.image.decode_image`.",
      "inputs": [
        {
          "description": "0-D.  The GIF-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[num_frames, height, width, 3]`. RGB order",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode the first frame of a GIF-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodeJSONExample",
    "schema": {
      "description": "This op translates a tensor containing Example records, encoded using\nthe [standard JSON\nmapping](https://developers.google.com/protocol-buffers/docs/proto3#json),\ninto a tensor containing the same records encoded as binary protocol\nbuffers. The resulting tensor can then be fed to any of the other\nExample-parsing ops.",
      "inputs": [
        {
          "description": "Each string is a JSON object serialized according to the JSON\nmapping of the Example proto.",
          "name": "json_examples",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Each string is a binary Example protocol buffer corresponding\nto the respective element of `json_examples`.",
          "name": "binary_examples",
          "type": 7
        }
      ],
      "summary": "Convert JSON-encoded Example records to binary protocol buffer strings."
    }
  },
  {
    "name": "DecodeJpeg",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of color channels for the decoded image.",
          "name": "channels",
          "type": "int"
        },
        {
          "default": 1,
          "description": "Downscaling ratio.",
          "name": "ratio",
          "type": "int"
        },
        {
          "default": true,
          "description": "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only).",
          "name": "fancy_upscaling",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If true try to recover an image from truncated input.",
          "name": "try_recover_truncated",
          "type": "bool"
        },
        {
          "default": 1.0,
          "description": "The minimum required fraction of lines before a truncated\ninput is accepted.",
          "name": "acceptable_fraction",
          "type": "float"
        },
        {
          "default": "",
          "description": "string specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)",
          "name": "dct_method",
          "type": "string"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later.\n\n\nThis op also supports decoding PNGs and non-animated GIFs since the interface is\nthe same, though it is cleaner to use `tf.image.decode_image`.",
      "inputs": [
        {
          "description": "0-D.  The JPEG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`..",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode a JPEG-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodePng",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of color channels for the decoded image.",
          "name": "channels",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            }
          ],
          "default": {
            "type": "type",
            "value": 4
          },
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the PNG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n*   4: output an RGBA image.\n\nIf needed, the PNG-encoded image is transformed to match the requested number\nof color channels.\n\nThis op also supports decoding JPEGs and non-animated GIFs since the interface\nis the same, though it is cleaner to use `tf.image.decode_image`.",
      "inputs": [
        {
          "description": "0-D.  The PNG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`.",
          "name": "image",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Decode a PNG-encoded image to a uint8 or uint16 tensor."
    }
  },
  {
    "name": "DecodeProtoV2",
    "schema": {
      "attributes": [
        {
          "description": "Name of the proto message type to decode.",
          "name": "message_type",
          "type": "string"
        },
        {
          "description": "List of strings containing proto field names.",
          "name": "field_names",
          "type": "list(string)"
        },
        {
          "description": "List of TF types to use for the respective field in field_names.",
          "minimum": 0,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "default": "local://",
          "description": "Either the special value `local://` or a path to a file containing\na serialized `FileDescriptorSet`.",
          "name": "descriptor_source",
          "type": "string"
        },
        {
          "default": "binary",
          "description": "Either `binary` or `text`.",
          "name": "message_format",
          "type": "string"
        },
        {
          "default": false,
          "description": "Whether to sanitize the result or not.",
          "name": "sanitize",
          "type": "bool"
        }
      ],
      "description": "The `decode_proto` op extracts fields from a serialized protocol buffers\nmessage into tensors.  The fields in `field_names` are decoded and converted\nto the corresponding `output_types` if possible.\n\nA `message_type` name must be provided to give context for the field\nnames. The actual message descriptor can be looked up either in the\nlinked-in descriptor pool or a filename provided by the caller using\nthe `descriptor_source` attribute.\n\nEach output tensor is a dense tensor. This means that it is padded to\nhold the largest number of repeated elements seen in the input\nminibatch. (The shape is also padded by one to prevent zero-sized\ndimensions). The actual repeat counts for each example in the\nminibatch can be found in the `sizes` output. In many cases the output\nof `decode_proto` is fed immediately into tf.squeeze if missing values\nare not a concern. When using tf.squeeze, always pass the squeeze\ndimension explicitly to avoid surprises.\n\nFor the most part, the mapping between Proto field types and\nTensorFlow dtypes is straightforward. However, there are a few\nspecial cases:\n\n- A proto field that contains a submessage or group can only be converted\nto `DT_STRING` (the serialized submessage). This is to reduce the\ncomplexity of the API. The resulting string can be used as input\nto another instance of the decode_proto op.\n\n- TensorFlow lacks support for unsigned integers. The ops represent uint64\ntypes as a `DT_INT64` with the same twos-complement bit pattern\n(the obvious way). Unsigned int32 values can be represented exactly by\nspecifying type `DT_INT64`, or using twos-complement if the caller\nspecifies `DT_INT32` in the `output_types` attribute.\n\nThe `descriptor_source` attribute selects a source of protocol\ndescriptors to consult when looking up `message_type`. This may be a\nfilename containing a serialized `FileDescriptorSet` message,\nor the special value `local://`, in which case only descriptors linked\ninto the code will be searched; the filename can be on any filesystem\naccessible to TensorFlow.\n\nYou can build a `descriptor_source` file using the `--descriptor_set_out`\nand `--include_imports` options to the protocol compiler `protoc`.\n\nThe `local://` database only covers descriptors linked into the\ncode via C++ libraries, not Python imports. You can link in a proto descriptor\nby creating a cc_library target with alwayslink=1.\n\nBoth binary and text proto serializations are supported, and can be\nchosen using the `format` attribute.",
      "inputs": [
        {
          "description": "Tensor of serialized protos with shape `batch_shape`.",
          "name": "bytes",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Tensor of int32 with shape `[batch_shape, len(field_names)]`.\nEach entry is the number of values found for the corresponding field.\nOptional fields may have 0 or 1 values.",
          "name": "sizes",
          "type": 3
        },
        {
          "description": "List of tensors containing values for the corresponding field.\n`values[i]` has datatype `output_types[i]`\nand shape `[batch_shape, max(sizes[...,i])]`.",
          "name": "values",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "The op extracts fields from a serialized protocol buffers message into tensors."
    }
  },
  {
    "name": "DecodeRaw",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "out_type",
          "type": "type"
        },
        {
          "default": true,
          "description": "Whether the input `bytes` are in little-endian order.\nIgnored for `out_type` values that are stored in a single byte like\n`uint8`.",
          "name": "little_endian",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "All the elements must have the same length.",
          "name": "bytes",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor with one more dimension than the input `bytes`.  The\nadded dimension will have size equal to the length of the elements\nof `bytes` divided by the number of bytes to represent `out_type`.",
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Reinterpret the bytes of a string as a vector of numbers."
    }
  },
  {
    "name": "DecodeWav",
    "schema": {
      "attributes": [
        {
          "default": -1,
          "description": "Number of sample channels wanted.",
          "name": "desired_channels",
          "type": "int"
        },
        {
          "default": -1,
          "description": "Length of audio requested.",
          "name": "desired_samples",
          "type": "int"
        }
      ],
      "description": "The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.\n\nWhen desired_channels is set, if the input contains fewer channels than this\nthen the last channel will be duplicated to give the requested number, else if\nthe input has more channels than requested then the additional channels will be\nignored.\n\nIf desired_samples is set, then the audio will be cropped or padded with zeroes\nto the requested length.\n\nThe first output contains a Tensor with the content of the audio samples. The\nlowest dimension will be the number of channels, and the second will be the\nnumber of samples. For example, a ten-sample-long stereo WAV file should give an\noutput shape of [10, 2].",
      "inputs": [
        {
          "description": "The WAV-encoded audio, usually from a file.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "2-D with shape `[length, channels]`.",
          "name": "audio",
          "type": 1
        },
        {
          "description": "Scalar holding the sample rate found in the WAV header.",
          "name": "sample_rate",
          "type": 3
        }
      ],
      "summary": "Decode a 16-bit PCM WAV file to a float tensor."
    }
  },
  {
    "name": "DeepCopy",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The source tensor of type `T`.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "    y: A `Tensor` of type `T`. A copy of `x`. Guaranteed that `y`\n      is not an alias of `x`.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Makes a copy of `x`."
    }
  },
  {
    "name": "DeleteSessionTensor",
    "schema": {
      "inputs": [
        {
          "description": "The handle for a tensor stored in the session state.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Delete the tensor specified by its handle in the session."
    }
  },
  {
    "name": "DenseToDenseSetOperation",
    "schema": {
      "attributes": [
        {
          "name": "set_operation",
          "type": "string"
        },
        {
          "default": true,
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
      "inputs": [
        {
          "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
          "name": "set1",
          "typeAttr": "T"
        },
        {
          "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set1`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
          "name": "set2",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "2D indices of a `SparseTensor`.",
          "name": "result_indices",
          "type": 9
        },
        {
          "description": "1D values of a `SparseTensor`.",
          "name": "result_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
          "name": "result_shape",
          "type": 9
        }
      ],
      "summary": "Applies set operation along last dimension of 2 `Tensor` inputs."
    }
  },
  {
    "name": "DenseToSparseSetOperation",
    "schema": {
      "attributes": [
        {
          "name": "set_operation",
          "type": "string"
        },
        {
          "default": true,
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nInput `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,\nand `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same\nas `set1`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set2`\nindices.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
      "inputs": [
        {
          "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
          "name": "set1",
          "typeAttr": "T"
        },
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must\nbe the same as the 1st `n-1` dimensions of `set1`, `result_shape[n]` is the\nmax set size across `n-1` dimensions.",
          "name": "set2_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2D indices of a `SparseTensor`.",
          "name": "result_indices",
          "type": 9
        },
        {
          "description": "1D values of a `SparseTensor`.",
          "name": "result_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
          "name": "result_shape",
          "type": 9
        }
      ],
      "summary": "Applies set operation along last dimension of `Tensor` and `SparseTensor`."
    }
  },
  {
    "name": "DepthToSpace",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the spatial block, same as in Space2Depth.",
          "minimum": 2,
          "name": "block_size",
          "type": "int"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW",
            "NCHW_VECT_C"
          ],
          "default": "NHWC",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "Rearranges data from depth into blocks of spatial data.\nThis is the reverse transformation of SpaceToDepth. More specifically,\nthis op outputs a copy of the input tensor where values from the `depth`\ndimension are moved in spatial blocks to the `height` and `width` dimensions.\nThe attr `block_size` indicates the input block size and how the data is moved.\n\n  * Chunks of data of size `block_size * block_size` from depth are rearranged\n    into non-overlapping blocks of size `block_size x block_size`\n  * The width the output tensor is `input_depth * block_size`, whereas the\n    height is `input_height * block_size`.\n  * The Y, X coordinates within each block of the output image are determined\n    by the high order component of the input channel index.\n  * The depth of the input tensor must be divisible by\n    `block_size * block_size`.\n\nThe `data_format` attr specifies the layout of the input and output tensors\nwith the following options:\n  \"NHWC\": `[ batch, height, width, channels ]`\n  \"NCHW\": `[ batch, channels, height, width ]`\n  \"NCHW_VECT_C\":\n      `qint8 [ batch, channels / 4, height, width, 4 ]`\n\nIt is useful to consider the operation as transforming a 6-D Tensor.\ne.g. for data_format = NHWC,\n     Each element in the input tensor can be specified via 6 coordinates,\n     ordered by decreasing memory layout significance as:\n     n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates\n                        within the input image, bX, bY means coordinates\n                        within the output block, oC means output channels).\n     The output would be the input transposed to the following layout:\n     n,iY,bY,iX,bX,oC\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given an input of shape `[1, 1, 1, 4]`, data_format = \"NHWC\" and\nblock_size = 2:\n\n```\nx = [[[[1, 2, 3, 4]]]]\n\n```\n\nThis operation will output a tensor of shape `[1, 2, 2, 1]`:\n\n```\n   [[[[1], [2]],\n     [[3], [4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[1, 1, 4]`,\nthe corresponding output will have 2x2 elements and will have a depth of\n1 channel (1 = `4 / (block_size * block_size)`).\nThe output element shape is `[2, 2, 1]`.\n\nFor an input tensor with larger depth, here of shape `[1, 1, 1, 12]`, e.g.\n\n```\nx = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nThis operation, for block size of 2, will return the following tensor of shape\n`[1, 2, 2, 3]`\n\n```\n   [[[[1, 2, 3], [4, 5, 6]],\n     [[7, 8, 9], [10, 11, 12]]]]\n\n```\n\nSimilarly, for the following input of shape `[1 2 2 4]`, and a block size of 2:\n\n```\nx =  [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 4 4 1]`:\n\n```\nx = [[[ [1],   [2],  [5],  [6]],\n      [ [3],   [4],  [7],  [8]],\n      [ [9],  [10], [13],  [14]],\n      [ [11], [12], [15],  [16]]]]\n\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "DepthToSpace for tensors of type T."
    }
  },
  {
    "name": "DepthwiseConv2dNative",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "category": "Layer",
      "description": "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, channel_multiplier]`, containing\n`in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies\na different filter to each input channel (expanding from 1 channel to\n`channel_multiplier` channels for each), then concatenates the results\ntogether. Thus, the output has `in_channels * channel_multiplier` channels.\n\n```\nfor k in 0..in_channels-1\n  for q in 0..channel_multiplier-1\n    output[b, i, j, k * channel_multiplier + q] =\n      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *\n                        filter[di, dj, k, q]\n```\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "filter",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors."
    }
  },
  {
    "name": "DepthwiseConv2dNativeBackpropFilter",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape based on `data_format`.  For example, if\n`data_format` is 'NHWC' then `input` is a 4-D `[batch, in_height,\nin_width, in_channels]` tensor.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, depthwise_multiplier]` tensor.",
          "name": "filter_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape  based on `data_format`.\nFor example, if `data_format` is 'NHWC' then\nout_backprop shape is `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of depthwise convolution with respect to the filter."
    }
  },
  {
    "name": "DepthwiseConv2dNativeBackpropInput",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each filter\nelement on that dimension. The dimension order is determined by the value of\n`data_format`, see above for details. Dilations in the batch and depth\ndimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "inputs": [
        {
          "description": "An integer vector representing the shape of `input`, based\non `data_format`.  For example, if `data_format` is 'NHWC' then\n `input` is a 4-D `[batch, height, width, channels]` tensor.",
          "name": "input_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, depthwise_multiplier]`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape  based on `data_format`.\nFor example, if `data_format` is 'NHWC' then\nout_backprop shape is `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape according to `data_format`.  For example, if\n`data_format` is 'NHWC', output shape is `[batch, in_height,\nin_width, in_channels]`.  Gradient w.r.t. the input of the\nconvolution.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradients of depthwise convolution with respect to the input."
    }
  },
  {
    "name": "Dequantize",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "MIN_COMBINED",
            "MIN_FIRST",
            "SCALED"
          ],
          "default": "MIN_COMBINED",
          "name": "mode",
          "type": "string"
        }
      ],
      "category": "Tensor",
      "description": "[min_range, max_range] are scalar floats that specify the range for\nthe 'input' data. The 'mode' attribute controls exactly which calculations are\nused to convert the float values to their quantized equivalents.\n\nIn 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n\n```\nif T == qint8: in[i] += (range(T) + 1)/ 2.0\nout[i] = min_range + (in[i]* (max_range - min_range) / range(T))\n```\nhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`\n\n*MIN_COMBINED Mode Example*\n\nIf the input comes from a QuantizedRelu6, the output type is\nquint8 (range of 0-255) but the possible range of QuantizedRelu6 is\n0-6.  The min_range and max_range values are therefore 0.0 and 6.0.\nDequantize on quint8 will take each value, cast to float, and multiply\nby 6 / 255.\nNote that if quantizedtype is qint8, the operation will additionally add\neach value by 128 prior to casting.\n\nIf the mode is 'MIN_FIRST', then this approach is used:\n\n```c++\nnum_discrete_values = 1 << (# of bits in T)\nrange_adjust = num_discrete_values / (num_discrete_values - 1)\nrange = (range_max - range_min) * range_adjust\nrange_scale = range / num_discrete_values\nconst double offset_input = static_cast<double>(input) - lowest_quantized;\nresult = range_min + ((input - numeric_limits<T>::min()) * range_scale)\n```\n\n*SCALED mode Example*\n\n`SCALED` mode matches the quantization approach used in\n`QuantizeAndDequantize{V2|V3}`.\n\nIf the mode is `SCALED`, we do not use the full range of the output type,\nchoosing to elide the lowest possible value for symmetry (e.g., output range is\n-127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to\n0.\n\nWe first find the range of values in our tensor. The\nrange we use is always centered on 0, so we find m such that\n```c++\n  m = max(abs(input_min), abs(input_max))\n```\n\nOur input tensor range is then `[-m, m]`.\n\nNext, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.\nIf T is signed, this is\n```\n  num_bits = sizeof(T) * 8\n  [min_fixed, max_fixed] =\n      [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1]\n```\n\nOtherwise, if T is unsigned, the fixed-point range is\n```\n  [min_fixed, max_fixed] = [0, (1 << num_bits) - 1]\n```\n\nFrom this we compute our scaling factor, s:\n```c++\n  s = (2 * m) / (max_fixed - min_fixed)\n```\n\nNow we can dequantize the elements of our tensor:\n```c++\nresult = input * s\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The minimum scalar value possibly produced for the input.",
          "name": "min_range",
          "type": 1
        },
        {
          "description": "The maximum scalar value possibly produced for the input.",
          "name": "max_range",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Dequantize the 'input' tensor into a float Tensor."
    }
  },
  {
    "name": "DeserializeIterator",
    "schema": {
      "inputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        },
        {
          "description": "A variant tensor storing the state of the iterator contained in the\nresource.",
          "name": "serialized",
          "type": 21
        }
      ],
      "summary": "Converts the given variant tensor to an iterator and stores it in the given resource."
    }
  },
  {
    "name": "DeserializeManySparse",
    "schema": {
      "attributes": [
        {
          "description": "The `dtype` of the serialized `SparseTensor` objects.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where\n`N` is the minibatch size and the rows correspond to packed outputs of\n`SerializeSparse`.  The ranks of the original `SparseTensor` objects\nmust all match.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension).\n\nThe output `SparseTensor` object's shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]",
      "inputs": [
        {
          "description": "2-D, The `N` serialized `SparseTensor` objects.\nMust have 3 columns.",
          "name": "serialized_sparse",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "sparse_indices",
          "type": 9
        },
        {
          "name": "sparse_values",
          "typeAttr": "dtype"
        },
        {
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "summary": "Deserialize and concatenate `SparseTensors` from a serialized minibatch."
    }
  },
  {
    "name": "DeserializeSparse",
    "schema": {
      "attributes": [
        {
          "description": "The `dtype` of the serialized `SparseTensor` objects.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 7
            },
            {
              "type": "type",
              "value": 21
            }
          ],
          "default": {
            "type": "type",
            "value": 7
          },
          "name": "Tserialized",
          "type": "type"
        }
      ],
      "description": "The input `serialized_sparse` must have the shape `[?, ?, ..., ?, 3]` where\nthe last dimension stores serialized `SparseTensor` objects and the other N\ndimensions (N >= 0) correspond to a batch. The ranks of the original\n`SparseTensor` objects must all match. When the final `SparseTensor` is\ncreated, its rank is the rank of the incoming `SparseTensor` objects plus N;\nthe sparse tensors have been concatenated along new dimensions, one for each\nbatch.\n\nThe output `SparseTensor` object's shape values for the original dimensions\nare the max across the input `SparseTensor` objects' shape values for the\ncorresponding dimensions. The new dimensions match the size of the batch.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]",
      "inputs": [
        {
          "description": "The serialized `SparseTensor` objects. The last dimension\nmust have 3 columns.",
          "name": "serialized_sparse",
          "typeAttr": "Tserialized"
        }
      ],
      "outputs": [
        {
          "name": "sparse_indices",
          "type": 9
        },
        {
          "name": "sparse_values",
          "typeAttr": "dtype"
        },
        {
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "summary": "Deserialize `SparseTensor` objects."
    }
  },
  {
    "name": "DestroyResourceOp",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "whether to ignore the error when the resource\ndoesn't exist.",
          "name": "ignore_lookup_error",
          "type": "bool"
        }
      ],
      "description": "All subsequent operations using the resource will result in a NotFound\nerror status.",
      "inputs": [
        {
          "description": "handle to the resource to delete.",
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Deletes the resource specified by the handle."
    }
  },
  {
    "name": "DestroyTemporaryVariable",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "Name of the temporary variable, usually the name of the matching\n'TemporaryVariable' op.",
          "name": "var_name",
          "type": "string"
        }
      ],
      "description": "Sets output to the value of the Tensor pointed to by 'ref', then destroys\nthe temporary variable called 'var_name'.\nAll other uses of 'ref' *must* have executed before this op.\nThis is typically achieved by chaining the ref through each assign op, or by\nusing control dependencies.\n\nOutputs the final value of the tensor pointed to by 'ref'.",
      "inputs": [
        {
          "description": "A reference to the temporary variable tensor.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "summary": "Destroys the temporary variable and returns its final value."
    }
  },
  {
    "name": "Diag",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of\nrank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:\n\n`output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.\n\nFor example:\n\n```\n# 'diagonal' is [1, 2, 3, 4]\ntf.diag(diagonal) ==> [[1, 0, 0, 0]\n                       [0, 2, 0, 0]\n                       [0, 0, 3, 0]\n                       [0, 0, 0, 4]]\n```",
      "inputs": [
        {
          "description": "Rank k tensor where k is at most 1.",
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a diagonal tensor with a given diagonal values."
    }
  },
  {
    "name": "DiagPart",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor with the `diagonal` part\nof the `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has dimensions `[D1,..., Dk, D1,..., Dk]`, then the output is a\ntensor of rank `k` with dimensions `[D1,..., Dk]` where:\n\n`diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]`.\n\nFor example:\n\n```\n# 'input' is [[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]]\n\ntf.diag_part(input) ==> [1, 2, 3, 4]\n```",
      "inputs": [
        {
          "description": "Rank k tensor where k is even and not zero.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The extracted diagonal.",
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the diagonal part of the tensor."
    }
  },
  {
    "name": "Digamma",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`Gamma(x)`), element-wise.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes Psi, the derivative of Lgamma (the log of the absolute value of"
    }
  },
  {
    "name": "Dilation2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor. Must be: `[1, stride_height, stride_width, 1]`.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The input stride for atrous morphological dilation. Must be:\n`[1, rate_height, rate_width, 1]`.",
          "minimum": 4,
          "name": "rates",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "The `input` tensor has shape `[batch, in_height, in_width, depth]` and the\n`filter` tensor has shape `[filter_height, filter_width, depth]`, i.e., each\ninput channel is processed independently of the others with its own structuring\nfunction. The `output` tensor has shape\n`[batch, out_height, out_width, depth]`. The spatial dimensions of the output\ntensor depend on the `padding` algorithm. We currently only support the default\n\"NHWC\" `data_format`.\n\nIn detail, the grayscale morphological 2-D dilation is the max-sum correlation\n(for consistency with `conv2d`, we use unmirrored filters):\n\n    output[b, y, x, c] =\n       max_{dy, dx} input[b,\n                          strides[1] * y + rates[1] * dy,\n                          strides[2] * x + rates[2] * dx,\n                          c] +\n                    filter[dy, dx, c]\n\nMax-pooling is a special case when the filter has size equal to the pooling\nkernel size and contains all zeros.\n\nNote on duality: The dilation of `input` by the `filter` is equal to the\nnegation of the erosion of `-input` by the reflected `filter`.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors."
    }
  },
  {
    "name": "Dilation2DBackpropFilter",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: `[1, stride_height, stride_width, 1]`.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. The input stride for atrous morphological dilation.\nMust be: `[1, rate_height, rate_width, 1]`.",
          "minimum": 4,
          "name": "rates",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter_backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of morphological 2-D dilation with respect to the filter."
    }
  },
  {
    "name": "Dilation2DBackpropInput",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: `[1, stride_height, stride_width, 1]`.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. The input stride for atrous morphological dilation.\nMust be: `[1, rate_height, rate_width, 1]`.",
          "minimum": 4,
          "name": "rates",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
          "name": "out_backprop",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "in_backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of morphological 2-D dilation with respect to the input."
    }
  },
  {
    "name": "Div",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Div` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x / y element-wise."
    }
  },
  {
    "name": "DivNoNan",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "\n*NOTE*: `DivNoNan` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns 0 if the denominator is zero."
    }
  },
  {
    "name": "DrawBoundingBoxes",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a copy of `images` but draws on top of the pixels zero or more bounding\nboxes specified by the locations in `boxes`. The coordinates of the each\nbounding box in `boxes` are encoded as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example, if an image is 100 x 200 pixels (height x width) and the bounding\nbox is `[0.1, 0.2, 0.5, 0.9]`, the upper-left and bottom-right coordinates of\nthe bounding box will be `(40, 10)` to `(180, 50)` (in (x,y) coordinates).\n\nParts of the bounding box may fall outside the image.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, depth]`. A batch of images.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding\nboxes.",
          "name": "boxes",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "4-D with the same shape as `images`. The batch of input images with\nbounding boxes drawn on the images.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Draw bounding boxes on a batch of images."
    }
  },
  {
    "name": "DynamicPartition",
    "schema": {
      "attributes": [
        {
          "description": "The number of partitions to output.",
          "minimum": 1,
          "name": "num_partitions",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`\nbecomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`\nare placed in `outputs[i]` in lexicographic order of `js`, and the first\ndimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.\nIn detail,\n\n```python\n    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]\n\n    outputs[i] = pack([data[js, ...] for js if partitions[js] == i])\n```\n\n`data.shape` must start with `partitions.shape`.\n\nFor example:\n\n```python\n    # Scalar partitions.\n    partitions = 1\n    num_partitions = 2\n    data = [10, 20]\n    outputs[0] = []  # Empty with shape [0, 2]\n    outputs[1] = [[10, 20]]\n\n    # Vector partitions.\n    partitions = [0, 0, 1, 1, 0]\n    num_partitions = 2\n    data = [10, 20, 30, 40, 50]\n    outputs[0] = [10, 20, 50]\n    outputs[1] = [30, 40]\n```\n\nSee `dynamic_stitch` for an example on how to merge partitions back.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicPartition.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "Any shape.  Indices in the range `[0, num_partitions)`.",
          "name": "partitions",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "outputs",
          "typeAttr": "T"
        }
      ],
      "summary": "Partitions `data` into `num_partitions` tensors using indices from `partitions`."
    }
  },
  {
    "name": "DynamicStitch",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Builds a merged tensor such that\n\n```python\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n```\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n```python\n    # Scalar indices:\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices:\n    merged[indices[m][i], ...] = data[m][i, ...]\n```\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues are merged in order, so if an index appears in both `indices[m][i]` and\n`indices[n][j]` for `(m,i) < (n,j)` the slice `data[n][j]` will appear in the\nmerged result. If you do not need this guarantee, ParallelDynamicStitch might\nperform better on some devices.\n\nFor example:\n\n```python\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n```\n\nThis method can be used to merge partitions created by `dynamic_partition`\nas illustrated on the following example:\n\n```python\n    # Apply function (increments x_i) on elements for which a certain condition\n    # apply (x_i != -1 in this example).\n    x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n    condition_mask=tf.not_equal(x,tf.constant(-1.))\n    partitioned_data = tf.dynamic_partition(\n        x, tf.cast(condition_mask, tf.int32) , 2)\n    partitioned_data[1] = partitioned_data[1] + 1.0\n    condition_indices = tf.dynamic_partition(\n        tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n    x = tf.dynamic_stitch(condition_indices, partitioned_data)\n    # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n    # unchanged.\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "indices",
          "numberAttr": "N",
          "type": 3
        },
        {
          "name": "data",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "merged",
          "typeAttr": "T"
        }
      ],
      "summary": "Interleave the values from the `data` tensors into a single tensor."
    }
  },
  {
    "name": "EagerPyFunc",
    "schema": {
      "attributes": [
        {
          "name": "token",
          "type": "string"
        },
        {
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        }
      ],
      "description": "semantics of the input, output, and attributes are the same as those for\nPyFunc.",
      "inputs": [
        {
          "name": "input",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "Eagerly executes a python function to compute func(input)->output. The"
    }
  },
  {
    "name": "EditDistance",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "boolean (if true, edit distances are normalized by length of truth).\n\nThe output is:",
          "name": "normalize",
          "type": "bool"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The inputs are variable-length sequences provided by SparseTensors\n  (hypothesis_indices, hypothesis_values, hypothesis_shape)\nand\n  (truth_indices, truth_values, truth_shape).\n\nThe inputs are:",
      "inputs": [
        {
          "description": "The indices of the hypothesis list SparseTensor.\nThis is an N x R int64 matrix.",
          "name": "hypothesis_indices",
          "type": 9
        },
        {
          "description": "The values of the hypothesis list SparseTensor.\nThis is an N-length vector.",
          "name": "hypothesis_values",
          "typeAttr": "T"
        },
        {
          "description": "The shape of the hypothesis list SparseTensor.\nThis is an R-length vector.",
          "name": "hypothesis_shape",
          "type": 9
        },
        {
          "description": "The indices of the truth list SparseTensor.\nThis is an M x R int64 matrix.",
          "name": "truth_indices",
          "type": 9
        },
        {
          "description": "The values of the truth list SparseTensor.\nThis is an M-length vector.",
          "name": "truth_values",
          "typeAttr": "T"
        },
        {
          "description": "truth indices, vector.",
          "name": "truth_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A dense float tensor with rank R - 1.\n\nFor the example input:\n\n    // hypothesis represents a 2x1 matrix with variable-length values:\n    //   (0,0) = [\"a\"]\n    //   (1,0) = [\"b\"]\n    hypothesis_indices = [[0, 0, 0],\n                          [1, 0, 0]]\n    hypothesis_values = [\"a\", \"b\"]\n    hypothesis_shape = [2, 1, 1]\n\n    // truth represents a 2x2 matrix with variable-length values:\n    //   (0,0) = []\n    //   (0,1) = [\"a\"]\n    //   (1,0) = [\"b\", \"c\"]\n    //   (1,1) = [\"a\"]\n    truth_indices = [[0, 1, 0],\n                     [1, 0, 0],\n                     [1, 0, 1],\n                     [1, 1, 0]]\n    truth_values = [\"a\", \"b\", \"c\", \"a\"]\n    truth_shape = [2, 2, 2]\n    normalize = true\n\nThe output will be:\n\n    // output is a 2x2 matrix with edit distances normalized by truth lengths.\n    output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis\n              [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Computes the (possibly normalized) Levenshtein Edit Distance."
    }
  },
  {
    "name": "Elu",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)\n](http://arxiv.org/abs/1511.07289)",
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes exponential linear: `exp(features) - 1` if < 0, `features` otherwise."
    }
  },
  {
    "name": "EluGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Elu operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The outputs of the corresponding Elu operation.",
          "name": "outputs",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients * (outputs + 1)` if outputs < 0,\n`gradients` otherwise.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients for the exponential linear (Elu) operation."
    }
  },
  {
    "name": "Empty",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, initialize the returned tensor with the default value of dtype.  Otherwise, the implementation is free not to initializethe tensor's content.",
          "name": "init",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "1-D. Represents the shape of the output tensor.",
          "name": "shape",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` of type `T`.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Creates a tensor with the given shape.\n\nThis operation creates a tensor of `shape` and `dtype`."
    }
  },
  {
    "name": "EmptyTensorList",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "shape_type",
          "type": "type"
        }
      ],
      "description": "All list elements must be tensors of dtype element_dtype and shape compatible\nwith element_shape.\n\nhandle: an empty tensor list.\nelement_dtype: the type of elements in the list.\nelement_shape: a shape compatible with that of elements in the list.",
      "inputs": [
        {
          "name": "element_shape",
          "typeAttr": "shape_type"
        },
        {
          "name": "max_num_elements",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates and returns an empty tensor list."
    }
  },
  {
    "name": "EncodeBase64",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "Bool whether padding is applied at the ends.",
          "name": "pad",
          "type": "bool"
        }
      ],
      "description": "Refer to the following article for more information on base64 format:\nen.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the\nend so that the encoded has length multiple of 4. See Padding section of the\nlink above.\n\nWeb-safe means that the encoder uses - and _ instead of + and /.",
      "inputs": [
        {
          "description": "Strings to be encoded.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Input strings encoded in base64.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Encode strings into web-safe base64 format."
    }
  },
  {
    "name": "EncodeJpeg",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "",
            "grayscale",
            "rgb"
          ],
          "default": "",
          "description": "Per pixel image format.",
          "name": "format",
          "type": "string"
        },
        {
          "default": 95,
          "description": "Quality of the compression from 0 to 100 (higher is better and slower).",
          "name": "quality",
          "type": "int"
        },
        {
          "default": false,
          "description": "If True, create a JPEG that loads progressively (coarse to fine).",
          "name": "progressive",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If True, spend CPU/RAM to reduce size with no quality change.",
          "name": "optimize_size",
          "type": "bool"
        },
        {
          "default": true,
          "description": "See http://en.wikipedia.org/wiki/Chroma_subsampling.",
          "name": "chroma_downsampling",
          "type": "bool"
        },
        {
          "allowedValues": [
            "in",
            "cm"
          ],
          "default": "in",
          "description": "Unit used to specify `x_density` and `y_density`:\npixels per inch (`'in'`) or centimeter (`'cm'`).",
          "name": "density_unit",
          "type": "string"
        },
        {
          "default": 300,
          "description": "Horizontal pixels per density unit.",
          "name": "x_density",
          "type": "int"
        },
        {
          "default": 300,
          "description": "Vertical pixels per density unit.",
          "name": "y_density",
          "type": "int"
        },
        {
          "default": "",
          "description": "If not empty, embed this XMP metadata in the image header.",
          "name": "xmp_metadata",
          "type": "string"
        }
      ],
      "description": "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.\n\nThe attr `format` can be used to override the color format of the encoded\noutput.  Values can be:\n\n*   `''`: Use a default format based on the number of channels in the image.\n*   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension\n    of `image` must be 1.\n*   `rgb`: Output an RGB JPEG image. The `channels` dimension\n    of `image` must be 3.\n\nIf `format` is not specified or is the empty string, a default format is picked\nin function of the number of channels in `image`:\n\n*   1: Output a grayscale image.\n*   3: Output an RGB image.",
      "inputs": [
        {
          "description": "3-D with shape `[height, width, channels]`.",
          "name": "image",
          "type": 4
        }
      ],
      "outputs": [
        {
          "description": "0-D. JPEG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "JPEG-encode an image."
    }
  },
  {
    "name": "EncodePng",
    "schema": {
      "attributes": [
        {
          "default": -1,
          "description": "Compression level.",
          "name": "compression",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            }
          ],
          "default": {
            "type": "type",
            "value": 4
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`image` is a 3-D uint8 or uint16 Tensor of shape `[height, width, channels]`\nwhere `channels` is:\n\n*   1: for grayscale.\n*   2: for grayscale + alpha.\n*   3: for RGB.\n*   4: for RGBA.\n\nThe ZLIB compression level, `compression`, can be -1 for the PNG-encoder\ndefault or a value from 0 to 9.  9 is the highest compression level, generating\nthe smallest output, but is slower.",
      "inputs": [
        {
          "description": "3-D with shape `[height, width, channels]`.",
          "name": "image",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "0-D. PNG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "PNG-encode an image."
    }
  },
  {
    "name": "EncodeProto",
    "schema": {
      "attributes": [
        {
          "description": "List of strings containing proto field names.",
          "name": "field_names",
          "type": "list(string)"
        },
        {
          "description": "Name of the proto message type to decode.",
          "name": "message_type",
          "type": "string"
        },
        {
          "default": "local://",
          "name": "descriptor_source",
          "type": "string"
        },
        {
          "description": "The input types.",
          "minimum": 1,
          "name": "Tinput_types",
          "type": "list(type)"
        }
      ],
      "description": "The types of the tensors in `values` must match the schema for the\nfields specified in `field_names`. All the tensors in `values` must\nhave a common shape prefix, *batch_shape*.\n\nThe `sizes` tensor specifies repeat counts for each field.  The repeat\ncount (last dimension) of a each tensor in `values` must be greater\nthan or equal to corresponding repeat count in `sizes`.\n\nA `message_type` name must be provided to give context for the field\nnames. The actual message descriptor can be looked up either in the\nlinked-in descriptor pool or a filename provided by the caller using\nthe `descriptor_source` attribute.\n\nThe `descriptor_source` attribute selects a source of protocol\ndescriptors to consult when looking up `message_type`. This may be a\nfilename containing a serialized `FileDescriptorSet` message,\nor the special value `local://`, in which case only descriptors linked\ninto the code will be searched; the filename can be on any filesystem\naccessible to TensorFlow.\n\nYou can build a `descriptor_source` file using the `--descriptor_set_out`\nand `--include_imports` options to the protocol compiler `protoc`.\n\nThe `local://` database only covers descriptors linked into the\ncode via C++ libraries, not Python imports. You can link in a proto descriptor\nby creating a cc_library target with alwayslink=1.\n\nThere are a few special cases in the value mapping:\n\nSubmessage and group fields must be pre-serialized as TensorFlow strings.\n\nTensorFlow lacks support for unsigned int64s, so they must be\nrepresented as `tf.int64` with the same twos-complement bit pattern\n(the obvious way).\n\nUnsigned int32 values can be represented exactly with `tf.int64`, or\nwith sign wrapping if the input is of type `tf.int32`.",
      "inputs": [
        {
          "description": "Tensor of int32 with shape `[batch_shape, len(field_names)]`.",
          "name": "sizes",
          "type": 3
        },
        {
          "description": "List of tensors containing values for the corresponding field.",
          "name": "values",
          "typeListAttr": "Tinput_types"
        }
      ],
      "outputs": [
        {
          "description": "Tensor of serialized protos with shape `batch_shape`.",
          "name": "bytes",
          "type": 7
        }
      ],
      "summary": "The op serializes protobuf messages provided in the input tensors."
    }
  },
  {
    "name": "EncodeWav",
    "schema": {
      "description": "This operation will generate a string suitable to be saved out to create a .wav\naudio file. It will be encoded in the 16-bit PCM format. It takes in float\nvalues in the range -1.0f to 1.0f, and any outside that value will be clamped to\nthat range.\n\n`audio` is a 2-D float Tensor of shape `[length, channels]`.\n`sample_rate` is a scalar Tensor holding the rate to use (e.g. 44100).",
      "inputs": [
        {
          "description": "2-D with shape `[length, channels]`.",
          "name": "audio",
          "type": 1
        },
        {
          "description": "Scalar containing the sample frequency.",
          "name": "sample_rate",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "0-D. WAV-encoded file contents.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "Encode audio data using the WAV file format."
    }
  },
  {
    "name": "EnsureShape",
    "schema": {
      "attributes": [
        {
          "description": "The expected (possibly partially specified) shape of the input tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Raises an error if the input tensor's shape does not match the specified shape.\nReturns the input tensor otherwise.",
      "inputs": [
        {
          "description": "A tensor, whose shape is to be validated.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor with the same shape and contents as the input tensor or value.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Ensures that the tensor's shape matches the expected shape."
    }
  },
  {
    "name": "Enter",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "The name of the child frame.",
          "name": "frame_name",
          "type": "string"
        },
        {
          "default": false,
          "description": "If true, the output is constant within the child frame.",
          "name": "is_constant",
          "type": "bool"
        },
        {
          "default": 10,
          "description": "The number of iterations allowed to run in parallel.",
          "name": "parallel_iterations",
          "type": "int"
        }
      ],
      "description": "This op is used together with `Exit` to create loops in the graph.\nThe unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the child frame.",
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Creates or finds a child frame, and makes `data` available to the child frame."
    }
  },
  {
    "name": "Equal",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 7
            },
            {
              "type": "type",
              "value": 10
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Equal` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x == y) element-wise."
    }
  },
  {
    "name": "Erf",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the Gauss error function of `x` element-wise."
    }
  },
  {
    "name": "Erfc",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the complementary error function of `x` element-wise."
    }
  },
  {
    "name": "Exit",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Exit makes its input `data` available to the parent frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the parent frame.",
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Exits the current frame to its parent frame."
    }
  },
  {
    "name": "Exp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes exponential of x element-wise.  \\\\(y = e^x\\\\)."
    }
  },
  {
    "name": "ExpandDims",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tdim",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input`, this operation inserts a dimension of 1 at the\ndimension index `dim` of `input`'s shape. The dimension index `dim` starts at\nzero; if you specify a negative number for `dim` it is counted backward from\nthe end.\n\nThis operation is useful if you want to add a batch dimension to a single\nelement. For example, if you have a single image of shape `[height, width,\nchannels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,\nwhich will make the shape `[1, height, width, channels]`.\n\nOther examples:\n\n```\n# 't' is a tensor of shape [2]\nshape(expand_dims(t, 0)) ==> [1, 2]\nshape(expand_dims(t, 1)) ==> [2, 1]\nshape(expand_dims(t, -1)) ==> [2, 1]\n\n# 't2' is a tensor of shape [2, 3, 5]\nshape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]\nshape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]\nshape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]\n```\n\nThis operation requires that:\n\n`-1-input.dims() <= dim <= input.dims()`\n\nThis operation is related to `squeeze()`, which removes dimensions of\nsize 1.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "0-D (scalar). Specifies the dimension index at which to\nexpand the shape of `input`. Must be in the range\n`[-rank(input) - 1, rank(input)]`.",
          "name": "dim",
          "typeAttr": "Tdim"
        }
      ],
      "outputs": [
        {
          "description": "Contains the same data as `input`, but its shape has an additional\ndimension of size 1 added.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Inserts a dimension of 1 into a tensor's shape."
    }
  },
  {
    "name": "ExperimentalAssertNextDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "transformations",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalBytesProducedStatsDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "tag",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Records the bytes size of each element of `input_dataset` in a StatsAggregator."
    }
  },
  {
    "name": "ExperimentalCSVDataset",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "filenames",
          "type": 7
        },
        {
          "name": "compression_type",
          "type": 7
        },
        {
          "name": "buffer_size",
          "type": 9
        },
        {
          "name": "header",
          "type": 10
        },
        {
          "name": "field_delim",
          "type": 7
        },
        {
          "name": "use_quote_delim",
          "type": 10
        },
        {
          "name": "na_value",
          "type": 7
        },
        {
          "name": "select_cols",
          "type": 9
        },
        {
          "name": "record_defaults",
          "typeListAttr": "output_types"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalDatasetCardinality",
    "schema": {
      "description": "Returns the cardinality of `input_dataset`.",
      "inputs": [
        {
          "description": "A variant tensor representing the dataset to return cardinality for.",
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "The cardinality of `input_dataset`. Named constants are used to represent\ninfinite and unknown cardinality.",
          "name": "cardinality",
          "type": 9
        }
      ],
      "summary": "Returns the cardinality of `input_dataset`."
    }
  },
  {
    "name": "ExperimentalDatasetToTFRecord",
    "schema": {
      "inputs": [
        {
          "description": "A variant tensor representing the dataset to write.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar string tensor representing the filename to use.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "A scalar string tensor containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
          "name": "compression_type",
          "type": 7
        }
      ],
      "summary": "Writes the given dataset to the given file using the TFRecord format."
    }
  },
  {
    "name": "ExperimentalDenseToSparseBatchDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A handle to an input dataset. Must have a single component.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A vector representing the dense shape of each row in the produced\nSparseTensor. The shape may be partially specified, using `-1` to indicate\nthat a particular dimension should use the maximum size of all batch elements.",
          "name": "row_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches input elements into a SparseTensor."
    }
  },
  {
    "name": "ExperimentalDirectedInterleaveDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "A dataset of scalar `DT_INT64` elements that determines which of the\n`N` data inputs should produce the next output element.",
          "name": "selector_input_dataset",
          "type": 21
        },
        {
          "description": "`N` datasets with the same type that will be interleaved according to\nthe values of `selector_input_dataset`.",
          "name": "data_input_datasets",
          "numberAttr": "N",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "A substitute for `InterleaveDataset` on a fixed list of `N` datasets."
    }
  },
  {
    "name": "ExperimentalGroupByReducerDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64.",
          "name": "key_func",
          "type": "func"
        },
        {
          "description": "A function mapping a key of type DT_INT64, concatenated with\n`init_func_other_arguments` to the initial reducer state.",
          "name": "init_func",
          "type": "func"
        },
        {
          "description": "A function mapping the current reducer state and an element of `input_dataset`,\nconcatenated with `reduce_func_other_arguments` to a new reducer state.",
          "name": "reduce_func",
          "type": "func"
        },
        {
          "description": "A function mapping the final reducer state to an output element.",
          "name": "finalize_func",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Tkey_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Tinit_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Treduce_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Tfinalize_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Creates a dataset that computes a group-by on `input_dataset`.",
      "inputs": [
        {
          "description": "A variant tensor representing the input dataset.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `key_func`.",
          "name": "key_func_other_arguments",
          "typeListAttr": "Tkey_func_other_arguments"
        },
        {
          "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `init_func`.",
          "name": "init_func_other_arguments",
          "typeListAttr": "Tinit_func_other_arguments"
        },
        {
          "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `reduce_func`.",
          "name": "reduce_func_other_arguments",
          "typeListAttr": "Treduce_func_other_arguments"
        },
        {
          "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `finalize_func`.",
          "name": "finalize_func_other_arguments",
          "typeListAttr": "Tfinalize_func_other_arguments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that computes a group-by on `input_dataset`."
    }
  },
  {
    "name": "ExperimentalGroupByWindowDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64.",
          "name": "key_func",
          "type": "func"
        },
        {
          "name": "reduce_func",
          "type": "func"
        },
        {
          "name": "window_size_func",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Tkey_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Treduce_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Twindow_size_func_other_arguments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "// TODO(mrry): Support non-int64 keys.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "key_func_other_arguments",
          "typeListAttr": "Tkey_func_other_arguments"
        },
        {
          "name": "reduce_func_other_arguments",
          "typeListAttr": "Treduce_func_other_arguments"
        },
        {
          "name": "window_size_func_other_arguments",
          "typeListAttr": "Twindow_size_func_other_arguments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that computes a windowed group-by on `input_dataset`."
    }
  },
  {
    "name": "ExperimentalIdentityIndexedDataset",
    "schema": {
      "inputs": [
        {
          "name": "size",
          "type": 23
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalIgnoreErrorsDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that contains the elements of `input_dataset` ignoring errors."
    }
  },
  {
    "name": "ExperimentalIndexedDatasetGet",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "materialized",
          "type": 20
        },
        {
          "name": "index",
          "type": 23
        }
      ],
      "outputs": [
        {
          "name": "components",
          "typeListAttr": "output_types"
        }
      ]
    }
  },
  {
    "name": "ExperimentalIndexedDatasetMaterialize",
    "schema": {
      "inputs": [
        {
          "name": "dataset",
          "type": 21
        },
        {
          "name": "materialized",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "ExperimentalIteratorGetDevice",
    "schema": {
      "inputs": [
        {
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "device",
          "type": 7
        }
      ],
      "summary": "Returns the name of the device on which `resource` has been placed."
    }
  },
  {
    "name": "ExperimentalLMDBDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "filenames",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalLatencyStatsDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "tag",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Records the latency of producing `input_dataset` elements in a StatsAggregator."
    }
  },
  {
    "name": "ExperimentalMapAndBatchDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function to apply to the outputs of `input_dataset`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": false,
          "name": "preserve_cardinality",
          "type": "bool"
        }
      ],
      "description": "Creates a dataset that applies `f` to the outputs of `input_dataset` and then\nbatches `batch_size` of them.\n\nUnlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `batch_size * num_parallel_batches` copies of `f` in parallel.",
      "inputs": [
        {
          "description": "A variant tensor representing the input dataset.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A list of tensors, typically values that were captured when building a closure\nfor `f`.",
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch. It determines the number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A scalar representing the maximum number of parallel invocations of the `map_fn`\nfunction. Applying the `map_fn` on consecutive input elements in parallel has\nthe potential to improve input pipeline throughput.",
          "name": "num_parallel_calls",
          "type": 9
        },
        {
          "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
          "name": "drop_remainder",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that fuses mapping with batching."
    }
  },
  {
    "name": "ExperimentalMapDataset",
    "schema": {
      "attributes": [
        {
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": true,
          "name": "use_inter_op_parallelism",
          "type": "bool"
        },
        {
          "default": false,
          "name": "preserve_cardinality",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "ExperimentalMatchingFilesDataset",
    "schema": {
      "inputs": [
        {
          "name": "patterns",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalMaterializedIndexDatasetHandle",
    "schema": {
      "attributes": [
        {
          "name": "container",
          "type": "string"
        },
        {
          "name": "shared_name",
          "type": "string"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "ExperimentalMaxIntraOpParallelismDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "Identifies the maximum intra-op parallelism to use.",
          "name": "max_intra_op_parallelism",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that overrides the maximum intra-op parallelism."
    }
  },
  {
    "name": "ExperimentalNonSerializableDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalNumaMapAndBatchDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function to apply to the outputs of `input_dataset`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": false,
          "name": "preserve_cardinality",
          "type": "bool"
        }
      ],
      "description": "Creates a dataset that applies `f` to the outputs of `input_dataset` and then\nbatches `batch_size` of them.\n\nUnlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `batch_size * num_parallel_batches` copies of `f` in parallel.\n\nUnlike \"MapAndBatchDatasetV2\", this dataset uses a NUMA-aware thread scheduling\npolicy. Because it uses the single-threaded executor, it only supports the\nfunction-based control flow ops.",
      "inputs": [
        {
          "description": "A variant tensor representing the input dataset.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A list of tensors, typically values that were captured when building a closure\nfor `f`.",
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch. It determines the number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A scalar representing the maximum number of parallel invocations of the `map_fn`\nfunction. Applying the `map_fn` on consecutive input elements in parallel has\nthe potential to improve input pipeline throughput.",
          "name": "num_parallel_calls",
          "type": 9
        },
        {
          "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
          "name": "drop_remainder",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that fuses mapping with batching."
    }
  },
  {
    "name": "ExperimentalParallelInterleaveDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "The resulting dataset is similar to the `InterleaveDataset`, with the exception\nthat if retrieving the next value from a dataset would cause the requester to\nblock, it will skip that input dataset. This dataset is especially useful\nwhen loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\nallows the training step to proceed so long as some data is available.\n\n!! WARNING !! This dataset is not deterministic!",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        },
        {
          "name": "cycle_length",
          "type": 9
        },
        {
          "name": "block_length",
          "type": 9
        },
        {
          "name": "sloppy",
          "type": 10
        },
        {
          "name": "buffer_output_elements",
          "type": 9
        },
        {
          "name": "prefetch_input_elements",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "ExperimentalParseExampleDataset",
    "schema": {
      "attributes": [
        {
          "description": "A list of string keys in the examples features.\nThe results for these keys will be returned as `SparseTensor` objects.",
          "minimum": 0,
          "name": "sparse_keys",
          "type": "list(string)"
        },
        {
          "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples features associated with dense values.",
          "minimum": 0,
          "name": "dense_keys",
          "type": "list(string)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "description": "A list of `DTypes` of the same length as `sparse_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported.",
          "minimum": 0,
          "name": "sparse_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "description": "A list of DTypes of the same length as `dense_keys`.\nOnly `tf.float32` (`FloatList`), `tf.int64` (`Int64List`),\nand `tf.string` (`BytesList`) are supported.\n",
          "minimum": 0,
          "name": "Tdense",
          "type": "list(type)"
        },
        {
          "description": "List of tuples with the same length as `dense_keys`.\nThe shape of the data for each dense feature referenced by `dense_keys`.\nRequired for any input tensors identified by `dense_keys`.  Must be\neither fully defined, or may contain an unknown first dimension.\nAn unknown first dimension means the feature is treated as having\na variable number of blocks, and the output shape along this dimension\nis considered unknown at graph build time.  Padding is applied for\nminibatch elements smaller than the maximum number of blocks for the\ngiven feature along this dimension.",
          "minimum": 0,
          "name": "dense_shapes",
          "type": "list(shape)"
        },
        {
          "description": "The type list for the return values.",
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "The list of shapes being produced.",
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": false,
          "name": "sloppy",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "num_parallel_calls",
          "type": 9
        },
        {
          "description": "A dict mapping string keys to `Tensor`s.\nThe keys of the dict must match the dense_keys of the feature.",
          "name": "dense_defaults",
          "typeListAttr": "Tdense"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Transforms `input_dataset` containing `Example` protos as vectors of DT_STRING into a dataset of `Tensor` or `SparseTensor` objects representing the parsed features."
    }
  },
  {
    "name": "ExperimentalPrivateThreadPoolDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "Identifies the number of threads to use for the private threadpool.",
          "name": "num_threads",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`."
    }
  },
  {
    "name": "ExperimentalRandomDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A scalar seed for the random number generator. If either seed or\nseed2 is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": 9
        },
        {
          "description": "A second scalar seed to avoid seed collision.",
          "name": "seed2",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a Dataset that returns pseudorandom numbers."
    }
  },
  {
    "name": "ExperimentalScanDataset",
    "schema": {
      "attributes": [
        {
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 1,
          "name": "Tstate",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": false,
          "name": "preserve_cardinality",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "initial_state",
          "typeListAttr": "Tstate"
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset successively reduces `f` over the elements of `input_dataset`."
    }
  },
  {
    "name": "ExperimentalSetStatsAggregatorDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "stats_aggregator",
          "type": 20
        },
        {
          "name": "tag",
          "type": 7
        },
        {
          "name": "counter_prefix",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalSleepDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "sleep_microseconds",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "ExperimentalSlidingWindowDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements in the\nsliding window.",
          "name": "window_size",
          "type": 9
        },
        {
          "description": "A scalar representing the steps moving the sliding window\nforward in one iteration. It must be positive.",
          "name": "window_shift",
          "type": 9
        },
        {
          "description": "A scalar representing the stride of the input elements of the sliding window.\nIt must be positive.",
          "name": "window_stride",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that passes a sliding window over `input_dataset`."
    }
  },
  {
    "name": "ExperimentalSqlDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "The database type. Currently, the only supported type is 'sqlite'.",
          "name": "driver_name",
          "type": 7
        },
        {
          "description": "A connection string to connect to the database.",
          "name": "data_source_name",
          "type": 7
        },
        {
          "description": "A SQL query to execute.",
          "name": "query",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that executes a SQL query and emits rows of the result set."
    }
  },
  {
    "name": "ExperimentalStatsAggregatorHandle",
    "schema": {
      "attributes": [
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Creates a statistics manager resource."
    }
  },
  {
    "name": "ExperimentalStatsAggregatorSummary",
    "schema": {
      "inputs": [
        {
          "name": "iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Produces a summary of any statistics recorded by the given statistics manager."
    }
  },
  {
    "name": "ExperimentalThreadPoolDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A resource produced by the ThreadPoolHandle op.",
          "name": "thread_pool",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`."
    }
  },
  {
    "name": "ExperimentalThreadPoolHandle",
    "schema": {
      "attributes": [
        {
          "description": "The number of threads in the thread pool.",
          "name": "num_threads",
          "type": "int"
        },
        {
          "default": 1,
          "description": "The maximum degree of parallelism to use within operations that execute on this\nthreadpool.",
          "name": "max_intra_op_parallelism",
          "type": "int"
        },
        {
          "description": "A human-readable name for the threads that may be visible in some\nvisualizations.\nthreadpool.",
          "name": "display_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "A resource that can be consumed by one or more ExperimentalThreadPoolDataset\nops.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Creates a dataset that uses a custom thread pool to compute `input_dataset`."
    }
  },
  {
    "name": "ExperimentalUnbatchDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "A dataset that splits the elements of its input into multiple elements."
    }
  },
  {
    "name": "ExperimentalUniqueDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that contains the unique elements of `input_dataset`."
    }
  },
  {
    "name": "Expm1",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = (\\exp x) - 1\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes exponential of x - 1 element-wise."
    }
  },
  {
    "name": "ExtractGlimpse",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "indicates if the offset coordinates are centered relative to\nthe image, in which case the (0, 0) offset is relative to the center\nof the input images. If false, the (0,0) offset corresponds to the\nupper left corner of the input images.",
          "name": "centered",
          "type": "bool"
        },
        {
          "default": true,
          "description": "indicates if the offset coordinates are normalized.",
          "name": "normalized",
          "type": "bool"
        },
        {
          "default": true,
          "description": "indicates if the noise should be generated using a\nuniform distribution or a Gaussian distribution.",
          "name": "uniform_noise",
          "type": "bool"
        }
      ],
      "description": "Returns a set of windows called glimpses extracted at location\n`offsets` from the input tensor. If the windows only partially\noverlaps the inputs, the non overlapping areas will be filled with\nrandom noise.\n\nThe result is a 4-D tensor of shape `[batch_size, glimpse_height,\nglimpse_width, channels]`. The channels and batch dimensions are the\nsame as that of the input tensor. The height and width of the output\nwindows are specified in the `size` parameter.\n\nThe argument `normalized` and `centered` controls how the windows are built:\n\n* If the coordinates are normalized but not centered, 0.0 and 1.0\n  correspond to the minimum and maximum of each height and width\n  dimension.\n* If the coordinates are both normalized and centered, they range from\n  -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper\n  left corner, the lower right corner is located at (1.0, 1.0) and the\n  center is at (0, 0).\n* If the coordinates are not normalized they are interpreted as\n  numbers of pixels.",
      "inputs": [
        {
          "description": "A 4-D float tensor of shape `[batch_size, height, width, channels]`.",
          "name": "input",
          "type": 1
        },
        {
          "description": "A 1-D tensor of 2 elements containing the size of the glimpses\nto extract.  The glimpse height must be specified first, following\nby the glimpse width.",
          "name": "size",
          "type": 3
        },
        {
          "description": "A 2-D integer tensor of shape `[batch_size, 2]` containing\nthe y, x locations of the center of each window.",
          "name": "offsets",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A tensor representing the glimpses `[batch_size,\nglimpse_height, glimpse_width, channels]`.",
          "name": "glimpse",
          "type": 1
        }
      ],
      "summary": "Extracts a glimpse from the input tensor."
    }
  },
  {
    "name": "ExtractImagePatches",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of `images`.",
          "minimum": 4,
          "name": "ksizes",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. How far the centers of two consecutive patches are in\nthe images. Must be: `[1, stride_rows, stride_cols, 1]`.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. Must be: `[1, rate_rows, rate_cols, 1]`. This is the\ninput stride, specifying how far two consecutive patch samples are in the\ninput. Equivalent to extracting patches with\n`patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)`, followed by\nsubsampling them spatially by a factor of `rates`. This is equivalent to\n`rate` in dilated (a.k.a. Atrous) convolutions.",
          "minimum": 4,
          "name": "rates",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.\n\nWe specify the size-related attributes as:\n\n```python\n      ksizes = [1, ksize_rows, ksize_cols, 1]\n      strides = [1, strides_rows, strides_cols, 1]\n      rates = [1, rates_rows, rates_cols, 1]\n```",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D Tensor with shape `[batch, in_rows, in_cols, depth]`.",
          "name": "images",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D Tensor with shape `[batch, out_rows, out_cols, ksize_rows *\nksize_cols * depth]` containing image patches with size\n`ksize_rows x ksize_cols x depth` vectorized in the \"depth\" dimension. Note\n`out_rows` and `out_cols` are the dimensions of the output patches.",
          "name": "patches",
          "typeAttr": "T"
        }
      ],
      "summary": "Extract `patches` from `images` and put them in the \"depth\" output dimension."
    }
  },
  {
    "name": "ExtractJpegShape",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "description": "(Optional) The output type of the operation (int32 or int64).\nDefaults to int32.",
          "name": "output_type",
          "type": "type"
        }
      ],
      "description": "This op only parses the image header, so it is much faster than DecodeJpeg.",
      "inputs": [
        {
          "description": "0-D. The JPEG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "1-D. The image shape with format [height, width, channels].",
          "name": "image_shape",
          "typeAttr": "output_type"
        }
      ],
      "summary": "Extract the shape information of a JPEG-encoded image."
    }
  },
  {
    "name": "ExtractVolumePatches",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of `input`.",
          "minimum": 5,
          "name": "ksizes",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 5. How far the centers of two consecutive patches are in\n`input`. Must be: `[1, stride_planes, stride_rows, stride_cols, 1]`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.\n\nWe specify the size-related attributes as:\n\n```python\n      ksizes = [1, ksize_planes, ksize_rows, ksize_cols, 1]\n      strides = [1, stride_planes, strides_rows, strides_cols, 1]\n```",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "5-D Tensor with shape `[batch, in_planes, in_rows, in_cols, depth]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "5-D Tensor with shape `[batch, out_planes, out_rows, out_cols,\nksize_planes * ksize_rows * ksize_cols * depth]` containing patches\nwith size `ksize_planes x ksize_rows x ksize_cols x depth` vectorized\nin the \"depth\" dimension. Note `out_planes`, `out_rows` and `out_cols`\nare the dimensions of the output patches.",
          "name": "patches",
          "typeAttr": "T"
        }
      ],
      "summary": "Extract `patches` from `input` and put them in the \"depth\" output dimension. 3D extension of `extract_image_patches`."
    }
  },
  {
    "name": "FFT",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tcomplex",
          "type": "type"
        }
      ],
      "description": "Computes the 1-dimensional discrete Fourier transform over the inner-most\ndimension of `input`.",
      "inputs": [
        {
          "description": "A complex tensor.",
          "name": "input",
          "typeAttr": "Tcomplex"
        }
      ],
      "outputs": [
        {
          "description": "A complex tensor of the same shape as `input`. The inner-most\n  dimension of `input` is replaced with its 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fft\n@end_compatibility",
          "name": "output",
          "typeAttr": "Tcomplex"
        }
      ],
      "summary": "Fast Fourier transform."
    }
  },
  {
    "name": "FFT2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tcomplex",
          "type": "type"
        }
      ],
      "description": "Computes the 2-dimensional discrete Fourier transform over the inner-most\n2 dimensions of `input`.",
      "inputs": [
        {
          "description": "A complex tensor.",
          "name": "input",
          "typeAttr": "Tcomplex"
        }
      ],
      "outputs": [
        {
          "description": "A complex tensor of the same shape as `input`. The inner-most 2\n  dimensions of `input` are replaced with their 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fft2\n@end_compatibility",
          "name": "output",
          "typeAttr": "Tcomplex"
        }
      ],
      "summary": "2D fast Fourier transform."
    }
  },
  {
    "name": "FFT3D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tcomplex",
          "type": "type"
        }
      ],
      "description": "Computes the 3-dimensional discrete Fourier transform over the inner-most 3\ndimensions of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "typeAttr": "Tcomplex"
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most 3\n  dimensions of `input` are replaced with their 3D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "typeAttr": "Tcomplex"
        }
      ],
      "summary": "3D fast Fourier transform."
    }
  },
  {
    "name": "FIFOQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "FIFOQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "Fact",
    "schema": {
      "outputs": [
        {
          "name": "fact",
          "type": 7
        }
      ],
      "summary": "Output a fact about factorials."
    }
  },
  {
    "name": "FakeParam",
    "schema": {
      "attributes": [
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "    The purported shape of the output. This is only used for shape inference;\n    the output will not necessarily have this shape. Can be a partial shape.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "outputs": [
        {
          "description": "    \\\"Fake\\\" output value. This should not be consumed by another op.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "  This op is used as a placeholder in If branch functions. It doesn't provide a\n  valid output when run, so must either be removed (e.g. replaced with a\n  function input) or guaranteed not to be used (e.g. if mirroring an\n  intermediate output needed for the gradient computation of the other branch)."
    }
  },
  {
    "name": "FakeQuantWithMinMaxArgs",
    "schema": {
      "attributes": [
        {
          "default": -6.0,
          "name": "min",
          "type": "float"
        },
        {
          "default": 6.0,
          "name": "max",
          "type": "float"
        },
        {
          "default": 8,
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "description": "Attributes `[min; max]` define the clamping range for the `inputs` data.\n`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`\nwhen `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and\nthen de-quantized and output as floats in `[min; max]` interval.\n`num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.\n\nQuantization is called fake since the output is still in floating point.",
      "inputs": [
        {
          "name": "inputs",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "outputs",
          "type": 1
        }
      ],
      "summary": "Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type."
    }
  },
  {
    "name": "FakeQuantWithMinMaxArgsGradient",
    "schema": {
      "attributes": [
        {
          "default": -6.0,
          "name": "min",
          "type": "float"
        },
        {
          "default": 6.0,
          "name": "max",
          "type": "float"
        },
        {
          "default": 8,
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "Values passed as inputs to the FakeQuantWithMinMaxArgs operation.",
          "name": "inputs",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:\n`gradients * (inputs >= min && inputs <= max)`.",
          "name": "backprops",
          "type": 1
        }
      ],
      "summary": "Compute gradients for a FakeQuantWithMinMaxArgs operation."
    }
  },
  {
    "name": "FakeQuantWithMinMaxVars",
    "schema": {
      "attributes": [
        {
          "default": 8,
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "description": "and `max` to 'outputs' tensor of same shape as `inputs`.\n\n`[min; max]` define the clamping range for the `inputs` data.\n`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`\nwhen `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and\nthen de-quantized and output as floats in `[min; max]` interval.\n`num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.\n\nThis operation has a gradient and thus allows for training `min` and `max`\nvalues.",
      "inputs": [
        {
          "name": "inputs",
          "type": 1
        },
        {
          "name": "min",
          "type": 1
        },
        {
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "outputs",
          "type": 1
        }
      ],
      "summary": "Fake-quantize the 'inputs' tensor of type float via global float scalars `min`"
    }
  },
  {
    "name": "FakeQuantWithMinMaxVarsGradient",
    "schema": {
      "attributes": [
        {
          "default": 8,
          "description": "The bitwidth of the quantization; between 2 and 8, inclusive.",
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether to quantize into 2^num_bits - 1 distinct values.",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Backpropagated gradients above the FakeQuantWithMinMaxVars operation.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "Values passed as inputs to the FakeQuantWithMinMaxVars operation.\nmin, max: Quantization interval, scalar floats.",
          "name": "inputs",
          "type": 1
        },
        {
          "name": "min",
          "type": 1
        },
        {
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Backpropagated gradients w.r.t. inputs:\n`gradients * (inputs >= min && inputs <= max)`.",
          "name": "backprops_wrt_input",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. min parameter:\n`sum(gradients * (inputs < min))`.",
          "name": "backprop_wrt_min",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. max parameter:\n`sum(gradients * (inputs > max))`.",
          "name": "backprop_wrt_max",
          "type": 1
        }
      ],
      "summary": "Compute gradients for a FakeQuantWithMinMaxVars operation."
    }
  },
  {
    "name": "FakeQuantWithMinMaxVarsPerChannel",
    "schema": {
      "attributes": [
        {
          "default": 8,
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "description": "`[b, d]` `[b, h, w, d]` via per-channel floats `min` and `max` of shape `[d]`\nto 'outputs' tensor of same shape as `inputs`.\n\n`[min; max]` define the clamping range for the `inputs` data.\n`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`\nwhen `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and\nthen de-quantized and output as floats in `[min; max]` interval.\n`num_bits` is the bitwidth of the quantization; between 2 and 16, inclusive.\n\nThis operation has a gradient and thus allows for training `min` and `max`\nvalues.",
      "inputs": [
        {
          "name": "inputs",
          "type": 1
        },
        {
          "name": "min",
          "type": 1
        },
        {
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "outputs",
          "type": 1
        }
      ],
      "summary": "Fake-quantize the 'inputs' tensor of type float and one of the shapes: `[d]`,"
    }
  },
  {
    "name": "FakeQuantWithMinMaxVarsPerChannelGradient",
    "schema": {
      "attributes": [
        {
          "default": 8,
          "description": "The bitwidth of the quantization; between 2 and 16, inclusive.",
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether to quantize into 2^num_bits - 1 distinct values.",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Backpropagated gradients above the FakeQuantWithMinMaxVars operation,\nshape one of: `[d]`, `[b, d]`,  `[b, h, w, d]`.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape\n  same as `gradients`.\nmin, max: Quantization interval, floats of shape `[d]`.",
          "name": "inputs",
          "type": 1
        },
        {
          "name": "min",
          "type": 1
        },
        {
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Backpropagated gradients w.r.t. inputs, shape same as\n`inputs`:\n  `gradients * (inputs >= min && inputs <= max)`.",
          "name": "backprops_wrt_input",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. min parameter, shape `[d]`:\n`sum_per_d(gradients * (inputs < min))`.",
          "name": "backprop_wrt_min",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. max parameter, shape `[d]`:\n`sum_per_d(gradients * (inputs > max))`.",
          "name": "backprop_wrt_max",
          "type": 1
        }
      ],
      "summary": "Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation."
    }
  },
  {
    "name": "FakeQueue",
    "schema": {
      "inputs": [
        {
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Do not use."
    }
  },
  {
    "name": "Fill",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "index_type",
          "type": "type"
        }
      ],
      "description": "This operation creates a tensor of shape `dims` and fills it with `value`.\n\nFor example:\n\n```\n# Output tensor has shape [2, 3].\nfill([2, 3], 9) ==> [[9, 9, 9]\n                     [9, 9, 9]]\n```\n\n`tf.fill` differs from `tf.constant` in a few ways:\n\n*   `tf.fill` only supports scalar contents, whereas `tf.constant` supports\n    Tensor values.\n*   `tf.fill` creates an Op in the computation graph that constructs the actual\n    Tensor value at runtime. This is in contrast to `tf.constant` which embeds\n    the entire Tensor into the graph with a `Const` node.\n*   Because `tf.fill` evaluates at graph runtime, it supports dynamic shapes\n    based on other runtime Tensors, unlike `tf.constant`.",
      "inputs": [
        {
          "description": "1-D. Represents the shape of the output tensor.",
          "name": "dims",
          "typeAttr": "index_type"
        },
        {
          "description": "0-D (scalar). Value to fill the returned tensor.\n\n@compatibility(numpy)\nEquivalent to np.full\n@end_compatibility",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Creates a tensor filled with a scalar value."
    }
  },
  {
    "name": "FilterByLastComponentDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 21
        }
      ],
      "summary": "Creates a dataset containing elements of first component of `input_dataset` having true in the last component."
    }
  },
  {
    "name": "FilterDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function returning a scalar boolean.",
          "name": "predicate",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "The `predicate` function must return a scalar boolean and accept the\nfollowing arguments:\n\n* One tensor for each component of an element of `input_dataset`.\n* One tensor for each value in `other_arguments`.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `predicate`.",
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset containing elements of `input_dataset` matching `predicate`."
    }
  },
  {
    "name": "FixedLengthRecordDataset",
    "schema": {
      "inputs": [
        {
          "description": "A scalar or a vector containing the name(s) of the file(s) to be\nread.",
          "name": "filenames",
          "type": 7
        },
        {
          "description": "A scalar representing the number of bytes to skip at the\nbeginning of a file.",
          "name": "header_bytes",
          "type": 9
        },
        {
          "description": "A scalar representing the number of bytes in each record.",
          "name": "record_bytes",
          "type": 9
        },
        {
          "description": "A scalar representing the number of bytes to skip at the end\nof a file.",
          "name": "footer_bytes",
          "type": 9
        },
        {
          "description": "A scalar representing the number of bytes to buffer. Must be > 0.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the records from one or more binary files."
    }
  },
  {
    "name": "FixedLengthRecordDatasetV2",
    "schema": {
      "inputs": [
        {
          "name": "filenames",
          "type": 7
        },
        {
          "name": "header_bytes",
          "type": 9
        },
        {
          "name": "record_bytes",
          "type": 9
        },
        {
          "name": "footer_bytes",
          "type": 9
        },
        {
          "name": "buffer_size",
          "type": 9
        },
        {
          "name": "compression_type",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "FixedLengthRecordReader",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of bytes in the header, defaults to 0.",
          "name": "header_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes in the record.",
          "name": "record_bytes",
          "type": "int"
        },
        {
          "default": 0,
          "description": "Number of bytes in the footer, defaults to 0.",
          "name": "footer_bytes",
          "type": "int"
        },
        {
          "default": 0,
          "description": "Number of bytes to hop before each read. Default of 0 means using\nrecord_bytes.",
          "name": "hop_bytes",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs fixed-length records from a file."
    }
  },
  {
    "name": "FixedLengthRecordReaderV2",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of bytes in the header, defaults to 0.",
          "name": "header_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes in the record.",
          "name": "record_bytes",
          "type": "int"
        },
        {
          "default": 0,
          "description": "Number of bytes in the footer, defaults to 0.",
          "name": "footer_bytes",
          "type": "int"
        },
        {
          "default": 0,
          "description": "Number of bytes to hop before each read. Default of 0 means using\nrecord_bytes.",
          "name": "hop_bytes",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": "",
          "description": "The type of encoding for the file. Currently ZLIB and GZIP\nare supported. Defaults to none.",
          "name": "encoding",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs fixed-length records from a file."
    }
  },
  {
    "name": "FixedUnigramCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "minimum": 1,
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "minimum": 1,
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "minimum": 1,
          "name": "range_max",
          "type": "int"
        },
        {
          "default": "",
          "description": "Each valid line in this file (which should have a CSV-like format)\ncorresponds to a valid word ID. IDs are in sequential order, starting from\nnum_reserved_ids. The last entry in each line is expected to be a value\ncorresponding to the count or relative probability. Exactly one of vocab_file\nand unigrams needs to be passed to this op.",
          "name": "vocab_file",
          "type": "string"
        },
        {
          "default": 1.0,
          "description": "The distortion is used to skew the unigram probability distribution.\nEach weight is first raised to the distortion's power before adding to the\ninternal unigram distribution. As a result, distortion = 1.0 gives regular\nunigram sampling (as defined by the vocab file), and distortion = 0.0 gives\na uniform distribution.",
          "name": "distortion",
          "type": "float"
        },
        {
          "default": 0,
          "description": "Optionally some reserved IDs can be added in the range [0,\n..., num_reserved_ids) by the users. One use case is that a special unknown\nword token is used as ID 0. These IDs will have a sampling probability of 0.",
          "name": "num_reserved_ids",
          "type": "int"
        },
        {
          "default": 1,
          "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with 'shard') indicates the number of partitions that are being\nused in the overall computation.",
          "minimum": 1,
          "name": "num_shards",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with 'num_shards') indicates the particular partition number of a\nsampler op, when partitioning is being used.",
          "minimum": 0,
          "name": "shard",
          "type": "int"
        },
        {
          "default": [],
          "description": "A list of unigram counts or probabilities, one per ID in sequential\norder. Exactly one of vocab_file and unigrams should be passed to this op.",
          "name": "unigrams",
          "type": "list(float)"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "A unigram sampler could use a fixed unigram distribution read from a\nfile or passed in as an in-memory array instead of building up the distribution\nfrom data on the fly. There is also an option to skew the distribution by\napplying a distortion power to the weights.\n\nThe vocabulary file should be in CSV-like format, with the last field\nbeing the weight associated with the word.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "FlatMapDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Unlike MapDataset, the `f` in FlatMapDataset is expected to return a\nDataset variant, and FlatMapDataset will flatten successive results\ninto a single Dataset.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "Floor",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns element-wise largest integer not greater than x."
    }
  },
  {
    "name": "FloorDiv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `FloorDiv` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x // y element-wise."
    }
  },
  {
    "name": "FloorMod",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "true, this follows Python semantics in that the result here is consistent\nwith a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.\n\n*NOTE*: `FloorMod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns element-wise remainder of division. When `x < 0` xor `y < 0` is"
    }
  },
  {
    "name": "FlushSummaryWriter",
    "schema": {
      "inputs": [
        {
          "name": "writer",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "For",
    "schema": {
      "attributes": [
        {
          "description": "A list of dtypes.",
          "minimum": 0,
          "name": "T",
          "type": "list(type)"
        },
        {
          "description": "    A function that takes a list of tensors (int32, T) and returns another\n    list of tensors (T).",
          "name": "body",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "The lower bound. An int32",
          "name": "start",
          "type": 3
        },
        {
          "description": "The upper bound. An int32",
          "name": "limit",
          "type": 3
        },
        {
          "description": "The increment. An int32",
          "name": "delta",
          "type": 3
        },
        {
          "description": "A list of input tensors whose types are T.",
          "name": "input",
          "typeListAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A list of output tensors whose types are T.",
          "name": "output",
          "typeListAttr": "T"
        }
      ],
      "summary": "  ```python\n   output = input;\n   for i in range(start, limit, delta)\n     output = body(i, output);\n  ```"
    }
  },
  {
    "name": "FractionalAvgPool",
    "schema": {
      "attributes": [
        {
          "description": "Pooling ratio for each dimension of `value`, currently only\nsupports row and col dimension and should be >= 1.0. For example, a valid\npooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements\nmust be 1.0 because we don't allow pooling on batch and channels\ndimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions\nrespectively.",
          "minimum": 4,
          "name": "pooling_ratio",
          "type": "list(float)"
        },
        {
          "default": false,
          "description": "When set to True, generates the pooling sequence in a\npseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin\nGraham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for\ndifference between pseudorandom and random.",
          "name": "pseudo_random",
          "type": "bool"
        },
        {
          "default": false,
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [41/3, 26/3] for fractional avg pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "default": false,
          "description": "When set to True, a fixed pooling region will be used when\niterating over a FractionalAvgPool node in the computation graph. Mainly used\nin unit test to make FractionalAvgPool deterministic.",
          "name": "deterministic",
          "type": "bool"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Fractional average pooling is similar to Fractional max pooling in the pooling\nregion generation step. The only difference is that after pooling regions are\ngenerated, a mean operation is performed instead of a max operation in each\npooling region.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "output tensor after fractional avg pooling.",
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "row pooling sequence, needed to calculate gradient.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, needed to calculate gradient.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "summary": "Performs fractional average pooling on the input."
    }
  },
  {
    "name": "FractionalAvgPoolGrad",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [41/3, 26/3] for fractional avg pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Unlike FractionalMaxPoolGrad, we don't need to find arg_max for\nFractionalAvgPoolGrad, we just need to evenly back-propagate each element of\nout_backprop to those indices that form the same pooling cell. Therefore, we\njust need to know the shape of original input tensor, instead of the whole\ntensor.",
      "inputs": [
        {
          "description": "Original input tensor shape for `fractional_avg_pool`",
          "name": "orig_input_tensor_shape",
          "type": 9
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients\nw.r.t. the output of `fractional_avg_pool`.",
          "name": "out_backprop",
          "typeAttr": "T"
        },
        {
          "description": "row pooling sequence, form pooling region with\ncol_pooling_sequence.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, form pooling region with\nrow_pooling sequence.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "4-D.  Gradients w.r.t. the input of `fractional_avg_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradient of the FractionalAvgPool function."
    }
  },
  {
    "name": "FractionalMaxPool",
    "schema": {
      "attributes": [
        {
          "description": "Pooling ratio for each dimension of `value`, currently only\nsupports row and col dimension and should be >= 1.0. For example, a valid\npooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements\nmust be 1.0 because we don't allow pooling on batch and channels\ndimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions\nrespectively.",
          "minimum": 4,
          "name": "pooling_ratio",
          "type": "list(float)"
        },
        {
          "default": false,
          "description": "When set to True, generates the pooling sequence in a\npseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin\nGraham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for\ndifference between pseudorandom and random.",
          "name": "pseudo_random",
          "type": "bool"
        },
        {
          "default": false,
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [20, 16] for fractional max pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "default": false,
          "description": "When set to True, a fixed pooling region will be used when\niterating over a FractionalMaxPool node in the computation graph. Mainly used\nin unit test to make FractionalMaxPool deterministic.",
          "name": "deterministic",
          "type": "bool"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Fractional max pooling is slightly different than regular max pooling.  In\nregular max pooling, you downsize an input set by taking the maximum value of\nsmaller N x N subsections of the set (often 2x2), and try to reduce the set by\na factor of N, where N is an integer.  Fractional max pooling, as you might\nexpect from the word \"fractional\", means that the overall reduction ratio N\ndoes not have to be an integer.\n\nThe sizes of the pooling regions are generated randomly but are fairly uniform.\nFor example, let's look at the height dimension, and the constraints on the\nlist of rows that will be pool boundaries.\n\nFirst we define the following:\n\n1.  input_row_length : the number of rows from the input set\n2.  output_row_length : which will be smaller than the input\n3.  alpha = input_row_length / output_row_length : our reduction ratio\n4.  K = floor(alpha)\n5.  row_pooling_sequence : this is the result list of pool boundary rows\n\nThen, row_pooling_sequence should satisfy:\n\n1.  a[0] = 0 : the first value of the sequence is 0\n2.  a[end] = input_row_length : the last value of the sequence is the size\n3.  K <= (a[i+1] - a[i]) <= K+1 : all intervals are K or K+1 size\n4.  length(row_pooling_sequence) = output_row_length+1\n\nFor more details on fractional max pooling, see this paper:\n[Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "output tensor after fractional max pooling.",
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "row pooling sequence, needed to calculate gradient.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, needed to calculate gradient.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "summary": "Performs fractional max pooling on the input."
    }
  },
  {
    "name": "FractionalMaxPoolGrad",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [20, 16] for fractional max pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Original input for `fractional_max_pool`",
          "name": "orig_input",
          "typeAttr": "T"
        },
        {
          "description": "Original output for `fractional_max_pool`",
          "name": "orig_output",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients\nw.r.t. the output of `fractional_max_pool`.",
          "name": "out_backprop",
          "typeAttr": "T"
        },
        {
          "description": "row pooling sequence, form pooling region with\ncol_pooling_sequence.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, form pooling region with\nrow_pooling sequence.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "4-D.  Gradients w.r.t. the input of `fractional_max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradient of the FractionalMaxPool function."
    }
  },
  {
    "name": "FusedBatchNorm",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            }
          ],
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "default": 9.999999747378752e-05,
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": true,
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "category": "Normalization",
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for offset, to shift to the normalized x.",
          "name": "offset",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
          "name": "mean",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
          "name": "variance",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for output data.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
          "name": "batch_mean",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
          "name": "batch_variance",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
          "name": "reserve_space_1",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
          "name": "reserve_space_2",
          "typeAttr": "T"
        }
      ],
      "summary": "Batch normalization."
    }
  },
  {
    "name": "FusedBatchNormGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            }
          ],
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "default": 9.999999747378752e-05,
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": true,
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to y.",
          "name": "y_backprop",
          "typeAttr": "T"
        },
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "typeAttr": "T"
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
          "name": "reserve_space_1",
          "typeAttr": "T"
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
          "name": "reserve_space_2",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to x.",
          "name": "x_backprop",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the gradient with respect to scale.",
          "name": "scale_backprop",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the gradient with respect to offset.",
          "name": "offset_backprop",
          "typeAttr": "T"
        },
        {
          "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
          "name": "reserve_space_3",
          "typeAttr": "T"
        },
        {
          "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
          "name": "reserve_space_4",
          "typeAttr": "T"
        }
      ],
      "summary": "Gradient for batch normalization."
    }
  },
  {
    "name": "FusedBatchNormGradV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            }
          ],
          "description": "The data type for the scale, offset, mean, and variance.",
          "name": "U",
          "type": "type"
        },
        {
          "default": 9.999999747378752e-05,
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": true,
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to y.",
          "name": "y_backprop",
          "typeAttr": "T"
        },
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "type": 1
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
          "name": "reserve_space_1",
          "typeAttr": "U"
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
          "name": "reserve_space_2",
          "typeAttr": "U"
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to x.",
          "name": "x_backprop",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the gradient with respect to scale.",
          "name": "scale_backprop",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for the gradient with respect to offset.",
          "name": "offset_backprop",
          "typeAttr": "U"
        },
        {
          "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
          "name": "reserve_space_3",
          "typeAttr": "U"
        },
        {
          "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
          "name": "reserve_space_4",
          "typeAttr": "U"
        }
      ],
      "summary": "Gradient for batch normalization."
    }
  },
  {
    "name": "FusedBatchNormV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            }
          ],
          "description": "The data type for the scale, offset, mean, and variance.",
          "name": "U",
          "type": "type"
        },
        {
          "default": 9.999999747378752e-05,
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "default": true,
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for offset, to shift to the normalized x.",
          "name": "offset",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
          "name": "mean",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
          "name": "variance",
          "typeAttr": "U"
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for output data.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
          "name": "batch_mean",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
          "name": "batch_variance",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
          "name": "reserve_space_1",
          "typeAttr": "U"
        },
        {
          "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
          "name": "reserve_space_2",
          "typeAttr": "U"
        }
      ],
      "summary": "Batch normalization."
    }
  },
  {
    "name": "FusedPadConv2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "REFLECT",
            "SYMMETRIC"
          ],
          "name": "mode",
          "type": "string"
        },
        {
          "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "Similar to FusedResizeAndPadConv2d, this op allows for an optimized\nimplementation where the spatial padding transformation stage is fused with the\nim2col lookup, but in this case without the bilinear filtering required for\nresizing. Fusing the padding prevents the need to write out the intermediate\nresults as whole tensors, reducing memory pressure, and we can get some latency\ngains by merging the transformation calculations.\nThe data_format attribute for Conv2D isn't supported by this op, and 'NHWC'\norder is used instead.\nInternally this op uses a single per-graph scratch buffer, which means that it\nwill block if multiple versions are being run in parallel. This is because this\noperator is primarily an optimization to minimize memory usage.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
          "name": "filter",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs a padding as a preprocess during a convolution."
    }
  },
  {
    "name": "FusedResizeAndPadConv2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
          "name": "resize_align_corners",
          "type": "bool"
        },
        {
          "allowedValues": [
            "REFLECT",
            "SYMMETRIC"
          ],
          "name": "mode",
          "type": "string"
        },
        {
          "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "It's often possible to do spatial transformations more efficiently as part of\nthe packing stage of a convolution, so this op allows for an optimized\nimplementation where these stages are fused together. This prevents the need to\nwrite out the intermediate results as whole tensors, reducing memory pressure,\nand we can get some latency gains by merging the transformation calculations.\nThe data_format attribute for Conv2D isn't supported by this op, and defaults to\n'NHWC' order.\nInternally this op uses a single per-graph scratch buffer, which means that it\nwill block if multiple versions are being run in parallel. This is because this\noperator is primarily an optimization to minimize memory usage.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
          "name": "filter",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs a resize and padding as a preprocess during a convolution."
    }
  },
  {
    "name": "Gather",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "name": "Tparams",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n```python\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n```\n\nIf `indices` is a permutation and `len(indices) == params.shape[0]` then\nthis operation will permute `params` accordingly.\n\n`validate_indices`: DEPRECATED. If this operation is assigned to CPU, values in\n`indices` are always validated to be within range. If assigned to GPU,\nout-of-bound indices result in safe but unspecified behavior, which may include\nraising an error.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "params",
          "typeAttr": "Tparams"
        },
        {
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "Tparams"
        }
      ],
      "summary": "Gather slices from `params` according to `indices`."
    }
  },
  {
    "name": "GatherNd",
    "schema": {
      "attributes": [
        {
          "name": "Tparams",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "`indices` is an K-dimensional integer tensor, best thought of as a\n(K-1)-dimensional tensor of indices into `params`, where each element defines a\nslice of `params`:\n\n    output[\\\\(i_0, ..., i_{K-2}\\\\)] = params[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n\nWhereas in `tf.gather` `indices` defines slices into the first\ndimension of `params`, in `tf.gather_nd`, `indices` defines slices into the\nfirst `N` dimensions of `params`, where `N = indices.shape[-1]`.\n\nThe last dimension of `indices` can be at most the rank of\n`params`:\n\n    indices.shape[-1] <= params.rank\n\nThe last dimension of `indices` corresponds to elements\n(if `indices.shape[-1] == params.rank`) or slices\n(if `indices.shape[-1] < params.rank`) along dimension `indices.shape[-1]`\nof `params`.  The output tensor has shape\n\n    indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, a 0 is stored in the\ncorresponding output value.\n\nSome examples below.\n\nSimple indexing into a matrix:\n\n```python\n    indices = [[0, 0], [1, 1]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = ['a', 'd']\n```\n\nSlice indexing into a matrix:\n\n```python\n    indices = [[1], [0]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [['c', 'd'], ['a', 'b']]\n```\n\nIndexing into a 3-tensor:\n\n```python\n    indices = [[1]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[['a1', 'b1'], ['c1', 'd1']]]\n\n\n    indices = [[0, 1], [1, 0]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [['c0', 'd0'], ['a1', 'b1']]\n\n\n    indices = [[0, 0, 1], [1, 0, 1]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = ['b0', 'b1']\n```\n\nBatched indexing into a matrix:\n\n```python\n    indices = [[[0, 0]], [[0, 1]]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [['a'], ['b']]\n```\n\nBatched slice indexing into a matrix:\n\n```python\n    indices = [[[1]], [[0]]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [[['c', 'd']], [['a', 'b']]]\n```\n\nBatched indexing into a 3-tensor:\n\n```python\n    indices = [[[1]], [[0]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[[['a1', 'b1'], ['c1', 'd1']]],\n              [[['a0', 'b0'], ['c0', 'd0']]]]\n\n    indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[['c0', 'd0'], ['a1', 'b1']],\n              [['a0', 'b0'], ['c1', 'd1']]]\n\n\n    indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [['b0', 'b1'], ['d0', 'c1']]\n```\n\nSee also `tf.gather` and `tf.batch_gather`.",
      "inputs": [
        {
          "description": "The tensor from which to gather values.",
          "name": "params",
          "typeAttr": "Tparams"
        },
        {
          "description": "Index tensor.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Values from `params` gathered from indices given by `indices`, with\nshape `indices.shape[:-1] + params.shape[indices.shape[-1]:]`.",
          "name": "output",
          "typeAttr": "Tparams"
        }
      ],
      "summary": "Gather slices from `params` into a Tensor with shape specified by `indices`."
    }
  },
  {
    "name": "GatherV2",
    "schema": {
      "attributes": [
        {
          "name": "Tparams",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Taxis",
          "type": "type"
        }
      ],
      "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `params.shape[:axis] + indices.shape +\nparams.shape[axis + 1:]` where:\n\n```python\n    # Scalar indices (output is rank(params) - 1).\n    output[a_0, ..., a_n, b_0, ..., b_n] =\n      params[a_0, ..., a_n, indices, b_0, ..., b_n]\n\n    # Vector indices (output is rank(params)).\n    output[a_0, ..., a_n, i, b_0, ..., b_n] =\n      params[a_0, ..., a_n, indices[i], b_0, ..., b_n]\n\n    # Higher rank indices (output is rank(params) + rank(indices) - 1).\n    output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =\n      params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt>\n</div>\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, a 0 is stored in the\ncorresponding output value.\n\nSee also `tf.batch_gather` and `tf.gather_nd`.",
      "inputs": [
        {
          "description": "The tensor from which to gather values. Must be at least rank\n`axis + 1`.",
          "name": "params",
          "typeAttr": "Tparams"
        },
        {
          "description": "Index tensor. Must be in range `[0, params.shape[axis])`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "The axis in `params` to gather `indices` from. Defaults to the first\ndimension. Supports negative indexes.",
          "name": "axis",
          "typeAttr": "Taxis"
        }
      ],
      "outputs": [
        {
          "description": "Values from `params` gathered from indices given by `indices`, with\nshape `params.shape[:axis] + indices.shape + params.shape[axis + 1:]`.",
          "name": "output",
          "typeAttr": "Tparams"
        }
      ],
      "summary": "Gather slices from `params` axis `axis` according to `indices`."
    }
  },
  {
    "name": "GenerateVocabRemapping",
    "schema": {
      "attributes": [
        {
          "description": "How many entries into the new vocab file to start reading.",
          "minimum": 0,
          "name": "new_vocab_offset",
          "type": "int"
        },
        {
          "description": "Number of entries in the new vocab file to remap.",
          "minimum": 0,
          "name": "num_new_vocab",
          "type": "int"
        },
        {
          "default": -1,
          "description": "Number of entries in the old vocab file to consider.  If -1,\nuse the entire old vocabulary.",
          "minimum": -1,
          "name": "old_vocab_size",
          "type": "int"
        }
      ],
      "description": "length `num_new_vocab`, where `remapping[i]` contains the row number in the old\nvocabulary that corresponds to row `i` in the new vocabulary (starting at line\n`new_vocab_offset` and up to `num_new_vocab` entities), or `-1` if entry `i`\nin the new vocabulary is not in the old vocabulary.  The old vocabulary is\nconstrained to the first `old_vocab_size` entries if `old_vocab_size` is not the\ndefault value of -1.\n\n`num_vocab_offset` enables\nuse in the partitioned variable case, and should generally be set through\nexamining partitioning info.  The format of the files should be a text file,\nwith each line containing a single entity within the vocabulary.\n\nFor example, with `new_vocab_file` a text file containing each of the following\nelements on a single line: `[f0, f1, f2, f3]`, old_vocab_file = [f1, f0, f3],\n`num_new_vocab = 3, new_vocab_offset = 1`, the returned remapping would be\n`[0, -1, 2]`.\n\nThe op also returns a count of how many entries in the new vocabulary\nwere present in the old vocabulary, which is used to calculate the number of\nvalues to initialize in a weight matrix remapping\n\nThis functionality can be used to remap both row vocabularies (typically,\nfeatures) and column vocabularies (typically, classes) from TensorFlow\ncheckpoints.  Note that the partitioning logic relies on contiguous vocabularies\ncorresponding to div-partitioned variables.  Moreover, the underlying remapping\nuses an IndexTable (as opposed to an inexact CuckooTable), so client code should\nuse the corresponding index_table_from_file() as the FeatureColumn framework\ndoes (as opposed to tf.feature_to_id(), which uses a CuckooTable).",
      "inputs": [
        {
          "description": "Path to the new vocab file.",
          "name": "new_vocab_file",
          "type": 7
        },
        {
          "description": "Path to the old vocab file.",
          "name": "old_vocab_file",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of length num_new_vocab where the element at index i\nis equal to the old ID that maps to the new ID i.  This element is -1 for any\nnew ID that is not found in the old vocabulary.",
          "name": "remapping",
          "type": 9
        },
        {
          "description": "Number of new vocab entries found in old vocab.",
          "name": "num_present",
          "type": 3
        }
      ],
      "summary": "Given a path to new and old vocabulary files, returns a remapping Tensor of"
    }
  },
  {
    "name": "GeneratorDataset",
    "schema": {
      "attributes": [
        {
          "name": "init_func",
          "type": "func"
        },
        {
          "name": "next_func",
          "type": "func"
        },
        {
          "name": "finalize_func",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Tinit_func_args",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Tnext_func_args",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Tfinalize_func_args",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "init_func_other_args",
          "typeListAttr": "Tinit_func_args"
        },
        {
          "name": "next_func_other_args",
          "typeListAttr": "Tnext_func_args"
        },
        {
          "name": "finalize_func_other_args",
          "typeListAttr": "Tfinalize_func_args"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that invokes a function to generate elements."
    }
  },
  {
    "name": "GetSessionHandle",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be stored.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The handle for the tensor stored in the session state, represented\nas a string.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Store the input tensor in the state of the current session."
    }
  },
  {
    "name": "GetSessionHandleV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be stored.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The handle for the tensor stored in the session state, represented\nas a ResourceHandle object.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Store the input tensor in the state of the current session."
    }
  },
  {
    "name": "GetSessionTensor",
    "schema": {
      "attributes": [
        {
          "description": "The type of the output value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle for a tensor stored in the session state.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The tensor for the given handle.",
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Get the value of the tensor specified by its handle."
    }
  },
  {
    "name": "Greater",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Greater` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x > y) element-wise."
    }
  },
  {
    "name": "GreaterEqual",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x >= y) element-wise."
    }
  },
  {
    "name": "GuaranteeConst",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The runtime is then free to make optimizations based on this.\n\nOnly accepts value typed tensors as inputs and rejects resource variable handles\nas input.\n\nReturns the input tensor without modification.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Gives a guarantee to the TF runtime that the input tensor is a constant."
    }
  },
  {
    "name": "HSVToRGB",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a tensor of the same shape as the `images` tensor, containing the RGB\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\nSee `rgb_to_hsv` for a description of the HSV encoding.",
      "inputs": [
        {
          "description": "1-D or higher rank. HSV data to convert. Last dimension must be size 3.",
          "name": "images",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "`images` converted to RGB.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Convert one or more images from HSV to RGB."
    }
  },
  {
    "name": "HashTable",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates a non-initialized hash table."
    }
  },
  {
    "name": "HashTableV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates a non-initialized hash table."
    }
  },
  {
    "name": "HistogramFixedWidth",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Given the tensor `values`, this operation returns a rank 1 histogram counting\nthe number of entries in `values` that fall into every bin.  The bins are\nequal width and determined by the arguments `value_range` and `nbins`.\n\n```python\n# Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)\nnbins = 5\nvalue_range = [0.0, 5.0]\nnew_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]\n\nwith tf.get_default_session() as sess:\n  hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)\n  variables.global_variables_initializer().run()\n  sess.run(hist) => [2, 1, 1, 0, 2]\n```",
      "inputs": [
        {
          "description": "Numeric `Tensor`.",
          "name": "values",
          "typeAttr": "T"
        },
        {
          "description": "Shape [2] `Tensor` of same `dtype` as `values`.\nvalues <= value_range[0] will be mapped to hist[0],\nvalues >= value_range[1] will be mapped to hist[-1].",
          "name": "value_range",
          "typeAttr": "T"
        },
        {
          "description": "Scalar `int32 Tensor`.  Number of histogram bins.",
          "name": "nbins",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 1-D `Tensor` holding histogram of values.",
          "name": "out",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Return histogram of values."
    }
  },
  {
    "name": "HistogramSummary",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nhas one summary value containing a histogram for `values`.\n\nThis op reports an `InvalidArgument` error if any value is not finite.",
      "inputs": [
        {
          "description": "Scalar.  Tag to use for the `Summary.Value`.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "Any shape. Values to use to build the histogram.",
          "name": "values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with a histogram."
    }
  },
  {
    "name": "HostConst",
    "schema": {
      "attributes": [
        {
          "description": "Attr `value` is the tensor to return.",
          "name": "value",
          "type": "tensor"
        },
        {
          "name": "dtype",
          "type": "type"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Returns a constant tensor on the host. Only for writing C++ tests."
    }
  },
  {
    "name": "IFFT",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tcomplex",
          "type": "type"
        }
      ],
      "description": "Computes the inverse 1-dimensional discrete Fourier transform over the\ninner-most dimension of `input`.",
      "inputs": [
        {
          "description": "A complex tensor.",
          "name": "input",
          "typeAttr": "Tcomplex"
        }
      ],
      "outputs": [
        {
          "description": "A complex tensor of the same shape as `input`. The inner-most\n  dimension of `input` is replaced with its inverse 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifft\n@end_compatibility",
          "name": "output",
          "typeAttr": "Tcomplex"
        }
      ],
      "summary": "Inverse fast Fourier transform."
    }
  },
  {
    "name": "IFFT2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tcomplex",
          "type": "type"
        }
      ],
      "description": "Computes the inverse 2-dimensional discrete Fourier transform over the\ninner-most 2 dimensions of `input`.",
      "inputs": [
        {
          "description": "A complex tensor.",
          "name": "input",
          "typeAttr": "Tcomplex"
        }
      ],
      "outputs": [
        {
          "description": "A complex tensor of the same shape as `input`. The inner-most 2\n  dimensions of `input` are replaced with their inverse 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifft2\n@end_compatibility",
          "name": "output",
          "typeAttr": "Tcomplex"
        }
      ],
      "summary": "Inverse 2D fast Fourier transform."
    }
  },
  {
    "name": "IFFT3D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "Tcomplex",
          "type": "type"
        }
      ],
      "description": "Computes the inverse 3-dimensional discrete Fourier transform over the\ninner-most 3 dimensions of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "typeAttr": "Tcomplex"
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most 3\n  dimensions of `input` are replaced with their inverse 3D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "typeAttr": "Tcomplex"
        }
      ],
      "summary": "Inverse 3D fast Fourier transform."
    }
  },
  {
    "name": "IRFFT",
    "schema": {
      "description": "Computes the inverse 1-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most dimension of `input`.\n\nThe inner-most dimension of `input` is assumed to be the result of `RFFT`: the\n`fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If\n`fft_length` is not provided, it is computed from the size of the inner-most\ndimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to\ncompute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong the axis `IRFFT` is computed on, if `fft_length / 2 + 1` is smaller\nthan the corresponding dimension of `input`, the dimension is cropped. If it is\nlarger, the dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        },
        {
          "description": "An int32 tensor of shape [1]. The FFT length.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A float32 tensor of the same rank as `input`. The inner-most\n  dimension of `input` is replaced with the `fft_length` samples of its inverse\n  1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfft\n@end_compatibility",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Inverse real-valued fast Fourier transform."
    }
  },
  {
    "name": "IRFFT2D",
    "schema": {
      "description": "Computes the inverse 2-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most 2 dimensions of `input`.\n\nThe inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:\nThe inner-most dimension contains the `fft_length / 2 + 1` unique components of\nthe DFT of a real-valued signal. If `fft_length` is not provided, it is computed\nfrom the size of the inner-most 2 dimensions of `input`. If the FFT length used\nto compute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong each axis `IRFFT2D` is computed on, if `fft_length` (or\n`fft_length / 2 + 1` for the inner-most dimension) is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        },
        {
          "description": "An int32 tensor of shape [2]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A float32 tensor of the same rank as `input`. The inner-most 2\n  dimensions of `input` are replaced with the `fft_length` samples of their\n  inverse 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfft2\n@end_compatibility",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Inverse 2D real-valued fast Fourier transform."
    }
  },
  {
    "name": "IRFFT3D",
    "schema": {
      "description": "Computes the inverse 3-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most 3 dimensions of `input`.\n\nThe inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:\nThe inner-most dimension contains the `fft_length / 2 + 1` unique components of\nthe DFT of a real-valued signal. If `fft_length` is not provided, it is computed\nfrom the size of the inner-most 3 dimensions of `input`. If the FFT length used\nto compute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong each axis `IRFFT3D` is computed on, if `fft_length` (or\n`fft_length / 2 + 1` for the inner-most dimension) is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        },
        {
          "description": "An int32 tensor of shape [3]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A float32 tensor of the same rank as `input`. The inner-most 3\n  dimensions of `input` are replaced with the `fft_length` samples of their\n  inverse 3D real Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.irfftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Inverse 3D real-valued fast Fourier transform."
    }
  },
  {
    "name": "Identity",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Control",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Return a tensor with the same shape and contents as the input tensor or value."
    }
  },
  {
    "name": "IdentityN",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "tensors.\n\nThis op can be used to override the gradient for complicated functions. For\nexample, suppose y = f(x) and we wish to apply a custom function g for backprop\nsuch that dx = g(dy). In Python,\n\n```python\nwith tf.get_default_graph().gradient_override_map(\n    {'IdentityN': 'OverrideGradientWithG'}):\n  y, _ = identity_n([f(x), x])\n\n@tf.RegisterGradient('OverrideGradientWithG')\ndef ApplyG(op, dy, _):\n  return [None, g(dy)]  # Do not backprop to f(x).\n```",
      "inputs": [
        {
          "name": "input",
          "typeListAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeListAttr": "T"
        }
      ],
      "summary": "Returns a list of tensors with the same shapes and contents as the input"
    }
  },
  {
    "name": "IdentityReader",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the queued work as both the key and value."
    }
  },
  {
    "name": "IdentityReaderV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the queued work as both the key and value."
    }
  },
  {
    "name": "If",
    "schema": {
      "attributes": [
        {
          "name": "Tcond",
          "type": "type"
        },
        {
          "description": "A list of input types.",
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "A list of output types.",
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "      A function that takes 'inputs' and returns a list of tensors, whose\n      types are the same as what else_branch returns.",
          "name": "then_branch",
          "type": "func"
        },
        {
          "description": "    A function that takes 'inputs' and returns a list of tensors, whose\n    types are the same as what then_branch returns.",
          "name": "else_branch",
          "type": "func"
        },
        {
          "default": [],
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "      A Tensor. If the tensor is a scalar of non-boolean type, the\n      scalar is converted to a boolean according to the\n      following rule: if the scalar is a numerical value, non-zero means\n      `True` and zero means False; if the scalar is a string, non-empty\n      means `True` and empty means `False`. If the tensor is not a scalar,\n      being empty means False and being non-empty means True.",
          "name": "cond",
          "typeAttr": "Tcond"
        },
        {
          "description": "A list of input tensors.",
          "name": "input",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "A list of return values.",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "output = cond ? then_branch(input) : else_branch(input)"
    }
  },
  {
    "name": "Igamma",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The lower regularized incomplete Gamma function is defined as:\n\n\n\\\\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\\\)\n\nwhere\n\n\\\\(gamma(a, x) = \\\\int_{0}^{x} t^{a-1} exp(-t) dt\\\\)\n\nis the lower incomplete Gamma function.\n\nNote, above `Q(a, x)` (`Igammac`) is the upper regularized complete\nGamma function.",
      "inputs": [
        {
          "name": "a",
          "typeAttr": "T"
        },
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the lower regularized incomplete Gamma function `P(a, x)`."
    }
  },
  {
    "name": "IgammaGradA",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "a",
          "typeAttr": "T"
        },
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of `igamma(a, x)` wrt `a`."
    }
  },
  {
    "name": "Igammac",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The upper regularized incomplete Gamma function is defined as:\n\n\\\\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\\\)\n\nwhere\n\n\\\\(Gamma(a, x) = int_{x}^{\\infty} t^{a-1} exp(-t) dt\\\\)\n\nis the upper incomplete Gama function.\n\nNote, above `P(a, x)` (`Igamma`) is the lower regularized complete\nGamma function.",
      "inputs": [
        {
          "name": "a",
          "typeAttr": "T"
        },
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the upper regularized incomplete Gamma function `Q(a, x)`."
    }
  },
  {
    "name": "Imag",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the imaginary part of each element in `input`. All\nelements in `input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part returned by this operation.\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.imag(input) ==> [4.75, 5.75]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Returns the imaginary part of a complex number."
    }
  },
  {
    "name": "ImageSummary",
    "schema": {
      "attributes": [
        {
          "default": 3,
          "description": "Max number of batch elements to generate images for.",
          "minimum": 1,
          "name": "max_images",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        },
        {
          "default": {
            "type": "tensor",
            "value": "?"
          },
          "description": "Color to use for pixels with non-finite values.",
          "name": "bad_color",
          "type": "tensor"
        }
      ],
      "description": "The summary has up to `max_images` summary values containing images. The\nimages are built from `tensor` which must be 4-D with shape `[batch_size,\nheight, width, channels]` and where `channels` can be:\n\n*  1: `tensor` is interpreted as Grayscale.\n*  3: `tensor` is interpreted as RGB.\n*  4: `tensor` is interpreted as RGBA.\n\nThe images have the same number of channels as the input tensor. For float\ninput, the values are normalized one image at a time to fit in the range\n`[0, 255]`.  `uint8` values are unchanged.  The op uses two different\nnormalization algorithms:\n\n*  If the input values are all positive, they are rescaled so the largest one\n   is 255.\n\n*  If any input value is negative, the values are shifted so input value 0.0\n   is at 127.  They are then rescaled so that either the smallest value is 0,\n   or the largest one is 255.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_images` is 1, the summary value tag is '*tag*/image'.\n*  If `max_images` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.\n\nThe `bad_color` argument is the color to use in the generated images for\nnon-finite input values.  It is a `uint8` 1-D tensor of length `channels`.\nEach element must be in the range `[0, 255]` (It represents the value of a\npixel in the output image).  Non-finite values in the input tensor are\nreplaced by this tensor in the output image.  The default value is the color\nred.",
      "inputs": [
        {
          "description": "Scalar. Used to build the `tag` attribute of the summary values.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "4-D of shape `[batch_size, height, width, channels]` where\n`channels` is 1, 3, or 4.",
          "name": "tensor",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with images."
    }
  },
  {
    "name": "ImmutableConst",
    "schema": {
      "attributes": [
        {
          "description": "Type of the returned tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "Shape of the returned tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "Name of readonly memory region used by the tensor, see\nNewReadOnlyMemoryRegionFromFile in tensorflow::Env.",
          "name": "memory_region_name",
          "type": "string"
        }
      ],
      "description": "The current implementation memmaps the tensor from a file.",
      "outputs": [
        {
          "name": "tensor",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Returns immutable tensor from memory region."
    }
  },
  {
    "name": "ImportEvent",
    "schema": {
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "event",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "InTopK",
    "schema": {
      "attributes": [
        {
          "description": "Number of top elements to look at for computing precision.",
          "name": "k",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$",
      "inputs": [
        {
          "description": "A `batch_size` x `classes` tensor.",
          "name": "predictions",
          "type": 1
        },
        {
          "description": "A `batch_size` vector of class ids.",
          "name": "targets",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Computed Precision at `k` as a `bool Tensor`.",
          "name": "precision",
          "type": 10
        }
      ],
      "summary": "Says whether the targets are in the top `K` predictions."
    }
  },
  {
    "name": "InTopKV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$",
      "inputs": [
        {
          "description": "A `batch_size` x `classes` tensor.",
          "name": "predictions",
          "type": 1
        },
        {
          "description": "A `batch_size` vector of class ids.",
          "name": "targets",
          "typeAttr": "T"
        },
        {
          "description": "Number of top elements to look at for computing precision.",
          "name": "k",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Computed precision at `k` as a `bool Tensor`.",
          "name": "precision",
          "type": 10
        }
      ],
      "summary": "Says whether the targets are in the top `K` predictions."
    }
  },
  {
    "name": "InitializeTable",
    "schema": {
      "attributes": [
        {
          "name": "Tkey",
          "type": "type"
        },
        {
          "name": "Tval",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Keys of type Tkey.",
          "name": "keys",
          "typeAttr": "Tkey"
        },
        {
          "description": "Values of type Tval.",
          "name": "values",
          "typeAttr": "Tval"
        }
      ],
      "summary": "Table initializer that takes two tensors for keys and values respectively."
    }
  },
  {
    "name": "InitializeTableFromTextFile",
    "schema": {
      "attributes": [
        {
          "description": "Column index in a line to get the table `key` values from.",
          "minimum": -2,
          "name": "key_index",
          "type": "int"
        },
        {
          "description": "Column index that represents information of a line to get the table\n`value` values from.",
          "minimum": -2,
          "name": "value_index",
          "type": "int"
        },
        {
          "default": -1,
          "description": "Number of elements of the file, use -1 if unknown.",
          "minimum": -1,
          "name": "vocab_size",
          "type": "int"
        },
        {
          "default": "\t",
          "description": "Delimiter to separate fields in a line.",
          "name": "delimiter",
          "type": "string"
        }
      ],
      "description": "It inserts one key-value pair into the table for each line of the file.\nThe key and value is extracted from the whole line content, elements from the\nsplit line based on `delimiter` or the line number (starting from zero).\nWhere to extract the key and value from a line is specified by `key_index` and\n`value_index`.\n\n- A value of -1 means use the line number(starting from zero), expects `int64`.\n- A value of -2 means use the whole line content, expects `string`.\n- A value >= 0 means use the index (starting at zero) of the split line based\n  on `delimiter`.",
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Filename of a vocabulary text file.",
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Initializes a table from a text file."
    }
  },
  {
    "name": "InitializeTableFromTextFileV2",
    "schema": {
      "attributes": [
        {
          "description": "Column index in a line to get the table `key` values from.",
          "minimum": -2,
          "name": "key_index",
          "type": "int"
        },
        {
          "description": "Column index that represents information of a line to get the table\n`value` values from.",
          "minimum": -2,
          "name": "value_index",
          "type": "int"
        },
        {
          "default": -1,
          "description": "Number of elements of the file, use -1 if unknown.",
          "minimum": -1,
          "name": "vocab_size",
          "type": "int"
        },
        {
          "default": "\t",
          "description": "Delimiter to separate fields in a line.",
          "name": "delimiter",
          "type": "string"
        }
      ],
      "description": "It inserts one key-value pair into the table for each line of the file.\nThe key and value is extracted from the whole line content, elements from the\nsplit line based on `delimiter` or the line number (starting from zero).\nWhere to extract the key and value from a line is specified by `key_index` and\n`value_index`.\n\n- A value of -1 means use the line number(starting from zero), expects `int64`.\n- A value of -2 means use the whole line content, expects `string`.\n- A value >= 0 means use the index (starting at zero) of the split line based\n  on `delimiter`.",
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Filename of a vocabulary text file.",
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Initializes a table from a text file."
    }
  },
  {
    "name": "InitializeTableV2",
    "schema": {
      "attributes": [
        {
          "name": "Tkey",
          "type": "type"
        },
        {
          "name": "Tval",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Keys of type Tkey.",
          "name": "keys",
          "typeAttr": "Tkey"
        },
        {
          "description": "Values of type Tval.",
          "name": "values",
          "typeAttr": "Tval"
        }
      ],
      "summary": "Table initializer that takes two tensors for keys and values respectively."
    }
  },
  {
    "name": "InplaceAdd",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A `Tensor` of type T.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A vector. Indices into the left-most dimension of `x`.",
          "name": "i",
          "type": 3
        },
        {
          "description": "A `Tensor` of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.",
          "name": "v",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` of type T. An alias of `x`. The content of `y` is undefined if there are duplicates in `i`.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "    Adds v into specified rows of x.\n\n    Computes y = x; y[i, :] += v; return y."
    }
  },
  {
    "name": "InplaceSub",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A `Tensor` of type T.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A vector. Indices into the left-most dimension of `x`.",
          "name": "i",
          "type": 3
        },
        {
          "description": "A `Tensor` of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.",
          "name": "v",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` of type T. An alias of `x`. The content of `y` is undefined if there are duplicates in `i`.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "    Subtracts `v` into specified rows of `x`.\n\n    Computes y = x; y[i, :] -= v; return y."
    }
  },
  {
    "name": "InplaceUpdate",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A tensor of type `T`.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A vector. Indices into the left-most dimension of `x`.",
          "name": "i",
          "type": 3
        },
        {
          "description": "A `Tensor` of type T. Same dimension sizes as x except the first dimension, which must be the same as i's size.",
          "name": "v",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` of type T. An alias of `x`. The content of `y` is undefined if there are duplicates in `i`.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "    Updates specified rows with values in `v`.\n\n    Computes `x[i, :] = v; return x`."
    }
  },
  {
    "name": "InterleaveDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Unlike MapDataset, the `f` in InterleaveDataset is expected to return\na Dataset variant, and InterleaveDataset will flatten successive\nresults into a single Dataset. Unlike FlatMapDataset,\nInterleaveDataset will interleave sequences of up to `block_length`\nconsecutive elements from `cycle_length` input elements.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        },
        {
          "name": "cycle_length",
          "type": 9
        },
        {
          "name": "block_length",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "Inv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = 1 / x\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the reciprocal of x element-wise."
    }
  },
  {
    "name": "InvGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient for the inverse of `x` wrt its input."
    }
  },
  {
    "name": "Invert",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have exactly those bits set, that are not set in `x`. The\ncomputation is performed on the underlying representation of x.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Flips all bits elementwise."
    }
  },
  {
    "name": "InvertPermutation",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation computes the inverse of an index permutation. It takes a 1-D\ninteger tensor `x`, which represents the indices of a zero-based array, and\nswaps each value with its index position. In other words, for an output tensor\n`y` and an input tensor `x`, this operation computes the following:\n\n`y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`\n\nThe values must include 0. There can be no duplicate values or negative values.\n\nFor example:\n\n```\n# tensor `x` is [3, 4, 0, 2, 1]\ninvert_permutation(x) ==> [2, 4, 3, 0, 1]\n```",
      "inputs": [
        {
          "description": "1-D.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the inverse permutation of a tensor."
    }
  },
  {
    "name": "IsBoostedTreesEnsembleInitialized",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree ensemble resouce.",
          "name": "tree_ensemble_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "output boolean on whether it is initialized or not.",
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a tree ensemble has been initialized."
    }
  },
  {
    "name": "IsBoostedTreesQuantileStreamResourceInitialized",
    "schema": {
      "description": "An Op that checks if quantile stream resource is initialized.",
      "inputs": [
        {
          "description": "resource; The reference to quantile stream resource handle.",
          "name": "quantile_stream_resource_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "bool; True if the resource is initialized, False otherwise.",
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a quantile stream has been initialized."
    }
  },
  {
    "name": "IsFinite",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "@compatibility(numpy)\nEquivalent to np.isfinite\n@end_compatibility",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns which elements of x are finite."
    }
  },
  {
    "name": "IsInf",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "@compatibility(numpy)\nEquivalent to np.isinf\n@end_compatibility",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns which elements of x are Inf."
    }
  },
  {
    "name": "IsNan",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "@compatibility(numpy)\nEquivalent to np.isnan\n@end_compatibility",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns which elements of x are NaN."
    }
  },
  {
    "name": "IsVariableInitialized",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the variable tensor.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Outputs boolean scalar indicating whether the tensor has been initialized.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node. May be uninitialized.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "dtype"
        }
      ],
      "outputs": [
        {
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a tensor has been initialized."
    }
  },
  {
    "name": "Iterator",
    "schema": {
      "attributes": [
        {
          "name": "shared_name",
          "type": "string"
        },
        {
          "name": "container",
          "type": "string"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "outputs": [
        {
          "description": "A handle to the iterator that can be passed to a \"MakeIterator\"\nor \"IteratorGetNext\" op.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A container for an iterator resource."
    }
  },
  {
    "name": "IteratorFromStringHandle",
    "schema": {
      "attributes": [
        {
          "default": [],
          "description": "If specified, defines the type of each tuple component in an\nelement produced by the resulting iterator.",
          "minimum": 0,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "If specified, defines the shape of each tuple component in an\nelement produced by the resulting iterator.",
          "minimum": 0,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A string representation of the given handle.",
          "name": "string_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        }
      ],
      "summary": "Converts the given string representing a handle to an iterator to a resource."
    }
  },
  {
    "name": "IteratorFromStringHandleV2",
    "schema": {
      "attributes": [
        {
          "default": [],
          "minimum": 0,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "minimum": 0,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "string_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "resource_handle",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "IteratorGetNext",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "components",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "Gets the next output from the given iterator ."
    }
  },
  {
    "name": "IteratorGetNextAsOptional",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "optional",
          "type": 21
        }
      ],
      "summary": "Gets the next output from the given iterator as an Optional variant."
    }
  },
  {
    "name": "IteratorGetNextSync",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "This operation is a synchronous version IteratorGetNext. It should only be used\nin situations where the iterator does not block the calling thread, or where\nthe calling thread is not a member of the thread pool used to execute parallel\noperations (e.g. in eager mode).",
      "inputs": [
        {
          "name": "iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "components",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "Gets the next output from the given iterator."
    }
  },
  {
    "name": "IteratorToStringHandle",
    "schema": {
      "inputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A string representation of the given handle.",
          "name": "string_handle",
          "type": 7
        }
      ],
      "summary": "Converts the given `resource_handle` representing an iterator to a string."
    }
  },
  {
    "name": "IteratorV2",
    "schema": {
      "attributes": [
        {
          "name": "shared_name",
          "type": "string"
        },
        {
          "name": "container",
          "type": "string"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "KMC2ChainInitialization",
    "schema": {
      "description": "Entries in distances are assumed to be squared distances of candidate points to\nthe already sampled centers in the seed set. The op constructs one Markov chain\nof the k-MC^2 algorithm and returns the index of one candidate point to be added\nas an additional cluster center.",
      "inputs": [
        {
          "description": "Vector with squared distances to the closest previously sampled cluster center\nfor each candidate point.",
          "name": "distances",
          "type": 1
        },
        {
          "description": "Scalar. Seed for initializing the random number generator.",
          "name": "seed",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Scalar with the index of the sampled point.",
          "name": "index",
          "type": 9
        }
      ],
      "summary": "Returns the index of a data point that should be added to the seed set."
    }
  },
  {
    "name": "KmeansPlusPlusInitialization",
    "schema": {
      "description": "Rows of points are assumed to be input points. One row is selected at random.\nSubsequent rows are sampled with probability proportional to the squared L2\ndistance from the nearest row selected thus far till num_to_sample rows have\nbeen sampled.",
      "inputs": [
        {
          "description": "Matrix of shape (n, d). Rows are assumed to be input points.",
          "name": "points",
          "type": 1
        },
        {
          "description": "Scalar. The number of rows to sample. This value must not be larger than n.",
          "name": "num_to_sample",
          "type": 9
        },
        {
          "description": "Scalar. Seed for initializing the random number generator.",
          "name": "seed",
          "type": 9
        },
        {
          "description": "Scalar. For each row that is sampled, this parameter\nspecifies the number of additional points to draw from the current\ndistribution before selecting the best. If a negative value is specified, a\nheuristic is used to sample O(log(num_to_sample)) additional points.",
          "name": "num_retries_per_sample",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Matrix of shape (num_to_sample, d). The sampled rows.",
          "name": "samples",
          "type": 1
        }
      ],
      "summary": "Selects num_to_sample rows of input using the KMeans++ criterion."
    }
  },
  {
    "name": "L2Loss",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes half the L2 norm of a tensor without the `sqrt`:\n\n    output = sum(t ** 2) / 2",
      "inputs": [
        {
          "description": "Typically 2-D, but may have any dimensions.",
          "name": "t",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "0-D.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "L2 Loss."
    }
  },
  {
    "name": "LMDBReader",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the records from a LMDB file."
    }
  },
  {
    "name": "LRN",
    "schema": {
      "attributes": [
        {
          "default": 5,
          "description": "0-D.  Half-width of the 1-D normalization window.",
          "name": "depth_radius",
          "type": "int"
        },
        {
          "default": 1.0,
          "description": "An offset (usually positive to avoid dividing by 0).",
          "name": "bias",
          "type": "float"
        },
        {
          "default": 1.0,
          "description": "A scale factor, usually positive.",
          "name": "alpha",
          "type": "float"
        },
        {
          "default": 0.5,
          "description": "An exponent.",
          "name": "beta",
          "type": "float"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Normalization",
      "description": "The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last\ndimension), and each vector is normalized independently.  Within a given vector,\neach component is divided by the weighted, squared sum of inputs within\n`depth_radius`.  In detail,\n\n    sqr_sum[a, b, c, d] =\n        sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)\n    output = input / (bias + alpha * sqr_sum) ** beta\n\nFor details, see [Krizhevsky et al., ImageNet classification with deep\nconvolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).",
      "inputs": [
        {
          "description": "4-D.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Local Response Normalization."
    }
  },
  {
    "name": "LRNGrad",
    "schema": {
      "attributes": [
        {
          "default": 5,
          "description": "A depth radius.",
          "name": "depth_radius",
          "type": "int"
        },
        {
          "default": 1.0,
          "description": "An offset (usually > 0 to avoid dividing by 0).",
          "name": "bias",
          "type": "float"
        },
        {
          "default": 1.0,
          "description": "A scale factor, usually positive.",
          "name": "alpha",
          "type": "float"
        },
        {
          "default": 0.5,
          "description": "An exponent.",
          "name": "beta",
          "type": "float"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "input_grads",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "input_image",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "output_image",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The gradients for LRN.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Gradients for Local Response Normalization."
    }
  },
  {
    "name": "LeakyRelu",
    "schema": {
      "attributes": [
        {
          "default": 0.20000000298023224,
          "name": "alpha",
          "type": "float"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes rectified linear: `max(features, features * alpha)`."
    }
  },
  {
    "name": "LeakyReluGrad",
    "schema": {
      "attributes": [
        {
          "default": 0.20000000298023224,
          "name": "alpha",
          "type": "float"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding LeakyRelu operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The features passed as input to the corresponding LeakyRelu operation,\nOR the outputs of that operation (both work equivalently).",
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "`gradients * (features > 0) + alpha * gradients * (featurs <= 0)`.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes rectified linear gradients for a LeakyRelu operation."
    }
  },
  {
    "name": "LearnedUnigramCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "minimum": 1,
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "minimum": 1,
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "minimum": 1,
          "name": "range_max",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "LeftShift",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `y` is negative, or greater than or equal to the width of `x` in bits the\nresult is implementation defined.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Elementwise computes the bitwise left-shift of `x` and `y`."
    }
  },
  {
    "name": "Less",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Less` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x < y) element-wise."
    }
  },
  {
    "name": "LessEqual",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `LessEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x <= y) element-wise."
    }
  },
  {
    "name": "Lgamma",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the log of the absolute value of `Gamma(x)` element-wise."
    }
  },
  {
    "name": "LinSpace",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "A sequence of `num` evenly-spaced values are generated beginning at `start`.\nIf `num > 1`, the values in the sequence increase by `stop - start / num - 1`,\nso that the last one is exactly `stop`.\n\nFor example:\n\n```\ntf.linspace(10.0, 12.0, 3, name=\"linspace\") => [ 10.0  11.0  12.0]\n```",
      "inputs": [
        {
          "description": "0-D tensor. First entry in the range.",
          "name": "start",
          "typeAttr": "T"
        },
        {
          "description": "0-D tensor. Last entry in the range.",
          "name": "stop",
          "typeAttr": "T"
        },
        {
          "description": "0-D tensor. Number of values to generate.",
          "name": "num",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "1-D. The generated values.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Generates values in an interval."
    }
  },
  {
    "name": "ListDiff",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "Given a list `x` and a list `y`, this operation returns a list `out` that\nrepresents all values that are in `x` but not in `y`. The returned list `out`\nis sorted in the same order that the numbers appear in `x` (duplicates are\npreserved). This operation also returns a list `idx` that represents the\nposition of each `out` element in `x`. In other words:\n\n`out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`\n\nFor example, given this input:\n\n```\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n```\n\nThis operation would return:\n\n```\nout ==> [2, 4, 6]\nidx ==> [1, 3, 5]\n```",
      "inputs": [
        {
          "description": "1-D. Values to keep.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "1-D. Values to remove.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D. Values present in `x` but not in `y`.",
          "name": "out",
          "typeAttr": "T"
        },
        {
          "description": "1-D. Positions of `x` values preserved in `out`.",
          "name": "idx",
          "typeAttr": "out_idx"
        }
      ],
      "summary": "Computes the difference between two lists of numbers or strings."
    }
  },
  {
    "name": "LoadAndRemapMatrix",
    "schema": {
      "attributes": [
        {
          "description": "Number of rows (length of the 1st dimension) in the output matrix.",
          "minimum": 0,
          "name": "num_rows",
          "type": "int"
        },
        {
          "description": "Number of columns (length of the 2nd dimension) in the output matrix.",
          "minimum": 1,
          "name": "num_cols",
          "type": "int"
        },
        {
          "default": -1,
          "description": "The maximum number of rows to load from the checkpoint at\nonce. If less than or equal to 0, the entire matrix will be loaded into\nmemory. Setting this arg trades increased disk reads for lower memory usage.",
          "name": "max_rows_in_memory",
          "type": "int"
        }
      ],
      "description": "at `ckpt_path` and potentially reorders its rows and columns using the\nspecified remappings.\n\nMost users should use one of the wrapper initializers (such as\n`tf.contrib.framework.load_and_remap_matrix_initializer`) instead of this\nfunction directly.\n\nThe remappings are 1-D tensors with the following properties:\n\n* `row_remapping` must have exactly `num_rows` entries. Row `i` of the output\n  matrix will be initialized from the row corresponding to index\n  `row_remapping[i]` in the old `Tensor` from the checkpoint.\n* `col_remapping` must have either 0 entries (indicating that no column\n  reordering is needed) or `num_cols` entries. If specified, column `j` of the\n  output matrix will be initialized from the column corresponding to index\n  `col_remapping[j]` in the old `Tensor` from the checkpoint.\n* A value of -1 in either of the remappings signifies a \"missing\" entry. In that\n  case, values from the `initializing_values` tensor will be used to fill that\n  missing row or column. If `row_remapping` has `r` missing entries and\n  `col_remapping` has `c` missing entries, then the following condition must be\n  true:\n\n`(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)`\n\nThe remapping tensors can be generated using the GenerateVocabRemapping op.\n\nAs an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],\ninitializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing\nthe value from row i, column j of the old tensor in the checkpoint, the output\nmatrix will look like the following:\n\n[[w(1, 0),  w(1, 2),  0.5],\n [w(0, 0),  w(0, 2), -0.5],\n [0.25,    -0.25,      42]]",
      "inputs": [
        {
          "description": "Path to the TensorFlow checkpoint (version 2, `TensorBundle`) from\nwhich the old matrix `Tensor` will be loaded.",
          "name": "ckpt_path",
          "type": 7
        },
        {
          "description": "Name of the 2-D `Tensor` to load from checkpoint.",
          "name": "old_tensor_name",
          "type": 7
        },
        {
          "description": "An int `Tensor` of row remappings (generally created by\n`generate_vocab_remapping`).  Even if no row remapping is needed, this must\nstill be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted\nindex-valued `Tensor` (e.g. [8, 9, 10, ...], for partitioned `Variables`).",
          "name": "row_remapping",
          "type": 9
        },
        {
          "description": "An int `Tensor` of column remappings (generally created by\n`generate_vocab_remapping`).  May be a size-0 `Tensor` if only row remapping\nis to be done (e.g. column ordering is the same).",
          "name": "col_remapping",
          "type": 9
        },
        {
          "description": "A float `Tensor` containing  values to fill in for cells\nin the output matrix that are not loaded from the checkpoint. Length must be\nexactly the same as the number of missing / new cells.",
          "name": "initializing_values",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Output matrix containing existing values loaded from the\ncheckpoint, and with any missing values filled in from initializing_values.",
          "name": "output_matrix",
          "type": 1
        }
      ],
      "summary": "Loads a 2-D (matrix) `Tensor` with name `old_tensor_name` from the checkpoint"
    }
  },
  {
    "name": "Log",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = \\log_e x\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes natural logarithm of x element-wise."
    }
  },
  {
    "name": "Log1p",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = \\log_e (1 + x)\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes natural logarithm of (1 + x) element-wise."
    }
  },
  {
    "name": "LogMatrixDeterminant",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "one or more square matrices.\n\nThe input is a tensor of shape `[N, M, M]` whose inner-most 2 dimensions\nform square matrices. The outputs are two tensors containing the signs and\nabsolute values of the log determinants for all N input submatrices\n`[..., :, :]` such that the determinant = sign*exp(log_abs_determinant).\nThe log_abs_determinant is computed as det(P)*sum(log(diag(LU))) where LU\nis the LU decomposition of the input and P is the corresponding\npermutation matrix.",
      "inputs": [
        {
          "description": "Shape is `[N, M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The signs of the log determinants of the inputs. Shape is `[N]`.",
          "name": "sign",
          "typeAttr": "T"
        },
        {
          "description": "The logs of the absolute values of the determinants\nof the N input matrices.  Shape is `[N]`.",
          "name": "log_abs_determinant",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sign and the log of the absolute value of the determinant of"
    }
  },
  {
    "name": "LogSoftmax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each batch `i` and class `j` we have\n\n    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))",
      "inputs": [
        {
          "description": "2-D with shape `[batch_size, num_classes]`.",
          "name": "logits",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `logits`.",
          "name": "logsoftmax",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes log softmax activations."
    }
  },
  {
    "name": "LogUniformCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "minimum": 1,
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "minimum": 1,
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "minimum": 1,
          "name": "range_max",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a log-uniform distribution."
    }
  },
  {
    "name": "LogicalAnd",
    "schema": {
      "description": "*NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "type": 10
        },
        {
          "name": "y",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of x AND y element-wise."
    }
  },
  {
    "name": "LogicalNot",
    "schema": {
      "inputs": [
        {
          "name": "x",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of NOT x element-wise."
    }
  },
  {
    "name": "LogicalOr",
    "schema": {
      "description": "*NOTE*: `LogicalOr` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "type": 10
        },
        {
          "name": "y",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of x OR y element-wise."
    }
  },
  {
    "name": "LookupTableExport",
    "schema": {
      "attributes": [
        {
          "name": "Tkeys",
          "type": "type"
        },
        {
          "name": "Tvalues",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to the table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Vector of all keys present in the table.",
          "name": "keys",
          "typeAttr": "Tkeys"
        },
        {
          "description": "Tensor of all values in the table. Indexed in parallel with `keys`.",
          "name": "values",
          "typeAttr": "Tvalues"
        }
      ],
      "summary": "Outputs all keys and values in the table."
    }
  },
  {
    "name": "LookupTableExportV2",
    "schema": {
      "attributes": [
        {
          "name": "Tkeys",
          "type": "type"
        },
        {
          "name": "Tvalues",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Vector of all keys present in the table.",
          "name": "keys",
          "typeAttr": "Tkeys"
        },
        {
          "description": "Tensor of all values in the table. Indexed in parallel with `keys`.",
          "name": "values",
          "typeAttr": "Tvalues"
        }
      ],
      "summary": "Outputs all keys and values in the table."
    }
  },
  {
    "name": "LookupTableFind",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        },
        {
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "typeAttr": "Tin"
        },
        {
          "name": "default_value",
          "typeAttr": "Tout"
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys.",
          "name": "values",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Looks up keys in a table, outputs the corresponding values."
    }
  },
  {
    "name": "LookupTableFindV2",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        },
        {
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "typeAttr": "Tin"
        },
        {
          "name": "default_value",
          "typeAttr": "Tout"
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys.",
          "name": "values",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Looks up keys in a table, outputs the corresponding values."
    }
  },
  {
    "name": "LookupTableImport",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        },
        {
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "typeAttr": "Tin"
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Replaces the contents of the table with the specified keys and values."
    }
  },
  {
    "name": "LookupTableImportV2",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        },
        {
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "typeAttr": "Tin"
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Replaces the contents of the table with the specified keys and values."
    }
  },
  {
    "name": "LookupTableInsert",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        },
        {
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "typeAttr": "Tin"
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Updates the table to associates keys with values."
    }
  },
  {
    "name": "LookupTableInsertV2",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        },
        {
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "typeAttr": "Tin"
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Updates the table to associates keys with values."
    }
  },
  {
    "name": "LookupTableRemoveV2",
    "schema": {
      "attributes": [
        {
          "name": "Tin",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must of the same type as the keys of the table. Keys not\nalready in the table are silently ignored.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys of the elements to remove.",
          "name": "keys",
          "typeAttr": "Tin"
        }
      ],
      "summary": "Removes keys and its associated values from a table."
    }
  },
  {
    "name": "LookupTableSize",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Scalar that contains number of elements in the table.",
          "name": "size",
          "type": 9
        }
      ],
      "summary": "Computes the number of elements in the given table."
    }
  },
  {
    "name": "LookupTableSizeV2",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Scalar that contains number of elements in the table.",
          "name": "size",
          "type": 9
        }
      ],
      "summary": "Computes the number of elements in the given table."
    }
  },
  {
    "name": "LoopCond",
    "schema": {
      "description": "This operator represents the loop termination condition used by the\n\"pivot\" switches of a loop.",
      "inputs": [
        {
          "description": "A boolean scalar, representing the branch predicate of the Switch op.",
          "name": "input",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `input`.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Forwards the input to the output."
    }
  },
  {
    "name": "LowerBound",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "Each set of rows with the same index in (sorted_inputs, values) is treated\nindependently.  The resulting row is the equivalent of calling\n`np.searchsorted(sorted_inputs, values, side='left')`.\n\nThe result is not a global index to the entire \n`Tensor`, but rather just the index in the last dimension.\n\nA 2-D example:\n  sorted_sequence = [[0, 3, 9, 9, 10],\n                     [1, 2, 3, 4, 5]]\n  values = [[2, 4, 9],\n            [0, 2, 6]]\n\n  result = LowerBound(sorted_sequence, values)\n\n  result == [[1, 2, 2],\n             [0, 1, 5]]",
      "inputs": [
        {
          "description": "2-D Tensor where each row is ordered.",
          "name": "sorted_inputs",
          "typeAttr": "T"
        },
        {
          "description": "2-D Tensor with the same numbers of rows as `sorted_search_values`. Contains\nthe values that will be searched for in `sorted_search_values`.",
          "name": "values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the same shape as `values`.  It contains the first scalar index\ninto the last dimension where values can be inserted without changing the\nordered property.",
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Applies lower_bound(sorted_search_values, values) along each row."
    }
  },
  {
    "name": "Lu",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "output_idx_type",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices.\n\nThe input has to be invertible.\n\nThe output consists of two tensors LU and P containing the LU decomposition\nof all input submatrices `[..., :, :]`. LU encodes the lower triangular and\nupper triangular factors.\n\nFor each input submatrix of shape `[M, M]`, L is a lower triangular matrix of\nshape `[M, M]` with unit diagonal whose entries correspond to the strictly lower\ntriangular part of LU. U is a upper triangular matrix of shape `[M, M]` whose\nentries correspond to the upper triangular part, including the diagonal, of LU.\n\nP represents a permutation matrix encoded as a list of indices each between `0`\nand `M-1`, inclusive. If P_mat denotes the permutation matrix corresponding to\nP, then the L, U and P satisfies P_mat * input = L * U.",
      "inputs": [
        {
          "description": "A tensor of shape `[..., M, M]` whose inner-most 2 dimensions form matrices of\nsize `[M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of shape `[..., M, M]` whose strictly lower triangular part denotes the\nlower triangular factor `L` with unit diagonal, and whose upper triangular part\ndenotes the upper triangular factor `U`.",
          "name": "lu",
          "typeAttr": "T"
        },
        {
          "description": "Permutation of the rows encoded as a list of indices in `0..M-1`. Shape is\n`[..., M]`.\n@compatibility(scipy)\nSimilar to `scipy.linalg.lu`, except the triangular factors `L` and `U` are\npacked into a single tensor, the permutation is applied to `input` instead of\nthe right hand side and the permutation `P` is returned as a list of indices\ninstead of a permutation matrix.\n@end_compatibility",
          "name": "p",
          "typeAttr": "output_idx_type"
        }
      ],
      "summary": "Computes the LU decomposition of one or more square matrices."
    }
  },
  {
    "name": "MakeIterator",
    "schema": {
      "description": "This operation may be executed multiple times. Each execution will reset the\niterator in `iterator` to the first element of `dataset`.",
      "inputs": [
        {
          "name": "dataset",
          "type": 21
        },
        {
          "name": "iterator",
          "type": 20
        }
      ],
      "summary": "Makes a new iterator from the given `dataset` and stores it in `iterator`."
    }
  },
  {
    "name": "MapClear",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "summary": "Op removes all elements in the underlying container."
    }
  },
  {
    "name": "MapDataset",
    "schema": {
      "attributes": [
        {
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": true,
          "name": "use_inter_op_parallelism",
          "type": "bool"
        },
        {
          "default": false,
          "name": "preserve_cardinality",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "MapDefun",
    "schema": {
      "attributes": [
        {
          "description": "A list of types.",
          "minimum": 1,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "A list of types.",
          "minimum": 0,
          "name": "Tcaptured",
          "type": "list(type)"
        },
        {
          "description": "A list of types.",
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "A list of shapes.",
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "name": "f",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "    A list of tensors whose types are `Targuments`, corresponding to the inputs\n    the function should be mapped over.",
          "name": "arguments",
          "typeListAttr": "Targuments"
        },
        {
          "description": "    A list of tensors whose types are `Tcaptured`, corresponding to the captured\n    inputs of the defun.",
          "name": "captured_inputs",
          "typeListAttr": "Tcaptured"
        }
      ],
      "outputs": [
        {
          "description": "    A list of output tensors whose types are `output_types` and whose dimensions\n    0 are the same as the dimensions 0 of the tensors in `arguments`, and whose\n    remaining dimensions correspond to those in `output_shapes`.",
          "name": "output",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "  Maps a function on the list of tensors unpacked from arguments on dimension 0."
    }
  },
  {
    "name": "MapIncompleteSize",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of incomplete elements in the underlying container."
    }
  },
  {
    "name": "MapPeek",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "underlying container does not contain this key\nthis op will block until it does.",
      "inputs": [
        {
          "name": "key",
          "type": 9
        },
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op peeks at the values at the specified key.  If the"
    }
  },
  {
    "name": "MapSize",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of elements in the underlying container."
    }
  },
  {
    "name": "MapStage",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "fake_dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "It is necessary to match this name to the matching Unstage Op.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "int64",
          "name": "key",
          "type": 9
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
          "name": "values",
          "typeListAttr": "fake_dtypes"
        }
      ],
      "summary": "Stage (key, values) in the underlying container which behaves like a hashtable."
    }
  },
  {
    "name": "MapUnstage",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "from the underlying container.   If the underlying container\ndoes not contain this key, the op will block until it does.",
      "inputs": [
        {
          "name": "key",
          "type": 9
        },
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op removes and returns the values associated with the key"
    }
  },
  {
    "name": "MapUnstageNoKey",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "from the underlying container.   If the underlying container\ndoes not contain elements, the op will block until it does.",
      "inputs": [
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "key",
          "type": 9
        },
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op removes and returns a random (key, value)"
    }
  },
  {
    "name": "MatMul",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, \"a\" is transposed before multiplication.",
          "name": "transpose_a",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If true, \"b\" is transposed before multiplication.",
          "name": "transpose_b",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The inputs must be two-dimensional matrices and the inner dimension of\n\"a\" (after being transposed if transpose_a is true) must match the\nouter dimension of \"b\" (after being transposed if transposed_b is\ntrue).\n\n*Note*: The default kernel implementation for MatMul on GPUs uses\ncublas.",
      "inputs": [
        {
          "name": "a",
          "typeAttr": "T"
        },
        {
          "name": "b",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "product",
          "typeAttr": "T"
        }
      ],
      "summary": "Multiply the matrix \"a\" by the matrix \"b\"."
    }
  },
  {
    "name": "MatchingFiles",
    "schema": {
      "description": "Note that this routine only supports wildcard characters in the\nbasename portion of the pattern, not in the directory portion.\nNote also that the order of filenames returned can be non-deterministic.",
      "inputs": [
        {
          "description": "Shell wildcard pattern(s). Scalar or vector of type string.",
          "name": "pattern",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A vector of matching filenames.",
          "name": "filenames",
          "type": 7
        }
      ],
      "summary": "Returns the set of files matching one or more glob patterns."
    }
  },
  {
    "name": "MatrixBandPart",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tindex",
          "type": "type"
        }
      ],
      "description": "to zero.\n\nThe `band` part is computed as follows:\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor with the same shape where\n\n`band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n\nThe indicator function\n\n`in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)) &&\n                 (num_upper < 0 || (n-m) <= num_upper)`.\n\nFor example:\n\n```\n# if 'input' is [[ 0,  1,  2, 3]\n                 [-1,  0,  1, 2]\n                 [-2, -1,  0, 1]\n                 [-3, -2, -1, 0]],\n\ntf.matrix_band_part(input, 1, -1) ==> [[ 0,  1,  2, 3]\n                                       [-1,  0,  1, 2]\n                                       [ 0, -1,  0, 1]\n                                       [ 0,  0, -1, 0]],\n\ntf.matrix_band_part(input, 2, 1) ==> [[ 0,  1,  0, 0]\n                                      [-1,  0,  1, 0]\n                                      [-2, -1,  0, 1]\n                                      [ 0, -2, -1, 0]]\n```\n\nUseful special cases:\n\n```\n tf.matrix_band_part(input, 0, -1) ==> Upper triangular part.\n tf.matrix_band_part(input, -1, 0) ==> Lower triangular part.\n tf.matrix_band_part(input, 0, 0) ==> Diagonal.\n```",
      "inputs": [
        {
          "description": "Rank `k` tensor.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "0-D tensor. Number of subdiagonals to keep. If negative, keep entire\nlower triangle.",
          "name": "num_lower",
          "typeAttr": "Tindex"
        },
        {
          "description": "0-D tensor. Number of superdiagonals to keep. If negative, keep\nentire upper triangle.",
          "name": "num_upper",
          "typeAttr": "Tindex"
        }
      ],
      "outputs": [
        {
          "description": "Rank `k` tensor of the same shape as input. The extracted banded tensor.",
          "name": "band",
          "typeAttr": "T"
        }
      ],
      "summary": "Copy a tensor setting everything outside a central band in each innermost matrix"
    }
  },
  {
    "name": "MatrixDeterminant",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor containing the determinants\nfor all input submatrices `[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[...]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the determinant of one or more square matrices."
    }
  },
  {
    "name": "MatrixDiag",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has `k` dimensions `[I, J, K, ..., N]`, then the output is a\ntensor of rank `k+1` with dimensions [I, J, K, ..., N, N]` where:\n\n`output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]`.\n\nFor example:\n\n```\n# 'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nand diagonal.shape = (2, 4)\n\ntf.matrix_diag(diagonal) ==> [[[1, 0, 0, 0]\n                                     [0, 2, 0, 0]\n                                     [0, 0, 3, 0]\n                                     [0, 0, 0, 4]],\n                                    [[5, 0, 0, 0]\n                                     [0, 6, 0, 0]\n                                     [0, 0, 7, 0]\n                                     [0, 0, 0, 8]]]\n\nwhich has shape (2, 4, 4)\n```",
      "inputs": [
        {
          "description": "Rank `k`, where `k >= 1`.",
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Rank `k+1`, with `output.shape = diagonal.shape + [diagonal.shape[-1]]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a batched diagonal tensor with a given batched diagonal values."
    }
  },
  {
    "name": "MatrixDiagPart",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor with the `diagonal` part\nof the batched `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor of rank `k - 1` with dimensions `[I, J, K, ..., min(M, N)]` where:\n\n`diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]`.\n\nThe input must be at least a matrix.\n\nFor example:\n\n```\n# 'input' is [[[1, 0, 0, 0]\n               [0, 2, 0, 0]\n               [0, 0, 3, 0]\n               [0, 0, 0, 4]],\n              [[5, 0, 0, 0]\n               [0, 6, 0, 0]\n               [0, 0, 7, 0]\n               [0, 0, 0, 8]]]\n\nand input.shape = (2, 4, 4)\n\ntf.matrix_diag_part(input) ==> [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nwhich has shape (2, 4)\n```",
      "inputs": [
        {
          "description": "Rank `k` tensor where `k >= 2`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The extracted diagonal(s) having shape\n`diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]`.",
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the batched diagonal part of a batched tensor."
    }
  },
  {
    "name": "MatrixExponential",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Deprecated, use python implementation tf.linalg.matrix_exponential."
    }
  },
  {
    "name": "MatrixInverse",
    "schema": {
      "attributes": [
        {
          "default": false,
          "name": "adjoint",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "adjoints (conjugate transposes).\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the inverse for all input submatrices `[..., :, :]`.\n\nThe op uses LU decomposition with partial pivoting to compute the inverses.\n\nIf a matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.\n\n@compatibility(numpy)\nEquivalent to np.linalg.inv\n@end_compatibility",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the inverse of one or more square invertible matrices or their"
    }
  },
  {
    "name": "MatrixLogarithm",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "\n\\\\(log(exp(A)) = A\\\\)\n\nThis op is only defined for complex matrices. If A is positive-definite and\nreal, then casting to a complex matrix, taking the logarithm and casting back\nto a real matrix will give the correct result.\n\nThis function computes the matrix logarithm using the Schur-Parlett algorithm.\nDetails of the algorithm can be found in Section 11.6.2 of:\nNicholas J. Higham, Functions of Matrices: Theory and Computation, SIAM 2008.\nISBN 978-0-898716-46-7.\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the exponential for all input submatrices `[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.\n\n@compatibility(scipy)\nEquivalent to scipy.linalg.logm\n@end_compatibility",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the matrix logarithm of one or more square matrices:"
    }
  },
  {
    "name": "MatrixSetDiag",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given `input` and `diagonal`, this operation returns a tensor with the\nsame shape and values as `input`, except for the main diagonal of the\ninnermost matrices.  These will be overwritten by the values in `diagonal`.\n\nThe output is computed as follows:\n\nAssume `input` has `k+1` dimensions `[I, J, K, ..., M, N]` and `diagonal` has\n`k` dimensions `[I, J, K, ..., min(M, N)]`.  Then the output is a\ntensor of rank `k+1` with dimensions `[I, J, K, ..., M, N]` where:\n\n  * `output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]` for `m == n`.\n  * `output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]` for `m != n`.",
      "inputs": [
        {
          "description": "Rank `k+1`, where `k >= 1`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "Rank `k`, where `k >= 1`.",
          "name": "diagonal",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Rank `k+1`, with `output.shape = input.shape`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a batched matrix tensor with new batched diagonal values."
    }
  },
  {
    "name": "MatrixSolve",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "Boolean indicating whether to solve with `matrix` or its (block-wise)\nadjoint.",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`Matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. `Rhs` is a tensor of shape `[..., M, K]`. The `output` is\na tensor shape `[..., M, K]`.  If `adjoint` is `False` then each output matrix\nsatisfies `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `True` then each output matrix satisfies\n`adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "matrix",
          "typeAttr": "T"
        },
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "rhs",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Solves systems of linear equations."
    }
  },
  {
    "name": "MatrixSolveLs",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": true,
          "name": "fast",
          "type": "bool"
        }
      ],
      "description": "`matrix` is a tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform real or complex matrices of size `[M, N]`. `Rhs` is a tensor of the same\ntype as `matrix` and shape `[..., M, K]`.\nThe output is a tensor shape `[..., N, K]` where each output matrix solves\neach of the equations\n`matrix[..., :, :]` * `output[..., :, :]` = `rhs[..., :, :]`\nin the least squares sense.\n\nWe use the following notation for (complex) matrix and right-hand sides\nin the batch:\n\n`matrix`=\\\\(A \\in \\mathbb{C}^{m \\times n}\\\\),\n`rhs`=\\\\(B  \\in \\mathbb{C}^{m \\times k}\\\\),\n`output`=\\\\(X  \\in \\mathbb{C}^{n \\times k}\\\\),\n`l2_regularizer`=\\\\(\\lambda \\in \\mathbb{R}\\\\).\n\nIf `fast` is `True`, then the solution is computed by solving the normal\nequations using Cholesky decomposition. Specifically, if \\\\(m \\ge n\\\\) then\n\\\\(X = (A^H A + \\lambda I)^{-1} A^H B\\\\), which solves the least-squares\nproblem \\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k} } ||A Z - B||_F^2 + \\lambda ||Z||_F^2\\\\). \nIf \\\\(m \\lt n\\\\) then `output` is computed as\n\\\\(X = A^H (A A^H + \\lambda I)^{-1} B\\\\), which (for \\\\(\\lambda = 0\\\\)) is the\nminimum-norm solution to the under-determined linear system, i.e.\n\\\\(X = \\mathrm{argmin}_{Z \\in \\mathbb{C}^{n \\times k} } ||Z||_F^2 \\\\),\nsubject to \\\\(A Z = B\\\\). Notice that the fast path is only numerically stable\nwhen \\\\(A\\\\) is numerically full rank and has a condition number\n\\\\(\\mathrm{cond}(A) \\lt \\frac{1}{\\sqrt{\\epsilon_{mach} } }\\\\) or \\\\(\\lambda\\\\) is\nsufficiently large.\n\nIf `fast` is `False` an algorithm based on the numerically robust complete\northogonal decomposition is used. This computes the minimum-norm\nleast-squares solution, even when \\\\(A\\\\) is rank deficient. This path is\ntypically 6-7 times slower than the fast path. If `fast` is `False` then\n`l2_regularizer` is ignored.",
      "inputs": [
        {
          "description": "Shape is `[..., M, N]`.",
          "name": "matrix",
          "typeAttr": "T"
        },
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "rhs",
          "typeAttr": "T"
        },
        {
          "description": "Scalar tensor.\n\n@compatibility(numpy)\nEquivalent to np.linalg.lstsq\n@end_compatibility",
          "name": "l2_regularizer",
          "type": 2
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., N, K]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Solves one or more linear least-squares problems."
    }
  },
  {
    "name": "MatrixSquareRoot",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "matmul(sqrtm(A), sqrtm(A)) = A\n\nThe input matrix should be invertible. If the input matrix is real, it should\nhave no eigenvalues which are real and negative (pairs of complex conjugate\neigenvalues are allowed).\n\nThe matrix square root is computed by first reducing the matrix to \nquasi-triangular form with the real Schur decomposition. The square root \nof the quasi-triangular matrix is then computed directly. Details of \nthe algorithm can be found in: Nicholas J. Higham, \"Computing real \nsquare roots of a real matrix\", Linear Algebra Appl., 1987.\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the matrix square root for all input submatrices `[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.\n\n@compatibility(scipy)\nEquivalent to scipy.linalg.sqrtm\n@end_compatibility",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the matrix square root of one or more square matrices:"
    }
  },
  {
    "name": "MatrixTriangularSolve",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "Boolean indicating whether the innermost matrices in `matrix` are\nlower or upper triangular.",
          "name": "lower",
          "type": "bool"
        },
        {
          "default": false,
          "description": "Boolean indicating whether to solve with `matrix` or its (block-wise)\n         adjoint.\n\n@compatibility(numpy)\nEquivalent to scipy.linalg.solve_triangular\n@end_compatibility",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "backsubstitution.\n\n`matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions form\nsquare matrices. If `lower` is `True` then the strictly upper triangular part\nof each inner-most matrix is assumed to be zero and not accessed.\nIf `lower` is False then the strictly lower triangular part of each inner-most\nmatrix is assumed to be zero and not accessed.\n`rhs` is a tensor of shape `[..., M, K]`.\n\nThe output is a tensor of shape `[..., M, K]`. If `adjoint` is\n`True` then the innermost matrices in `output` satisfy matrix equations\n`matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `False` then the strictly then the  innermost matrices in\n`output` satisfy matrix equations\n`adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "matrix",
          "typeAttr": "T"
        },
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "rhs",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Solves systems of linear equations with upper or lower triangular matrices by"
    }
  },
  {
    "name": "Max",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the maximum of elements across dimensions of a tensor."
    }
  },
  {
    "name": "MaxPool",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 11
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW",
            "NCHW_VECT_C"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "category": "Pool",
      "inputs": [
        {
          "description": "4-D input to pool over.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs max pooling on the input."
    }
  },
  {
    "name": "MaxPool3D",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "minimum": 5,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, channels]` tensor to pool over.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs 3D max pooling on the input."
    }
  },
  {
    "name": "MaxPool3DGrad",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "minimum": 5,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "TInput",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "typeAttr": "TInput"
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "typeAttr": "TInput"
        },
        {
          "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients of max pooling function."
    }
  },
  {
    "name": "MaxPool3DGradGrad",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "minimum": 5,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "minimum": 5,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NDHWC",
            "NCDHW"
          ],
          "default": "NDHWC",
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "typeAttr": "T"
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "typeAttr": "T"
        },
        {
          "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGrad",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "typeAttr": "T"
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "typeAttr": "T"
        },
        {
          "description": "4-D.  Gradients w.r.t. the output of `max_pool`.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradGrad",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "typeAttr": "T"
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "typeAttr": "T"
        },
        {
          "description": "4-D.  Gradients of gradients w.r.t. the input of `max_pool`.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradGradV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "typeAttr": "T"
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "typeAttr": "T"
        },
        {
          "description": "4-D.  Gradients of gradients w.r.t. the input of `max_pool`.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": 3
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradGradWithArgmax",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Targmax",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\ninput of `max_pool`.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "The indices of the maximum values chosen for each output of `max_pool`.",
          "name": "argmax",
          "typeAttr": "Targmax"
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input of `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "typeAttr": "T"
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "typeAttr": "T"
        },
        {
          "description": "4-D.  Gradients w.r.t. the output of `max_pool`.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": 3
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradWithArgmax",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Targmax",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\noutput of `max_pool`.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "The indices of the maximum values chosen for each output of `max_pool`.",
          "name": "argmax",
          "typeAttr": "Targmax"
        }
      ],
      "outputs": [
        {
          "description": "Gradients w.r.t. the input of `max_pool`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 11
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW",
            "NCHW_VECT_C"
          ],
          "default": "NHWC",
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "category": "Pool",
      "inputs": [
        {
          "description": "4-D input to pool over.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": 3
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Performs max pooling on the input."
    }
  },
  {
    "name": "MaxPoolWithArgmax",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "minimum": 4,
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "minimum": 4,
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Targmax",
          "type": "type"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The indices in `argmax` are flattened, so that a maximum value at position\n`[b, y, x, c]` becomes flattened index\n`((b * height + y) * width + x) * channels + c`.\n\nThe indices returned are always in `[0, height) x [0, width)` before flattening,\neven if padding is involved and the mathematically correct answer is outside\n(either negative or too large).  This is a bug, but fixing it is difficult to do\nin a safe backwards compatible way, especially due to flattening.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Input to pool over.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "4-D.  The flattened indices of the max values chosen for each output.",
          "name": "argmax",
          "typeAttr": "Targmax"
        }
      ],
      "summary": "Performs max pooling on the input and outputs both max values and indices."
    }
  },
  {
    "name": "Maximum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Maximum` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the max of x and y (i.e. x > y ? x : y) element-wise."
    }
  },
  {
    "name": "Mean",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the mean of elements across dimensions of a tensor."
    }
  },
  {
    "name": "Merge",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "description": "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor to become available to `output`, and sets\n`value_index` to its index in `inputs`.",
      "inputs": [
        {
          "description": "The input tensors, exactly one of which will become available.",
          "name": "inputs",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Will be set to the available input tensor.",
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "The index of the chosen input tensor in `inputs`.",
          "name": "value_index",
          "type": 3
        }
      ],
      "summary": "Forwards the value of an available tensor from `inputs` to `output`."
    }
  },
  {
    "name": "MergeSummary",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "description": "This op creates a\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nprotocol buffer that contains the union of all the values in the input\nsummaries.\n\nWhen the Op is run, it reports an `InvalidArgument` error if multiple values\nin the summaries to merge use the same tag.",
      "inputs": [
        {
          "description": "Can be of any shape.  Each must contain serialized `Summary` protocol\nbuffers.",
          "name": "inputs",
          "numberAttr": "N",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Merges summaries."
    }
  },
  {
    "name": "MergeV2Checkpoints",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "see above.",
          "name": "delete_old_dirs",
          "type": "bool"
        }
      ],
      "description": "result is one logical checkpoint, with one physical metadata file and renamed\ndata files.\n\nIntended for \"grouping\" multiple checkpoints in a sharded checkpoint setup.\n\nIf delete_old_dirs is true, attempts to delete recursively the dirname of each\npath in the input checkpoint_prefixes.  This is useful when those paths are non\nuser-facing temporary locations.",
      "inputs": [
        {
          "description": "prefixes of V2 checkpoints to merge.",
          "name": "checkpoint_prefixes",
          "type": 7
        },
        {
          "description": "scalar.  The desired final prefix.  Allowed to be the same\nas one of the checkpoint_prefixes.",
          "name": "destination_prefix",
          "type": 7
        }
      ],
      "summary": "V2 format specific: merges the metadata files of sharded checkpoints.  The"
    }
  },
  {
    "name": "Mfcc",
    "schema": {
      "attributes": [
        {
          "default": 4000.0,
          "description": "The highest frequency to use when calculating the\nceptstrum.",
          "name": "upper_frequency_limit",
          "type": "float"
        },
        {
          "default": 20.0,
          "description": "The lowest frequency to use when calculating the\nceptstrum.",
          "name": "lower_frequency_limit",
          "type": "float"
        },
        {
          "default": 40,
          "description": "Resolution of the Mel bank used internally.",
          "name": "filterbank_channel_count",
          "type": "int"
        },
        {
          "default": 13,
          "description": "How many output channels to produce per time slice.",
          "name": "dct_coefficient_count",
          "type": "int"
        }
      ],
      "description": "Mel Frequency Cepstral Coefficients are a way of representing audio data that's\nbeen effective as an input feature for machine learning. They are created by\ntaking the spectrum of a spectrogram (a 'cepstrum'), and discarding some of the\nhigher frequencies that are less significant to the human ear. They have a long\nhistory in the speech recognition world, and https://en.wikipedia.org/wiki/Mel-frequency_cepstrum\nis a good resource to learn more.",
      "inputs": [
        {
          "description": "Typically produced by the Spectrogram op, with magnitude_squared\nset to true.",
          "name": "spectrogram",
          "type": 1
        },
        {
          "description": "How many samples per second the source audio used.",
          "name": "sample_rate",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Transforms a spectrogram into a form that's useful for speech recognition."
    }
  },
  {
    "name": "Min",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the minimum of elements across dimensions of a tensor."
    }
  },
  {
    "name": "Minimum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Minimum` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the min of x and y (i.e. x < y ? x : y) element-wise."
    }
  },
  {
    "name": "MirrorPad",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tpaddings",
          "type": "type"
        },
        {
          "allowedValues": [
            "REFLECT",
            "SYMMETRIC"
          ],
          "description": "Either `REFLECT` or `SYMMETRIC`. In reflect mode the padded regions\ndo not include the borders, while in symmetric mode the padded regions\ndo include the borders. For example, if `input` is `[1, 2, 3]` and `paddings`\nis `[0, 2]`, then the output is `[1, 2, 3, 2, 1]` in reflect mode, and\nit is `[1, 2, 3, 3, 2]` in symmetric mode.",
          "name": "mode",
          "type": "string"
        }
      ],
      "description": "This operation pads a `input` with mirrored values according to the `paddings`\nyou specify. `paddings` is an integer tensor with shape `[n, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many values to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many values to add after the contents of `input`\nin that dimension. Both `paddings[D, 0]` and `paddings[D, 1]` must be no greater\nthan `input.dim_size(D)` (or `input.dim_size(D) - 1`) if `copy_border` is true\n(if false, respectively).\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 2, 3], [4, 5, 6]].\n# 'paddings' is [[1, 1]], [2, 2]].\n# 'mode' is SYMMETRIC.\n# rank of 't' is 2.\npad(t, paddings) ==> [[2, 1, 1, 2, 3, 3, 2]\n                      [2, 1, 1, 2, 3, 3, 2]\n                      [5, 4, 4, 5, 6, 6, 5]\n                      [5, 4, 4, 5, 6, 6, 5]]\n```",
      "inputs": [
        {
          "description": "The input tensor to be padded.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "typeAttr": "Tpaddings"
        }
      ],
      "outputs": [
        {
          "description": "The padded tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Pads a tensor with mirrored values."
    }
  },
  {
    "name": "MirrorPadGrad",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tpaddings",
          "type": "type"
        },
        {
          "allowedValues": [
            "REFLECT",
            "SYMMETRIC"
          ],
          "description": "The mode used in the `MirrorPad` op.",
          "name": "mode",
          "type": "string"
        }
      ],
      "description": "This operation folds the padded areas of `input` by `MirrorPad` according to the\n`paddings` you specify. `paddings` must be the same as `paddings` argument\ngiven to the corresponding `MirrorPad` op.\n\nThe folded size of each dimension D of the output is:\n\n`input.dim_size(D) - paddings(D, 0) - paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\n# 'paddings' is [[0, 1]], [0, 1]].\n# 'mode' is SYMMETRIC.\n# rank of 't' is 2.\npad(t, paddings) ==> [[ 1,  5]\n                      [11, 28]]\n```",
      "inputs": [
        {
          "description": "The input tensor to be folded.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "typeAttr": "Tpaddings"
        }
      ],
      "outputs": [
        {
          "description": "The folded tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor."
    }
  },
  {
    "name": "Mod",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "the result here is consistent with a truncating divide. E.g.\n`tf.truncatediv(x, y) * y + truncate_mod(x, y) = x`.\n\n*NOTE*: `Mod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns element-wise remainder of division. This emulates C semantics in that"
    }
  },
  {
    "name": "ModelDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Identity transformation that models performance.",
      "inputs": [
        {
          "description": "A variant tensor representing the input dataset.",
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Identity transformation that models performance."
    }
  },
  {
    "name": "Mul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Mul` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x * y element-wise."
    }
  },
  {
    "name": "MultiDeviceIterator",
    "schema": {
      "attributes": [
        {
          "description": "A list of devices the iterator works across.",
          "minimum": 1,
          "name": "devices",
          "type": "list(string)"
        },
        {
          "description": "If non-empty, this resource will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "If non-empty, this resource is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "The type list for the return values.",
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "The list of shapes being produced.",
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "outputs": [
        {
          "description": "Handle to the resource created.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Creates a MultiDeviceIterator resource."
    }
  },
  {
    "name": "MultiDeviceIteratorFromStringHandle",
    "schema": {
      "attributes": [
        {
          "default": [],
          "description": "The type list for the return values.",
          "minimum": 0,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The list of shapes being produced.",
          "minimum": 0,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "String representing the resource.",
          "name": "string_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A MultiDeviceIterator resource.",
          "name": "multi_device_iterator",
          "type": 20
        }
      ],
      "summary": "Generates a MultiDeviceIterator resource from its provided string handle."
    }
  },
  {
    "name": "MultiDeviceIteratorGetNextFromShard",
    "schema": {
      "attributes": [
        {
          "description": "The type list for the return values.",
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "The list of shapes being produced.",
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A MultiDeviceIterator resource.",
          "name": "multi_device_iterator",
          "type": 20
        },
        {
          "description": "Integer representing which shard to fetch data for.",
          "name": "shard_num",
          "type": 3
        },
        {
          "description": "Which incarnation of the MultiDeviceIterator is running.",
          "name": "incarnation_id",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Result of the get_next on the dataset.",
          "name": "components",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "Gets next element for the provided shard number."
    }
  },
  {
    "name": "MultiDeviceIteratorInit",
    "schema": {
      "inputs": [
        {
          "description": "Dataset to be iterated upon.",
          "name": "dataset",
          "type": 21
        },
        {
          "description": "A MultiDeviceIteratorResource.",
          "name": "multi_device_iterator",
          "type": 20
        },
        {
          "description": "The maximum size of the host side per device buffer to keep.",
          "name": "max_buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "An int64 indicating which incarnation of the MultiDeviceIterator\nis running.",
          "name": "incarnation_id",
          "type": 9
        }
      ],
      "summary": "Initializes the multi device iterator with the given dataset."
    }
  },
  {
    "name": "MultiDeviceIteratorToStringHandle",
    "schema": {
      "inputs": [
        {
          "description": "A MultiDeviceIterator resource.",
          "name": "multi_device_iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A string representing the resource.",
          "name": "string_handle",
          "type": 7
        }
      ],
      "summary": "Produces a string handle for the given MultiDeviceIterator."
    }
  },
  {
    "name": "Multinomial",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either seed or seed2 is set to be non-zero, the internal random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "output_dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`\nrepresents the unnormalized log probabilities for all classes.",
          "name": "logits",
          "typeAttr": "T"
        },
        {
          "description": "0-D.  Number of independent samples to draw for each row slice.",
          "name": "num_samples",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`\ncontains the drawn class labels with range `[0, num_classes)`.",
          "name": "output",
          "typeAttr": "output_dtype"
        }
      ],
      "summary": "Draws samples from a multinomial distribution."
    }
  },
  {
    "name": "MutableDenseHashTable",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "description": "The shape of each value.",
          "name": "value_shape",
          "type": "shape"
        },
        {
          "default": 131072,
          "description": "The initial number of hash table buckets. Must be a power\nto 2.",
          "name": "initial_num_buckets",
          "type": "int"
        },
        {
          "default": 0.800000011920929,
          "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
          "name": "max_load_factor",
          "type": "float"
        }
      ],
      "description": "It uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThis op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "inputs": [
        {
          "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
          "name": "empty_key",
          "typeAttr": "key_dtype"
        }
      ],
      "outputs": [
        {
          "description": "Handle to a table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates an empty hash table that uses tensors as the backing store."
    }
  },
  {
    "name": "MutableDenseHashTableV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "description": "The shape of each value.",
          "name": "value_shape",
          "type": "shape"
        },
        {
          "default": 131072,
          "description": "The initial number of hash table buckets. Must be a power\nto 2.",
          "name": "initial_num_buckets",
          "type": "int"
        },
        {
          "default": 0.800000011920929,
          "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
          "name": "max_load_factor",
          "type": "float"
        }
      ],
      "description": "It uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThis op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "inputs": [
        {
          "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
          "name": "empty_key",
          "typeAttr": "key_dtype"
        },
        {
          "name": "deleted_key",
          "typeAttr": "key_dtype"
        }
      ],
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates an empty hash table that uses tensors as the backing store."
    }
  },
  {
    "name": "MutableHashTable",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutableHashTableOfTensors",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "value_shape",
          "type": "shape"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a vector. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "isRef": true,
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutableHashTableOfTensorsV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "value_shape",
          "type": "shape"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a vector. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutableHashTableV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": false,
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutexLock",
    "schema": {
      "description": "is alive, any other request to use `MutexLock` with this mutex will wait.\n\nThis is particularly useful for creating a critical section when used in\nconjunction with `MutexLockIdentity`:\n\n```python\n\nmutex = mutex_v2(\n  shared_name=handle_name, container=container, name=name)\n\ndef execute_in_critical_section(fn, *args, **kwargs):\n  lock = gen_resource_variable_ops.mutex_lock(mutex)\n\n  with ops.control_dependencies([lock]):\n    r = fn(*args, **kwargs)\n\n  with ops.control_dependencies(nest.flatten(r)):\n    with ops.colocate_with(mutex):\n      ensure_lock_exists = mutex_lock_identity(lock)\n\n    # Make sure that if any element of r is accessed, all of\n    # them are executed together.\n    r = nest.map_structure(tf.identity, r)\n\n  with ops.control_dependencies([ensure_lock_exists]):\n    return nest.map_structure(tf.identity, r)\n```\n\nWhile `fn` is running in the critical section, no other functions which wish to\nuse this critical section may run.\n\nOften the use case is that two executions of the same graph, in parallel,\nwish to run `fn`; and we wish to ensure that only one of them executes\nat a time.  This is especially important if `fn` modifies one or more\nvariables at a time.\n\nIt is also useful if two separate functions must share a resource, but we\nwish to ensure the usage is exclusive.",
      "inputs": [
        {
          "description": "The mutex resource to lock.",
          "name": "mutex",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A tensor that keeps a shared pointer to a lock on the mutex;\nwhen the Tensor is destroyed, the use count on the shared pointer is decreased\nby 1.  When it reaches 0, the lock is released.",
          "name": "mutex_lock",
          "type": 21
        }
      ],
      "summary": "Locks a mutex resource.  The output is the lock.  So long as the lock tensor"
    }
  },
  {
    "name": "MutexV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The mutex resource.",
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Creates a Mutex resource that can be locked by `MutexLock`."
    }
  },
  {
    "name": "NcclAllReduce",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "min",
            "max",
            "prod",
            "sum"
          ],
          "name": "reduction",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "name": "num_devices",
          "type": "int"
        },
        {
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Outputs a tensor containing the reduction across all input tensors passed to ops\nwithin the same `shared_name.\n\nThe graph should be constructed so if one op runs with shared_name value `c`,\nthen `num_devices` ops will run with shared_name value `c`.  Failure to do so\nwill cause the graph execution to fail to complete.\n\ninput: the input to the reduction\ndata: the value of the reduction across all `num_devices` devices.\nreduction: the reduction operation to perform.\nnum_devices: The number of devices participating in this reduction.\nshared_name: Identifier that shared between ops of the same reduction.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "summary": "Outputs a tensor containing the reduction across all input tensors."
    }
  },
  {
    "name": "NcclBroadcast",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "Sends `input` to all devices that are connected to the output.\n\nThe graph should be constructed so that all ops connected to the output have a\nvalid device assignment, and the op itself is assigned one of these devices.\n\ninput: The input to the broadcast.\noutput: The same as input.\nshape: The shape of the input tensor.\n",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Sends `input` to all devices that are connected to the output."
    }
  },
  {
    "name": "NcclReduce",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "min",
            "max",
            "prod",
            "sum"
          ],
          "name": "reduction",
          "type": "string"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 1,
          "name": "num_devices",
          "type": "int"
        }
      ],
      "description": "Reduces `input` from `num_devices` using `reduction` to a single device.\n\nThe graph should be constructed so that all inputs have a valid device\nassignment, and the op itself is assigned one of these devices.\n\ninput: The input to the reduction.\ndata: the value of the reduction across all `num_devices` devices.\nreduction: the reduction operation to perform.",
      "inputs": [
        {
          "name": "input",
          "numberAttr": "num_devices",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "summary": "Reduces `input` from `num_devices` using `reduction` to a single device."
    }
  },
  {
    "name": "NearestNeighbors",
    "schema": {
      "description": "Rows of points are assumed to be input points. Rows of centers are assumed to be\nthe list of candidate centers. For each point, the k centers that have least L2\ndistance to it are computed.",
      "inputs": [
        {
          "description": "Matrix of shape (n, d). Rows are assumed to be input points.",
          "name": "points",
          "type": 1
        },
        {
          "description": "Matrix of shape (m, d). Rows are assumed to be centers.",
          "name": "centers",
          "type": 1
        },
        {
          "description": "Number of nearest centers to return for each point. If k is larger than m, then\nonly m centers are returned.",
          "name": "k",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Matrix of shape (n, min(m, k)). Each row contains the indices of the centers\nclosest to the corresponding point, ordered by increasing distance.",
          "name": "nearest_center_indices",
          "type": 9
        },
        {
          "description": "Matrix of shape (n, min(m, k)). Each row contains the squared L2 distance to the\ncorresponding center in nearest_center_indices.",
          "name": "nearest_center_distances",
          "type": 1
        }
      ],
      "summary": "Selects the k nearest centers for each point."
    }
  },
  {
    "name": "Neg",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = -x\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes numerical negative value element-wise."
    }
  },
  {
    "name": "NegTrain",
    "schema": {
      "attributes": [
        {
          "description": "Count of words in the vocabulary.",
          "name": "vocab_count",
          "type": "list(int)"
        },
        {
          "description": "Number of negative samples per example.",
          "name": "num_negative_samples",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "input word embedding.",
          "isRef": true,
          "name": "w_in",
          "type": 1
        },
        {
          "description": "output word embedding.",
          "isRef": true,
          "name": "w_out",
          "type": 1
        },
        {
          "description": "A vector of word ids.",
          "name": "examples",
          "type": 3
        },
        {
          "description": "A vector of word ids.",
          "name": "labels",
          "type": 3
        },
        {
          "name": "lr",
          "type": 1
        }
      ],
      "summary": "Training via negative sampling."
    }
  },
  {
    "name": "NextAfter",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns the same result as the C++ std::nextafter function.\n\nIt can also return a subnormal number.\n\n@compatibility(cpp)\nEquivalent to C++ std::nextafter function.\n@end_compatibility",
      "inputs": [
        {
          "name": "x1",
          "typeAttr": "T"
        },
        {
          "name": "x2",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the next representable value of `x1` in the direction of `x2`, element-wise."
    }
  },
  {
    "name": "NextIteration",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be made available to the next iteration.",
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Makes its input available to the next iteration."
    }
  },
  {
    "name": "NoOp",
    "schema": {
      "summary": "Does nothing. Only useful as a placeholder for control edges."
    }
  },
  {
    "name": "NonMaxSuppression",
    "schema": {
      "attributes": [
        {
          "default": 0.5,
          "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU.",
          "name": "iou_threshold",
          "type": "float"
        }
      ],
      "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system.  Note that this\nalgorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression(\n      boxes, scores, max_output_size, iou_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "type": 1
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NonMaxSuppressionV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system.  Note that this\nalgorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\n\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
          "name": "boxes",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "typeAttr": "T"
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
          "name": "iou_threshold",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NonMaxSuppressionV3",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system and more\ngenerally is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
          "name": "boxes",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "typeAttr": "T"
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
          "name": "iou_threshold",
          "type": 1
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
          "name": "score_threshold",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NonMaxSuppressionV4",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the output `selected_indices` is padded to be of length\n`max_output_size`. Defaults to false.",
          "name": "pad_to_max_output_size",
          "type": "bool"
        }
      ],
      "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system and more\ngenerally is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
          "name": "boxes",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "typeAttr": "T"
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
          "name": "iou_threshold",
          "type": 1
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
          "name": "score_threshold",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        },
        {
          "description": "A 0-D integer tensor representing the number of valid elements in\n`selected_indices`, with the valid elements appearing first.",
          "name": "valid_outputs",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NonMaxSuppressionWithOverlaps",
    "schema": {
      "description": "pruning away boxes that have high overlaps\nwith previously selected boxes.  Bounding boxes with score less than\n`score_threshold` are removed. N-by-n overlap values are supplied as square matrix,\nwhich allows for defining a custom overlap criterium (eg. intersection over union,\nintersection over area, etc.).\n\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n\n  selected_indices = tf.image.non_max_suppression_with_overlaps(\n      overlaps, scores, max_output_size, overlap_threshold, score_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, num_boxes]` representing\nthe n-by-n box overlap values.",
          "name": "overlaps",
          "type": 1
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "type": 1
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too.",
          "name": "overlap_threshold",
          "type": 1
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding when to remove\nboxes based on score.",
          "name": "score_threshold",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NotEqual",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 7
            },
            {
              "type": "type",
              "value": 10
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `NotEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x != y) element-wise."
    }
  },
  {
    "name": "NthElement",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "When set to True, find the nth-largest value in the vector and vice\nversa.",
          "name": "reverse",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the input is a vector (rank-1), finds the entries which is the nth-smallest\nvalue in the vector and outputs their values as scalar tensor.\n\nFor matrices (resp. higher rank input), computes the entries which is the\nnth-smallest value in each row (resp. vector along the last dimension). Thus,\n\n    values.shape = input.shape[:-1]",
      "inputs": [
        {
          "description": "1-D or higher with last dimension at least `n+1`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "0-D. Position of sorted vector to select along the last dimension (along\neach row for matrices). Valid range of n is `[0, input.shape[:-1])`",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The `n`-th order statistic along each last dimensional slice.",
          "name": "values",
          "typeAttr": "T"
        }
      ],
      "summary": "Finds values of the `n`-th order statistic for the last dimension."
    }
  },
  {
    "name": "OneHot",
    "schema": {
      "attributes": [
        {
          "default": -1,
          "description": "The axis to fill (default: -1, a new inner-most axis).",
          "name": "axis",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "TI",
          "type": "type"
        }
      ],
      "description": "The locations represented by indices in `indices` take value `on_value`,\nwhile all other locations take value `off_value`.\n\nIf the input `indices` is rank `N`, the output will have rank `N+1`,\nThe new axis is created at dimension `axis` (default: the new axis is\nappended at the end).\n\nIf `indices` is a scalar the output shape will be a vector of length `depth`.\n\nIf `indices` is a vector of length `features`, the output shape will be:\n```\n  features x depth if axis == -1\n  depth x features if axis == 0\n```\n\nIf `indices` is a matrix (batch) with shape `[batch, features]`,\nthe output shape will be:\n```\n  batch x features x depth if axis == -1\n  batch x depth x features if axis == 1\n  depth x batch x features if axis == 0\n```\n\n\nExamples\n=========\n\nSuppose that\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 5.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[4 x 3]`:\n```\noutput =\n  [5.0 0.0 0.0]  // one_hot(0)\n  [0.0 0.0 5.0]  // one_hot(2)\n  [0.0 0.0 0.0]  // one_hot(-1)\n  [0.0 5.0 0.0]  // one_hot(1)\n```\n\nSuppose that\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 0.0\n  off_value = 3.0\n  axis = 0\n```\n\nThen output is `[3 x 4]`:\n```\noutput =\n  [0.0 3.0 3.0 3.0]\n  [3.0 3.0 3.0 0.0]\n  [3.0 3.0 3.0 3.0]\n  [3.0 0.0 3.0 3.0]\n//  ^                one_hot(0)\n//      ^            one_hot(2)\n//          ^        one_hot(-1)\n//              ^    one_hot(1)\n```\n\nSuppose that\n```\n  indices = [[0, 2], [1, -1]]\n  depth = 3\n  on_value = 1.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[2 x 2 x 3]`:\n```\noutput =\n  [\n    [1.0, 0.0, 0.0]  // one_hot(0)\n    [0.0, 0.0, 1.0]  // one_hot(2)\n  ][\n    [0.0, 1.0, 0.0]  // one_hot(1)\n    [0.0, 0.0, 0.0]  // one_hot(-1)\n  ]\n```",
      "inputs": [
        {
          "description": "A tensor of indices.",
          "name": "indices",
          "typeAttr": "TI"
        },
        {
          "description": "A scalar defining the depth of the one hot dimension.",
          "name": "depth",
          "type": 3
        },
        {
          "description": "A scalar defining the value to fill in output when `indices[j] = i`.",
          "name": "on_value",
          "typeAttr": "T"
        },
        {
          "description": "A scalar defining the value to fill in output when `indices[j] != i`.",
          "name": "off_value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The one-hot tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a one-hot tensor."
    }
  },
  {
    "name": "OneShotIterator",
    "schema": {
      "attributes": [
        {
          "description": "A function of type `() -> DT_VARIANT`, where the returned\nDT_VARIANT is a dataset.",
          "name": "dataset_factory",
          "type": "func"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A one-shot iterator bundles the logic for defining the dataset and\nthe state of the iterator in a single op, which allows simple input\npipelines to be defined without an additional initialization\n(\"MakeIterator\") step.\n\nOne-shot iterators have the following limitations:\n\n* They do not support parameterization: all logic for creating the underlying\n  dataset must be bundled in the `dataset_factory` function.\n* They are not resettable. Once a one-shot iterator reaches the end of its\n  underlying dataset, subsequent \"IteratorGetNext\" operations on that\n  iterator will always produce an `OutOfRange` error.\n\nFor greater flexibility, use \"Iterator\" and \"MakeIterator\" to define\nan iterator using an arbitrary subgraph, which may capture tensors\n(including fed values) as parameters, and which may be reset multiple\ntimes by rerunning \"MakeIterator\".",
      "outputs": [
        {
          "description": "A handle to the iterator that can be passed to an \"IteratorGetNext\"\nop.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Makes a \"one-shot\" iterator that can be iterated only once."
    }
  },
  {
    "name": "OnesLike",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 10
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "a tensor of type T.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "a tensor of the same shape and type as x but filled with ones.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a tensor of ones with the same shape and type as x."
    }
  },
  {
    "name": "OptimizeDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Creates a dataset by applying optimizations to `input_dataset`.",
      "inputs": [
        {
          "description": "A variant tensor representing the input dataset.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A `tf.string` vector `tf.Tensor` identifying optimizations to use.",
          "name": "optimizations",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset by applying optimizations to `input_dataset`."
    }
  },
  {
    "name": "OptionalFromValue",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Toutput_types",
          "type": "list(type)"
        }
      ],
      "inputs": [
        {
          "name": "components",
          "typeListAttr": "Toutput_types"
        }
      ],
      "outputs": [
        {
          "name": "optional",
          "type": 21
        }
      ],
      "summary": "Constructs an Optional variant from a tuple of tensors."
    }
  },
  {
    "name": "OptionalGetValue",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "optional",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "components",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "Returns the value stored in an Optional variant or raises an error if none exists."
    }
  },
  {
    "name": "OptionalHasValue",
    "schema": {
      "inputs": [
        {
          "name": "optional",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "has_value",
          "type": 10
        }
      ],
      "summary": "Returns true if and only if the given Optional variant has a value."
    }
  },
  {
    "name": "OptionalNone",
    "schema": {
      "outputs": [
        {
          "name": "optional",
          "type": 21
        }
      ],
      "summary": "Creates an Optional variant with no value."
    }
  },
  {
    "name": "OrderedMapClear",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "summary": "Op removes all elements in the underlying container."
    }
  },
  {
    "name": "OrderedMapIncompleteSize",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of incomplete elements in the underlying container."
    }
  },
  {
    "name": "OrderedMapPeek",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "underlying container does not contain this key\nthis op will block until it does.   This Op is optimized for\nperformance.",
      "inputs": [
        {
          "name": "key",
          "type": 9
        },
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op peeks at the values at the specified key.  If the"
    }
  },
  {
    "name": "OrderedMapSize",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of elements in the underlying container."
    }
  },
  {
    "name": "OrderedMapStage",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "fake_dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "It is necessary to match this name to the matching Unstage Op.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "associative container.   Elements are ordered by key.",
      "inputs": [
        {
          "description": "int64",
          "name": "key",
          "type": 9
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
          "name": "values",
          "typeListAttr": "fake_dtypes"
        }
      ],
      "summary": "Stage (key, values) in the underlying container which behaves like a ordered"
    }
  },
  {
    "name": "OrderedMapUnstage",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "from the underlying container.   If the underlying container\ndoes not contain this key, the op will block until it does.",
      "inputs": [
        {
          "name": "key",
          "type": 9
        },
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op removes and returns the values associated with the key"
    }
  },
  {
    "name": "OrderedMapUnstageNoKey",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "key from the underlying container.   If the underlying container\ndoes not contain elements, the op will block until it does.",
      "inputs": [
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "key",
          "type": 9
        },
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op removes and returns the (key, value) element with the smallest"
    }
  },
  {
    "name": "Pack",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": 0,
          "description": "Dimension along which to pack.  Negative values wrap around, so the\nvalid range is `[-(R+1), R+1)`.",
          "name": "axis",
          "type": "int"
        }
      ],
      "description": "Packs the `N` tensors in `values` into a tensor with rank one higher than each\ntensor in `values`, by packing them along the `axis` dimension.\nGiven a list of tensors of shape `(A, B, C)`;\n\nif `axis == 0` then the `output` tensor will have the shape `(N, A, B, C)`.\nif `axis == 1` then the `output` tensor will have the shape `(A, N, B, C)`.\nEtc.\n\nFor example:\n\n```\n# 'x' is [1, 4]\n# 'y' is [2, 5]\n# 'z' is [3, 6]\npack([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\npack([x, y, z], axis=1) => [[1, 2, 3], [4, 5, 6]]\n```\n\nThis is the opposite of `unpack`.",
      "inputs": [
        {
          "description": "Must be of same shape and type.",
          "name": "values",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The packed tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor."
    }
  },
  {
    "name": "Pad",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tpaddings",
          "type": "type"
        }
      ],
      "description": "This operation pads a `input` with zeros according to the `paddings` you\nspecify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the\nrank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many zeros to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many zeros to add after the contents of `input`\nin that dimension.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 1], [2, 2]]\n# 'paddings' is [[1, 1], [2, 2]]\n# rank of 't' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```\n",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "paddings",
          "typeAttr": "Tpaddings"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Pads a tensor with zeros."
    }
  },
  {
    "name": "PadV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tpaddings",
          "type": "type"
        }
      ],
      "description": "This operation pads `input` according to the `paddings` and `constant_values`\nyou specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many padding values to add before the contents of `input` in that dimension,\nand `paddings[D, 1]` indicates how many padding values to add after the contents\nof `input` in that dimension. `constant_values` is a scalar tensor of the same\ntype as `input` that indicates the value to use for padding `input`.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 1], [2, 2]]\n# 'paddings' is [[1, 1], [2, 2]]\n# 'constant_values' is 0\n# rank of 't' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "paddings",
          "typeAttr": "Tpaddings"
        },
        {
          "name": "constant_values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Pads a tensor."
    }
  },
  {
    "name": "PaddedBatchDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A list of int64 tensors representing the desired padded shapes\nof the corresponding output components. These shapes may be partially\nspecified, using `-1` to indicate that a particular dimension should be\npadded to the maximum size of all batch elements.",
          "name": "padded_shapes",
          "numberAttr": "N",
          "type": 9
        },
        {
          "description": "A list of scalars containing the padding value to use for\neach of the outputs.",
          "name": "padding_values",
          "typeListAttr": "Toutput_types"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches and pads `batch_size` elements from the input."
    }
  },
  {
    "name": "PaddedBatchDatasetV2",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A list of int64 tensors representing the desired padded shapes\nof the corresponding output components. These shapes may be partially\nspecified, using `-1` to indicate that a particular dimension should be\npadded to the maximum size of all batch elements.",
          "name": "padded_shapes",
          "numberAttr": "N",
          "type": 9
        },
        {
          "description": "A list of scalars containing the padding value to use for\neach of the outputs.",
          "name": "padding_values",
          "typeListAttr": "Toutput_types"
        },
        {
          "description": "A scalar representing whether the last batch should be dropped in case its size\nis smaller than desired.",
          "name": "drop_remainder",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches and pads `batch_size` elements from the input."
    }
  },
  {
    "name": "PaddingFIFOQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "PaddingFIFOQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "ParallelConcat",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "the final shape of the result; should be equal to the shapes of any input\nbut with the number of input values in the first dimension.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "The input tensors are all required to have size 1 in the first dimension.\n\nFor example:\n\n```\n# 'x' is [[1, 4]]\n# 'y' is [[2, 5]]\n# 'z' is [[3, 6]]\nparallel_concat([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\n```\n\nThe difference between concat and parallel_concat is that concat requires all\nof the inputs be computed before the operation will begin but doesn't require\nthat the input shapes be known during graph construction.  Parallel concat\nwill copy pieces of the input into the output as they become available, in\nsome situations this can provide a performance benefit.",
      "inputs": [
        {
          "description": "Tensors to be concatenated. All must have size 1 in the first dimension\nand same shape.",
          "name": "values",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The concatenated tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Concatenates a list of `N` tensors along the first dimension."
    }
  },
  {
    "name": "ParallelDynamicStitch",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Builds a merged tensor such that\n\n```python\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n```\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n```python\n    # Scalar indices:\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices:\n    merged[indices[m][i], ...] = data[m][i, ...]\n```\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues may be merged in parallel, so if an index appears in both `indices[m][i]`\nand `indices[n][j]`, the result may be invalid. This differs from the normal\nDynamicStitch operator that defines the behavior in that case.\n\nFor example:\n\n```python\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n```\n\nThis method can be used to merge partitions created by `dynamic_partition`\nas illustrated on the following example:\n\n```python\n    # Apply function (increments x_i) on elements for which a certain condition\n    # apply (x_i != -1 in this example).\n    x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n    condition_mask=tf.not_equal(x,tf.constant(-1.))\n    partitioned_data = tf.dynamic_partition(\n        x, tf.cast(condition_mask, tf.int32) , 2)\n    partitioned_data[1] = partitioned_data[1] + 1.0\n    condition_indices = tf.dynamic_partition(\n        tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n    x = tf.dynamic_stitch(condition_indices, partitioned_data)\n    # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n    # unchanged.\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "indices",
          "numberAttr": "N",
          "type": 3
        },
        {
          "name": "data",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "merged",
          "typeAttr": "T"
        }
      ],
      "summary": "Interleave the values from the `data` tensors into a single tensor."
    }
  },
  {
    "name": "ParallelInterleaveDatasetV2",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": false,
          "name": "sloppy",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        },
        {
          "name": "cycle_length",
          "type": 9
        },
        {
          "name": "block_length",
          "type": 9
        },
        {
          "name": "num_parallel_calls",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "ParallelMapDataset",
    "schema": {
      "attributes": [
        {
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": true,
          "name": "use_inter_op_parallelism",
          "type": "bool"
        },
        {
          "default": false,
          "name": "sloppy",
          "type": "bool"
        },
        {
          "default": false,
          "name": "preserve_cardinality",
          "type": "bool"
        }
      ],
      "description": "Unlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `num_parallel_calls` copies of `f` in parallel.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        },
        {
          "description": "The number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
          "name": "num_parallel_calls",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "ParameterizedTruncatedNormal",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "scalar which applies to the entire output, or a vector of length shape[0] which\nstores the parameters for each batch.",
      "inputs": [
        {
          "description": "The shape of the output tensor. Batches are indexed by the 0th dimension.",
          "name": "shape",
          "typeAttr": "T"
        },
        {
          "description": "The mean parameter of each batch.",
          "name": "means",
          "typeAttr": "dtype"
        },
        {
          "description": "The standard deviation parameter of each batch. Must be greater than 0.",
          "name": "stdevs",
          "typeAttr": "dtype"
        },
        {
          "description": "The minimum cutoff. May be -infinity.",
          "name": "minvals",
          "typeAttr": "dtype"
        },
        {
          "description": "The maximum cutoff. May be +infinity, and must be more than the minval\nfor each batch.",
          "name": "maxvals",
          "typeAttr": "dtype"
        }
      ],
      "outputs": [
        {
          "description": "A matrix of shape num_batches x samples_per_batch, filled with random\ntruncated normal values using the parameters for each row.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs random values from a normal distribution. The parameters may each be a"
    }
  },
  {
    "name": "ParseExample",
    "schema": {
      "attributes": [
        {
          "minimum": 0,
          "name": "Nsparse",
          "type": "int"
        },
        {
          "minimum": 0,
          "name": "Ndense",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "description": "A list of Nsparse types; the data types of data in each Feature\ngiven in sparse_keys.\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "sparse_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "minimum": 0,
          "name": "Tdense",
          "type": "list(type)"
        },
        {
          "description": "A list of Ndense shapes; the shapes of data in each Feature\ngiven in dense_keys.\nThe number of elements in the Feature corresponding to dense_key[j]\nmust always equal dense_shapes[j].NumEntries().\nIf dense_shapes[j] == (D0, D1, ..., DN) then the shape of output\nTensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):\nThe dense outputs are just the inputs row-stacked by batch.\nThis works for dense_shapes[j] = (-1, D1, ..., DN).  In this case\nthe shape of the output Tensor dense_values[j] will be\n(|serialized|, M, D1, .., DN), where M is the maximum number of blocks\nof elements of length D1 * .... * DN, across all minibatch entries\nin the input.  Any minibatch entry with less than M blocks of elements of\nlength D1 * ... * DN will be padded with the corresponding default_value\nscalar element along the second dimension.",
          "minimum": 0,
          "name": "dense_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A vector containing a batch of binary serialized Example protos.",
          "name": "serialized",
          "type": 7
        },
        {
          "description": "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) names for the\ncorresponding serialized protos.  These are purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no names are available.\nIf non-empty, this vector must be the same length as \"serialized\".",
          "name": "names",
          "type": 7
        },
        {
          "description": "A list of Nsparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with sparse values.",
          "name": "sparse_keys",
          "numberAttr": "Nsparse",
          "type": 7
        },
        {
          "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples' features associated with dense values.",
          "name": "dense_keys",
          "numberAttr": "Ndense",
          "type": 7
        },
        {
          "description": "A list of Ndense Tensors (some may be empty).\ndense_defaults[j] provides default values\nwhen the example's feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it's empty.\nIf dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,\nthen the shape of dense_defaults[j] must match that of dense_shapes[j].\nIf dense_shapes[j] has an undefined major dimension (variable strides dense\nfeature), dense_defaults[j] must contain a single element:\nthe padding element.",
          "name": "dense_defaults",
          "typeListAttr": "Tdense"
        }
      ],
      "outputs": [
        {
          "name": "sparse_indices",
          "type": 9
        },
        {
          "name": "sparse_values",
          "typeListAttr": "sparse_types"
        },
        {
          "name": "sparse_shapes",
          "type": 9
        },
        {
          "name": "dense_values",
          "typeListAttr": "Tdense"
        }
      ],
      "summary": "Transforms a vector of brain.Example protos (as strings) into typed tensors."
    }
  },
  {
    "name": "ParseSequenceExample",
    "schema": {
      "attributes": [
        {
          "description": "A vector listing the\nFeatureList keys which may be missing from the SequenceExamples.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExamples.",
          "minimum": 0,
          "name": "feature_list_dense_missing_assumed_empty",
          "type": "list(string)"
        },
        {
          "description": "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with context_sparse\nvalues.",
          "minimum": 0,
          "name": "context_sparse_keys",
          "type": "list(string)"
        },
        {
          "description": "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' context features associated with\ndense values.",
          "minimum": 0,
          "name": "context_dense_keys",
          "type": "list(string)"
        },
        {
          "description": "A list of Nfeature_list_sparse string Tensors\n(scalars).  The keys expected in the FeatureLists associated with sparse\nvalues.",
          "minimum": 0,
          "name": "feature_list_sparse_keys",
          "type": "list(string)"
        },
        {
          "description": "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' feature_lists associated\nwith lists of dense values.",
          "minimum": 0,
          "name": "feature_list_dense_keys",
          "type": "list(string)"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Ncontext_sparse",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Ncontext_dense",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Nfeature_list_sparse",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Nfeature_list_dense",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "description": "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "context_sparse_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "minimum": 0,
          "name": "Tcontext_dense",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "minimum": 0,
          "name": "feature_list_dense_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j].",
          "minimum": 0,
          "name": "context_dense_shapes",
          "type": "list(shape)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "description": "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "feature_list_sparse_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries().",
          "minimum": 0,
          "name": "feature_list_dense_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A vector containing binary serialized SequenceExample protos.",
          "name": "serialized",
          "type": 7
        },
        {
          "description": "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no name is available.",
          "name": "debug_name",
          "type": 7
        },
        {
          "description": "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample's context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it's\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j].",
          "name": "context_dense_defaults",
          "typeListAttr": "Tcontext_dense"
        }
      ],
      "outputs": [
        {
          "name": "context_sparse_indices",
          "type": 9
        },
        {
          "name": "context_sparse_values",
          "typeListAttr": "context_sparse_types"
        },
        {
          "name": "context_sparse_shapes",
          "type": 9
        },
        {
          "name": "context_dense_values",
          "typeListAttr": "Tcontext_dense"
        },
        {
          "name": "feature_list_sparse_indices",
          "type": 9
        },
        {
          "name": "feature_list_sparse_values",
          "typeListAttr": "feature_list_sparse_types"
        },
        {
          "name": "feature_list_sparse_shapes",
          "type": 9
        },
        {
          "name": "feature_list_dense_values",
          "typeListAttr": "feature_list_dense_types"
        },
        {
          "name": "feature_list_dense_lengths",
          "type": 9
        }
      ],
      "summary": "Transforms a vector of brain.SequenceExample protos (as strings) into typed tensors."
    }
  },
  {
    "name": "ParseSingleExample",
    "schema": {
      "attributes": [
        {
          "description": "The number of sparse features to be parsed from the example. This\nmust match the lengths of `sparse_keys` and `sparse_types`.",
          "minimum": 0,
          "name": "num_sparse",
          "type": "int"
        },
        {
          "description": "A list of `num_sparse` strings.\nThe keys expected in the Examples' features associated with sparse values.",
          "minimum": 0,
          "name": "sparse_keys",
          "type": "list(string)"
        },
        {
          "description": "The keys expected in the Examples' features associated with dense\nvalues.",
          "minimum": 0,
          "name": "dense_keys",
          "type": "list(string)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "description": "A list of `num_sparse` types; the data types of data in each\nFeature given in sparse_keys.\nCurrently the ParseSingleExample op supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "sparse_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "description": "The data types of data in each Feature given in dense_keys.\nThe length of this list must match the length of `dense_keys`.\nCurrently the ParseSingleExample op supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "Tdense",
          "type": "list(type)"
        },
        {
          "description": "The shapes of data in each Feature given in dense_keys.\nThe length of this list must match the length of `dense_keys`.  The\nnumber of elements in the Feature corresponding to dense_key[j] must\nalways equal dense_shapes[j].NumEntries().  If dense_shapes[j] ==\n(D0, D1, ..., DN) then the shape of output Tensor dense_values[j]\nwill be (D0, D1, ..., DN): In the case dense_shapes[j] = (-1, D1,\n..., DN), the shape of the output Tensor dense_values[j] will be (M,\nD1, .., DN), where M is the number of blocks of elements of length\nD1 * .... * DN, in the input.",
          "minimum": 0,
          "name": "dense_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A vector containing a batch of binary serialized Example protos.",
          "name": "serialized",
          "type": 7
        },
        {
          "description": "A list of Tensors (some may be empty), whose length matches\nthe length of `dense_keys`. dense_defaults[j] provides default values\nwhen the example's feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it's empty.\nIf dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,\nthen the shape of dense_defaults[j] must match that of dense_shapes[j].\nIf dense_shapes[j] has an undefined major dimension (variable strides dense\nfeature), dense_defaults[j] must contain a single element:\nthe padding element.",
          "name": "dense_defaults",
          "typeListAttr": "Tdense"
        }
      ],
      "outputs": [
        {
          "name": "sparse_indices",
          "type": 9
        },
        {
          "name": "sparse_values",
          "typeListAttr": "sparse_types"
        },
        {
          "name": "sparse_shapes",
          "type": 9
        },
        {
          "name": "dense_values",
          "typeListAttr": "Tdense"
        }
      ],
      "summary": "Transforms a tf.Example proto (as a string) into typed tensors."
    }
  },
  {
    "name": "ParseSingleSequenceExample",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "Ncontext_sparse",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Ncontext_dense",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Nfeature_list_sparse",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "Nfeature_list_dense",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "description": "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "context_sparse_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "minimum": 0,
          "name": "Tcontext_dense",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "minimum": 0,
          "name": "feature_list_dense_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j].",
          "minimum": 0,
          "name": "context_dense_shapes",
          "type": "list(shape)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "default": [],
          "description": "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "minimum": 0,
          "name": "feature_list_sparse_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries().",
          "minimum": 0,
          "name": "feature_list_dense_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A scalar containing a binary serialized SequenceExample proto.",
          "name": "serialized",
          "type": 7
        },
        {
          "description": "A vector listing the\nFeatureList keys which may be missing from the SequenceExample.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExample.",
          "name": "feature_list_dense_missing_assumed_empty",
          "type": 7
        },
        {
          "description": "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with context_sparse\nvalues.",
          "name": "context_sparse_keys",
          "numberAttr": "Ncontext_sparse",
          "type": 7
        },
        {
          "description": "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' context features associated with\ndense values.",
          "name": "context_dense_keys",
          "numberAttr": "Ncontext_dense",
          "type": 7
        },
        {
          "description": "A list of Nfeature_list_sparse string Tensors\n(scalars).  The keys expected in the FeatureLists associated with sparse\nvalues.",
          "name": "feature_list_sparse_keys",
          "numberAttr": "Nfeature_list_sparse",
          "type": 7
        },
        {
          "description": "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' feature_lists associated\nwith lists of dense values.",
          "name": "feature_list_dense_keys",
          "numberAttr": "Nfeature_list_dense",
          "type": 7
        },
        {
          "description": "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample's context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it's\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j].",
          "name": "context_dense_defaults",
          "typeListAttr": "Tcontext_dense"
        },
        {
          "description": "A scalar containing the name of the serialized proto.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty scalar if no name is available.",
          "name": "debug_name",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "context_sparse_indices",
          "type": 9
        },
        {
          "name": "context_sparse_values",
          "typeListAttr": "context_sparse_types"
        },
        {
          "name": "context_sparse_shapes",
          "type": 9
        },
        {
          "name": "context_dense_values",
          "typeListAttr": "Tcontext_dense"
        },
        {
          "name": "feature_list_sparse_indices",
          "type": 9
        },
        {
          "name": "feature_list_sparse_values",
          "typeListAttr": "feature_list_sparse_types"
        },
        {
          "name": "feature_list_sparse_shapes",
          "type": 9
        },
        {
          "name": "feature_list_dense_values",
          "typeListAttr": "feature_list_dense_types"
        }
      ],
      "summary": "Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors."
    }
  },
  {
    "name": "ParseTensor",
    "schema": {
      "attributes": [
        {
          "description": "The type of the serialized tensor.  The provided type must match the\ntype of the serialized tensor and no implicit conversion will take place.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A scalar string containing a serialized TensorProto proto.",
          "name": "serialized",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of type `out_type`.",
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Transforms a serialized tensorflow.TensorProto proto into a Tensor."
    }
  },
  {
    "name": "PartitionedCall",
    "schema": {
      "attributes": [
        {
          "description": "A list of input types.",
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "A list of output types.",
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "      A function that takes 'args', a list of tensors, and returns 'output',\n      another list of tensors. Input and output types are specified by 'Tin'\n      and 'Tout'. The function body of f will be placed and partitioned across\n      devices, setting this op apart from the regular Call op.",
          "name": "f",
          "type": "func"
        },
        {
          "default": "",
          "name": "config",
          "type": "string"
        },
        {
          "default": "",
          "name": "config_proto",
          "type": "string"
        },
        {
          "default": "",
          "name": "executor_type",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "A list of input tensors.",
          "name": "args",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "A list of return values.",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "returns `f(inputs)`, where `f`'s body is placed and partitioned."
    }
  },
  {
    "name": "Placeholder",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "description": "(Optional) The shape of the tensor. If the shape has 0 dimensions, the\nshape is unconstrained.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime.",
      "outputs": [
        {
          "description": "A placeholder tensor that must be replaced using the feed mechanism.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "A placeholder op for a value that will be fed into the computation."
    }
  },
  {
    "name": "PlaceholderV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The shape of the tensor. The shape can be any partially-specified\nshape.  To be unconstrained, pass in a shape with unknown rank.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime.",
      "outputs": [
        {
          "description": "A placeholder tensor that must be replaced using the feed mechanism.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "A placeholder op for a value that will be fed into the computation."
    }
  },
  {
    "name": "PlaceholderWithDefault",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The (possibly partial) shape of the tensor.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "The default value to produce when `output` is not fed.",
          "name": "input",
          "typeAttr": "dtype"
        }
      ],
      "outputs": [
        {
          "description": "A placeholder tensor that defaults to `input` if it is not fed.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "A placeholder op that passes through `input` when its output is not fed."
    }
  },
  {
    "name": "Polygamma",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The polygamma function is defined as:\n\n\n\\\\(\\psi^{(n)}(x) = \\frac{d^n}{dx^n} \\psi(x)\\\\)\n\nwhere \\\\(\\psi(x)\\\\) is the digamma function.",
      "inputs": [
        {
          "name": "a",
          "typeAttr": "T"
        },
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the polygamma function \\\\(\\psi^{(n)}(x)\\\\)."
    }
  },
  {
    "name": "PopulationCount",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each entry in `x`, calculates the number of `1` (on) bits in the binary\nrepresentation of that entry.\n\n**NOTE**: It is more efficient to first `tf.bitcast` your tensors into\n`int32` or `int64` and perform the bitcount on the result, than to feed in\n8- or 16-bit inputs and then aggregate the resulting counts.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "type": 4
        }
      ],
      "summary": "Computes element-wise population count (a.k.a. popcount, bitsum, bitcount)."
    }
  },
  {
    "name": "Pow",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `x` and a tensor `y`, this operation computes \\\\(x^y\\\\) for\ncorresponding elements in `x` and `y`. For example:\n\n```\n# tensor 'x' is [[2, 2]], [3, 3]]\n# tensor 'y' is [[8, 16], [2, 3]]\ntf.pow(x, y) ==> [[256, 65536], [9, 27]]\n```",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the power of one value to another."
    }
  },
  {
    "name": "PrefetchDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "The maximum number of elements to buffer in an iterator over\nthis dataset.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that asynchronously prefetches elements from `input_dataset`."
    }
  },
  {
    "name": "PreventGradient",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "description": "Will be printed in the error when anyone tries to differentiate\nthis operation.",
          "name": "message",
          "type": "string"
        }
      ],
      "description": "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, the TensorFlow gradient system\nwill return an error when trying to lookup the gradient of this op,\nbecause no gradient must ever be registered for this function.  This\nop exists to prevent subtle bugs from silently returning unimplemented\ngradients in some corner cases.",
      "inputs": [
        {
          "description": "any tensor.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "the same input tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "An identity op that triggers an error if a gradient is requested."
    }
  },
  {
    "name": "Print",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 0,
          "name": "U",
          "type": "list(type)"
        },
        {
          "default": "",
          "description": "A string, prefix of the error message.",
          "name": "message",
          "type": "string"
        },
        {
          "default": -1,
          "description": "Only log `first_n` number of times. -1 disables logging.",
          "name": "first_n",
          "type": "int"
        },
        {
          "default": 3,
          "description": "Only print this many entries of each tensor.",
          "name": "summarize",
          "type": "int"
        }
      ],
      "description": "Passes `input` through to `output` and prints `data` when evaluating.",
      "inputs": [
        {
          "description": "The tensor passed to `output`",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A list of tensors to print out when op is evaluated.",
          "name": "data",
          "typeListAttr": "U"
        }
      ],
      "outputs": [
        {
          "description": "= The unmodified `input` tensor",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Prints a list of tensors."
    }
  },
  {
    "name": "PrintV2",
    "schema": {
      "attributes": [
        {
          "default": "stderr",
          "description": "A string specifying the output stream or logging level to print to.",
          "name": "output_stream",
          "type": "string"
        }
      ],
      "description": "Prints a string scalar to the desired output_stream.",
      "inputs": [
        {
          "description": "The string scalar to print.",
          "name": "input",
          "type": 7
        }
      ],
      "summary": "Prints a string scalar."
    }
  },
  {
    "name": "PriorityQueue",
    "schema": {
      "attributes": [
        {
          "default": [],
          "description": "The type of each component in a value.",
          "minimum": 0,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Note that the PriorityQueue requires the first component of any element\nto be a scalar int64, in addition to the other elements declared by\ncomponent_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue\nand DequeueMany) on a PriorityQueue will all require (resp. output) one extra\nentry in their input (resp. output) lists.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that produces elements sorted by the first component value."
    }
  },
  {
    "name": "PriorityQueueV2",
    "schema": {
      "attributes": [
        {
          "default": [],
          "description": "The type of each component in a value.",
          "minimum": 0,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Note that the PriorityQueue requires the first component of any element\nto be a scalar int64, in addition to the other elements declared by\ncomponent_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue\nand DequeueMany) on a PriorityQueue will all require (resp. output) one extra\nentry in their input (resp. output) lists.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that produces elements sorted by the first component value."
    }
  },
  {
    "name": "Prod",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the product of elements across dimensions of a tensor."
    }
  },
  {
    "name": "PyFunc",
    "schema": {
      "attributes": [
        {
          "description": "A token representing a registered python function in this address space.",
          "name": "token",
          "type": "string"
        },
        {
          "description": "Data types of the inputs to the op.",
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "Data types of the outputs from the op.\nThe length of the list specifies the number of outputs.",
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        }
      ],
      "description": "This operation is considered stateful. For a stateless version, see\nPyFuncStateless.",
      "inputs": [
        {
          "description": "List of Tensors that will provide input to the Op.",
          "name": "input",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "The outputs from the Op.",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "Invokes a python function to compute func(input)->output."
    }
  },
  {
    "name": "PyFuncStateless",
    "schema": {
      "attributes": [
        {
          "name": "token",
          "type": "string"
        },
        {
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "A stateless version of PyFunc."
    }
  },
  {
    "name": "Qr",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, compute full-sized `q` and `r`. If false\n(the default), compute only the leading `P` columns of `q`.",
          "name": "full_matrices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes the QR decomposition of each inner matrix in `tensor` such that\n`tensor[..., :, :] = q[..., :, :] * r[..., :,:])`\n\n```python\n# a is a tensor.\n# q is a tensor of orthonormal matrices.\n# r is a tensor of upper triangular matrices.\nq, r = qr(a)\nq_full, r_full = qr(a, full_matrices=True)\n```",
      "inputs": [
        {
          "description": "A tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Orthonormal basis for range of `a`. If `full_matrices` is `False` then\nshape is `[..., M, P]`; if `full_matrices` is `True` then shape is\n`[..., M, M]`.",
          "name": "q",
          "typeAttr": "T"
        },
        {
          "description": "Triangular factor. If `full_matrices` is `False` then shape is\n`[..., P, N]`. If `full_matrices` is `True` then shape is `[..., M, N]`.",
          "name": "r",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the QR decompositions of one or more matrices."
    }
  },
  {
    "name": "QuantizeAndDequantize",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "signed_input",
          "type": "bool"
        },
        {
          "default": 8,
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "name": "range_given",
          "type": "bool"
        },
        {
          "default": 0.0,
          "name": "input_min",
          "type": "float"
        },
        {
          "default": 0.0,
          "name": "input_max",
          "type": "float"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Use QuantizeAndDequantizeV2 instead."
    }
  },
  {
    "name": "QuantizeAndDequantizeV2",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "Whether the quantization is signed or unsigned. (actually this parameter should\nhave been called <b>`signed_output`</b>)",
          "name": "signed_input",
          "type": "bool"
        },
        {
          "default": 8,
          "description": "The bitwidth of the quantization.",
          "name": "num_bits",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether the range is given or should be determined from the `input` tensor.",
          "name": "range_given",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "HALF_TO_EVEN",
            "HALF_UP"
          ],
          "default": "HALF_TO_EVEN",
          "description": "The 'round_mode' attribute controls which rounding tie-breaking algorithm is\nused when rounding float values to their quantized equivalents. The following\nrounding modes are currently supported:\n\n*   HALF_TO_EVEN: this is the default round_mode.\n*   HALF_UP: round towards positive. In this mode 7.5 rounds up to 8 and -7.5\n    rounds up to -7.\n",
          "name": "round_mode",
          "type": "string"
        }
      ],
      "description": "This op simulates the precision loss from the quantized forward pass by:\n\n1. Quantizing the tensor to fixed point numbers, which should match the target\n   quantization method when it is used in inference.\n2. Dequantizing it back to floating point numbers for the following ops, most\n   likely matmul.\n\nThere are different ways to quantize. This version uses only scaling, so 0.0\nmaps to 0.\n\nFrom the specified 'num_bits' in the quantized output type, it determines\nminimum and maximum representable quantized values.\n\ne.g.\n\n*   [-128, 127] for signed, num_bits = 8, or\n*   [0, 255] for unsigned, num_bits = 8.\n\nIf range_given == False, the initial input_min, input_max will be determined\nautomatically as the minimum and maximum values in the input tensor, otherwise\nthe specified values of input_min, input_max are used.\n\nNote: If the input_min, input_max are specified, they do not need to equal the\nactual minimum and maximum values in the tensor. e.g. in some cases it may be\nbeneficial to specify these values such that the low probability extremes of the\ninput distribution are clipped.\n\nThis op determines the maximum scale_factor that would map the initial\n[input_min, input_max] range to a range that lies within the representable\nquantized range.\n\nIt determines the scale from one of input_min and input_max, then updates the\nother one to maximize the respresentable range.\n\ne.g.\n\n*   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,\n    5.0]: it would use a scale_factor of -128 / -10.0 = 12.8 In this case, it\n    would update input_max to be 127 / 12.8 = 9.921875\n*   if the output is signed, num_bits = 8, [input_min, input_max] = [-10.0,\n    10.0]: it would use a scale_factor of 127 / 10.0 = 12.7 In this case, it\n    would update input_min to be 128.0 / 12.7 = -10.07874\n*   if the output is unsigned, input_min is forced to be 0, and only the\n    specified input_max is used.\n\nAfter determining the scale_factor and updating the input range, it applies the\nfollowing to each value in the 'input' tensor.\n\noutput = round(clamp(value, input_min, input_max) * scale_factor) / scale_factor.\n\nThe above round function rounds the value based on the given round_mode.\n",
      "inputs": [
        {
          "description": "Tensor to quantize and then dequantize.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "If `range_given == True`, this specifies the minimum input value that needs to\nbe represented, otherwise it is determined from the min value of the `input`\ntensor.",
          "name": "input_min",
          "typeAttr": "T"
        },
        {
          "description": "If `range_given == True`, this specifies the maximum input value that needs to\nbe represented, otherwise it is determined from the max value of the `input`\ntensor.",
          "name": "input_max",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Quantizes then dequantizes a tensor."
    }
  },
  {
    "name": "QuantizeAndDequantizeV3",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "signed_input",
          "type": "bool"
        },
        {
          "default": true,
          "name": "range_given",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a\ntensor, so its value can change during training.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "input_min",
          "typeAttr": "T"
        },
        {
          "name": "input_max",
          "typeAttr": "T"
        },
        {
          "name": "num_bits",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Quantizes then dequantizes a tensor."
    }
  },
  {
    "name": "QuantizeDownAndShrinkRange",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "description": "The type of the input.",
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "description": "The type of the output. Should be a lower bit depth than Tinput.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "actual distribution of the values to maximize the usage of the lower bit depth\nand adjusting the output min and max ranges accordingly.\n\n[input_min, input_max] are scalar floats that specify the range for the float\ninterpretation of the 'input' data. For example, if input_min is -1.0f and\ninput_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\nvalue in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.\n\nThis operator tries to squeeze as much precision as possible into an output with\na lower bit depth by calculating the actual min and max values found in the\ndata. For example, maybe that quint16 input has no values lower than 16,384 and\nnone higher than 49,152. That means only half the range is actually needed, all\nthe float interpretations are between -0.5f and 0.5f, so if we want to compress\nthe data into a quint8 output, we can use that range rather than the theoretical\n-1.0f to 1.0f that is suggested by the input min and max.\n\nIn practice, this is most useful for taking output from operations like\nQuantizedMatMul that can produce higher bit-depth outputs than their inputs and\nmay have large potential output ranges, but in practice have a distribution of\ninput values that only uses a small fraction of the possible range. By feeding\nthat output into this operator, we can reduce it from 32 bits down to 8 with\nminimal loss of accuracy.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "Tinput"
        },
        {
          "description": "The float value that the minimum quantized input value represents.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized input value represents.",
          "name": "input_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        },
        {
          "description": "The float value that the minimum quantized output value represents.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized output value represents.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Convert the quantized 'input' tensor into a lower-precision 'output', using the"
    }
  },
  {
    "name": "QuantizeV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "MIN_COMBINED",
            "MIN_FIRST",
            "SCALED"
          ],
          "default": "MIN_COMBINED",
          "name": "mode",
          "type": "string"
        },
        {
          "allowedValues": [
            "HALF_AWAY_FROM_ZERO",
            "HALF_TO_EVEN"
          ],
          "default": "HALF_AWAY_FROM_ZERO",
          "name": "round_mode",
          "type": "string"
        }
      ],
      "description": "[min_range, max_range] are scalar floats that specify the range for\nthe 'input' data. The 'mode' attribute controls exactly which calculations are\nused to convert the float values to their quantized equivalents.  The\n'round_mode' attribute controls which rounding tie-breaking algorithm is used\nwhen rounding float values to their quantized equivalents.\n\nIn 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n\n```\nout[i] = (in[i] - min_range) * range(T) / (max_range - min_range)\nif T == qint8: out[i] -= (range(T) + 1) / 2.0\n```\n\nhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`\n\n*MIN_COMBINED Mode Example*\n\nAssume the input is type float and has a possible range of [0.0, 6.0] and the\noutput type is quint8 ([0, 255]). The min_range and max_range values should be\nspecified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each\nvalue of the input by 255/6 and cast to quint8.\n\nIf the output type was qint8 ([-128, 127]), the operation will additionally\nsubtract each value by 128 prior to casting, so that the range of values aligns\nwith the range of qint8.\n\nIf the mode is 'MIN_FIRST', then this approach is used:\n\n```\nnum_discrete_values = 1 << (# of bits in T)\nrange_adjust = num_discrete_values / (num_discrete_values - 1)\nrange = (range_max - range_min) * range_adjust\nrange_scale = num_discrete_values / range\nquantized = round(input * range_scale) - round(range_min * range_scale) +\n  numeric_limits<T>::min()\nquantized = max(quantized, numeric_limits<T>::min())\nquantized = min(quantized, numeric_limits<T>::max())\n```\n\nThe biggest difference between this and MIN_COMBINED is that the minimum range\nis rounded first, before it's subtracted from the rounded value. With\nMIN_COMBINED, a small bias is introduced where repeated iterations of quantizing\nand dequantizing will introduce a larger and larger error.\n\n*SCALED mode Example*\n\n`SCALED` mode matches the quantization approach used in\n`QuantizeAndDequantize{V2|V3}`.\n\nIf the mode is `SCALED`, we do not use the full range of the output type,\nchoosing to elide the lowest possible value for symmetry (e.g., output range is\n-127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to\n0.\n\nWe first find the range of values in our tensor. The\nrange we use is always centered on 0, so we find m such that\n\n```c++\n  m = max(abs(input_min), abs(input_max))\n```\n\nOur input tensor range is then `[-m, m]`.\n\nNext, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.\nIf T is signed, this is\n\n```\n  num_bits = sizeof(T) * 8\n  [min_fixed, max_fixed] =\n      [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1]\n```\n\nOtherwise, if T is unsigned, the fixed-point range is\n\n```\n  [min_fixed, max_fixed] = [0, (1 << num_bits) - 1]\n```\n\nFrom this we compute our scaling factor, s:\n\n```c++\n  s = (max_fixed - min_fixed) / (2 * m)\n```\n\nNow we can quantize the elements of our tensor:\n\n```c++\nresult = round(input * s)\n```\n\nOne thing to watch out for is that the operator may choose to adjust the\nrequested minimum and maximum values slightly during the quantization process,\nso you should always use the output ports as the range for further calculations.\nFor example, if the requested minimum and maximum values are close to equal,\nthey will be separated by a small epsilon value to prevent ill-formed quantized\nbuffers from being created. Otherwise, you can end up with buffers where all the\nquantized values map to the same float value, which causes problems for\noperations that have to perform further calculations on them.",
      "inputs": [
        {
          "name": "input",
          "type": 1
        },
        {
          "description": "The minimum scalar value possibly produced for the input.",
          "name": "min_range",
          "type": 1
        },
        {
          "description": "The maximum scalar value possibly produced for the input.",
          "name": "max_range",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The quantized data produced from the float input.",
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "The actual minimum scalar value used for the output.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The actual maximum scalar value used for the output.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Quantize the 'input' tensor of type float to 'output' tensor of type 'T'."
    }
  },
  {
    "name": "QuantizedAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T1",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T2",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 13
          },
          "name": "Toutput",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T1"
        },
        {
          "name": "y",
          "typeAttr": "T2"
        },
        {
          "description": "The float value that the lowest quantized `x` value represents.",
          "name": "min_x",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `x` value represents.",
          "name": "max_x",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized `y` value represents.",
          "name": "min_y",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `y` value represents.",
          "name": "max_y",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "Toutput"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_z",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.\n\n*NOTE*: `QuantizedAdd` supports limited forms of broadcasting. More about\nbroadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
          "name": "max_z",
          "type": 1
        }
      ],
      "summary": "Returns x + y element-wise, working on quantized buffers."
    }
  },
  {
    "name": "QuantizedAvgPool",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor.  The length must be 4 to match the number of dimensions of the input.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_output",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_output",
          "type": 1
        }
      ],
      "summary": "Produces the average pool of the input tensor for quantized types."
    }
  },
  {
    "name": "QuantizedBatchNormWithGlobalNormalization",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "out_type",
          "type": "type"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma.",
          "name": "scale_after_normalization",
          "type": "bool"
        }
      ],
      "description": "This op is deprecated and will be removed in the future. Prefer\n`tf.nn.batch_normalization`.",
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "t",
          "typeAttr": "Tinput"
        },
        {
          "description": "The value represented by the lowest quantized input.",
          "name": "t_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized input.",
          "name": "t_max",
          "type": 1
        },
        {
          "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "m",
          "typeAttr": "Tinput"
        },
        {
          "description": "The value represented by the lowest quantized mean.",
          "name": "m_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized mean.",
          "name": "m_max",
          "type": 1
        },
        {
          "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "v",
          "typeAttr": "Tinput"
        },
        {
          "description": "The value represented by the lowest quantized variance.",
          "name": "v_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized variance.",
          "name": "v_max",
          "type": 1
        },
        {
          "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor.",
          "name": "beta",
          "typeAttr": "Tinput"
        },
        {
          "description": "The value represented by the lowest quantized offset.",
          "name": "beta_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized offset.",
          "name": "beta_max",
          "type": 1
        },
        {
          "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor.",
          "name": "gamma",
          "typeAttr": "Tinput"
        },
        {
          "description": "The value represented by the lowest quantized gamma.",
          "name": "gamma_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized gamma.",
          "name": "gamma_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "result",
          "typeAttr": "out_type"
        },
        {
          "name": "result_min",
          "type": 1
        },
        {
          "name": "result_max",
          "type": 1
        }
      ],
      "summary": "Quantized Batch normalization."
    }
  },
  {
    "name": "QuantizedBiasAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T1",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T2",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "Broadcasts the values of bias on dimensions 0..N-2 of 'input'.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T1"
        },
        {
          "description": "A 1D bias Tensor with size matching the last dimension of 'input'.",
          "name": "bias",
          "typeAttr": "T2"
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized bias value represents.",
          "name": "min_bias",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized bias value represents.",
          "name": "max_bias",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_out",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_out",
          "type": 1
        }
      ],
      "summary": "Adds Tensor 'bias' to Tensor 'input' for Quantized types."
    }
  },
  {
    "name": "QuantizedConcat",
    "schema": {
      "attributes": [
        {
          "minimum": 2,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values)).",
          "name": "concat_dim",
          "type": 3
        },
        {
          "description": "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
          "name": "values",
          "numberAttr": "N",
          "typeAttr": "T"
        },
        {
          "description": "The minimum scalar values for each of the input tensors.",
          "name": "input_mins",
          "numberAttr": "N",
          "type": 1
        },
        {
          "description": "The maximum scalar values for each of the input tensors.",
          "name": "input_maxes",
          "numberAttr": "N",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "The float value that the minimum quantized output value represents.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized output value represents.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Concatenates quantized tensors along one dimension."
    }
  },
  {
    "name": "QuantizedConv2D",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "Tfilter",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 13
          },
          "name": "out_type",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "default": [
            1,
            1,
            1,
            1
          ],
          "description": "1-D tensor of length 4.  The dilation factor for each dimension of\n`input`. If set to k > 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of `data_format`, see above for details. Dilations in the batch and\ndepth dimensions must be 1.",
          "name": "dilations",
          "type": "list(int)"
        }
      ],
      "description": "The inputs are quantized tensors where the lowest value represents the real\nnumber of the associated minimum, and the highest represents the maximum.\nThis means that you can only interpret the quantized output in the same way, by\ntaking the returned minimum and maximum values into account.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "Tinput"
        },
        {
          "description": "filter's input_depth dimension must match input's depth dimensions.",
          "name": "filter",
          "typeAttr": "Tfilter"
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized filter value represents.",
          "name": "min_filter",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized filter value represents.",
          "name": "max_filter",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_output",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_output",
          "type": 1
        }
      ],
      "summary": "Computes a 2D convolution given quantized 4D input and filter tensors."
    }
  },
  {
    "name": "QuantizedInstanceNorm",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, `given_y_min` and `given_y_min`\nand `given_y_max` are used as the output range. Otherwise,\nthe implementation computes the output range.",
          "name": "output_range_given",
          "type": "bool"
        },
        {
          "default": 0.0,
          "description": "Output in `y_min` if `output_range_given` is True.",
          "name": "given_y_min",
          "type": "float"
        },
        {
          "default": 0.0,
          "description": "Output in `y_max` if `output_range_given` is True.",
          "name": "given_y_max",
          "type": "float"
        },
        {
          "default": 9.999999747378752e-06,
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "default": 0.0010000000474974513,
          "description": "Minimum value of `y_max - y_min`",
          "name": "min_separation",
          "type": "float"
        }
      ],
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "The value represented by the lowest quantized input.",
          "name": "x_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized input.",
          "name": "x_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "The value represented by the lowest quantized output.",
          "name": "y_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized output.",
          "name": "y_max",
          "type": 1
        }
      ],
      "summary": "Quantized Instance normalization."
    }
  },
  {
    "name": "QuantizedMatMul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T1",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T2",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 13
          },
          "name": "Toutput",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, `a` is transposed before multiplication.",
          "name": "transpose_a",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If true, `b` is transposed before multiplication.",
          "name": "transpose_b",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 12
          },
          "description": "The type of output produced by activation function\nfollowing this operation.",
          "name": "Tactivation",
          "type": "type"
        }
      ],
      "description": "The inputs must be two-dimensional matrices and the inner dimension of\n`a` (after being transposed if `transpose_a` is non-zero) must match the\nouter dimension of `b` (after being transposed if `transposed_b` is\nnon-zero).",
      "inputs": [
        {
          "description": "Must be a two-dimensional tensor.",
          "name": "a",
          "typeAttr": "T1"
        },
        {
          "description": "Must be a two-dimensional tensor.",
          "name": "b",
          "typeAttr": "T2"
        },
        {
          "description": "The float value that the lowest quantized `a` value represents.",
          "name": "min_a",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `a` value represents.",
          "name": "max_a",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized `b` value represents.",
          "name": "min_b",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `b` value represents.",
          "name": "max_b",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "out",
          "typeAttr": "Toutput"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_out",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_out",
          "type": 1
        }
      ],
      "summary": "Perform a quantized matrix multiplication of  `a` by the matrix `b`."
    }
  },
  {
    "name": "QuantizedMaxPool",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor. The length must be 4 to match the number of dimensions of the input.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "allowedValues": [
            "SAME",
            "VALID"
          ],
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_output",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_output",
          "type": 1
        }
      ],
      "summary": "Produces the max pool of the input tensor for quantized types."
    }
  },
  {
    "name": "QuantizedMul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T1",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "T2",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 13
          },
          "name": "Toutput",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T1"
        },
        {
          "name": "y",
          "typeAttr": "T2"
        },
        {
          "description": "The float value that the lowest quantized `x` value represents.",
          "name": "min_x",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `x` value represents.",
          "name": "max_x",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized `y` value represents.",
          "name": "min_y",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `y` value represents.",
          "name": "max_y",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "Toutput"
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_z",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.\n\n*NOTE*: `QuantizedMul` supports limited forms of broadcasting. More about\nbroadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
          "name": "max_z",
          "type": 1
        }
      ],
      "summary": "Returns x * y element-wise, working on quantized buffers."
    }
  },
  {
    "name": "QuantizedRelu",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 12
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "features",
          "typeAttr": "Tinput"
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_features",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Has the same output shape as \"features\".",
          "name": "activations",
          "typeAttr": "out_type"
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_activations",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_activations",
          "type": 1
        }
      ],
      "summary": "Computes Quantized Rectified Linear: `max(features, 0)`"
    }
  },
  {
    "name": "QuantizedRelu6",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 12
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "features",
          "typeAttr": "Tinput"
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_features",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Has the same output shape as \"features\".",
          "name": "activations",
          "typeAttr": "out_type"
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_activations",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_activations",
          "type": 1
        }
      ],
      "summary": "Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`"
    }
  },
  {
    "name": "QuantizedReluX",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "default": {
            "type": "type",
            "value": 12
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "features",
          "typeAttr": "Tinput"
        },
        {
          "name": "max_value",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_features",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Has the same output shape as \"features\".",
          "name": "activations",
          "typeAttr": "out_type"
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_activations",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_activations",
          "type": 1
        }
      ],
      "summary": "Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`"
    }
  },
  {
    "name": "QuantizedReshape",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tshape",
          "type": "type"
        }
      ],
      "description": "```",
      "inputs": [
        {
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "Defines the shape of the output tensor.",
          "name": "shape",
          "typeAttr": "Tshape"
        },
        {
          "description": "The minimum value of the input.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The maximum value of the input.",
          "name": "input_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "This value is copied from input_min.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "This value is copied from input_max.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Reshapes a quantized tensor as per the Reshape op."
    }
  },
  {
    "name": "QuantizedResizeBilinear",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images and output images must be quantized types.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        },
        {
          "name": "min",
          "type": 1
        },
        {
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "typeAttr": "T"
        },
        {
          "name": "out_min",
          "type": 1
        },
        {
          "name": "out_max",
          "type": 1
        }
      ],
      "summary": "Resize quantized `images` to `size` using quantized bilinear interpolation."
    }
  },
  {
    "name": "QueueClose",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, all pending enqueue requests that are\nblocked on the given queue will be canceled.",
          "name": "cancel_pending_enqueues",
          "type": "bool"
        }
      ],
      "description": "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Closes the given queue."
    }
  },
  {
    "name": "QueueCloseV2",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, all pending enqueue requests that are\nblocked on the given queue will be canceled.",
          "name": "cancel_pending_enqueues",
          "type": "bool"
        }
      ],
      "description": "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Closes the given queue."
    }
  },
  {
    "name": "QueueDequeue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Dequeues a tuple of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueMany",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "If the queue is closed and there are fewer than `n` elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until `n` elements\nhave been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueManyV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "If the queue is closed and there are fewer than `n` elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until `n` elements\nhave been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueUpTo",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than `n`\nelements remaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, less than `n` elements are returned immediately.  If\nthe queue is closed and there are 0 elements left in the queue, then\nan OutOfRange error is returned just like in QueueDequeueMany.\nOtherwise the behavior is identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has k outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueUpToV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than `n`\nelements remaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, less than `n` elements are returned immediately.  If\nthe queue is closed and there are 0 elements left in the queue, then\nan OutOfRange error is returned just like in QueueDequeueMany.\nOtherwise the behavior is identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size n in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "typeListAttr": "component_types"
        }
      ],
      "summary": "Dequeues a tuple of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueEnqueue",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "One or more tensors from which the enqueued tensors should be taken.",
          "name": "components",
          "typeListAttr": "Tcomponents"
        }
      ],
      "summary": "Enqueues a tuple of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueEnqueueMany",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "One or more tensors from which the enqueued tensors should\nbe taken.",
          "name": "components",
          "typeListAttr": "Tcomponents"
        }
      ],
      "summary": "Enqueues zero or more tuples of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueEnqueueManyV2",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "One or more tensors from which the enqueued tensors should\nbe taken.",
          "name": "components",
          "typeListAttr": "Tcomponents"
        }
      ],
      "summary": "Enqueues zero or more tuples of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueEnqueueV2",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "default": -1,
          "description": "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "One or more tensors from which the enqueued tensors should be taken.",
          "name": "components",
          "typeListAttr": "Tcomponents"
        }
      ],
      "summary": "Enqueues a tuple of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueIsClosed",
    "schema": {
      "description": "This operation returns true if the queue is closed and false if the queue\nis open.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "is_closed",
          "type": 10
        }
      ],
      "summary": "Returns true if queue is closed."
    }
  },
  {
    "name": "QueueIsClosedV2",
    "schema": {
      "description": "This operation returns true if the queue is closed and false if the queue\nis open.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "is_closed",
          "type": 10
        }
      ],
      "summary": "Returns true if queue is closed."
    }
  },
  {
    "name": "QueueSize",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of elements in the given queue.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of elements in the given queue."
    }
  },
  {
    "name": "QueueSizeV2",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "The number of elements in the given queue.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of elements in the given queue."
    }
  },
  {
    "name": "RFFT",
    "schema": {
      "description": "Computes the 1-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most dimension of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the\n`fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,\nfollowed by the `fft_length / 2` positive-frequency terms.\n\nAlong the axis `RFFT` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A float32 tensor.",
          "name": "input",
          "type": 1
        },
        {
          "description": "An int32 tensor of shape [1]. The FFT length.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same rank as `input`. The inner-most\n  dimension of `input` is replaced with the `fft_length / 2 + 1` unique\n  frequency components of its 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfft\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "Real-valued fast Fourier transform."
    }
  },
  {
    "name": "RFFT2D",
    "schema": {
      "description": "Computes the 2-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most 2 dimensions of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the\n`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension\nof `output`: the zero-frequency term, followed by the `fft_length / 2`\npositive-frequency terms.\n\nAlong each axis `RFFT2D` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A float32 tensor.",
          "name": "input",
          "type": 1
        },
        {
          "description": "An int32 tensor of shape [2]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same rank as `input`. The inner-most 2\n  dimensions of `input` are replaced with their 2D Fourier transform. The\n  inner-most dimension contains `fft_length / 2 + 1` unique frequency\n  components.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfft2\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "2D real-valued fast Fourier transform."
    }
  },
  {
    "name": "RFFT3D",
    "schema": {
      "description": "Computes the 3-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most 3 dimensions of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the\n`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension\nof `output`: the zero-frequency term, followed by the `fft_length / 2`\npositive-frequency terms.\n\nAlong each axis `RFFT3D` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A float32 tensor.",
          "name": "input",
          "type": 1
        },
        {
          "description": "An int32 tensor of shape [3]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same rank as `input`. The inner-most 3\n  dimensions of `input` are replaced with the their 3D Fourier transform. The\n  inner-most dimension contains `fft_length / 2 + 1` unique frequency\n  components.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "3D real-valued fast Fourier transform."
    }
  },
  {
    "name": "RGBToHSV",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a tensor of the same shape as the `images` tensor, containing the HSV\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\n`output[..., 0]` contains hue, `output[..., 1]` contains saturation, and\n`output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0\ncorresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.",
      "inputs": [
        {
          "description": "1-D or higher rank. RGB data to convert. Last dimension must be size 3.",
          "name": "images",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "`images` converted to HSV.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Converts one or more images from RGB to HSV."
    }
  },
  {
    "name": "RaggedGather",
    "schema": {
      "attributes": [
        {
          "name": "Tvalues",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "The ragged rank of the `params` RaggedTensor. `params_nested_splits` should\ncontain this number of `row_splits` tensors. This value should equal\n`params.ragged_rank`.",
          "minimum": 1,
          "name": "PARAMS_RAGGED_RANK",
          "type": "int"
        },
        {
          "description": "The ragged rank of the output RaggedTensor. `output_nested_splits` will contain\nthis number of `row_splits` tensors. This value should equal\n`indices.shape.ndims + params.ragged_rank - 1`.",
          "minimum": 0,
          "name": "OUTPUT_RAGGED_RANK",
          "type": "int"
        }
      ],
      "description": "Outputs a `RaggedTensor` output composed from `output_dense_values` and\n`output_nested_splits`, such that:\n\n```python\noutput.shape = indices.shape + params.shape[1:]\noutput.ragged_rank = indices.shape.ndims + params.ragged_rank\noutput[i...j, d0...dn] = params[indices[i...j], d0...dn]\n```\n\nwhere\n\n* `params =\n   ragged.from_nested_row_splits(params_dense_values, params_nested_splits)`\n   provides the values that should be gathered.\n* `indices` ia a dense tensor with dtype `int32` or `int64`, indicating which\n   values should be gathered.\n* `output =\n   ragged.from_nested_row_splits(output_dense_values, output_nested_splits)`\n   is the output tensor.\n\n(Note: This c++ op is used to implement the higher-level python\n`tf.ragged.gather` op, which also supports ragged indices.)\n",
      "inputs": [
        {
          "description": "The `nested_row_splits` tensors that define the row-partitioning for the\n`params` RaggedTensor input.",
          "name": "params_nested_splits",
          "numberAttr": "PARAMS_RAGGED_RANK",
          "type": 9
        },
        {
          "description": "The `flat_values` for the `params` RaggedTensor. There was a terminology change\nat the python level from dense_values to flat_values, so dense_values is the\ndeprecated name.",
          "name": "params_dense_values",
          "typeAttr": "Tvalues"
        },
        {
          "description": "Indices in the outermost dimension of `params` of the values that should be\ngathered.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "The `nested_row_splits` tensors that define the row-partitioning for the\nreturned RaggedTensor.",
          "name": "output_nested_splits",
          "type": 9
        },
        {
          "description": "The `flat_values` for the returned RaggedTensor.",
          "name": "output_dense_values",
          "typeAttr": "Tvalues"
        }
      ],
      "summary": "Gather ragged slices from `params` axis `0` according to `indices`."
    }
  },
  {
    "name": "RaggedRange",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "\nReturns a `RaggedTensor` `result` composed from `rt_dense_values` and\n`rt_nested_splits`, such that\n`result[i] = range(starts[i], limits[i], deltas[i])`.\n\n```python\n>>> (rt_nested_splits, rt_dense_values) = gen_ragged_ops.ragged_range(\n...     starts=[2, 5, 8], limits=[3, 5, 12], deltas=1)\n>>> result = ragged.from_nested_row_splits(rt_dense_values, rt_nested_splits)\n>>> print result.eval().tolist()\n[[2],               # result[0] = range(2, 3)\n [],                # result[1] = range(5, 5)\n [8, 9, 10, 11]]    # result[2] = range(8, 12)\n```\n\nThe input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.\nThe vector inputs must all have the same size.  Scalar inputs are broadcast\nto match the size of the vector inputs.",
      "inputs": [
        {
          "description": "The starts of each range.",
          "name": "starts",
          "typeAttr": "T"
        },
        {
          "description": "The limits of each range.",
          "name": "limits",
          "typeAttr": "T"
        },
        {
          "description": "The deltas of each range.",
          "name": "deltas",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The `row_splits` for the returned `RaggedTensor`.",
          "name": "rt_nested_splits",
          "type": 9
        },
        {
          "description": "The `flat_values` for the returned `RaggedTensor`.",
          "name": "rt_dense_values",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a `RaggedTensor` containing the specified sequences of numbers."
    }
  },
  {
    "name": "RaggedTensorToSparse",
    "schema": {
      "attributes": [
        {
          "description": "The ragged rank of the input RaggedTensor.  `rt_nested_splits` should contain\nthis number of ragged-splits tensors.  This value should equal\n`input.ragged_rank`.",
          "minimum": 1,
          "name": "RAGGED_RANK",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "input=ragged.from_nested_row_splits(rt_dense_values, rt_nested_splits)\noutput=SparseTensor(indices=sparse_indices, values=sparse_values,\n                    dense_shape=sparse_dense_shape)",
      "inputs": [
        {
          "description": "The `row_splits` for the `RaggedTensor`.",
          "name": "rt_nested_splits",
          "numberAttr": "RAGGED_RANK",
          "type": 9
        },
        {
          "description": "The `flat_values` for the `RaggedTensor`.",
          "name": "rt_dense_values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The indices for the `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "The values of the `SparseTensor`.",
          "name": "sparse_values",
          "typeAttr": "T"
        },
        {
          "description": "`sparse_dense_shape` is a tight bounding box of the input `RaggedTensor`.",
          "name": "sparse_dense_shape",
          "type": 9
        }
      ],
      "summary": "Converts a `RaggedTensor` into a `SparseTensor` with the same values."
    }
  },
  {
    "name": "RandomCrop",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "`size` is a 1-D int64 tensor with 2 elements representing the crop height and\nwidth.  The values must be non negative.\n\nThis Op picks a random location in `image` and crops a `height` by `width`\nrectangle from that location.  The random location is picked so the cropped\narea will fit inside the original image.",
      "inputs": [
        {
          "description": "3-D of shape `[height, width, channels]`.",
          "name": "image",
          "typeAttr": "T"
        },
        {
          "description": "1-D of length 2 containing: `crop_height`, `crop_width`..",
          "name": "size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "3-D of shape `[crop_height, crop_width, channels].`",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Randomly crop `image`."
    }
  },
  {
    "name": "RandomGamma",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "S",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op uses the algorithm by Marsaglia et al. to acquire samples via\ntransformation-rejection from pairs of uniform and normal random variables.\nSee http://dl.acm.org/citation.cfm?id=358414",
      "inputs": [
        {
          "description": "1-D integer tensor. Shape of independent samples to draw from each\ndistribution described by the shape parameters given in alpha.",
          "name": "shape",
          "typeAttr": "S"
        },
        {
          "description": "A tensor in which each scalar is a \"shape\" parameter describing the\nassociated gamma distribution.",
          "name": "alpha",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor with shape `shape + shape(alpha)`. Each slice\n`[:, ..., :, i0, i1, ...iN]` contains the samples drawn for\n`alpha[i0, i1, ...iN]`. The dtype of the output matches the dtype of alpha.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Outputs random values from the Gamma distribution(s) described by alpha."
    }
  },
  {
    "name": "RandomGammaGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "name": "sample",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the derivative of a Gamma random sample w.r.t. `alpha`."
    }
  },
  {
    "name": "RandomPoisson",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "S",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "shape",
          "typeAttr": "S"
        },
        {
          "name": "rate",
          "typeAttr": "dtype"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Use RandomPoissonV2 instead."
    }
  },
  {
    "name": "RandomPoissonV2",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "S",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 2
          },
          "name": "R",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "This op uses two algorithms, depending on rate. If rate >= 10, then\nthe algorithm by Hormann is used to acquire samples via\ntransformation-rejection.\nSee http://www.sciencedirect.com/science/article/pii/0167668793909974.\n\nOtherwise, Knuth's algorithm is used to acquire samples via multiplying uniform\nrandom variables.\nSee Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer\nProgramming, Volume 2. Addison Wesley",
      "inputs": [
        {
          "description": "1-D integer tensor. Shape of independent samples to draw from each\ndistribution described by the shape parameters given in rate.",
          "name": "shape",
          "typeAttr": "S"
        },
        {
          "description": "A tensor in which each scalar is a \"rate\" parameter describing the\nassociated poisson distribution.",
          "name": "rate",
          "typeAttr": "R"
        }
      ],
      "outputs": [
        {
          "description": "A tensor with shape `shape + shape(rate)`. Each slice\n`[:, ..., :, i0, i1, ...iN]` contains the samples drawn for\n`rate[i0, i1, ...iN]`.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs random values from the Poisson distribution(s) described by rate."
    }
  },
  {
    "name": "RandomShuffle",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\n  to one and only one `output[i]`. For example, a mapping that might occur for a\n  3x2 tensor is:\n\n```\n[[1, 2],       [[5, 6],\n [3, 4],  ==>   [1, 2],\n [5, 6]]        [3, 4]]\n```",
      "inputs": [
        {
          "description": "The tensor to be shuffled.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of same shape and type as `value`, shuffled along its first\ndimension.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Randomly shuffles a tensor along its first dimension."
    }
  },
  {
    "name": "RandomShuffleQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "description": "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements.",
          "name": "min_after_dequeue",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that randomizes the order of elements."
    }
  },
  {
    "name": "RandomShuffleQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "minimum": 1,
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "default": [],
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "minimum": 0,
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "default": -1,
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "description": "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements.",
          "name": "min_after_dequeue",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that randomizes the order of elements."
    }
  },
  {
    "name": "RandomStandardNormal",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values will have mean 0 and standard deviation 1.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with random normal values.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs random values from a normal distribution."
    }
  },
  {
    "name": "RandomUniform",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with uniform random values.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs random values from a uniform distribution."
    }
  },
  {
    "name": "RandomUniformInt",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tout",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values are uniform integers in the range `[minval, maxval)`.\nThe lower bound `minval` is included in the range, while the upper bound\n`maxval` is excluded.\n\nThe random integers are slightly biased unless `maxval - minval` is an exact\npower of two.  The bias is small for values of `maxval - minval` significantly\nsmaller than the range of the output (either `2^32` or `2^64`).",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        },
        {
          "description": "0-D.  Inclusive lower bound on the generated integers.",
          "name": "minval",
          "typeAttr": "Tout"
        },
        {
          "description": "0-D.  Exclusive upper bound on the generated integers.",
          "name": "maxval",
          "typeAttr": "Tout"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with uniform random integers.",
          "name": "output",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Outputs random integers from a uniform distribution."
    }
  },
  {
    "name": "Range",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "This operation creates a sequence of numbers that begins at `start` and\nextends by increments of `delta` up to but not including `limit`.\n\nFor example:\n\n```\n# 'start' is 3\n# 'limit' is 18\n# 'delta' is 3\ntf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]\n```",
      "inputs": [
        {
          "description": "0-D (scalar). First entry in the sequence.",
          "name": "start",
          "typeAttr": "Tidx"
        },
        {
          "description": "0-D (scalar). Upper limit of sequence, exclusive.",
          "name": "limit",
          "typeAttr": "Tidx"
        },
        {
          "description": "0-D (scalar). Optional. Default is 1. Number that increments `start`.",
          "name": "delta",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "output",
          "typeAttr": "Tidx"
        }
      ],
      "summary": "Creates a sequence of numbers."
    }
  },
  {
    "name": "RangeDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "corresponds to start in python's xrange().",
          "name": "start",
          "type": 9
        },
        {
          "description": "corresponds to stop in python's xrange().",
          "name": "stop",
          "type": 9
        },
        {
          "description": "corresponds to step in python's xrange().",
          "name": "step",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset with a range of values. Corresponds to python's xrange."
    }
  },
  {
    "name": "Rank",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns an integer representing the rank of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n# shape of tensor 't' is [2, 2, 3]\nrank(t) ==> 3\n```\n\n**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank\nof a tensor is the number of indices required to uniquely select each element\nof the tensor. Rank is also known as \"order\", \"degree\", or \"ndims.\"",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 3
        }
      ],
      "summary": "Returns the rank of a tensor."
    }
  },
  {
    "name": "ReadFile",
    "schema": {
      "inputs": [
        {
          "name": "filename",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "Reads and outputs the entire contents of the input filename."
    }
  },
  {
    "name": "ReadVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The tensor returned by this operation is immutable.\n\nThe value returned by this operation is guaranteed to be influenced by all the\nwrites on which this operation depends directly or indirectly, and to not be\ninfluenced by any of the writes which depend directly or indirectly on this\noperation.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Reads the value of a variable."
    }
  },
  {
    "name": "ReaderNumRecordsProduced",
    "schema": {
      "description": "This is the same as the number of ReaderRead executions that have\nsucceeded.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "records_produced",
          "type": 9
        }
      ],
      "summary": "Returns the number of records this Reader has produced."
    }
  },
  {
    "name": "ReaderNumRecordsProducedV2",
    "schema": {
      "description": "This is the same as the number of ReaderRead executions that have\nsucceeded.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "records_produced",
          "type": 9
        }
      ],
      "summary": "Returns the number of records this Reader has produced."
    }
  },
  {
    "name": "ReaderNumWorkUnitsCompleted",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "units_completed",
          "type": 9
        }
      ],
      "summary": "Returns the number of work units this Reader has finished processing."
    }
  },
  {
    "name": "ReaderNumWorkUnitsCompletedV2",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "units_completed",
          "type": 9
        }
      ],
      "summary": "Returns the number of work units this Reader has finished processing."
    }
  },
  {
    "name": "ReaderRead",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        },
        {
          "description": "Handle to a Queue, with string work items.",
          "isRef": true,
          "name": "queue_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A scalar.",
          "name": "key",
          "type": 7
        },
        {
          "description": "A scalar.",
          "name": "value",
          "type": 7
        }
      ],
      "summary": "Returns the next record (key, value pair) produced by a Reader."
    }
  },
  {
    "name": "ReaderReadUpTo",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).\nIt may return less than `num_records` even before the last batch.",
      "inputs": [
        {
          "description": "Handle to a `Reader`.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        },
        {
          "description": "Handle to a `Queue`, with string work items.",
          "isRef": true,
          "name": "queue_handle",
          "type": 7
        },
        {
          "description": "number of records to read from `Reader`.",
          "name": "num_records",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A 1-D tensor.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "A 1-D tensor.",
          "name": "values",
          "type": 7
        }
      ],
      "summary": "Returns up to `num_records` (key, value) pairs produced by a Reader."
    }
  },
  {
    "name": "ReaderReadUpToV2",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).\nIt may return less than `num_records` even before the last batch.",
      "inputs": [
        {
          "description": "Handle to a `Reader`.",
          "name": "reader_handle",
          "type": 20
        },
        {
          "description": "Handle to a `Queue`, with string work items.",
          "name": "queue_handle",
          "type": 20
        },
        {
          "description": "number of records to read from `Reader`.",
          "name": "num_records",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A 1-D tensor.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "A 1-D tensor.",
          "name": "values",
          "type": 7
        }
      ],
      "summary": "Returns up to `num_records` (key, value) pairs produced by a Reader."
    }
  },
  {
    "name": "ReaderReadV2",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        },
        {
          "description": "Handle to a Queue, with string work items.",
          "name": "queue_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A scalar.",
          "name": "key",
          "type": 7
        },
        {
          "description": "A scalar.",
          "name": "value",
          "type": 7
        }
      ],
      "summary": "Returns the next record (key, value pair) produced by a Reader."
    }
  },
  {
    "name": "ReaderReset",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "Restore a Reader to its initial clean state."
    }
  },
  {
    "name": "ReaderResetV2",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "Restore a Reader to its initial clean state."
    }
  },
  {
    "name": "ReaderRestoreState",
    "schema": {
      "description": "Not all Readers support being restored, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        },
        {
          "description": "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle.",
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Restore a reader to a previously saved state."
    }
  },
  {
    "name": "ReaderRestoreStateV2",
    "schema": {
      "description": "Not all Readers support being restored, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        },
        {
          "description": "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle.",
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Restore a reader to a previously saved state."
    }
  },
  {
    "name": "ReaderSerializeState",
    "schema": {
      "description": "Not all Readers support being serialized, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Produce a string tensor that encodes the state of a Reader."
    }
  },
  {
    "name": "ReaderSerializeStateV2",
    "schema": {
      "description": "Not all Readers support being serialized, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Produce a string tensor that encodes the state of a Reader."
    }
  },
  {
    "name": "Real",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "default": {
            "type": "type",
            "value": 8
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the real part of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real\n part returned by this operation and *b* is the imaginary part.\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.real(input) ==> [-2.25, 3.25]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "Tout"
        }
      ],
      "summary": "Returns the real part of a complex number."
    }
  },
  {
    "name": "RealDiv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `x` and `y` are reals, this will return the floating-point division.\n\n*NOTE*: `Div` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x / y element-wise for real types."
    }
  },
  {
    "name": "Reciprocal",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = 1 / x\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the reciprocal of x element-wise."
    }
  },
  {
    "name": "ReciprocalGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient for the inverse of `x` wrt its input."
    }
  },
  {
    "name": "RecordInput",
    "schema": {
      "attributes": [
        {
          "description": "Glob pattern for the data files.",
          "name": "file_pattern",
          "type": "string"
        },
        {
          "default": 301,
          "description": "Random seeds used to produce randomized records.",
          "name": "file_random_seed",
          "type": "int"
        },
        {
          "default": 0.0,
          "description": "Shifts the list of files after the list is randomly\nshuffled.",
          "name": "file_shuffle_shift_ratio",
          "type": "float"
        },
        {
          "default": 10000,
          "description": "The randomization shuffling buffer.",
          "name": "file_buffer_size",
          "type": "int"
        },
        {
          "default": 16,
          "description": "How many sstables are opened and concurrently iterated over.",
          "name": "file_parallelism",
          "type": "int"
        },
        {
          "default": 32,
          "description": "The batch size.",
          "name": "batch_size",
          "type": "int"
        },
        {
          "default": "",
          "description": "The type of compression for the file. Currently ZLIB and\nGZIP are supported. Defaults to none.",
          "name": "compression_type",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of shape [batch_size].",
          "name": "records",
          "type": 7
        }
      ],
      "summary": "Emits randomized records."
    }
  },
  {
    "name": "ReduceDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function that maps `(old_state, input_element)` to `new_state`. It must take\ntwo arguments and return a nested structures of tensors. The structure of\n`new_state` must match the structure of `initial_state`.",
          "name": "f",
          "type": "func"
        },
        {
          "minimum": 1,
          "name": "Tstate",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": true,
          "name": "use_inter_op_parallelism",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "A variant tensor representing the input dataset.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A nested structure of tensors, representing the initial state of the\ntransformation.",
          "name": "initial_state",
          "typeListAttr": "Tstate"
        },
        {
          "name": "other_arguments",
          "typeListAttr": "Targuments"
        }
      ],
      "outputs": [
        {
          "name": "components",
          "typeListAttr": "output_types"
        }
      ],
      "summary": "Reduces the input dataset to a singleton using a reduce function."
    }
  },
  {
    "name": "ReduceJoin",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If `True`, retain reduced dimensions with length `1`.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "default": "",
          "description": "The separator to use when joining.",
          "name": "separator",
          "type": "string"
        }
      ],
      "description": "Computes the string join across dimensions in the given string Tensor of shape\n`[\\\\(d_0, d_1, ..., d_{n-1}\\\\)]`.  Returns a new Tensor created by joining the input\nstrings with the given separator (default: empty string).  Negative indices are\ncounted backwards from the end, with `-1` being equivalent to `n - 1`.  If\nindices are not specified, joins across all dimensions beginning from `n - 1`\nthrough `0`.\n\nFor example:\n\n```python\n# tensor `a` is [[\"a\", \"b\"], [\"c\", \"d\"]]\ntf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, 0, keep_dims=True) ==> [[\"ac\", \"bd\"]]\ntf.reduce_join(a, 1, keep_dims=True) ==> [[\"ab\"], [\"cd\"]]\ntf.reduce_join(a, 0, separator=\".\") ==> [\"a.c\", \"b.d\"]\ntf.reduce_join(a, [0, 1]) ==> \"acbd\"\ntf.reduce_join(a, [1, 0]) ==> \"abcd\"\ntf.reduce_join(a, []) ==> [[\"a\", \"b\"], [\"c\", \"d\"]]\ntf.reduce_join(a) = tf.reduce_join(a, [1, 0]) ==> \"abcd\"\n```",
      "inputs": [
        {
          "description": "The input to be joined.  All reduced indices must have non-zero size.",
          "name": "inputs",
          "type": 7
        },
        {
          "description": "The dimensions to reduce over.  Dimensions are reduced in the\norder specified.  Omitting `reduction_indices` is equivalent to passing\n`[n-1, n-2, ..., 0]`.  Negative indices from `-n` to `-1` are supported.",
          "name": "reduction_indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has shape equal to that of the input with reduced dimensions removed or\nset to `1` depending on `keep_dims`.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Joins a string Tensor across the given dimensions."
    }
  },
  {
    "name": "RefEnter",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "The name of the child frame.",
          "name": "frame_name",
          "type": "string"
        },
        {
          "default": false,
          "description": "If true, the output is constant within the child frame.",
          "name": "is_constant",
          "type": "bool"
        },
        {
          "default": 10,
          "description": "The number of iterations allowed to run in parallel.",
          "name": "parallel_iterations",
          "type": "int"
        }
      ],
      "description": "The unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the child frame.",
          "isRef": true,
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Creates or finds a child frame, and makes `data` available to the child frame."
    }
  },
  {
    "name": "RefExit",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Exit makes its input `data` available to the parent frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the parent frame.",
          "isRef": true,
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Exits the current frame to its parent frame."
    }
  },
  {
    "name": "RefIdentity",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Return the same ref tensor as the input ref tensor."
    }
  },
  {
    "name": "RefMerge",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "description": "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor for become available to `output`, and sets\n`value_index` to its index in `inputs`.",
      "inputs": [
        {
          "description": "The input tensors, exactly one of which will become available.",
          "isRef": true,
          "name": "inputs",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Will be set to the available input tensor.",
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        },
        {
          "description": "The index of the chosen input tensor in `inputs`.",
          "name": "value_index",
          "type": 3
        }
      ],
      "summary": "Forwards the value of an available tensor from `inputs` to `output`."
    }
  },
  {
    "name": "RefNextIteration",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be made available to the next iteration.",
          "isRef": true,
          "name": "data",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Makes its input available to the next iteration."
    }
  },
  {
    "name": "RefSelect",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "A scalar that determines the input that gets selected.",
          "name": "index",
          "type": 3
        },
        {
          "description": "A list of ref tensors, one of which will be forwarded to `output`.",
          "isRef": true,
          "name": "inputs",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The forwarded tensor.",
          "isRef": true,
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Forwards the `index`th element of `inputs` to `output`."
    }
  },
  {
    "name": "RefSwitch",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `Switch` and `Merge`.",
      "inputs": [
        {
          "description": "The ref tensor to be forwarded to the appropriate output.",
          "isRef": true,
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A scalar that specifies which output port will receive data.",
          "name": "pred",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "If `pred` is false, data will be forwarded to this output.",
          "isRef": true,
          "name": "output_false",
          "typeAttr": "T"
        },
        {
          "description": "If `pred` is true, data will be forwarded to this output.",
          "isRef": true,
          "name": "output_true",
          "typeAttr": "T"
        }
      ],
      "summary": "Forwards the ref tensor `data` to the output port determined by `pred`."
    }
  },
  {
    "name": "RegexFullMatch",
    "schema": {
      "description": "The input is a string tensor of any shape. The pattern is a scalar\nstring tensor which is applied to every element of the input tensor.\nThe boolean values (True or False) of the output tensor indicate\nif the input matches the regex pattern provided.\n\nThe pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
      "inputs": [
        {
          "description": "A string tensor of the text to be processed.",
          "name": "input",
          "type": 7
        },
        {
          "description": "A scalar string tensor containing the regular expression to match the input.",
          "name": "pattern",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A bool tensor with the same shape as `input`.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Check if the input matches the regex pattern."
    }
  },
  {
    "name": "RegexReplace",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "If True, the replacement is global, otherwise the replacement\nis done only on the first match.",
          "name": "replace_global",
          "type": "bool"
        }
      ],
      "description": "It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
      "inputs": [
        {
          "description": "The text to be processed.",
          "name": "input",
          "type": 7
        },
        {
          "description": "The regular expression to match the input.",
          "name": "pattern",
          "type": 7
        },
        {
          "description": "The rewrite to be applied to the matched expression.",
          "name": "rewrite",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The text after applying pattern and rewrite.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Replaces the match of pattern in input with rewrite."
    }
  },
  {
    "name": "Relu",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            },
            {
              "type": "type",
              "value": 11
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Activation",
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes rectified linear: `max(features, 0)`."
    }
  },
  {
    "name": "Relu6",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Activation",
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes rectified linear 6: `min(max(features, 0), 6)`."
    }
  },
  {
    "name": "Relu6Grad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Relu6 operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The features passed as input to the corresponding Relu6 operation, or\nits output; using either one produces the same result.",
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The gradients:\n`gradients * (features > 0) * (features < 6)`.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes rectified linear 6 gradients for a Relu6 operation."
    }
  },
  {
    "name": "ReluGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Relu operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The features passed as input to the corresponding Relu operation, OR\nthe outputs of that operation (both work equivalently).",
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "`gradients * (features > 0)`.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes rectified linear gradients for a Relu operation."
    }
  },
  {
    "name": "RemoteCall",
    "schema": {
      "attributes": [
        {
          "description": "The type list for the arguments.",
          "minimum": 1,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "The type list for the return values.",
          "minimum": 1,
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "The function to run remotely.",
          "name": "f",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "A fully specified device name where we want to run the function.",
          "name": "target",
          "type": 7
        },
        {
          "description": "A list of arguments for the function.",
          "name": "args",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "A list of return values.",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "Runs function `f` on a remote device indicated by `target`."
    }
  },
  {
    "name": "RemoteFusedGraphExecute",
    "schema": {
      "attributes": [
        {
          "minimum": 0,
          "name": "Tinputs",
          "type": "list(type)"
        },
        {
          "minimum": 0,
          "name": "Toutputs",
          "type": "list(type)"
        },
        {
          "description": "Serialized protocol buffer\nof RemoteFusedGraphExecuteInfo which contains graph specifications.",
          "name": "serialized_remote_fused_graph_execute_info",
          "type": "string"
        }
      ],
      "description": "The graph specifications(such as graph itself, input tensors and output names)\nare stored as a serialized protocol buffer of RemoteFusedGraphExecuteInfo\nas serialized_remote_fused_graph_execute_info.\nThe specifications will be passed to a dedicated registered\nremote fused graph executor.  The executor will send the graph specifications\nto a remote processor and execute that graph.  The execution results\nwill be passed to consumer nodes as outputs of this node.",
      "inputs": [
        {
          "description": "Arbitrary number of tensors with arbitrary data types",
          "name": "inputs",
          "typeListAttr": "Tinputs"
        }
      ],
      "outputs": [
        {
          "description": "Arbitrary number of tensors with arbitrary data types",
          "name": "outputs",
          "typeListAttr": "Toutputs"
        }
      ],
      "summary": "Execute a sub graph on a remote processor."
    }
  },
  {
    "name": "RepeatDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of times that `input_dataset` should\nbe repeated. A value of `-1` indicates that it should be repeated infinitely.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the outputs of `input_dataset` `count` times."
    }
  },
  {
    "name": "RequantizationRange",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "description": "The type of the input.",
          "name": "Tinput",
          "type": "type"
        }
      ],
      "description": "range that covers the actual values present in that tensor.  This op is\ntypically used to produce the requested_output_min and requested_output_max for\nRequantize.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "Tinput"
        },
        {
          "description": "The float value that the minimum quantized input value represents.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized input value represents.",
          "name": "input_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The computed min output.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "the computed max output.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Given a quantized tensor described by (input, input_min, input_max), outputs a"
    }
  },
  {
    "name": "Requantize",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "description": "The type of the input.",
          "name": "Tinput",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 15
            },
            {
              "type": "type",
              "value": 16
            }
          ],
          "description": "The type of the output. Should be a lower bit depth than Tinput.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "output range specified with 'requested_output_min' and 'requested_output_max'.\n\n[input_min, input_max] are scalar floats that specify the range for the float\ninterpretation of the 'input' data. For example, if input_min is -1.0f and\ninput_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\nvalue in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "Tinput"
        },
        {
          "description": "The float value that the minimum quantized input value represents.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized input value represents.",
          "name": "input_max",
          "type": 1
        },
        {
          "description": "The float value that the minimum quantized output value represents.",
          "name": "requested_output_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized output value represents.",
          "name": "requested_output_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        },
        {
          "description": "The requested_output_min value is copied into this output.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The requested_output_max value is copied into this output.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Convert the quantized 'input' tensor into a lower-precision 'output', using the"
    }
  },
  {
    "name": "Reshape",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tshape",
          "type": "type"
        }
      ],
      "category": "Shape",
      "description": "Given `tensor`, this operation returns a tensor that has the same values\nas `tensor` with shape `shape`.\n\nIf one component of `shape` is the special value -1, the size of that dimension\nis computed so that the total size remains constant.  In particular, a `shape`\nof `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.\n\nIf `shape` is 1-D or higher, then the operation returns a tensor with shape\n`shape` filled with the values of `tensor`. In this case, the number of elements\nimplied by `shape` must be the same as the number of elements in `tensor`.\n\nFor example:\n\n```\n# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# tensor 't' has shape [9]\nreshape(t, [3, 3]) ==> [[1, 2, 3],\n                        [4, 5, 6],\n                        [7, 8, 9]]\n\n# tensor 't' is [[[1, 1], [2, 2]],\n#                [[3, 3], [4, 4]]]\n# tensor 't' has shape [2, 2, 2]\nreshape(t, [2, 4]) ==> [[1, 1, 2, 2],\n                        [3, 3, 4, 4]]\n\n# tensor 't' is [[[1, 1, 1],\n#                 [2, 2, 2]],\n#                [[3, 3, 3],\n#                 [4, 4, 4]],\n#                [[5, 5, 5],\n#                 [6, 6, 6]]]\n# tensor 't' has shape [3, 2, 3]\n# pass '[-1]' to flatten 't'\nreshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]\n\n# -1 can also be used to infer the shape\n\n# -1 is inferred to be 9:\nreshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n# -1 is inferred to be 2:\nreshape(t, [-1, 9]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n# -1 is inferred to be 3:\nreshape(t, [ 2, -1, 3]) ==> [[[1, 1, 1],\n                              [2, 2, 2],\n                              [3, 3, 3]],\n                             [[4, 4, 4],\n                              [5, 5, 5],\n                              [6, 6, 6]]]\n\n# tensor 't' is [7]\n# shape `[]` reshapes to a scalar\nreshape(t, []) ==> 7\n```",
      "inputs": [
        {
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "Defines the shape of the output tensor.",
          "name": "shape",
          "typeAttr": "Tshape"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Reshapes a tensor."
    }
  },
  {
    "name": "ResizeArea",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images can be of different types but output images are always float.\n\nThe range of pixel values for the output image might be slightly different\nfrom the range for the input image because of limited numerical precision.\nTo guarantee an output range, for example `[0.0, 1.0]`, apply\n`tf.clip_by_value` to the output.\n\nEach output pixel is computed by first transforming the pixel's footprint into\nthe input tensor and then averaging the pixels that intersect the footprint. An\ninput pixel's contribution to the average is weighted by the fraction of its\narea that intersects the footprint.  This is the same as OpenCV's INTER_AREA.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 1
        }
      ],
      "summary": "Resize `images` to `size` using area interpolation."
    }
  },
  {
    "name": "ResizeBicubic",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images can be of different types but output images are always float.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 1
        }
      ],
      "summary": "Resize `images` to `size` using bicubic interpolation."
    }
  },
  {
    "name": "ResizeBicubicGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and grad tensors are\naligned. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized.",
          "name": "original_image",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of bicubic interpolation."
    }
  },
  {
    "name": "ResizeBilinear",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images can be of different types but output images are always float.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 1
        }
      ],
      "summary": "Resize `images` to `size` using bilinear interpolation."
    }
  },
  {
    "name": "ResizeBilinearGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and grad tensors are\naligned. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized.",
          "name": "original_image",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of bilinear interpolation."
    }
  },
  {
    "name": "ResizeNearestNeighbor",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "typeAttr": "T"
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "typeAttr": "T"
        }
      ],
      "summary": "Resize `images` to `size` using nearest neighbor interpolation."
    }
  },
  {
    "name": "ResizeNearestNeighborGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If true, the centers of the 4 corner pixels of the input and grad tensors are\naligned. Defaults to false.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "grads",
          "typeAttr": "T"
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The\noriginal input size.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients\nwith respect to the input image.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of nearest neighbor interpolation."
    }
  },
  {
    "name": "ResourceApplyAdaMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nv_t <- max(beta2 * v_{t-1}, abs(g))\nvariable <- variable - learning_rate / (1 - beta1^t) * m_t / (v_t + epsilon)",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "v",
          "type": 20
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the AdaMax algorithm."
    }
  },
  {
    "name": "ResourceApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum_update",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the adadelta scheme."
    }
  },
  {
    "name": "ResourceApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": true,
          "name": "update_slots",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the adagrad scheme."
    }
  },
  {
    "name": "ResourceApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_accumulator",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_squared_accumulator",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "summary": "Update '*var' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "ResourceApplyAdam",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, uses the nesterov update.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "$$lr_t := \\text{learning\\_rate} * \\sqrt{1 - beta_2^t} / (1 - beta_1^t)$$\n$$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$\n$$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$\n$$variable := variable - lr_t * m_t / (\\sqrt{v_t} + \\epsilon)$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "v",
          "type": 20
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta2_power",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Adam algorithm."
    }
  },
  {
    "name": "ResourceApplyAdamWithAmsgrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "$$lr_t := \\text{learning\\_rate} * \\sqrt{1 - beta_2^t} / (1 - beta_1^t)$$\n$$m_t := beta_1 * m_{t-1} + (1 - beta_1) * g$$\n$$v_t := beta_2 * v_{t-1} + (1 - beta_2) * g * g$$\n$$vhat_t := max{vhat_{t-1}, v_t}$$\n$$variable := variable - lr_t * m_t / (\\sqrt{vhat_t} + \\epsilon)$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "v",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "vhat",
          "type": 20
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta2_power",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "typeAttr": "T"
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Adam algorithm."
    }
  },
  {
    "name": "ResourceApplyAddSign",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- (alpha + sign_decay * sign(g) *sign(m)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ResourceApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\n\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nmg <- rho * mg_{t-1} + (1-rho) * grad\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mg",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "ResourceApplyFtrl",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum_new = accum + grad * grad\nlinear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regulariation. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "grad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "name": "l2_shrinkage",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceApplyGradientDescent",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "The change.",
          "name": "delta",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' by subtracting 'alpha' * 'delta' from it."
    }
  },
  {
    "name": "ResourceApplyKerasMomentum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, the tensor passed to compute grad will be\nvar + momentum * accum, so in the end, the var you get is actually\nvar + momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "want to use Nesterov momentum.\n\naccum = accum * momentum - lr * grad\nvar += accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the momentum scheme. Set use_nesterov = True if you"
    }
  },
  {
    "name": "ResourceApplyMomentum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "want to use Nesterov momentum.\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the momentum scheme. Set use_nesterov = True if you"
    }
  },
  {
    "name": "ResourceApplyPowerSign",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "logbase",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "typeAttr": "T"
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ResourceApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nprox_v = var - lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' and '*accum' according to FOBOS with Adagrad learning rate."
    }
  },
  {
    "name": "ResourceApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "prox_v = var - alpha * delta\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The change.",
          "name": "delta",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "ResourceApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "ResourceCountUpTo",
    "schema": {
      "attributes": [
        {
          "description": "If incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error.",
          "name": "limit",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a scalar `Variable` node.",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Increments variable pointed to by 'resource' until it reaches 'limit'."
    }
  },
  {
    "name": "ResourceGather",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n```python\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n```",
      "inputs": [
        {
          "name": "resource",
          "type": 20
        },
        {
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Gather slices from the variable pointed to by `resource` according to `indices`."
    }
  },
  {
    "name": "ResourceScatterAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Adds sparse updates to the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceScatterDiv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] /= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] /= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Divides sparse updates into the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceScatterMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = max(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions are combined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Reduces sparse updates into the variable referenced by `resource` using the `max` operation."
    }
  },
  {
    "name": "ResourceScatterMin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = min(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions are combined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Reduces sparse updates into the variable referenced by `resource` using the `min` operation."
    }
  },
  {
    "name": "ResourceScatterMul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] *= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] *= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Multiplies sparse updates into the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceScatterNdAdd",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": true,
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that addition would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nadd = tf.scatter_nd_add(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(add)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A resource handle. Must be from a VarHandleOp.",
          "name": "ref",
          "type": 20
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of\nvalues to add to ref.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse addition to individual values or slices in a Variable."
    }
  },
  {
    "name": "ResourceScatterNdSub",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": true,
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to subtract 4 scattered elements from a rank-1 tensor\nwith 8 elements. In Python, that subtraction would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8], use_resource=True)\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nsub = tf.scatter_nd_sub(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(sub)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, -9, 3, -6, -4, 6, 7, -4]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A resource handle. Must be from a VarHandleOp.",
          "name": "ref",
          "type": 20
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of\nvalues to add to ref.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse subtraction to individual values or slices in a Variable."
    }
  },
  {
    "name": "ResourceScatterNdUpdate",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": true,
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n```\n\nFor example, say we want to update 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that update would look like this:\n\n```python\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1] ,[7]])\n    updates = tf.constant([9, 10, 11, 12])\n    update = tf.scatter_nd_update(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(update)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 11, 3, 10, 9, 6, 7, 12]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A resource handle. Must be from a VarHandleOp.",
          "name": "ref",
          "type": 20
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to add to ref.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse `updates` to individual values or slices within a given"
    }
  },
  {
    "name": "ResourceScatterSub",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Subtracts sparse updates from the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceScatterUpdate",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Assigns sparse updates to the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceSparseApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": ": Should be from a Variable().",
          "name": "accum_update",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "summary": "var: Should be from a Variable()."
    }
  },
  {
    "name": "ResourceSparseApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": true,
          "name": "update_slots",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme."
    }
  },
  {
    "name": "ResourceSparseApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_accumulator",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_squared_accumulator",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "summary": "Update entries in '*var' and '*accum' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "ResourceSparseApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mg",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "ResourceSparseApplyFtrl",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\naccum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceSparseApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "name": "l2_shrinkage",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceSparseApplyKerasMomentum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, the tensor passed to compute grad will be\nvar + momentum * accum, so in the end, the var you get is actually\nvar + momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum - lr * grad\nvar += accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme."
    }
  },
  {
    "name": "ResourceSparseApplyMomentum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme."
    }
  },
  {
    "name": "ResourceSparseApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nprox_v = var\nprox_v -= lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "summary": "Sparse update entries in '*var' and '*accum' according to FOBOS algorithm."
    }
  },
  {
    "name": "ResourceSparseApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var as follows:\nprox_v = var - alpha * grad\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "summary": "Sparse update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "ResourceSparseApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "ResourceStridedSliceAssign",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Index",
          "type": "type"
        },
        {
          "default": 0,
          "name": "begin_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "end_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "The values of `value` are assigned to the positions in the variable\n`ref` that are selected by the slice parameters. The slice parameters\n`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s\nshape must be exactly the shape produced by the slice of `ref`.",
      "inputs": [
        {
          "name": "ref",
          "type": 20
        },
        {
          "name": "begin",
          "typeAttr": "Index"
        },
        {
          "name": "end",
          "typeAttr": "Index"
        },
        {
          "name": "strides",
          "typeAttr": "Index"
        },
        {
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "summary": "Assign `value` to the sliced l-value reference of `ref`."
    }
  },
  {
    "name": "Restore",
    "schema": {
      "attributes": [
        {
          "description": "The type of the tensor to be restored.",
          "name": "dt",
          "type": "type"
        },
        {
          "default": -1,
          "description": "Index of file to open first if multiple files match\n`file_pattern`.",
          "name": "preferred_shard",
          "type": "int"
        }
      ],
      "description": "Reads a tensor stored in one or several files. If there are several files (for\ninstance because a tensor was saved as slices), `file_pattern` may contain\nwildcard symbols (`*` and `?`) in the filename portion only, not in the\ndirectory portion.\n\nIf a `file_pattern` matches several files, `preferred_shard` can be used to hint\nin which file the requested tensor is likely to be found. This op will first\nopen the file at index `preferred_shard` in the list of matching files and try\nto restore tensors from that file.  Only if some tensors or tensor slices are\nnot found in that first file, then the Op opens all the files. Setting\n`preferred_shard` to match the value passed as the `shard` input\nof a matching `Save` Op may speed up Restore.  This attribute only affects\nperformance, not correctness.  The default value -1 means files are processed in\norder.\n\nSee also `RestoreSlice`.",
      "inputs": [
        {
          "description": "Must have a single element. The pattern of the files from\nwhich we read the tensor.",
          "name": "file_pattern",
          "type": 7
        },
        {
          "description": "Must have a single element. The name of the tensor to be\nrestored.",
          "name": "tensor_name",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The restored tensor.",
          "name": "tensor",
          "typeAttr": "dt"
        }
      ],
      "summary": "Restores a tensor from checkpoint files."
    }
  },
  {
    "name": "RestoreSlice",
    "schema": {
      "attributes": [
        {
          "description": "The type of the tensor to be restored.",
          "name": "dt",
          "type": "type"
        },
        {
          "default": -1,
          "description": "Index of file to open first if multiple files match\n`file_pattern`. See the documentation for `Restore`.",
          "name": "preferred_shard",
          "type": "int"
        }
      ],
      "description": "This is like `Restore` except that restored tensor can be listed as filling\nonly a slice of a larger tensor.  `shape_and_slice` specifies the shape of the\nlarger tensor and the slice that the restored tensor covers.\n\nThe `shape_and_slice` input has the same format as the\nelements of the `shapes_and_slices` input of the `SaveSlices` op.",
      "inputs": [
        {
          "description": "Must have a single element. The pattern of the files from\nwhich we read the tensor.",
          "name": "file_pattern",
          "type": 7
        },
        {
          "description": "Must have a single element. The name of the tensor to be\nrestored.",
          "name": "tensor_name",
          "type": 7
        },
        {
          "description": "Scalar. The shapes and slice specifications to use when\nrestoring a tensors.",
          "name": "shape_and_slice",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The restored tensor.",
          "name": "tensor",
          "typeAttr": "dt"
        }
      ],
      "summary": "Restores a tensor from checkpoint files."
    }
  },
  {
    "name": "RestoreV2",
    "schema": {
      "attributes": [
        {
          "description": "shape {N}.  The list of expected dtype for the tensors.  Must match\nthose stored in the checkpoint.",
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        }
      ],
      "description": "For backward compatibility with the V1 format, this Op currently allows\nrestoring from a V1 checkpoint as well:\n  - This Op first attempts to find the V2 index file pointed to by \"prefix\", and\n    if found proceed to read it as a V2 checkpoint;\n  - Otherwise the V1 read path is invoked.\nRelying on this behavior is not recommended, as the ability to fall back to read\nV1 might be deprecated and eventually removed.\n\nBy default, restores the named tensors in full.  If the caller wishes to restore\nspecific slices of stored tensors, \"shape_and_slices\" should be non-empty\nstrings and correspondingly well-formed.\n\nCallers must ensure all the named tensors are indeed stored in the checkpoint.",
      "inputs": [
        {
          "description": "Must have a single element.  The prefix of a V2 checkpoint.",
          "name": "prefix",
          "type": 7
        },
        {
          "description": "shape {N}.  The names of the tensors to be restored.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "shape {N}.  The slice specs of the tensors to be restored.\nEmpty strings indicate that they are non-partitioned tensors.",
          "name": "shape_and_slices",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "shape {N}.  The restored tensors, whose shapes are read from the\ncheckpoint directly.",
          "name": "tensors",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Restores tensors from a V2 checkpoint."
    }
  },
  {
    "name": "Reverse",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 10
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a `tensor`, and a `bool` tensor `dims` representing the dimensions\nof `tensor`, this operation reverses each dimension i of `tensor` where\n`dims[i]` is `True`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions\nof `tensor` must equal the number of elements in `dims`. In other words:\n\n`rank(tensor) = size(dims)`\n\nFor example:\n\n```\n# tensor 't' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor 't' shape is [1, 2, 3, 4]\n\n# 'dims' is [False, False, False, True]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# 'dims' is [False, True, False, False]\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# 'dims' is [False, False, True, False]\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```",
      "inputs": [
        {
          "description": "Up to 8-D.",
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "1-D. The dimensions to reverse.",
          "name": "dims",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "The same shape as `tensor`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Reverses specific dimensions of a tensor."
    }
  },
  {
    "name": "ReverseSequence",
    "schema": {
      "attributes": [
        {
          "description": "The dimension which is partially reversed.",
          "name": "seq_dim",
          "type": "int"
        },
        {
          "default": 0,
          "description": "The dimension along which reversal is performed.",
          "name": "batch_dim",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tlen",
          "type": "type"
        }
      ],
      "description": "This op first slices `input` along the dimension `batch_dim`, and for each\nslice `i`, reverses the first `seq_lengths[i]` elements along\nthe dimension `seq_dim`.\n\nThe elements of `seq_lengths` must obey `seq_lengths[i] <= input.dims[seq_dim]`,\nand `seq_lengths` must be a vector of length `input.dims[batch_dim]`.\n\nThe output slice `i` along dimension `batch_dim` is then given by input\nslice `i`, with the first `seq_lengths[i]` slices along dimension\n`seq_dim` reversed.\n\nFor example:\n\n```\n# Given this:\nbatch_dim = 0\nseq_dim = 1\ninput.dims = (4, 8, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]\noutput[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]\noutput[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]\noutput[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[0, 7:, :, ...] = input[0, 7:, :, ...]\noutput[1, 2:, :, ...] = input[1, 2:, :, ...]\noutput[2, 3:, :, ...] = input[2, 3:, :, ...]\noutput[3, 2:, :, ...] = input[3, 2:, :, ...]\n```\n\nIn contrast, if:\n\n```\n# Given this:\nbatch_dim = 2\nseq_dim = 0\ninput.dims = (8, ?, 4, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]\noutput[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]\noutput[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]\noutput[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]\noutput[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]\noutput[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]\noutput[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]\n```",
      "inputs": [
        {
          "description": "The input to reverse.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "1-D with length `input.dims(batch_dim)` and\n`max(seq_lengths) <= input.dims(seq_dim)`",
          "name": "seq_lengths",
          "typeAttr": "Tlen"
        }
      ],
      "outputs": [
        {
          "description": "The partially reversed input. It has the same shape as `input`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Reverses variable length slices."
    }
  },
  {
    "name": "ReverseV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 10
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "NOTE `tf.reverse` has now changed behavior in preparation for 1.0.\n`tf.reverse_v2` is currently an alias that will be deprecated before TF 1.0.\n\nGiven a `tensor`, and a `int32` tensor `axis` representing the set of\ndimensions of `tensor` to reverse. This operation reverses each dimension\n`i` for which there exists `j` s.t. `axis[j] == i`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions specified\nin `axis` may be 0 or more entries. If an index is specified more than\nonce, a InvalidArgument error is raised.\n\nFor example:\n\n```\n# tensor 't' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor 't' shape is [1, 2, 3, 4]\n\n# 'dims' is [3] or 'dims' is [-1]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# 'dims' is '[1]' (or 'dims' is '[-3]')\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# 'dims' is '[2]' (or 'dims' is '[-2]')\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```",
      "inputs": [
        {
          "description": "Up to 8-D.",
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "1-D. The indices of the dimensions to reverse. Must be in the range\n`[-rank(tensor), rank(tensor))`.",
          "name": "axis",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The same shape as `tensor`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Reverses specific dimensions of a tensor."
    }
  },
  {
    "name": "RightShift",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Performs a logical shift for unsigned integer types, and an arithmetic shift\nfor signed integer types.\n\nIf `y` is negative, or greater than or equal to than the width of `x` in bits\nthe result is implementation defined.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Elementwise computes the bitwise right-shift of `x` and `y`."
    }
  },
  {
    "name": "Rint",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the result is midway between two representable values,\nthe even representable is chosen.\nFor example:\n\n```\nrint(-1.5) ==> -2.0\nrint(0.5000001) ==> 1.0\nrint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==> [-2., -2., -0., 0., 2., 2., 2.]\n```",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns element-wise integer closest to x."
    }
  },
  {
    "name": "Roll",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tshift",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Taxis",
          "type": "type"
        }
      ],
      "description": "The elements are shifted positively (towards larger indices) by the offset of\n`shift` along the dimension of `axis`. Negative `shift` values will shift\nelements in the opposite direction. Elements that roll passed the last position\nwill wrap around to the first and vice versa. Multiple shifts along multiple\naxes may be specified.\n\nFor example:\n\n```\n# 't' is [0, 1, 2, 3, 4]\nroll(t, shift=2, axis=0) ==> [3, 4, 0, 1, 2]\n\n# shifting along multiple dimensions\n# 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\nroll(t, shift=[1, -2], axis=[0, 1]) ==> [[7, 8, 9, 5, 6], [2, 3, 4, 0, 1]]\n\n# shifting along the same axis multiple times\n# 't' is [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]\nroll(t, shift=[2, -3], axis=[1, 1]) ==> [[1, 2, 3, 4, 0], [6, 7, 8, 9, 5]]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "Dimension must be 0-D or 1-D. `shift[i]` specifies the number of places by which\nelements are shifted positively (towards larger indices) along the dimension\nspecified by `axis[i]`. Negative shifts will roll the elements in the opposite\ndirection.",
          "name": "shift",
          "typeAttr": "Tshift"
        },
        {
          "description": "Dimension must be 0-D or 1-D. `axis[i]` specifies the dimension that the shift\n`shift[i]` should occur. If the same axis is referenced more than once, the\ntotal shift for that axis will be the sum of all the shifts that belong to that\naxis.",
          "name": "axis",
          "typeAttr": "Taxis"
        }
      ],
      "outputs": [
        {
          "description": "Has the same shape and size as the input. The elements are shifted\npositively (towards larger indices) by the offsets of `shift` along the\ndimensions of `axis`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Rolls the elements of a tensor along an axis."
    }
  },
  {
    "name": "Round",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Rounds half to even.  Also known as bankers rounding. If you want to round\naccording to the current system rounding mode use std::cint.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Rounds the values of a tensor to the nearest integer, element-wise."
    }
  },
  {
    "name": "Rpc",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "RPC protocol to use.  Empty string means use the default protocol.\nOptions include 'grpc'.",
          "name": "protocol",
          "type": "string"
        },
        {
          "default": true,
          "description": "`boolean`. If `true` (default), then failures to connect\n(i.e., the server does not immediately respond) cause an RPC failure.",
          "name": "fail_fast",
          "type": "bool"
        },
        {
          "default": 0,
          "description": "`int`. If `0` (default), then the kernel will run the RPC\nrequest and only time out if the RPC deadline passes or the session times out.\nIf this value is greater than `0`, then the op will raise an exception if\nthe RPC takes longer than `timeout_in_ms`.",
          "name": "timeout_in_ms",
          "type": "int"
        }
      ],
      "description": "This op asynchronously performs either a single RPC request, or a batch\nof requests.  RPC requests are defined by three main parameters:\n\n  - `address` (the host+port or BNS address of the request)\n  - `method` (the RPC method name for the request)\n  - `request` (the serialized proto string, or vector of strings,\n     of the RPC request argument).\n\nFor example, if you have an RPC service running on port localhost:2345,\nand its interface is configured with the following proto declaration:\n\n```\nservice MyService {\n  rpc MyMethod(MyRequestProto) returns (MyResponseProto) {\n  }\n};\n```\n\nthen call this op with arguments:\n\n```\naddress = \"localhost:2345\"\nmethod = \"MyService/MyMethod\"\n```\n\nThe `request` tensor is a string tensor representing serialized `MyRequestProto`\nstrings; and the output string tensor `response` will have the same shape\nand contain (upon successful completion) corresponding serialized\n`MyResponseProto` strings.\n\nFor example, to send a single, empty, `MyRequestProto`, call\nthis op with `request = \"\"`.  To send 5 **parallel** empty requests,\ncall this op with `request = [\"\", \"\", \"\", \"\", \"\"]`.\n\nMore generally, one can create a batch of `MyRequestProto` serialized protos\nfrom regular batched tensors using the `encode_proto` op, and convert\nthe response `MyResponseProto` serialized protos to batched tensors\nusing the `decode_proto` op.\n\n**NOTE** Working with serialized proto strings is faster than instantiating\nactual proto objects in memory, so no performance degradation is expected\ncompared to writing custom kernels for this workflow.\n\nIf the connection fails or the remote worker returns an error\nstatus, the op reraises this exception locally.\n\nSee the `TryRpc` op if you prefer to handle RPC failures manually in the graph.",
      "inputs": [
        {
          "description": "`0-D` or `1-D`.  The address (i.e. host_name:port) of the RPC server.\nIf this tensor has more than 1 element, then multiple parallel rpc requests\nare sent.  This argument broadcasts with `method` and `request`.",
          "name": "address",
          "type": 7
        },
        {
          "description": "`0-D` or `1-D`.  The method address on the RPC server.\nIf this tensor has more than 1 element, then multiple parallel rpc requests\nare sent.  This argument broadcasts with `address` and `request`.",
          "name": "method",
          "type": 7
        },
        {
          "description": "`0-D` or `1-D`.  Serialized proto strings: the rpc request argument.\nIf this tensor has more than 1 element, then multiple parallel rpc requests\nare sent.  This argument broadcasts with `address` and `method`.",
          "name": "request",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `request`. Serialized proto strings: the rpc responses.",
          "name": "response",
          "type": 7
        }
      ],
      "summary": "Perform batches of RPC requests."
    }
  },
  {
    "name": "Rsqrt",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = 1 / \\sqrt{x}\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes reciprocal of square root of x element-wise."
    }
  },
  {
    "name": "RsqrtGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * -0.5 * y^3`, where `y = rsqrt(x)`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient for the rsqrt of `x` wrt its input."
    }
  },
  {
    "name": "SampleDistortedBoundingBox",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "default": 0.10000000149011612,
          "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
          "name": "min_object_covered",
          "type": "float"
        },
        {
          "default": [
            0.75,
            1.3300000429153442
          ],
          "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
          "name": "aspect_ratio_range",
          "type": "list(float)"
        },
        {
          "default": [
            0.05000000074505806,
            1.0
          ],
          "description": "The cropped area of the image must contain a fraction of the\nsupplied image within this range.",
          "name": "area_range",
          "type": "list(float)"
        },
        {
          "default": 100,
          "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
          "name": "max_attempts",
          "type": "int"
        },
        {
          "default": false,
          "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
          "name": "use_image_if_no_bounding_boxes",
          "type": "bool"
        }
      ],
      "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n```python\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.summary.image('images_with_box', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n```\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
      "inputs": [
        {
          "description": "1-D, containing `[height, width, channels]`.",
          "name": "image_size",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
          "name": "bounding_boxes",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
          "name": "begin",
          "typeAttr": "T"
        },
        {
          "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
          "name": "size",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
          "name": "bboxes",
          "type": 1
        }
      ],
      "summary": "Generate a single randomly distorted bounding box for an image."
    }
  },
  {
    "name": "SampleDistortedBoundingBoxV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "default": [
            0.75,
            1.3300000429153442
          ],
          "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
          "name": "aspect_ratio_range",
          "type": "list(float)"
        },
        {
          "default": [
            0.05000000074505806,
            1.0
          ],
          "description": "The cropped area of the image must contain a fraction of the\nsupplied image within this range.",
          "name": "area_range",
          "type": "list(float)"
        },
        {
          "default": 100,
          "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
          "name": "max_attempts",
          "type": "int"
        },
        {
          "default": false,
          "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
          "name": "use_image_if_no_bounding_boxes",
          "type": "bool"
        }
      ],
      "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n```python\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.summary.image('images_with_box', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n```\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
      "inputs": [
        {
          "description": "1-D, containing `[height, width, channels]`.",
          "name": "image_size",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
          "name": "bounding_boxes",
          "type": 1
        },
        {
          "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
          "name": "min_object_covered",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
          "name": "begin",
          "typeAttr": "T"
        },
        {
          "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
          "name": "size",
          "typeAttr": "T"
        },
        {
          "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
          "name": "bboxes",
          "type": 1
        }
      ],
      "summary": "Generate a single randomly distorted bounding box for an image."
    }
  },
  {
    "name": "Save",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "The size of `tensor_names` must match the number of tensors in `data`. `data[i]`\nis written to `filename` with name `tensor_names[i]`.\n\nSee also `SaveSlices`.",
      "inputs": [
        {
          "description": "Must have a single element. The name of the file to which we write\nthe tensor.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "Shape `[N]`. The names of the tensors to be saved.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "`N` tensors to save.",
          "name": "data",
          "typeListAttr": "T"
        }
      ],
      "summary": "Saves the input tensors to disk."
    }
  },
  {
    "name": "SaveSlices",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "This is like `Save` except that tensors can be listed in the saved file as being\na slice of a larger tensor.  `shapes_and_slices` specifies the shape of the\nlarger tensor and the slice that this tensor covers. `shapes_and_slices` must\nhave as many elements as `tensor_names`.\n\nElements of the `shapes_and_slices` input must either be:\n\n*  The empty string, in which case the corresponding tensor is\n   saved normally.\n*  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the\n   `dimI` are the dimensions of the larger tensor and `slice-spec`\n   specifies what part is covered by the tensor to save.\n\n`slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`\nwhere each `sliceI` is either:\n\n*  The string `-` meaning that the slice covers all indices of this dimension\n*  `start,length` where `start` and `length` are integers.  In that\n   case the slice covers `length` indices starting at `start`.\n\nSee also `Save`.",
      "inputs": [
        {
          "description": "Must have a single element. The name of the file to which we write the\ntensor.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "Shape `[N]`. The names of the tensors to be saved.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "Shape `[N]`.  The shapes and slice specifications to use when\nsaving the tensors.",
          "name": "shapes_and_slices",
          "type": 7
        },
        {
          "description": "`N` tensors to save.",
          "name": "data",
          "typeListAttr": "T"
        }
      ],
      "summary": "Saves input tensors slices to disk."
    }
  },
  {
    "name": "SaveV2",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        }
      ],
      "description": "By default, saves the named tensors in full.  If the caller wishes to save\nspecific slices of full tensors, \"shape_and_slices\" should be non-empty strings\nand correspondingly well-formed.",
      "inputs": [
        {
          "description": "Must have a single element. The prefix of the V2 checkpoint to which we\nwrite the tensors.",
          "name": "prefix",
          "type": 7
        },
        {
          "description": "shape {N}. The names of the tensors to be saved.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "shape {N}.  The slice specs of the tensors to be saved.\nEmpty strings indicate that they are non-partitioned tensors.",
          "name": "shape_and_slices",
          "type": 7
        },
        {
          "description": "`N` tensors to save.",
          "name": "tensors",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Saves tensors in V2 checkpoint format."
    }
  },
  {
    "name": "ScalarSummary",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input `tags` and `values` must have the same shape.  The generated summary\nhas a summary value for each tag-value pair in `tags` and `values`.",
      "inputs": [
        {
          "description": "Tags for the summary.",
          "name": "tags",
          "type": 7
        },
        {
          "description": "Same shape as `tags.  Values for the summary.",
          "name": "values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Scalar.  Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with scalar values."
    }
  },
  {
    "name": "ScaleAndTranslate",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": "lanczos3",
          "name": "kernel_type",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "name": "images",
          "typeAttr": "T"
        },
        {
          "name": "size",
          "type": 3
        },
        {
          "name": "scale",
          "type": 1
        },
        {
          "name": "translation",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "resized_images",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "ScaleAndTranslateGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "default": "lanczos3",
          "name": "kernel_type",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "name": "grads",
          "typeAttr": "T"
        },
        {
          "name": "original_image",
          "typeAttr": "T"
        },
        {
          "name": "scale",
          "type": 1
        },
        {
          "name": "translation",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "ScatterAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Adds sparse updates to a variable reference."
    }
  },
  {
    "name": "ScatterDiv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the operation will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] /= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] /= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions divide.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of values that `ref` is divided by.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Divides a variable reference by sparse updates."
    }
  },
  {
    "name": "ScatterMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the update will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = max(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = max(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = max(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions combine.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to reduce into `ref`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Reduces sparse updates into a variable reference using the `max` operation."
    }
  },
  {
    "name": "ScatterMin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the update will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = min(ref[indices, ...], updates[...])\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = min(ref[indices[i], ...], updates[i, ...])\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = min(ref[indices[i, ..., j], ...], updates[i, ..., j, ...])\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions combine.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to reduce into `ref`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Reduces sparse updates into a variable reference using the `min` operation."
    }
  },
  {
    "name": "ScatterMul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the operation will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] *= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] *= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to multiply to `ref`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Multiplies sparse updates into a variable reference."
    }
  },
  {
    "name": "ScatterNd",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Creates a new tensor by applying sparse `updates` to individual values or\nslices within a tensor (initially zero for numeric, empty for string) of\nthe given `shape` according to indices.  This operator is the inverse of the\n`tf.gather_nd` operator which extracts values or slices from a given tensor.\n\nThis operation is similar to tensor_scatter_add, except that the tensor is\nzero-initialized. Calling `tf.scatter_nd(indices, values, shape)` is identical\nto `tensor_scatter_add(tf.zeros(shape, values.dtype), indices, values)`\n\nIf `indices` contains duplicates, then their updates are accumulated (summed).\n\n**WARNING**: The order in which updates are applied is nondeterministic, so the\noutput will be nondeterministic if `indices` contains duplicates -- because\nof some numerical approximation issues, numbers summed in different order\nmay yield different results.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.  The last dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.  `updates` is a tensor with shape\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of scatter is to insert individual elements in a tensor by\nindex. For example, say we want to insert 4 scattered elements in a rank-1\ntensor with 8 elements.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd1.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    shape = tf.constant([8])\n    scatter = tf.scatter_nd(indices, updates, shape)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [0, 11, 0, 10, 9, 0, 0, 12]\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd2.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[0], [2]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    shape = tf.constant([4, 4, 4])\n    scatter = tf.scatter_nd(indices, updates, shape)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n     [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
      "inputs": [
        {
          "description": "Index tensor.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Updates to scatter into output.",
          "name": "updates",
          "typeAttr": "T"
        },
        {
          "description": "1-D. The shape of the resulting tensor.",
          "name": "shape",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "A new tensor with the given shape and updates applied according\nto the indices.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Scatter `updates` into a new tensor according to `indices`."
    }
  },
  {
    "name": "ScatterNdAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that addition would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nadd = tf.scatter_nd_add(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(add)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A mutable Tensor. Should be from a Variable node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to ref.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse addition to individual values or slices in a Variable."
    }
  },
  {
    "name": "ScatterNdNonAliasingAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            },
            {
              "type": "type",
              "value": 10
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "from `updates` according to indices `indices`.  The updates are non-aliasing:\n`input` is only modified in-place if no other operations will use it.\nOtherwise, a copy of `input` is made.  This operation has a gradient with\nrespect to both `input` and `updates`.\n\n`input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `input`.\nIt must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or `(P-K)`-dimensional slices\n(if `K < P`) along the `K`th dimension of `input`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n$$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to 8\nelements. In Python, that addition would look like this:\n\n    input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    output = tf.scatter_nd_non_aliasing_add(input, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(output))\n\nThe resulting value `output` would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee `tf.scatter_nd` for more details about how to make updates to slices.",
      "inputs": [
        {
          "description": "A Tensor.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "A Tensor. Must be one of the following types: `int32`, `int64`.\nA tensor of indices into `input`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to `input`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the same shape as `input`, containing values of `input`\nupdated with `updates`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse addition to `input` using individual values or slices"
    }
  },
  {
    "name": "ScatterNdSub",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "within a given variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]]\n```\n\nFor example, say we want to subtract 4 scattered elements from a rank-1 tensor\nwith 8 elements. In Python, that subtraction would look like this:\n\n```python\nref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\nindices = tf.constant([[4], [3], [1], [7]])\nupdates = tf.constant([9, 10, 11, 12])\nsub = tf.scatter_nd_sub(ref, indices, updates)\nwith tf.Session() as sess:\n  print sess.run(sub)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, -9, 3, -6, -4, 6, 7, -4]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A mutable Tensor. Should be from a Variable node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto subtract from ref.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse subtraction to individual values or slices in a Variable."
    }
  },
  {
    "name": "ScatterNdUpdate",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": true,
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape \\\\([d_0, ..., d_{Q-2}, K]\\\\) where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n$$[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].$$\n\nFor example, say we want to update 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that update would look like this:\n\n```python\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1] ,[7]])\n    updates = tf.constant([9, 10, 11, 12])\n    update = tf.scatter_nd_update(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(update)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 11, 3, 10, 9, 6, 7, 12]\n\nSee `tf.scatter_nd` for more details about how to make updates to\nslices.\n\nSee also `tf.scatter_update` and `tf.batch_scatter_update`.",
      "inputs": [
        {
          "description": "A mutable Tensor. Should be from a Variable node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to add to ref.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as ref. Returned as a convenience for operations that want to\nuse the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse `updates` to individual values or slices within a given"
    }
  },
  {
    "name": "ScatterSub",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "```python\n    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their (negated) contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterSub.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to subtract from `ref`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Subtracts sparse updates to a variable reference."
    }
  },
  {
    "name": "ScatterUpdate",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": true,
          "description": "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nIf values in `ref` is to be updated more than once, because there are\nduplicate entries in `indices`, the order at which the updates happen\nfor each value is undefined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]` or `updates.shape = []`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterUpdate.png\" alt>\n</div>\n\nSee also `tf.batch_scatter_update` and `tf.scatter_nd_update`.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "A tensor of updated values to store in `ref`.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies sparse updates to a variable reference."
    }
  },
  {
    "name": "SdcaFprint",
    "schema": {
      "inputs": [
        {
          "description": "vector of strings to compute fingerprints on.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "a (N,2) shaped matrix where N is the number of elements in the input\nvector. Each row contains the low and high parts of the fingerprint.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Computes fingerprints of the input strings."
    }
  },
  {
    "name": "SdcaOptimizer",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "logistic_loss",
            "squared_loss",
            "hinge_loss",
            "smooth_hinge_loss",
            "poisson_loss"
          ],
          "description": "Type of the primal loss. Currently SdcaSolver supports logistic,\nsquared and hinge losses.",
          "name": "loss_type",
          "type": "string"
        },
        {
          "default": false,
          "description": "Whether to use Adaptive SDCA for the inner loop.",
          "name": "adaptative",
          "type": "bool"
        },
        {
          "description": "Number of sparse feature groups to train on.",
          "minimum": 0,
          "name": "num_sparse_features",
          "type": "int"
        },
        {
          "description": "Number of sparse feature groups with values\nassociated with it, otherwise implicitly treats values as 1.0.",
          "minimum": 0,
          "name": "num_sparse_features_with_values",
          "type": "int"
        },
        {
          "description": "Number of dense feature groups to train on.",
          "minimum": 0,
          "name": "num_dense_features",
          "type": "int"
        },
        {
          "description": "Symmetric l1 regularization strength.",
          "name": "l1",
          "type": "float"
        },
        {
          "description": "Symmetric l2 regularization strength.",
          "name": "l2",
          "type": "float"
        },
        {
          "description": "Number of partitions of the global loss function.",
          "minimum": 1,
          "name": "num_loss_partitions",
          "type": "int"
        },
        {
          "description": "Number of iterations per mini-batch.",
          "minimum": 1,
          "name": "num_inner_iterations",
          "type": "int"
        }
      ],
      "description": "linear models with L1 + L2 regularization. As global optimization objective is\nstrongly-convex, the optimizer optimizes the dual objective at each step. The\noptimizer applies each update one example at a time. Examples are sampled\nuniformly, and the optimizer is learning rate free and enjoys linear convergence\nrate.\n\n[Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).<br>\nShai Shalev-Shwartz, Tong Zhang. 2012\n\n$$Loss Objective = \\sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$\n\n[Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).<br>\nChenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,\nPeter Richtarik, Martin Takac. 2015\n\n[Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).<br>\nDominik Csiba, Zheng Qu, Peter Richtarik. 2015",
      "inputs": [
        {
          "description": "a list of vectors which contain example indices.",
          "name": "sparse_example_indices",
          "numberAttr": "num_sparse_features",
          "type": 9
        },
        {
          "description": "a list of vectors which contain feature indices.",
          "name": "sparse_feature_indices",
          "numberAttr": "num_sparse_features",
          "type": 9
        },
        {
          "description": "a list of vectors which contains feature value\nassociated with each feature group.",
          "name": "sparse_feature_values",
          "numberAttr": "num_sparse_features_with_values",
          "type": 1
        },
        {
          "description": "a list of matrices which contains the dense feature values.",
          "name": "dense_features",
          "numberAttr": "num_dense_features",
          "type": 1
        },
        {
          "description": "a vector which contains the weight associated with each\nexample.",
          "name": "example_weights",
          "type": 1
        },
        {
          "description": "a vector which contains the label/target associated with each\nexample.",
          "name": "example_labels",
          "type": 1
        },
        {
          "description": "a list of vectors where each value is the indices which has\ncorresponding weights in sparse_weights. This field maybe omitted for the\ndense approach.",
          "name": "sparse_indices",
          "numberAttr": "num_sparse_features",
          "type": 9
        },
        {
          "description": "a list of vectors where each value is the weight associated with\na sparse feature group.",
          "name": "sparse_weights",
          "numberAttr": "num_sparse_features",
          "type": 1
        },
        {
          "description": "a list of vectors where the values are the weights associated\nwith a dense feature group.",
          "name": "dense_weights",
          "numberAttr": "num_dense_features",
          "type": 1
        },
        {
          "description": "a list of vectors containing the example state data.",
          "name": "example_state_data",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "a list of vectors containing the updated example state\ndata.",
          "name": "out_example_state_data",
          "type": 1
        },
        {
          "description": "a list of vectors where each value is the delta\nweights associated with a sparse feature group.",
          "name": "out_delta_sparse_weights",
          "type": 1
        },
        {
          "description": "a list of vectors where the values are the delta\nweights associated with a dense feature group.",
          "name": "out_delta_dense_weights",
          "type": 1
        }
      ],
      "summary": "Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for"
    }
  },
  {
    "name": "SdcaOptimizerV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "logistic_loss",
            "squared_loss",
            "hinge_loss",
            "smooth_hinge_loss",
            "poisson_loss"
          ],
          "description": "Type of the primal loss. Currently SdcaSolver supports logistic,\nsquared and hinge losses.",
          "name": "loss_type",
          "type": "string"
        },
        {
          "default": false,
          "description": "Whether to use Adaptive SDCA for the inner loop.",
          "name": "adaptive",
          "type": "bool"
        },
        {
          "description": "Number of sparse feature groups to train on.",
          "minimum": 0,
          "name": "num_sparse_features",
          "type": "int"
        },
        {
          "description": "Number of sparse feature groups with values\nassociated with it, otherwise implicitly treats values as 1.0.",
          "minimum": 0,
          "name": "num_sparse_features_with_values",
          "type": "int"
        },
        {
          "description": "Number of dense feature groups to train on.",
          "minimum": 0,
          "name": "num_dense_features",
          "type": "int"
        },
        {
          "description": "Symmetric l1 regularization strength.",
          "name": "l1",
          "type": "float"
        },
        {
          "description": "Symmetric l2 regularization strength.",
          "name": "l2",
          "type": "float"
        },
        {
          "description": "Number of partitions of the global loss function.",
          "minimum": 1,
          "name": "num_loss_partitions",
          "type": "int"
        },
        {
          "description": "Number of iterations per mini-batch.",
          "minimum": 1,
          "name": "num_inner_iterations",
          "type": "int"
        }
      ],
      "description": "linear models with L1 + L2 regularization. As global optimization objective is\nstrongly-convex, the optimizer optimizes the dual objective at each step. The\noptimizer applies each update one example at a time. Examples are sampled\nuniformly, and the optimizer is learning rate free and enjoys linear convergence\nrate.\n\n[Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).<br>\nShai Shalev-Shwartz, Tong Zhang. 2012\n\n$$Loss Objective = \\sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$\n\n[Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).<br>\nChenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,\nPeter Richtarik, Martin Takac. 2015\n\n[Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).<br>\nDominik Csiba, Zheng Qu, Peter Richtarik. 2015",
      "inputs": [
        {
          "description": "a list of vectors which contain example indices.",
          "name": "sparse_example_indices",
          "numberAttr": "num_sparse_features",
          "type": 9
        },
        {
          "description": "a list of vectors which contain feature indices.",
          "name": "sparse_feature_indices",
          "numberAttr": "num_sparse_features",
          "type": 9
        },
        {
          "description": "a list of vectors which contains feature value\nassociated with each feature group.",
          "name": "sparse_feature_values",
          "numberAttr": "num_sparse_features_with_values",
          "type": 1
        },
        {
          "description": "a list of matrices which contains the dense feature values.",
          "name": "dense_features",
          "numberAttr": "num_dense_features",
          "type": 1
        },
        {
          "description": "a vector which contains the weight associated with each\nexample.",
          "name": "example_weights",
          "type": 1
        },
        {
          "description": "a vector which contains the label/target associated with each\nexample.",
          "name": "example_labels",
          "type": 1
        },
        {
          "description": "a list of vectors where each value is the indices which has\ncorresponding weights in sparse_weights. This field maybe omitted for the\ndense approach.",
          "name": "sparse_indices",
          "numberAttr": "num_sparse_features",
          "type": 9
        },
        {
          "description": "a list of vectors where each value is the weight associated with\na sparse feature group.",
          "name": "sparse_weights",
          "numberAttr": "num_sparse_features",
          "type": 1
        },
        {
          "description": "a list of vectors where the values are the weights associated\nwith a dense feature group.",
          "name": "dense_weights",
          "numberAttr": "num_dense_features",
          "type": 1
        },
        {
          "description": "a list of vectors containing the example state data.",
          "name": "example_state_data",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "a list of vectors containing the updated example state\ndata.",
          "name": "out_example_state_data",
          "type": 1
        },
        {
          "description": "a list of vectors where each value is the delta\nweights associated with a sparse feature group.",
          "name": "out_delta_sparse_weights",
          "type": 1
        },
        {
          "description": "a list of vectors where the values are the delta\nweights associated with a dense feature group.",
          "name": "out_delta_dense_weights",
          "type": 1
        }
      ],
      "summary": "Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for"
    }
  },
  {
    "name": "SdcaShrinkL1",
    "schema": {
      "attributes": [
        {
          "description": "Number of feature groups to apply shrinking step.",
          "minimum": 0,
          "name": "num_features",
          "type": "int"
        },
        {
          "description": "Symmetric l1 regularization strength.",
          "name": "l1",
          "type": "float"
        },
        {
          "description": "Symmetric l2 regularization strength. Should be a positive float.",
          "name": "l2",
          "type": "float"
        }
      ],
      "inputs": [
        {
          "description": "a list of vectors where each value is the weight associated with a\nfeature group.",
          "isRef": true,
          "name": "weights",
          "numberAttr": "num_features",
          "type": 1
        }
      ],
      "summary": "Applies L1 regularization shrink step on the parameters."
    }
  },
  {
    "name": "SegmentMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\max_j(data_j)\\\\) where `max` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the max is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMax.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the maximum along segments of a tensor."
    }
  },
  {
    "name": "SegmentMean",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\frac{\\sum_j data_j}{N}\\\\) where `mean` is\nover `j` such that `segment_ids[j] == i` and `N` is the total number of\nvalues summed.\n\nIf the mean is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMean.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the mean along segments of a tensor."
    }
  },
  {
    "name": "SegmentMin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\min_j(data_j)\\\\) where `min` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the min is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMin.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the minimum along segments of a tensor."
    }
  },
  {
    "name": "SegmentProd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\prod_j data_j\\\\) where the product is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the product is empty for a given segment ID `i`, `output[i] = 1`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentProd.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the product along segments of a tensor."
    }
  },
  {
    "name": "SegmentSum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentSum.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor whose size is equal to the size of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum along segments of a tensor."
    }
  },
  {
    "name": "Select",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The `t`, and `e` tensors must all have the same shape, and the\noutput will also have that shape.\n\nThe `condition` tensor must be a scalar if `t` and `e` are scalars.\nIf `t` and `e` are vectors or higher rank, then `condition` must be either a\nscalar, a vector with size matching the first dimension of `t`, or must have\nthe same shape as `t`.\n\nThe `condition` tensor acts as a mask that chooses, based on the value at each\nelement, whether the corresponding element / row in the output should be\ntaken from `t` (if true) or `e` (if false).\n\nIf `condition` is a vector and `t` and `e` are higher rank matrices, then\nit chooses which row (outer dimension) to copy from `t` and `e`.\nIf `condition` has the same shape as `t` and `e`, then it chooses which\nelement to copy from `t` and `e`.\n\nFor example:\n\n```python\n# 'condition' tensor is [[True,  False]\n#                        [False, True]]\n# 't' is [[1, 2],\n#         [3, 4]]\n# 'e' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e)  # => [[1, 6], [7, 4]]\n\n\n# 'condition' tensor is [True, False]\n# 't' is [[1, 2],\n#         [3, 4]]\n# 'e' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e) ==> [[1, 2],\n                             [7, 8]]\n\n```",
      "inputs": [
        {
          "name": "condition",
          "type": 10
        },
        {
          "description": "= A `Tensor` which may have the same shape as `condition`.\nIf `condition` is rank 1, `t` may have higher rank,\nbut its first dimension must match the size of `condition`.",
          "name": "t",
          "typeAttr": "T"
        },
        {
          "description": "= A `Tensor` with the same type and shape as `t`.",
          "name": "e",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= A `Tensor` with the same type and shape as `t` and `e`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Selects elements from `t` or `e`, depending on `condition`."
    }
  },
  {
    "name": "SelfAdjointEig",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix\nSelfAdjointEig.\n\nThe result is a [..., M+1, M] matrix with [..., 0,:] containing the\neigenvalues, and subsequent [...,1:, :] containing the eigenvectors. The eigenvalues\nare sorted in non-decreasing order.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M+1, M]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the Eigen Decomposition of a batch of square self-adjoint matrices."
    }
  },
  {
    "name": "SelfAdjointEigV2",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "If `True` then eigenvectors will be computed and returned in `v`.\nOtherwise, only the eigenvalues will be computed.",
          "name": "compute_v",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in\n`input` such that `input[..., :, :] = v[..., :, :] * diag(e[..., :])`. The eigenvalues\nare sorted in non-decreasing order.\n\n```python\n# a is a tensor.\n# e is a tensor of eigenvalues.\n# v is a tensor of eigenvectors.\ne, v = self_adjoint_eig(a)\ne = self_adjoint_eig(a, compute_v=False)\n```",
      "inputs": [
        {
          "description": "`Tensor` input of shape `[N, N]`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Eigenvalues. Shape is `[N]`.",
          "name": "e",
          "typeAttr": "T"
        },
        {
          "description": "Eigenvectors. Shape is `[N, N]`.",
          "name": "v",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the eigen decomposition of one or more square self-adjoint matrices."
    }
  },
  {
    "name": "Selu",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "if < 0, `scale * features` otherwise.\n\nTo be used together with\n`initializer = tf.variance_scaling_initializer(factor=1.0, mode='FAN_IN')`.\nFor correct dropout, use `tf.contrib.nn.alpha_dropout`.\n\nSee [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)",
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes scaled exponential linear: `scale * alpha * (exp(features) - 1)`"
    }
  },
  {
    "name": "SeluGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Selu operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The outputs of the corresponding Selu operation.",
          "name": "outputs",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients * (outputs + scale * alpha)`\nif outputs < 0, `scale * gradients` otherwise.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients for the scaled exponential linear (Selu) operation."
    }
  },
  {
    "name": "SerializeIterator",
    "schema": {
      "inputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A variant tensor storing the state of the iterator contained in the\nresource.",
          "name": "serialized",
          "type": 21
        }
      ],
      "summary": "Converts the given `resource_handle` representing an iterator to a variant tensor."
    }
  },
  {
    "name": "SerializeManySparse",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 7
            },
            {
              "type": "type",
              "value": 21
            }
          ],
          "default": {
            "type": "type",
            "value": 7
          },
          "description": "The `dtype` to use for serialization; the supported types are `string`\n(default) and `variant`.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "The `SparseTensor` must have rank `R` greater than 1, and the first dimension\nis treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The serialized\n`SparseTensor` objects going into each row of `serialized_sparse` will have\nrank `R-1`.\n\nThe minibatch size `N` is extracted from `sparse_shape[0]`.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the minibatch `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
          "name": "sparse_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the minibatch `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "serialized_sparse",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` `Tensor` object."
    }
  },
  {
    "name": "SerializeSparse",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 7
            },
            {
              "type": "type",
              "value": 21
            }
          ],
          "default": {
            "type": "type",
            "value": 7
          },
          "description": "The `dtype` to use for serialization; the supported types are `string`\n(default) and `variant`.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`.",
          "name": "sparse_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "serialized_sparse",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Serialize a `SparseTensor` into a `[3]` `Tensor` object."
    }
  },
  {
    "name": "SerializeTensor",
    "schema": {
      "attributes": [
        {
          "description": "The type of the input tensor.",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A Tensor of type `T`.",
          "name": "tensor",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A serialized TensorProto proto of the input tensor.",
          "name": "serialized",
          "type": 7
        }
      ],
      "summary": "Transforms a Tensor into a serialized TensorProto proto."
    }
  },
  {
    "name": "SetSize",
    "schema": {
      "attributes": [
        {
          "default": true,
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Input `set` is a `SparseTensor` represented by `set_indices`, `set_values`,\nand `set_shape`. The last dimension contains values in a set, duplicates are\nallowed but ignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set`\nindices.",
      "inputs": [
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`.",
          "name": "set_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`.",
          "name": "set_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`.",
          "name": "set_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "For `set` ranked `n`, this is a `Tensor` with rank `n-1`, and the same 1st\n`n-1` dimensions as `set`. Each value is the number of unique elements in\nthe corresponding `[0...n-1]` dimension of `set`.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Number of unique elements along last dimension of input `set`."
    }
  },
  {
    "name": "Shape",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Returns the shape of a tensor."
    }
  },
  {
    "name": "ShapeN",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns N 1-D integer tensors representing shape of `input[i]s`.",
      "inputs": [
        {
          "name": "input",
          "numberAttr": "N",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Returns shape of tensors."
    }
  },
  {
    "name": "ShardedFilename",
    "schema": {
      "description": "   %s-%05d-of-%05d, basename, shard, num_shards.",
      "inputs": [
        {
          "name": "basename",
          "type": 7
        },
        {
          "name": "shard",
          "type": 3
        },
        {
          "name": "num_shards",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Generate a sharded filename. The filename is printf formatted as"
    }
  },
  {
    "name": "ShardedFilespec",
    "schema": {
      "inputs": [
        {
          "name": "basename",
          "type": 7
        },
        {
          "name": "num_shards",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Generate a glob pattern matching all sharded file names."
    }
  },
  {
    "name": "ShuffleAndRepeatDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "pseudorandomly.",
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "The number of output elements to buffer in an iterator over\nthis dataset. Compare with the `min_after_dequeue` attr when creating a\n`RandomShuffleQueue`.",
          "name": "buffer_size",
          "type": 9
        },
        {
          "description": "A scalar seed for the random number generator. If either `seed` or\n`seed2` is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": 9
        },
        {
          "description": "A second scalar seed to avoid seed collision.",
          "name": "seed2",
          "type": 9
        },
        {
          "description": "A scalar representing the number of times the underlying dataset\nshould be repeated. The default is `-1`, which results in infinite repetition.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that shuffles and repeats elements from `input_dataset`"
    }
  },
  {
    "name": "ShuffleDataset",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "If true, each iterator over this dataset will be given\na different pseudorandomly generated seed, based on a sequence seeded by the\n`seed` and `seed2` inputs. If false, each iterator will be given the same\nseed, and repeated iteration over this dataset will yield the exact same\nsequence of results.",
          "name": "reshuffle_each_iteration",
          "type": "bool"
        },
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "The number of output elements to buffer in an iterator over\nthis dataset. Compare with the `min_after_dequeue` attr when creating a\n`RandomShuffleQueue`.",
          "name": "buffer_size",
          "type": 9
        },
        {
          "description": "A scalar seed for the random number generator. If either `seed` or\n`seed2` is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": 9
        },
        {
          "description": "A second scalar seed to avoid seed collision.",
          "name": "seed2",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that shuffles elements from `input_dataset` pseudorandomly."
    }
  },
  {
    "name": "Sigmoid",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Activation",
      "description": "Specifically, `y = 1 / (1 + exp(-x))`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes sigmoid of `x` element-wise."
    }
  },
  {
    "name": "SigmoidGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * y * (1 - y)`, where `y = sigmoid(x)`, and\n`dy` is the corresponding input gradient.",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient of the sigmoid of `x` wrt its input."
    }
  },
  {
    "name": "Sign",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`y = sign(x) = -1` if `x < 0`; 0 if `x == 0`; 1 if `x > 0`.\n\nFor complex numbers, `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`.",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns an element-wise indication of the sign of a number."
    }
  },
  {
    "name": "Sin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes sin of x element-wise."
    }
  },
  {
    "name": "Sinh",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes hyperbolic sine of x element-wise."
    }
  },
  {
    "name": "Size",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns an integer representing the number of elements in\n`input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]\nsize(t) ==> 12\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Returns the size of a tensor."
    }
  },
  {
    "name": "SkipDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements from the `input_dataset`\nthat should be skipped.  If count is -1, skips everything.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that skips `count` elements from the `input_dataset`."
    }
  },
  {
    "name": "Skipgram",
    "schema": {
      "attributes": [
        {
          "description": "The corpus's text file name.",
          "name": "filename",
          "type": "string"
        },
        {
          "description": "The size of produced batch.",
          "name": "batch_size",
          "type": "int"
        },
        {
          "default": 5,
          "description": "The number of words to predict to the left and right of the target.",
          "name": "window_size",
          "type": "int"
        },
        {
          "default": 5,
          "description": "The minimum number of word occurrences for it to be included in the\nvocabulary.",
          "name": "min_count",
          "type": "int"
        },
        {
          "default": 0.0010000000474974513,
          "description": "Threshold for word occurrence. Words that appear with higher\nfrequency will be randomly down-sampled. Set to 0 to disable.",
          "name": "subsample",
          "type": "float"
        }
      ],
      "outputs": [
        {
          "description": "A vector of words in the corpus.",
          "name": "vocab_word",
          "type": 7
        },
        {
          "description": "Frequencies of words. Sorted in the non-ascending order.",
          "name": "vocab_freq",
          "type": 3
        },
        {
          "description": "Number of words per epoch in the data file.",
          "name": "words_per_epoch",
          "type": 9
        },
        {
          "description": "The current epoch number.",
          "name": "current_epoch",
          "type": 3
        },
        {
          "description": "The total number of words processed so far.",
          "name": "total_words_processed",
          "type": 9
        },
        {
          "description": "A vector of word ids.",
          "name": "examples",
          "type": 3
        },
        {
          "description": "A vector of word ids.",
          "name": "labels",
          "type": 3
        }
      ],
      "summary": "Parses a text file and creates a batch of examples."
    }
  },
  {
    "name": "Slice",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Index",
          "type": "type"
        }
      ],
      "description": "The output tensor is a tensor with dimensions described by 'size'\nwhose values are extracted from 'input' starting at the offsets in\n'begin'.\n\n*Requirements*:\n  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "begin[i] specifies the offset into the 'i'th dimension of\n'input' to slice from.",
          "name": "begin",
          "typeAttr": "Index"
        },
        {
          "description": "size[i] specifies the number of elements of the 'i'th dimension\nof 'input' to slice. If size[i] is -1, all remaining elements in dimension\ni are included in the slice (i.e. this is equivalent to setting\nsize[i] = input.dim_size(i) - begin[i]).",
          "name": "size",
          "typeAttr": "Index"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Return a slice from 'input'."
    }
  },
  {
    "name": "Snapshot",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a copy of the input tensor."
    }
  },
  {
    "name": "Softmax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Activation",
      "description": "For each batch `i` and class `j` we have\n\n    $$softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))$$",
      "inputs": [
        {
          "description": "2-D with shape `[batch_size, num_classes]`.",
          "name": "logits",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `logits`.",
          "name": "softmax",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softmax activations."
    }
  },
  {
    "name": "SoftmaxCrossEntropyWithLogits",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Inputs are the logits, not probabilities.",
      "inputs": [
        {
          "description": "batch_size x num_classes matrix",
          "name": "features",
          "typeAttr": "T"
        },
        {
          "description": "batch_size x num_classes matrix\nThe caller must ensure that each batch of labels represents a valid\nprobability distribution.",
          "name": "labels",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Per example loss (batch_size vector).",
          "name": "loss",
          "typeAttr": "T"
        },
        {
          "description": "backpropagated gradients (batch_size x num_classes matrix).",
          "name": "backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softmax cross entropy cost and gradients to backpropagate."
    }
  },
  {
    "name": "Softplus",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softplus: `log(exp(features) + 1)`."
    }
  },
  {
    "name": "SoftplusGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding softplus operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The features passed as input to the corresponding softplus operation.",
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients / (1 + exp(-features))`.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softplus gradients for a softplus operation."
    }
  },
  {
    "name": "Softsign",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "activations",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softsign: `features / (abs(features) + 1)`."
    }
  },
  {
    "name": "SoftsignGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding softsign operation.",
          "name": "gradients",
          "typeAttr": "T"
        },
        {
          "description": "The features passed as input to the corresponding softsign operation.",
          "name": "features",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients / (1 + abs(features)) ** 2`.",
          "name": "backprops",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softsign gradients for a softsign operation."
    }
  },
  {
    "name": "SpaceToBatch",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tpaddings",
          "type": "type"
        },
        {
          "minimum": 2,
          "name": "block_size",
          "type": "int"
        }
      ],
      "description": "This is a legacy version of the more general SpaceToBatchND.\n\nZero-pads and then rearranges (permutes) blocks of spatial data into batch.\nMore specifically, this op outputs a copy of the input tensor where values from\nthe `height` and `width` dimensions are moved to the `batch` dimension. After\nthe zero-padding, both `height` and `width` of the input must be divisible by the\nblock size.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, depth]`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\n  the padding of the input with zeros across the spatial dimensions as follows:\n\n      paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]\n\n  The effective spatial dimensions of the zero-padded input tensor will be:\n\n      height_pad = pad_top + height + pad_bottom\n      width_pad = pad_left + width + pad_right\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\n  * Non-overlapping blocks of size `block_size x block size` in the height and\n    width dimensions are rearranged into the batch dimension at each location.\n  * The batch of the output tensor is `batch * block_size * block_size`.\n  * Both height_pad and width_pad must be divisible by block_size.\n\nThe shape of the output will be:\n\n    [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n     depth]\n\nSome examples:\n\n(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 1]` and value:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\n(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 3]` and value:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\n(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[4, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\n(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[8, 1, 2, 1]` and value:\n\n```\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n```\n\nAmong others, this operation is useful for reducing atrous convolution into\nregular convolution.",
          "name": "paddings",
          "typeAttr": "Tpaddings"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "SpaceToBatch for 4-D tensors of type T."
    }
  },
  {
    "name": "SpaceToBatchND",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tblock_shape",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tpaddings",
          "type": "type"
        }
      ],
      "description": "This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into a\ngrid of blocks of shape `block_shape`, and interleaves these blocks with the\n\"batch\" dimension (0) such that in the output, the spatial dimensions\n`[1, ..., M]` correspond to the position within the grid, and the batch\ndimension combines both the position within a spatial block and the original\nbatch position.  Prior to division into blocks, the spatial dimensions of the\ninput are optionally zero padded according to `paddings`.  See below for a\nprecise description.",
      "inputs": [
        {
          "description": "N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,\nwhere spatial_shape has `M` dimensions.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "1-D with shape `[M]`, all values must be >= 1.",
          "name": "block_shape",
          "typeAttr": "Tblock_shape"
        },
        {
          "description": "2-D with shape `[M, 2]`, all values must be >= 0.\n  `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension\n  `i + 1`, which corresponds to spatial dimension `i`.  It is required that\n  `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.\n\nThis operation is equivalent to the following steps:\n\n1. Zero-pad the start and end of dimensions `[1, ..., M]` of the\n   input according to `paddings` to produce `padded` of shape `padded_shape`.\n\n2. Reshape `padded` to `reshaped_padded` of shape:\n\n     [batch] +\n     [padded_shape[1] / block_shape[0],\n       block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1],\n      block_shape[M-1]] +\n     remaining_shape\n\n3. Permute dimensions of `reshaped_padded` to produce\n   `permuted_reshaped_padded` of shape:\n\n     block_shape +\n     [batch] +\n     [padded_shape[1] / block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1]] +\n     remaining_shape\n\n4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch\n   dimension, producing an output tensor of shape:\n\n     [batch * prod(block_shape)] +\n     [padded_shape[1] / block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1]] +\n     remaining_shape\n\nSome examples:\n\n(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 1]` and value:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\n(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 3]` and value:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\n(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[4, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\n(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and\n    paddings = `[[0, 0], [2, 0]]`:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[8, 1, 3, 1]` and value:\n\n```\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n```\n\nAmong others, this operation is useful for reducing atrous convolution into\nregular convolution.",
          "name": "paddings",
          "typeAttr": "Tpaddings"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "SpaceToBatch for N-D tensors of type T."
    }
  },
  {
    "name": "SpaceToDepth",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the spatial block.",
          "minimum": 2,
          "name": "block_size",
          "type": "int"
        },
        {
          "allowedValues": [
            "NHWC",
            "NCHW",
            "NCHW_VECT_C"
          ],
          "default": "NHWC",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "Rearranges blocks of spatial data, into depth. More specifically,\nthis op outputs a copy of the input tensor where values from the `height`\nand `width` dimensions are moved to the `depth` dimension.\nThe attr `block_size` indicates the input block size.\n\n  * Non-overlapping blocks of size `block_size x block size` are rearranged\n    into depth at each location.\n  * The depth of the output tensor is `block_size * block_size * input_depth`.\n  * The Y, X coordinates within each block of the input become the high order\n    component of the output channel index.\n  * The input tensor's height and width must be divisible by block_size.\n\nThe `data_format` attr specifies the layout of the input and output tensors\nwith the following options:\n  \"NHWC\": `[ batch, height, width, channels ]`\n  \"NCHW\": `[ batch, channels, height, width ]`\n  \"NCHW_VECT_C\":\n      `qint8 [ batch, channels / 4, height, width, 4 ]`\n\nIt is useful to consider the operation as transforming a 6-D Tensor.\ne.g. for data_format = NHWC,\n     Each element in the input tensor can be specified via 6 coordinates,\n     ordered by decreasing memory layout significance as:\n     n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates\n                        within the output image, bX, bY means coordinates\n                        within the input block, iC means input channels).\n     The output would be a transpose to the following layout:\n     n,oY,oX,bY,bX,iC\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given an input of shape `[1, 2, 2, 1]`, data_format = \"NHWC\" and\nblock_size = 2:\n\n```\nx = [[[[1], [2]],\n      [[3], [4]]]]\n```\n\nThis operation will output a tensor of shape `[1, 1, 1, 4]`:\n\n```\n[[[[1, 2, 3, 4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,\nthe corresponding output will have a single element (i.e. width and height are\nboth 1) and will have a depth of 4 channels (1 * block_size * block_size).\nThe output element shape is `[1, 1, 4]`.\n\nFor an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThis operation, for block_size of 2, will return the following tensor of shape\n`[1, 1, 1, 12]`\n\n```\n[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nSimilarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:\n\n```\nx = [[[[1],   [2],  [5],  [6]],\n      [[3],   [4],  [7],  [8]],\n      [[9],  [10], [13],  [14]],\n      [[11], [12], [15],  [16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 2 2 4]`:\n\n```\nx = [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "SpaceToDepth for tensors of type T."
    }
  },
  {
    "name": "SparseAccumulatorApplyGradient",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "Boolean indicating whether gradient_shape is unknown, in which\ncase the input is ignored during validation.",
          "name": "has_known_shape",
          "type": "bool"
        }
      ],
      "description": "Does not add if local_step is smaller than the accumulator's\nglobal_step.",
      "inputs": [
        {
          "description": "The handle to a accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "The local_step value at which the sparse gradient was computed.",
          "name": "local_step",
          "type": 9
        },
        {
          "description": "Indices of the sparse gradient to be accumulated. Must be a\nvector.",
          "name": "gradient_indices",
          "type": 9
        },
        {
          "description": "Values are the non-zero slices of the gradient, and must have\nthe same first dimension as indices, i.e., the nnz represented by indices and\nvalues must be consistent.",
          "name": "gradient_values",
          "typeAttr": "dtype"
        },
        {
          "description": "Shape of the sparse gradient to be accumulated.",
          "name": "gradient_shape",
          "type": 9
        }
      ],
      "summary": "Applies a sparse gradient to a given accumulator."
    }
  },
  {
    "name": "SparseAccumulatorTakeGradient",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The op will blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated. If the accumulator has already\naggregated more than num_required gradients, it will return its\naverage of the accumulated gradients.  Also automatically increments\nthe recorded global_step in the accumulator by 1, and resets the\naggregate to 0.",
      "inputs": [
        {
          "description": "The handle to a SparseConditionalAccumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "description": "Number of gradients required before we return an aggregate.",
          "name": "num_required",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Indices of the average of the accumulated sparse gradients.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "Values of the average of the accumulated sparse gradients.",
          "name": "values",
          "typeAttr": "dtype"
        },
        {
          "description": "Shape of the average of the accumulated sparse gradients.",
          "name": "shape",
          "type": 9
        }
      ],
      "summary": "Extracts the average sparse gradient in a SparseConditionalAccumulator."
    }
  },
  {
    "name": "SparseAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "Treal",
          "type": "type"
        }
      ],
      "description": "The input `SparseTensor` objects' indices are assumed ordered in standard\nlexicographic order.  If this is not the case, before this step run\n`SparseReorder` to restore index ordering.\n\nBy default, if two values sum to zero at some index, the output `SparseTensor`\nwould still include that particular location in its index, storing a zero in the\ncorresponding value slot.  To override this, callers can specify `thresh`,\nindicating that if the sum has a magnitude strictly smaller than `thresh`, its\ncorresponding value and index would then not be included.  In particular,\n`thresh == 0` (default) means everything is kept and actual thresholding happens\nonly for a positive value.\n\nIn the following shapes, `nnz` is the count after taking `thresh` into account.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the first `SparseTensor`, size `[nnz, ndims]` Matrix.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the first `SparseTensor`, size `[nnz]` Vector.",
          "name": "a_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the first `SparseTensor`, size `[ndims]` Vector.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the second `SparseTensor`, size `[nnz, ndims]` Matrix.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the second `SparseTensor`, size `[nnz]` Vector.",
          "name": "b_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the second `SparseTensor`, size `[ndims]` Vector.",
          "name": "b_shape",
          "type": 9
        },
        {
          "description": "0-D.  The magnitude threshold that determines if an output value/index\npair takes space.",
          "name": "thresh",
          "typeAttr": "Treal"
        }
      ],
      "outputs": [
        {
          "name": "sum_indices",
          "type": 9
        },
        {
          "name": "sum_values",
          "typeAttr": "T"
        },
        {
          "name": "sum_shape",
          "type": 9
        }
      ],
      "summary": "Adds two `SparseTensor` objects to produce another `SparseTensor`."
    }
  },
  {
    "name": "SparseAddGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The SparseAdd op calculates A + B, where A, B, and the sum are all represented\nas `SparseTensor` objects.  This op takes in the upstream gradient w.r.t.\nnon-empty values of the sum, and outputs the gradients w.r.t. the non-empty\nvalues of A and B.",
      "inputs": [
        {
          "description": "1-D with shape `[nnz(sum)]`.  The gradient with respect to\nthe non-empty values of the sum.",
          "name": "backprop_val_grad",
          "typeAttr": "T"
        },
        {
          "description": "2-D.  The `indices` of the `SparseTensor` A, size `[nnz(A), ndims]`.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the `SparseTensor` B, size `[nnz(B), ndims]`.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the sum `SparseTensor`, size\n`[nnz(sum), ndims]`.",
          "name": "sum_indices",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D with shape `[nnz(A)]`. The gradient with respect to the\nnon-empty values of A.",
          "name": "a_val_grad",
          "typeAttr": "T"
        },
        {
          "description": "1-D with shape `[nnz(B)]`. The gradient with respect to the\nnon-empty values of B.",
          "name": "b_val_grad",
          "typeAttr": "T"
        }
      ],
      "summary": "The gradient operator for the SparseAdd op."
    }
  },
  {
    "name": "SparseApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": ": Should be from a Variable().",
          "isRef": true,
          "name": "accum_update",
          "typeAttr": "T"
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "var: Should be from a Variable()."
    }
  },
  {
    "name": "SparseApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": true,
          "name": "update_slots",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\n$$accum += grad * grad$$\n$$var -= lr * grad * (1 / sqrt(accum))$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme."
    }
  },
  {
    "name": "SparseApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "gradient_accumulator",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "gradient_squared_accumulator",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update entries in '*var' and '*accum' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "SparseApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\n$$ms <- rho * ms_{t-1} + (1-rho) * grad * grad$$\n$$mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$\n$$var <- var - mom$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "mg",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "ms",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "mom",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "SparseApplyFtrl",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\n$$accum_new = accum + grad * grad$$\n$$linear += grad + (accum_{new}^{-lr_{power}} - accum^{-lr_{power}} / lr * var$$\n$$quadratic = 1.0 / (accum_{new}^{lr_{power}} * lr) + 2 * l2$$\n$$var = (sign(linear) * l1 - linear) / quadratic\\ if\\ |linear| > l1\\ else\\ 0.0$$\n$$accum = accum_{new}$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "linear",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "SparseApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "linear",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "name": "l2_shrinkage",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "SparseApplyMomentum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\n$$accum = accum * momentum + grad$$\n$$var -= lr * accum$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme."
    }
  },
  {
    "name": "SparseApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\n$$accum += grad * grad$$\n$$prox_v = var$$\n$$prox_v -= lr * grad * (1 / sqrt(accum))$$\n$$var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "accum",
          "typeAttr": "T"
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Sparse update entries in '*var' and '*accum' according to FOBOS algorithm."
    }
  },
  {
    "name": "SparseApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var as follows:\n$$prox_v = var - alpha * grad$$\n$$var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "typeAttr": "T"
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "typeAttr": "T"
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Sparse update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "SparseApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\n$$ms <- rho * ms_{t-1} + (1-rho) * grad * grad$$\n$$mom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)$$\n$$var <- var - mom$$",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "var",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "ms",
          "typeAttr": "T"
        },
        {
          "description": "Should be from a Variable().",
          "isRef": true,
          "name": "mom",
          "typeAttr": "T"
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "typeAttr": "T"
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "typeAttr": "T"
        },
        {
          "name": "momentum",
          "typeAttr": "T"
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "typeAttr": "T"
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "typeAttr": "Tindices"
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "isRef": true,
          "name": "out",
          "typeAttr": "T"
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "SparseConcat",
    "schema": {
      "attributes": [
        {
          "description": "Dimension to concatenate along. Must be in range [-rank, rank),\nwhere rank is the number of dimensions in each input `SparseTensor`.",
          "name": "concat_dim",
          "type": "int"
        },
        {
          "minimum": 2,
          "name": "N",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Concatenation is with respect to the dense versions of these sparse tensors.\nIt is assumed that each input is a `SparseTensor` whose elements are ordered\nalong increasing dimension number.\n\nAll inputs' shapes must match, except for the concat dimension.  The\n`indices`, `values`, and `shapes` lists must have the same length.\n\nThe output shape is identical to the inputs', except along the concat\ndimension, where it is the sum of the inputs' sizes along that dimension.\n\nThe output elements will be resorted to preserve the sort order along\nincreasing dimension number.\n\nThis op runs in `O(M log M)` time, where `M` is the total number of non-empty\nvalues across all inputs. This is due to the need for an internal sort in\norder to concatenate efficiently across an arbitrary dimension.\n\nFor example, if `concat_dim = 1` and the inputs are\n\n    sp_inputs[0]: shape = [2, 3]\n    [0, 2]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    sp_inputs[1]: shape = [2, 4]\n    [0, 1]: \"d\"\n    [0, 2]: \"e\"\n\nthen the output will be\n\n    shape = [2, 7]\n    [0, 2]: \"a\"\n    [0, 4]: \"d\"\n    [0, 5]: \"e\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\nGraphically this is equivalent to doing\n\n    [    a] concat [  d e  ] = [    a   d e  ]\n    [b c  ]        [       ]   [b c          ]",
      "inputs": [
        {
          "description": "2-D.  Indices of each input `SparseTensor`.",
          "name": "indices",
          "numberAttr": "N",
          "type": 9
        },
        {
          "description": "1-D.  Non-empty values of each `SparseTensor`.",
          "name": "values",
          "numberAttr": "N",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shapes of each `SparseTensor`.",
          "name": "shapes",
          "numberAttr": "N",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  Indices of the concatenated `SparseTensor`.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  Non-empty values of the concatenated `SparseTensor`.",
          "name": "output_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the concatenated `SparseTensor`.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Concatenates a list of `SparseTensor` along the specified dimension."
    }
  },
  {
    "name": "SparseConditionalAccumulator",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "description": "The type of the value being accumulated.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The shape of the values.",
          "name": "shape",
          "type": "shape"
        },
        {
          "default": "",
          "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this accumulator will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "allowedValues": [
            "MEAN",
            "SUM"
          ],
          "default": "MEAN",
          "name": "reduction_type",
          "type": "string"
        }
      ],
      "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.",
      "outputs": [
        {
          "description": "The handle to the accumulator.",
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A conditional accumulator for aggregating sparse gradients."
    }
  },
  {
    "name": "SparseCross",
    "schema": {
      "attributes": [
        {
          "minimum": 0,
          "name": "N",
          "type": "int"
        },
        {
          "description": "If true, returns the hash of the cross instead of the string.\nThis will allow us avoiding string manipulations.",
          "name": "hashed_output",
          "type": "bool"
        },
        {
          "description": "It is used if hashed_output is true.\noutput = hashed_value%num_buckets if num_buckets > 0 else hashed_value.",
          "minimum": 0,
          "name": "num_buckets",
          "type": "int"
        },
        {
          "description": "Specify the hash_key that will be used by the `FingerprintCat64`\nfunction to combine the crosses fingerprints.",
          "name": "hash_key",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "minimum": 0,
          "name": "sparse_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "minimum": 0,
          "name": "dense_types",
          "type": "list(type)"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "out_type",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "internal_type",
          "type": "type"
        }
      ],
      "description": "The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each\nrepresenting features of one feature column. It outputs a 2D `SparseTensor` with\nthe batchwise crosses of these features.\n\nFor example, if the inputs are\n\n    inputs[0]: SparseTensor with shape = [2, 2]\n    [0, 0]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    inputs[1]: SparseTensor with shape = [2, 1]\n    [0, 0]: \"d\"\n    [1, 0]: \"e\"\n\n    inputs[2]: Tensor [[\"f\"], [\"g\"]]\n\nthen the output will be\n\n    shape = [2, 2]\n    [0, 0]: \"a_X_d_X_f\"\n    [1, 0]: \"b_X_e_X_g\"\n    [1, 1]: \"c_X_e_X_g\"\n\nif hashed_output=true then the output will be\n\n    shape = [2, 2]\n    [0, 0]: FingerprintCat64(\n                Fingerprint64(\"f\"), FingerprintCat64(\n                    Fingerprint64(\"d\"), Fingerprint64(\"a\")))\n    [1, 0]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"b\")))\n    [1, 1]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
      "inputs": [
        {
          "description": "2-D.  Indices of each input `SparseTensor`.",
          "name": "indices",
          "numberAttr": "N",
          "type": 9
        },
        {
          "description": "1-D.   values of each `SparseTensor`.",
          "name": "values",
          "typeListAttr": "sparse_types"
        },
        {
          "description": "1-D.   Shapes of each `SparseTensor`.",
          "name": "shapes",
          "numberAttr": "N",
          "type": 9
        },
        {
          "description": "2-D.    Columns represented by dense `Tensor`.",
          "name": "dense_inputs",
          "typeListAttr": "dense_types"
        }
      ],
      "outputs": [
        {
          "description": "2-D.  Indices of the concatenated `SparseTensor`.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  Non-empty values of the concatenated or hashed\n`SparseTensor`.",
          "name": "output_values",
          "typeAttr": "out_type"
        },
        {
          "description": "1-D.  Shape of the concatenated `SparseTensor`.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Generates sparse cross from a list of sparse and dense tensors."
    }
  },
  {
    "name": "SparseDenseCwiseAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "(1) Broadcasts the dense side to have the same shape as the sparse side, if\n    eligible;\n(2) Then, only the dense values pointed to by the indices of the SparseTensor\n    participate in the cwise addition.\n\nBy these rules, the result is a logical SparseTensor with exactly the same\nindices and shape, but possibly with different non-zero values.  The output of\nthis Op is the resultant non-zero values.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        },
        {
          "description": "`R`-D.  The dense Tensor operand.",
          "name": "dense",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `N` values that are operated on.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adds up a SparseTensor and a dense Tensor, using these special rules:"
    }
  },
  {
    "name": "SparseDenseCwiseDiv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        },
        {
          "description": "`R`-D.  The dense Tensor operand.",
          "name": "dense",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `N` values that are operated on.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Component-wise divides a SparseTensor by a dense Tensor."
    }
  },
  {
    "name": "SparseDenseCwiseMul",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The output locations corresponding to the implicitly zero elements in the sparse\ntensor will be zero (i.e., will not take up storage space), regardless of the\ncontents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).\n\n*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        },
        {
          "description": "`R`-D.  The dense Tensor operand.",
          "name": "dense",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `N` values that are operated on.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Component-wise multiplies a SparseTensor by a dense Tensor."
    }
  },
  {
    "name": "SparseFillEmptyRows",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input `SparseTensor` is represented via the tuple of inputs\n(`indices`, `values`, `dense_shape`).  The output `SparseTensor` has the\nsame `dense_shape` but with indices `output_indices` and values\n`output_values`.\n\nThis op inserts a single entry for every row that doesn't have any values.\nThe index is created as `[row, 0, ..., 0]` and the inserted value\nis `default_value`.\n\nFor example, suppose `sp_input` has shape `[5, 6]` and non-empty values:\n\n    [0, 1]: a\n    [0, 3]: b\n    [2, 0]: c\n    [3, 1]: d\n\nRows 1 and 4 are empty, so the output will be of shape `[5, 6]` with values:\n\n    [0, 1]: a\n    [0, 3]: b\n    [1, 0]: default_value\n    [2, 0]: c\n    [3, 1]: d\n    [4, 0]: default_value\n\nThe output `SparseTensor` will be in row-major order and will have the\nsame shape as the input.\n\nThis op also returns an indicator vector shaped `[dense_shape[0]]` such that\n\n    empty_row_indicator[i] = True iff row i was an empty row.\n\nAnd a reverse index map vector shaped `[indices.shape[0]]` that is used during\nbackpropagation,\n\n    reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]",
      "inputs": [
        {
          "description": "2-D. the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D. the values of the sparse tensor.",
          "name": "values",
          "typeAttr": "T"
        },
        {
          "description": "1-D. the shape of the sparse tensor.",
          "name": "dense_shape",
          "type": 9
        },
        {
          "description": "0-D. default value to insert into location `[row, 0, ..., 0]`\n  for rows missing from the input sparse tensor.\noutput indices: 2-D. the indices of the filled sparse tensor.",
          "name": "default_value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D. the values of the filled sparse tensor.",
          "name": "output_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D. whether the dense row was missing in the\ninput sparse tensor.",
          "name": "empty_row_indicator",
          "type": 10
        },
        {
          "description": "1-D. a map from the input indices to the output indices.",
          "name": "reverse_index_map",
          "type": 9
        }
      ],
      "summary": "Fills empty rows in the input 2-D `SparseTensor` with a default value."
    }
  },
  {
    "name": "SparseFillEmptyRowsGrad",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Takes vectors reverse_index_map, shaped `[N]`, and grad_values,\nshaped `[N_full]`, where `N_full >= N` and copies data into either\n`d_values` or `d_default_value`.  Here `d_values` is shaped `[N]` and\n`d_default_value` is a scalar.\n\n  d_values[j] = grad_values[reverse_index_map[j]]\n  d_default_value = sum_{k : 0 .. N_full - 1} (\n     grad_values[k] * 1{k not in reverse_index_map})",
      "inputs": [
        {
          "description": "1-D.  The reverse index map from SparseFillEmptyRows.",
          "name": "reverse_index_map",
          "type": 9
        },
        {
          "description": "1-D.  The gradients from backprop.",
          "name": "grad_values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The backprop into values.",
          "name": "d_values",
          "typeAttr": "T"
        },
        {
          "description": "0-D.  The backprop into default_value.",
          "name": "d_default_value",
          "typeAttr": "T"
        }
      ],
      "summary": "The gradient of SparseFillEmptyRows."
    }
  },
  {
    "name": "SparseMatMul",
    "schema": {
      "attributes": [
        {
          "default": false,
          "name": "transpose_a",
          "type": "bool"
        },
        {
          "default": false,
          "name": "transpose_b",
          "type": "bool"
        },
        {
          "default": false,
          "name": "a_is_sparse",
          "type": "bool"
        },
        {
          "default": false,
          "name": "b_is_sparse",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 14
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "Ta",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 14
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "Tb",
          "type": "type"
        }
      ],
      "description": "The inputs must be two-dimensional matrices and the inner dimension of \"a\" must\nmatch the outer dimension of \"b\". Both \"a\" and \"b\" must be `Tensor`s not\n`SparseTensor`s.  This op is optimized for the case where at least one of \"a\" or\n\"b\" is sparse, in the sense that they have a large proportion of zero values.\nThe breakeven for using this versus a dense matrix multiply on one platform was\n30% zero values in the sparse matrix.\n\nThe gradient computation of this operation will only take advantage of sparsity\nin the input gradient when that gradient comes from a Relu.",
      "inputs": [
        {
          "name": "a",
          "typeAttr": "Ta"
        },
        {
          "name": "b",
          "typeAttr": "Tb"
        }
      ],
      "outputs": [
        {
          "name": "product",
          "type": 1
        }
      ],
      "summary": "Multiply matrix \"a\" by matrix \"b\"."
    }
  },
  {
    "name": "SparseReduceMax",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_max()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "`R-K`-D.  The reduced Tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the max of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReduceMaxSparse",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_max()`.  In contrast to SparseReduceMax, this Op returns a\nSparseTensor.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output_indices",
          "type": 9
        },
        {
          "name": "output_values",
          "typeAttr": "T"
        },
        {
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Computes the max of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReduceSum",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "`R-K`-D.  The reduced Tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReduceSumSparse",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In contrast to SparseReduceSum, this Op returns a\nSparseTensor.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output_indices",
          "type": 9
        },
        {
          "name": "output_values",
          "typeAttr": "T"
        },
        {
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Computes the sum of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReorder",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Note that by convention, all sparse ops preserve the canonical ordering along\nincreasing dimension number. The only time ordering can be violated is during\nmanual manipulation of the indices and values vectors to add entries.\n\nReordering does not affect the shape of the SparseTensor.\n\nIf the tensor has rank `R` and `N` non-empty values, `input_indices` has\nshape `[N, R]`, input_values has length `N`, and input_shape has length `R`.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  `N x R` matrix with the same indices as input_indices, but\nin canonical row-major ordering.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `output_indices`.",
          "name": "output_values",
          "typeAttr": "T"
        }
      ],
      "summary": "Reorders a SparseTensor into the canonical, row-major ordering."
    }
  },
  {
    "name": "SparseReshape",
    "schema": {
      "description": "This operation has the same semantics as reshape on the represented dense\ntensor.  The `input_indices` are recomputed based on the requested `new_shape`.\n\nIf one component of `new_shape` is the special value -1, the size of that\ndimension is computed so that the total dense size remains constant.  At\nmost one component of `new_shape` can be -1.  The number of dense elements\nimplied by `new_shape` must be the same as the number of dense elements\noriginally implied by `input_shape`.\n\nReshaping does not affect the order of values in the SparseTensor.\n\nIf the input tensor has rank `R_in` and `N` non-empty values, and `new_shape`\nhas length `R_out`, then `input_indices` has shape `[N, R_in]`,\n`input_shape` has length `R_in`, `output_indices` has shape `[N, R_out]`, and\n`output_shape` has length `R_out`.",
      "inputs": [
        {
          "description": "2-D.  `N x R_in` matrix with the indices of non-empty values in a\nSparseTensor.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `R_in` vector with the input SparseTensor's dense shape.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  `R_out` vector with the requested new dense shape.",
          "name": "new_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  `N x R_out` matrix with the updated indices of non-empty\nvalues in the output SparseTensor.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  `R_out` vector with the full dense shape of the output\nSparseTensor.  This is the same as `new_shape` but with any -1 dimensions\nfilled in.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Reshapes a SparseTensor to represent values in a new dense shape."
    }
  },
  {
    "name": "SparseSegmentMean",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nLike `SegmentMean`, but `segment_ids` can have rank less than `data`'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the mean along sparse segments of a tensor."
    }
  },
  {
    "name": "SparseSegmentMeanGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
      "inputs": [
        {
          "description": "gradient propagated to the SparseSegmentMean op.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "indices passed to the corresponding SparseSegmentMean op.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "segment_ids passed to the corresponding SparseSegmentMean op.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "dimension 0 of \"data\" passed to SparseSegmentMean op.",
          "name": "output_dim0",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients for SparseSegmentMean."
    }
  },
  {
    "name": "SparseSegmentMeanWithNumSegments",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "Like `SparseSegmentMean`, but allows missing ids in `segment_ids`. If an id is\nmisisng, the `output` tensor at that position will be zeroed.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "Should equal the number of distinct segment IDs.",
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which has size\n`num_segments`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the mean along sparse segments of a tensor."
    }
  },
  {
    "name": "SparseSegmentSqrtN",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "N is the size of the segment being reduced.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt of N."
    }
  },
  {
    "name": "SparseSegmentSqrtNGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
      "inputs": [
        {
          "description": "gradient propagated to the SparseSegmentSqrtN op.",
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "description": "indices passed to the corresponding SparseSegmentSqrtN op.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "segment_ids passed to the corresponding SparseSegmentSqrtN op.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "dimension 0 of \"data\" passed to SparseSegmentSqrtN op.",
          "name": "output_dim0",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes gradients for SparseSegmentSqrtN."
    }
  },
  {
    "name": "SparseSegmentSqrtNWithNumSegments",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "N is the size of the segment being reduced.\n\nLike `SparseSegmentSqrtN`, but allows missing ids in `segment_ids`. If an id is\nmisisng, the `output` tensor at that position will be zeroed.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "Should equal the number of distinct segment IDs.",
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt of N."
    }
  },
  {
    "name": "SparseSegmentSum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nLike `SegmentSum`, but `segment_ids` can have rank less than `data`'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.\n\nFor example:\n\n```python\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\n# Select two rows, one segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n# => [[0 0 0 0]]\n\n# Select two rows, two segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n# => [[ 1  2  3  4]\n#     [-1 -2 -3 -4]]\n\n# Select all rows, two segments.\ntf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n# => [[0 0 0 0]\n#     [5 6 7 8]]\n\n# Which is equivalent to:\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n```",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum along sparse segments of a tensor."
    }
  },
  {
    "name": "SparseSegmentSumWithNumSegments",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "Like `SparseSegmentSum`, but allows missing ids in `segment_ids`. If an id is\nmisisng, the `output` tensor at that position will be zeroed.\n\nRead\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nFor example:\n\n```python\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\ntf.sparse_segment_sum_with_num_segments(\n    c, tf.constant([0, 1]), tf.constant([0, 0]), num_segments=3)\n# => [[0 0 0 0]\n#     [0 0 0 0]\n#     [0 0 0 0]]\n\ntf.sparse_segment_sum_with_num_segments(c,\n                                        tf.constant([0, 1]),\n                                        tf.constant([0, 2],\n                                        num_segments=4))\n# => [[ 1  2  3  4]\n#     [ 0  0  0  0]\n#     [-1 -2 -3 -4]\n#     [ 0  0  0  0]]\n```",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "Should equal the number of distinct segment IDs.",
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `num_segments`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum along sparse segments of a tensor."
    }
  },
  {
    "name": "SparseSlice",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For example, if the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    sparse_slice([0, 0], [2, 4]) = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    sparse_slice([0, 4], [2, 3]) = shape = [2, 3]\n    [ d e  ]\n    [      ]",
      "inputs": [
        {
          "description": "2-D tensor represents the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D tensor represents the values of the sparse tensor.",
          "name": "values",
          "typeAttr": "T"
        },
        {
          "description": "1-D. tensor represents the shape of the sparse tensor.",
          "name": "shape",
          "type": 9
        },
        {
          "description": "1-D. tensor represents the start of the slice.",
          "name": "start",
          "type": 9
        },
        {
          "description": "1-D. tensor represents the size of the slice.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors.",
          "name": "size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "A list of 1-D tensors represents the values of the output sparse\ntensors.",
          "name": "output_values",
          "typeAttr": "T"
        },
        {
          "description": "A list of 1-D tensors represents the shape of the output sparse\ntensors.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Slice a `SparseTensor` based on the `start` and `size`."
    }
  },
  {
    "name": "SparseSliceGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op takes in the upstream gradient w.r.t. non-empty values of\nthe sliced `SparseTensor`, and outputs the gradients w.r.t.\nthe non-empty values of input `SparseTensor`.",
      "inputs": [
        {
          "description": "1-D. The gradient with respect to\nthe non-empty values of the sliced `SparseTensor`.",
          "name": "backprop_val_grad",
          "typeAttr": "T"
        },
        {
          "description": "2-D.  The `indices` of the input `SparseTensor`.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D. tensor represents the start of the slice.",
          "name": "input_start",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the sliced `SparseTensor`.",
          "name": "output_indices",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D. The gradient with respect to the non-empty values of input `SparseTensor`.",
          "name": "val_grad",
          "typeAttr": "T"
        }
      ],
      "summary": "The gradient operator for the SparseSlice op."
    }
  },
  {
    "name": "SparseSoftmax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The inputs represent an N-D SparseTensor  with logical shape `[..., B, C]`\n(where `N >= 2`), and with indices sorted in the canonical lexicographic order.\n\nThis op is equivalent to applying the normal `tf.nn.softmax()` to each innermost\nlogical submatrix with shape `[B, C]`, but with the catch that *the implicitly\nzero elements do not participate*.  Specifically, the algorithm is equivalent\nto the following:\n\n  (1) Applies `tf.nn.softmax()` to a densified view of each innermost submatrix\n      with shape `[B, C]`, along the size-C dimension;\n  (2) Masks out the original implicitly-zero locations;\n  (3) Renormalizes the remaining elements.\n\nHence, the `SparseTensor` result has exactly the same non-zero indices and\nshape.",
      "inputs": [
        {
          "description": "2-D.  `NNZ x R` matrix with the indices of non-empty values in a\nSparseTensor, in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `NNZ` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `NNZ` values for the result `SparseTensor`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Applies softmax to a batched N-D `SparseTensor`."
    }
  },
  {
    "name": "SparseSoftmaxCrossEntropyWithLogits",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tlabels",
          "type": "type"
        }
      ],
      "description": "Unlike `SoftmaxCrossEntropyWithLogits`, this operation does not accept\na matrix of label probabilities, but rather a single label per row\nof features.  This label is considered to have probability 1.0 for the\ngiven row.\n\nInputs are the logits, not probabilities.",
      "inputs": [
        {
          "description": "batch_size x num_classes matrix",
          "name": "features",
          "typeAttr": "T"
        },
        {
          "description": "batch_size vector with values in [0, num_classes).\nThis is the label for the given minibatch entry.",
          "name": "labels",
          "typeAttr": "Tlabels"
        }
      ],
      "outputs": [
        {
          "description": "Per example loss (batch_size vector).",
          "name": "loss",
          "typeAttr": "T"
        },
        {
          "description": "backpropagated gradients (batch_size x num_classes matrix).",
          "name": "backprop",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes softmax cross entropy cost and gradients to backpropagate."
    }
  },
  {
    "name": "SparseSparseMaximum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Assumes the two SparseTensors have the same shape, i.e., no broadcasting.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, in the canonical lexicographic ordering.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `a_indices`.",
          "name": "a_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "counterpart to `a_indices` for the other operand.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "counterpart to `a_values` for the other operand; must be of the same dtype.",
          "name": "b_values",
          "typeAttr": "T"
        },
        {
          "description": "counterpart to `a_shape` for the other operand; the two shapes must be equal.",
          "name": "b_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  The indices of the output SparseTensor.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  The values of the output SparseTensor.",
          "name": "output_values",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the element-wise max of two SparseTensors."
    }
  },
  {
    "name": "SparseSparseMinimum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Assumes the two SparseTensors have the same shape, i.e., no broadcasting.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, in the canonical lexicographic ordering.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `a_indices`.",
          "name": "a_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "counterpart to `a_indices` for the other operand.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "counterpart to `a_values` for the other operand; must be of the same dtype.",
          "name": "b_values",
          "typeAttr": "T"
        },
        {
          "description": "counterpart to `a_shape` for the other operand; the two shapes must be equal.",
          "name": "b_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  The indices of the output SparseTensor.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  The values of the output SparseTensor.",
          "name": "output_values",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the element-wise min of two SparseTensors."
    }
  },
  {
    "name": "SparseSplit",
    "schema": {
      "attributes": [
        {
          "description": "The number of ways to split.",
          "minimum": 1,
          "name": "num_split",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the `shape[split_dim]` is not an integer multiple of `num_split`. Slices\n`[0 : shape[split_dim] % num_split]` gets one extra dimension.\nFor example, if `split_dim = 1` and `num_split = 2` and the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    output_tensor[0] = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    output_tensor[1] = shape = [2, 3]\n    [ d e  ]\n    [      ]",
      "inputs": [
        {
          "description": "0-D.  The dimension along which to split.  Must be in the range\n`[0, rank(shape))`.",
          "name": "split_dim",
          "type": 9
        },
        {
          "description": "2-D tensor represents the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D tensor represents the values of the sparse tensor.",
          "name": "values",
          "typeAttr": "T"
        },
        {
          "description": "1-D. tensor represents the shape of the sparse tensor.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors.",
          "name": "shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "A list of 1-D tensors represents the values of the output sparse\ntensors.",
          "name": "output_values",
          "typeAttr": "T"
        },
        {
          "description": "A list of 1-D tensors represents the shape of the output sparse\ntensors.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Split a `SparseTensor` into `num_split` tensors along one dimension."
    }
  },
  {
    "name": "SparseTensorDenseAdd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This Op does not require `a_indices` be sorted in standard lexicographic order.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`, with shape `[nnz, ndims]`.",
          "name": "a_indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`, with shape `[nnz]`.",
          "name": "a_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`, with shape `[ndims]`.",
          "name": "a_shape",
          "typeAttr": "Tindices"
        },
        {
          "description": "`ndims`-D Tensor.  With shape `a_shape`.",
          "name": "b",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`."
    }
  },
  {
    "name": "SparseTensorDenseMatMul",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tindices",
          "type": "type"
        },
        {
          "default": false,
          "description": "Use the adjoint of A in the matrix multiply.  If A is complex, this\nis transpose(conj(A)).  Otherwise it's transpose(A).",
          "name": "adjoint_a",
          "type": "bool"
        },
        {
          "default": false,
          "description": "Use the adjoint of B in the matrix multiply.  If B is complex, this\nis transpose(conj(B)).  Otherwise it's transpose(B).",
          "name": "adjoint_b",
          "type": "bool"
        }
      ],
      "description": "No validity checking is performed on the indices of A.  However, the following\ninput format is recommended for optimal behavior:\n\nif adjoint_a == false:\n  A should be sorted in lexicographically increasing order.  Use SparseReorder\n  if you're not sure.\nif adjoint_a == true:\n  A should be sorted in order of increasing dimension 1 (i.e., \"column major\"\n  order instead of \"row major\" order).",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`, size `[nnz, 2]` Matrix.",
          "name": "a_indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`, size `[nnz]` Vector.",
          "name": "a_values",
          "typeAttr": "T"
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`, size `[2]` Vector.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "2-D.  A dense Matrix.",
          "name": "b",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "product",
          "typeAttr": "T"
        }
      ],
      "summary": "Multiply SparseTensor (of rank 2) \"A\" by dense matrix \"B\"."
    }
  },
  {
    "name": "SparseTensorSliceDataset",
    "schema": {
      "attributes": [
        {
          "name": "Tvalues",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "indices",
          "type": 9
        },
        {
          "name": "values",
          "typeAttr": "Tvalues"
        },
        {
          "name": "dense_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that splits a SparseTensor into elements row-wise."
    }
  },
  {
    "name": "SparseToDense",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "If true, indices are checked to make sure they are sorted in\nlexicographic order and that there are no repeats.",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Builds an array `dense` with shape `output_shape` such that\n\n```\n# If sparse_indices is scalar\ndense[i] = (i == sparse_indices ? sparse_values : default_value)\n\n# If sparse_indices is a vector, then for each i\ndense[sparse_indices[i]] = sparse_values[i]\n\n# If sparse_indices is an n by d matrix, then for each i in [0, n)\ndense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]\n```\n\nAll other values in `dense` are set to `default_value`.  If `sparse_values` is a\nscalar, all sparse indices are set to this single value.\n\nIndices should be sorted in lexicographic order, and indices must not\ncontain any repeats. If `validate_indices` is true, these properties\nare checked during execution.",
      "inputs": [
        {
          "description": "0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete\nindex where `sparse_values[i]` will be placed.",
          "name": "sparse_indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "1-D.  Shape of the dense output tensor.",
          "name": "output_shape",
          "typeAttr": "Tindices"
        },
        {
          "description": "1-D.  Values corresponding to each row of `sparse_indices`,\nor a scalar value to be used for all sparse indices.",
          "name": "sparse_values",
          "typeAttr": "T"
        },
        {
          "description": "Scalar value to set for indices not specified in\n`sparse_indices`.",
          "name": "default_value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Dense output tensor of shape `output_shape`.",
          "name": "dense",
          "typeAttr": "T"
        }
      ],
      "summary": "Converts a sparse representation into a dense tensor."
    }
  },
  {
    "name": "SparseToSparseSetOperation",
    "schema": {
      "attributes": [
        {
          "name": "set_operation",
          "type": "string"
        },
        {
          "default": true,
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 7
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nIf `validate_indices` is `True`, `SparseToSparseSetOperation` validates the\norder and range of `set1` and `set2` indices.\n\nInput `set1` is a `SparseTensor` represented by `set1_indices`, `set1_values`,\nand `set1_shape`. For `set1` ranked `n`, 1st `n-1` dimensions must be the same\nas `set2`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nInput `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,\nand `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same\nas `set1`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set1`\nand `set2` indices.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
      "inputs": [
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set1_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set1_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`. `set1_shape[0...n-1]` must\nbe the same as `set2_shape[0...n-1]`, `set1_shape[n]` is the\nmax set size across `0...n-1` dimensions.",
          "name": "set1_shape",
          "type": 9
        },
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must\nbe the same as `set1_shape[0...n-1]`, `set2_shape[n]` is the\nmax set size across `0...n-1` dimensions.",
          "name": "set2_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2D indices of a `SparseTensor`.",
          "name": "result_indices",
          "type": 9
        },
        {
          "description": "1D values of a `SparseTensor`.",
          "name": "result_values",
          "typeAttr": "T"
        },
        {
          "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
          "name": "result_shape",
          "type": 9
        }
      ],
      "summary": "Applies set operation along last dimension of 2 `SparseTensor` inputs."
    }
  },
  {
    "name": "Split",
    "schema": {
      "attributes": [
        {
          "description": "The number of ways to split.  Must evenly divide\n`value.shape[split_dim]`.",
          "minimum": 1,
          "name": "num_split",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "category": "Tensor",
      "inputs": [
        {
          "description": "0-D.  The dimension along which to split.  Must be in the range\n`[-rank(value), rank(value))`.",
          "name": "split_dim",
          "type": 3
        },
        {
          "description": "The tensor to split.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "They are identically shaped tensors, whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`values.shape[split_dim] / num_split`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Splits a tensor into `num_split` tensors along one dimension."
    }
  },
  {
    "name": "SplitV",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "num_split",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tlen",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to split.",
          "name": "value",
          "typeAttr": "T"
        },
        {
          "description": "list containing the sizes of each output tensor along the split\ndimension. Must sum to the dimension of value along split_dim.\nCan contain one -1 indicating that dimension is to be inferred.",
          "name": "size_splits",
          "typeAttr": "Tlen"
        },
        {
          "description": "0-D.  The dimension along which to split.  Must be in the range\n`[-rank(value), rank(value))`.",
          "name": "split_dim",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Tensors whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`size_splits[i]`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Splits a tensor into `num_split` tensors along one dimension."
    }
  },
  {
    "name": "Sqrt",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = \\sqrt{x} = x^{1/2}\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes square root of x element-wise."
    }
  },
  {
    "name": "SqrtGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * 0.5 / y`, where `y = sqrt(x)`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient for the sqrt of `x` wrt its input."
    }
  },
  {
    "name": "Square",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = x * x = x^2\\\\).",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes square of x element-wise."
    }
  },
  {
    "name": "SquaredDifference",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `SquaredDifference` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns (x - y)(x - y) element-wise."
    }
  },
  {
    "name": "Squeeze",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": [],
          "description": "If specified, only squeezes the dimensions listed. The dimension\nindex starts at 0. It is an error to squeeze a dimension that is not 1. Must\nbe in the range `[-rank(input), rank(input))`.",
          "minimum": 0,
          "name": "squeeze_dims",
          "type": "list(int)"
        }
      ],
      "category": "Shape",
      "description": "Given a tensor `input`, this operation returns a tensor of the same type with\nall dimensions of size 1 removed. If you don't want to remove all size 1\ndimensions, you can remove specific size 1 dimensions by specifying\n`squeeze_dims`.\n\nFor example:\n\n```\n# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t)) ==> [2, 3]\n```\n\nOr, to remove specific size 1 dimensions:\n\n```\n# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]\n```",
      "inputs": [
        {
          "description": "The `input` to squeeze.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Contains the same data as `input`, but has one or more dimensions of\nsize 1 removed.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Removes dimensions of size 1 from the shape of a tensor."
    }
  },
  {
    "name": "Stack",
    "schema": {
      "attributes": [
        {
          "name": "elem_type",
          "type": "type"
        },
        {
          "default": "",
          "name": "stack_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated, use StackV2."
    }
  },
  {
    "name": "StackClose",
    "schema": {
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated, use StackCloseV2."
    }
  },
  {
    "name": "StackCloseV2",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a stack.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Delete the stack from its resource container."
    }
  },
  {
    "name": "StackPop",
    "schema": {
      "attributes": [
        {
          "name": "elem_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "elem",
          "typeAttr": "elem_type"
        }
      ],
      "summary": "Deprecated, use StackPopV2."
    }
  },
  {
    "name": "StackPopV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is popped.",
          "name": "elem_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a stack.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "The tensor that is popped from the top of the stack.",
          "name": "elem",
          "typeAttr": "elem_type"
        }
      ],
      "summary": "Pop the element at the top of the stack."
    }
  },
  {
    "name": "StackPush",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "name": "swap_memory",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "elem",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Deprecated, use StackPushV2."
    }
  },
  {
    "name": "StackPushV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": false,
          "description": "Swap `elem` to CPU. Default to false.",
          "name": "swap_memory",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a stack.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The tensor to be pushed onto the stack.",
          "name": "elem",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as the input 'elem'.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Push an element onto the stack."
    }
  },
  {
    "name": "StackV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elements on the stack.",
          "name": "elem_type",
          "type": "type"
        },
        {
          "default": "",
          "description": "Overrides the name used for the temporary stack resource. Default\nvalue is the name of the 'Stack' op (which is guaranteed unique).",
          "name": "stack_name",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "The maximum size of the stack if non-negative. If negative, the stack\nsize is unlimited.",
          "name": "max_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The handle to the stack.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A stack that produces elements in first-in last-out order."
    }
  },
  {
    "name": "Stage",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "description": "The maximum number of bytes allowed for Tensors in the Staging Area.\nIf > 0, inserts will block until sufficient space is available.",
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "It is necessary to match this name to the matching Unstage Op.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The basic functionality of this Op is similar to a queue with many\nfewer capabilities and options.  This Op is optimized for performance.",
      "inputs": [
        {
          "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Stage values similar to a lightweight Enqueue."
    }
  },
  {
    "name": "StageClear",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "summary": "Op removes all elements in the underlying container."
    }
  },
  {
    "name": "StagePeek",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "underlying container does not contain sufficient elements\nthis op will block until it does.   This Op is optimized for\nperformance.",
      "inputs": [
        {
          "name": "index",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op peeks at the values at the specified index.  If the"
    }
  },
  {
    "name": "StageSize",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of elements in the underlying container."
    }
  },
  {
    "name": "StatefulPartitionedCall",
    "schema": {
      "attributes": [
        {
          "description": "A list of input types.",
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "A list of output types.",
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "      A function that takes 'args', a list of tensors, and returns 'output',\n      another list of tensors. Input and output types are specified by 'Tin'\n      and 'Tout'. The function body of f will be placed and partitioned across\n      devices, setting this op apart from the regular Call op. This op is\n      stateful.",
          "name": "f",
          "type": "func"
        },
        {
          "default": "",
          "name": "config",
          "type": "string"
        },
        {
          "default": "",
          "name": "config_proto",
          "type": "string"
        },
        {
          "default": "",
          "name": "executor_type",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "A list of input tensors.",
          "name": "args",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "A list of return values.",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "returns `f(inputs)`, where `f`'s body is placed and partitioned."
    }
  },
  {
    "name": "StatefulStandardNormal",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "shape_dtype",
          "type": "type"
        }
      ],
      "description": "The generated values will have mean 0 and standard deviation 1.",
      "inputs": [
        {
          "description": "The handle of the resource variable that stores the state of the RNG.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "shape_dtype"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with random normal values.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs random values from a normal distribution."
    }
  },
  {
    "name": "StatelessIf",
    "schema": {
      "attributes": [
        {
          "name": "Tcond",
          "type": "type"
        },
        {
          "description": "A list of input types.",
          "minimum": 0,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "A list of output types.",
          "minimum": 0,
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "      A function that takes 'inputs' and returns a list of tensors, whose\n      types are the same as what else_branch returns.",
          "name": "then_branch",
          "type": "func"
        },
        {
          "description": "    A function that takes 'inputs' and returns a list of tensors, whose\n    types are the same as what then_branch returns.",
          "name": "else_branch",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "      A Tensor. If the tensor is a scalar of non-boolean type, the\n      scalar is converted to a boolean according to the\n      following rule: if the scalar is a numerical value, non-zero means\n      `True` and zero means False; if the scalar is a string, non-empty\n      means `True` and empty means `False`. If the tensor is not a scalar,\n      being empty means False and being non-empty means True.\n\n      This should only be used when the if then/else body functions do not\n      have stateful ops.",
          "name": "cond",
          "typeAttr": "Tcond"
        },
        {
          "description": "A list of input tensors.",
          "name": "input",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "A list of return values.",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "output = cond ? then_branch(input) : else_branch(input)"
    }
  },
  {
    "name": "StatelessMultinomial",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tseed",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "output_dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`\nrepresents the unnormalized log probabilities for all classes.",
          "name": "logits",
          "typeAttr": "T"
        },
        {
          "description": "0-D.  Number of independent samples to draw for each row slice.",
          "name": "num_samples",
          "type": 3
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "typeAttr": "Tseed"
        }
      ],
      "outputs": [
        {
          "description": "2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`\ncontains the drawn class labels with range `[0, num_classes)`.",
          "name": "output",
          "typeAttr": "output_dtype"
        }
      ],
      "summary": "Draws samples from a multinomial distribution."
    }
  },
  {
    "name": "StatelessRandomNormal",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tseed",
          "type": "type"
        }
      ],
      "description": "The generated values will have mean 0 and standard deviation 1.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "typeAttr": "Tseed"
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs deterministic pseudorandom values from a normal distribution."
    }
  },
  {
    "name": "StatelessRandomUniform",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tseed",
          "type": "type"
        }
      ],
      "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "typeAttr": "Tseed"
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs deterministic pseudorandom random values from a uniform distribution."
    }
  },
  {
    "name": "StatelessRandomUniformInt",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tseed",
          "type": "type"
        }
      ],
      "description": "The generated values follow a uniform distribution in the range `[minval, maxval)`.\n\nThe outputs are a deterministic function of `shape`, `seed`, `minval`, and `maxval`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "typeAttr": "Tseed"
        },
        {
          "description": "Minimum value (inclusive, scalar).",
          "name": "minval",
          "typeAttr": "dtype"
        },
        {
          "description": "Maximum value (exclusive, scalar).",
          "name": "maxval",
          "typeAttr": "dtype"
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs deterministic pseudorandom random integers from a uniform distribution."
    }
  },
  {
    "name": "StatelessTruncatedNormal",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Tseed",
          "type": "type"
        }
      ],
      "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "typeAttr": "Tseed"
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs deterministic pseudorandom values from a truncated normal distribution."
    }
  },
  {
    "name": "StatelessWhile",
    "schema": {
      "attributes": [
        {
          "description": "dtype in use.",
          "minimum": 0,
          "name": "T",
          "type": "list(type)"
        },
        {
          "description": "      A function takes 'input' and returns a tensor.  If the tensor is\n      a scalar of non-boolean, the scalar is converted to a boolean\n      according to the following rule: if the scalar is a numerical\n      value, non-zero means True and zero means False; if the scalar is\n      a string, non-empty means True and empty means False. If the\n      tensor is not a scalar, non-emptiness means True and False\n      otherwise.\n\n      This should only be used when the while condition and body functions\n      do not have stateful ops.",
          "name": "cond",
          "type": "func"
        },
        {
          "description": "      A function that takes a list of tensors and returns another\n      list of tensors. Both lists have the same types as specified\n      by T.",
          "name": "body",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "A list of input tensors whose types are T.",
          "name": "input",
          "typeListAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A list of output tensors whose types are T.",
          "name": "output",
          "typeListAttr": "T"
        }
      ],
      "summary": "output = input; While (Cond(output)) { output = Body(output) }"
    }
  },
  {
    "name": "StaticRegexFullMatch",
    "schema": {
      "attributes": [
        {
          "description": "The regular expression to match the input.",
          "name": "pattern",
          "type": "string"
        }
      ],
      "description": "The input is a string tensor of any shape. The pattern is the\nregular expression to be matched with every element of the input tensor.\nThe boolean values (True or False) of the output tensor indicate\nif the input matches the regex pattern provided.\n\nThe pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
      "inputs": [
        {
          "description": "A string tensor of the text to be processed.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A bool tensor with the same shape as `input`.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Check if the input matches the regex pattern."
    }
  },
  {
    "name": "StaticRegexReplace",
    "schema": {
      "attributes": [
        {
          "description": "The regular expression to match the input.",
          "name": "pattern",
          "type": "string"
        },
        {
          "description": "The rewrite to be applied to the matched expresion.",
          "name": "rewrite",
          "type": "string"
        },
        {
          "default": true,
          "description": "If True, the replacement is global, otherwise the replacement\nis done only on the first match.",
          "name": "replace_global",
          "type": "bool"
        }
      ],
      "description": "It follows the re2 syntax (https://github.com/google/re2/wiki/Syntax)",
      "inputs": [
        {
          "description": "The text to be processed.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The text after applying pattern and rewrite.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Replaces the match of pattern in input with rewrite."
    }
  },
  {
    "name": "StopGradient",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, this op prevents the contribution of\nits inputs to be taken into account.  Normally, the gradient generator adds ops\nto a graph to compute the derivatives of a specified 'loss' by recursively\nfinding out inputs that contributed to its computation.  If you insert this op\nin the graph it inputs are masked from the gradient generator.  They are not\ntaken into account for computing gradients.\n\nThis is useful any time you want to compute a value with TensorFlow but need\nto pretend that the value was a constant. Some examples include:\n\n*  The *EM* algorithm where the *M-step* should not involve backpropagation\n   through the output of the *E-step*.\n*  Contrastive divergence training of Boltzmann machines where, when\n   differentiating the energy function, the training must not backpropagate\n   through the graph that generated the samples from the model.\n*  Adversarial training, where no backprop should happen through the adversarial\n   example generation process.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Stops gradient computation."
    }
  },
  {
    "name": "StridedSlice",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Index",
          "type": "type"
        },
        {
          "default": 0,
          "description": "a bitmask where a bit i being 1 means to ignore the begin\nvalue and instead use the largest interval possible. At runtime\nbegin[i] will be replaced with `[0, n-1)` if `stride[i] > 0` or\n`[-1, n-1]` if `stride[i] < 0`",
          "name": "begin_mask",
          "type": "int"
        },
        {
          "default": 0,
          "description": "analogous to `begin_mask`",
          "name": "end_mask",
          "type": "int"
        },
        {
          "default": 0,
          "description": "a bitmask where bit `i` being 1 means the `i`th\nposition is actually an ellipsis. One bit at most can be 1.\nIf `ellipsis_mask == 0`, then an implicit ellipsis mask of `1 << (m+1)`\nis provided. This means that `foo[3:5] == foo[3:5, ...]`. An ellipsis\nimplicitly creates as many range specifications as necessary to fully\nspecify the sliced range for every dimension. For example for a 4-dimensional\ntensor `foo` the slice `foo[2, ..., 5:8]` implies `foo[2, :, :, 5:8]`.",
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "description": "a bitmask where bit `i` being 1 means the `i`th\nspecification creates a new shape 1 dimension. For example\n`foo[:4, tf.newaxis, :2]` would produce a shape `(4, 1, 2)` tensor.",
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "description": "a bitmask where bit `i` implies that the `i`th\nspecification should shrink the dimensionality. begin and end\nmust imply a slice of size 1 in the dimension. For example in\npython one might do `foo[:, 3, :]` which would result in\n`shrink_axis_mask` being 2.",
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "Note, most python users will want to use the Python `Tensor.__getitem__`\nor `Variable.__getitem__` rather than this op directly.\n\nThe goal of this op is to produce a new tensor with a subset of\nthe elements from the `n` dimensional `input` tensor. The subset is chosen using\na sequence of `m` sparse range specifications encoded into the arguments\nof this function. Note, in some cases\n`m` could be equal to `n`, but this need not be the case. Each\nrange specification entry can be one of the following:\n\n- An ellipsis (...). Ellipses are used to imply zero or more\n  dimensions of full-dimension selection and are produced using\n  `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n\n- A new axis. This is used to insert a new shape=1 dimension and is\n  produced using `new_axis_mask`. For example, `foo[:, ...]` where\n  `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n\n\n- A range `begin:end:stride`. This is used to specify how much to choose from\n  a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n  which represents the index of the first value to select while `end` represents\n  the index of the last value to select. The number of values selected in each\n  dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n  `begin` and `end` can be negative where `-1` is the last element, `-2` is\n  the second to last. `begin_mask` controls whether to replace the explicitly\n  given `begin` with an implicit effective value of `0` if `stride > 0` and\n  `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n  required to create the largest open interval. For example, given a shape\n  `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n  not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n  and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n  first dimension of a tensor while dropping the last two (in the original\n  order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.\n\n- A single index. This is used to keep only elements that have a given\n  index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a\n  shape `(6,)` tensor. This is encoded in `begin` and `end` and\n  `shrink_axis_mask`.\n\nEach conceptual range specification is encoded in the op's argument. This\nencoding is best understand by considering a non-trivial example. In\nparticular,\n`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as\n\n```\nbegin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)\nend = [2, 4, x, x, -3, x]\nstrides = [1, 1, x, x, -1, 1]\nbegin_mask = 1<<4 | 1 << 5 = 48\nend_mask = 1<<5 = 32\nellipsis_mask = 1<<3 = 8\nnew_axis_mask = 1<<2 4\nshrink_axis_mask = 1<<0\n```\n\nIn this case if `foo.shape` is (5, 5, 5, 5, 5, 5) the final shape of\nthe slice becomes (2, 1, 5, 5, 2, 5).\nLet us walk step by step through each argument specification.\n\n1.  The first argument in the example slice is turned into `begin = 1` and\n`end = begin + 1 = 2`. To disambiguate from the original spec `2:4` we\nalso set the appropriate bit in `shrink_axis_mask`.\n\n2. `2:4` is contributes 2, 4, 1 to begin, end, and stride. All masks have\nzero bits contributed.\n\n3. None is a synonym for `tf.newaxis`. This means insert a dimension of size 1\ndimension in the final shape. Dummy values are contributed to begin,\nend and stride, while the new_axis_mask bit is set.\n\n4. `...` grab the full ranges from as many dimensions as needed to\nfully specify a slice for every dimension of the input shape.\n\n5. `:-3:-1` shows the use of negative indices. A negative index `i` associated\nwith a dimension that has shape `s` is converted to a positive index\n`s + i`. So `-1` becomes `s-1` (i.e. the last element). This conversion\nis done internally so begin, end and strides receive x, -3, and -1.\nThe appropriate begin_mask bit is set to indicate the start range is the\nfull range (ignoring the x).\n\n6. `:` indicates that the entire contents of the corresponding dimension\nis selected. This is equivalent to `::` or `0::1`. begin, end, and strides\nreceive 0, 0, and 1, respectively. The appropriate bits in `begin_mask` and\n`end_mask` are also set.\n\n*Requirements*:\n  `0 != strides[i] for i in [0, m)`\n  `ellipsis_mask must be a power of two (only one ellipsis)`",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "`begin[k]` specifies the offset into the `k`th range specification.\nThe exact dimension this corresponds to will be determined by context.\nOut-of-bounds values will be silently clamped. If the `k`th bit of\n`begin_mask` then `begin[k]` is ignored and the full range of the\nappropriate dimension is used instead. Negative values causes indexing\nto start from the highest element e.g. If `foo==[1,2,3]` then `foo[-1]==3`.",
          "name": "begin",
          "typeAttr": "Index"
        },
        {
          "description": "`end[i]` is like `begin` with the exception that `end_mask` is\nused to determine full ranges.",
          "name": "end",
          "typeAttr": "Index"
        },
        {
          "description": "`strides[i]` specifies the increment in the `i`th specification\nafter extracting a given element. Negative indices will reverse\nthe original order. Out or range values are\nclamped to `[0,dim[i]) if slice[i]>0` or `[-1,dim[i]-1] if slice[i] < 0`",
          "name": "strides",
          "typeAttr": "Index"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Return a strided slice from `input`."
    }
  },
  {
    "name": "StridedSliceAssign",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Index",
          "type": "type"
        },
        {
          "default": 0,
          "name": "begin_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "end_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "The values of `value` are assigned to the positions in the variable\n`ref` that are selected by the slice parameters. The slice parameters\n`begin`, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s\nshape must be exactly the shape produced by the slice of `ref`.",
      "inputs": [
        {
          "isRef": true,
          "name": "ref",
          "typeAttr": "T"
        },
        {
          "name": "begin",
          "typeAttr": "Index"
        },
        {
          "name": "end",
          "typeAttr": "Index"
        },
        {
          "name": "strides",
          "typeAttr": "Index"
        },
        {
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "output_ref",
          "typeAttr": "T"
        }
      ],
      "summary": "Assign `value` to the sliced l-value reference of `ref`."
    }
  },
  {
    "name": "StridedSliceGrad",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Index",
          "type": "type"
        },
        {
          "default": 0,
          "name": "begin_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "end_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "default": 0,
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "Since `StridedSlice` cuts out pieces of its `input` which is size\n`shape`, its gradient will have the same shape (which is passed here\nas `shape`). The gradient will be zero in any element that the slice\ndoes not select.\n\nArguments are the same as StridedSliceGrad with the exception that\n`dy` is the input gradient to be propagated and `shape` is the\nshape of `StridedSlice`'s `input`.",
      "inputs": [
        {
          "name": "shape",
          "typeAttr": "Index"
        },
        {
          "name": "begin",
          "typeAttr": "Index"
        },
        {
          "name": "end",
          "typeAttr": "Index"
        },
        {
          "name": "strides",
          "typeAttr": "Index"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the gradient of `StridedSlice`."
    }
  },
  {
    "name": "StringFormat",
    "schema": {
      "attributes": [
        {
          "minimum": 0,
          "name": "T",
          "type": "list(type)"
        },
        {
          "default": "%s",
          "description": "A string, the template to format tensor summaries into.",
          "name": "template",
          "type": "string"
        },
        {
          "default": "%s",
          "description": "A string, at each placeholder in the template a subsequent tensor summary will be inserted.",
          "name": "placeholder",
          "type": "string"
        },
        {
          "default": 3,
          "description": "When formatting the tensor summaries print the first and last summarize entries of each tensor dimension.",
          "name": "summarize",
          "type": "int"
        }
      ],
      "description": "Formats a string template using a list of tensors, pretty-printing tensor summaries.",
      "inputs": [
        {
          "description": "The list of tensors to format into the placeholder string.",
          "name": "inputs",
          "typeListAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "= The resulting string scalar.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Formats a string template using a list of tensors."
    }
  },
  {
    "name": "StringJoin",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        },
        {
          "default": "",
          "description": "string, an optional join separator.",
          "name": "separator",
          "type": "string"
        }
      ],
      "description": "with the given separator (default is an empty separator).",
      "inputs": [
        {
          "description": "A list of string tensors.  The tensors must all have the same shape,\nor be scalars.  Scalars may be mixed in; these will be broadcast to the shape\nof non-scalar inputs.",
          "name": "inputs",
          "numberAttr": "N",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Joins the strings in the given list of string tensors into one tensor;"
    }
  },
  {
    "name": "StringLength",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "BYTE",
            "UTF8_CHAR"
          ],
          "default": "BYTE",
          "description": "The unit that is counted to compute string length.  One of: `\"BYTE\"` (for\nthe number of bytes in each string) or `\"UTF8_CHAR\"` (for the number of UTF-8\nencoded Unicode code points in each string).  Results are undefined\nif `unit=UTF8_CHAR` and the `input` strings do not contain structurally\nvalid UTF-8.",
          "name": "unit",
          "type": "string"
        }
      ],
      "description": "Computes the length of each string given in the input tensor.",
      "inputs": [
        {
          "description": "The string for which to compute the length.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Integer tensor that has the same shape as `input`. The output contains the\nelement-wise string lengths of `input`.",
          "name": "output",
          "type": 3
        }
      ],
      "summary": "String lengths of `input`."
    }
  },
  {
    "name": "StringSplit",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "A `bool`. If `True`, skip the empty strings from the result.",
          "name": "skip_empty",
          "type": "bool"
        }
      ],
      "description": "Let N be the size of source (typically N will be the batch size). Split each\nelement of `input` based on `delimiter` and return a `SparseTensor`\ncontaining the splitted tokens. Empty tokens are ignored.\n\n`delimiter` can be empty, or a string of split characters. If `delimiter` is an\n empty string, each element of `input` is split into individual single-byte\n character strings, including splitting of UTF-8 multibyte sequences. Otherwise\n every character of `delimiter` is a potential split point.\n\nFor example:\n  N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output\n  will be\n\n  indices = [0, 0;\n             0, 1;\n             1, 0;\n             1, 1;\n             1, 2]\n  shape = [2, 3]\n  values = ['hello', 'world', 'a', 'b', 'c']",
      "inputs": [
        {
          "description": "1-D. Strings to split.",
          "name": "input",
          "type": 7
        },
        {
          "description": "0-D. Delimiter characters (bytes), or empty string.",
          "name": "delimiter",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A dense matrix of int64 representing the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "A vector of strings corresponding to the splited values.",
          "name": "values",
          "type": 7
        },
        {
          "description": "a length-2 vector of int64 representing the shape of the sparse\ntensor, where the first value is N and the second value is the maximum number\nof tokens in a single input entry.",
          "name": "shape",
          "type": 9
        }
      ],
      "summary": "Split elements of `input` based on `delimiter` into a `SparseTensor`."
    }
  },
  {
    "name": "StringSplitV2",
    "schema": {
      "attributes": [
        {
          "default": -1,
          "description": "An `int`. If `maxsplit > 0`, limit of the split of the result.",
          "name": "maxsplit",
          "type": "int"
        }
      ],
      "description": "Let N be the size of source (typically N will be the batch size). Split each\nelement of `source` based on `sep` and return a `SparseTensor`\ncontaining the split tokens. Empty tokens are ignored.\n\nFor example, N = 2, source[0] is 'hello world' and source[1] is 'a b c',\nthen the output will be\n```\nst.indices = [0, 0;\n              0, 1;\n              1, 0;\n              1, 1;\n              1, 2]\nst.shape = [2, 3]\nst.values = ['hello', 'world', 'a', 'b', 'c']\n```\n\nIf `sep` is given, consecutive delimiters are not grouped together and are\ndeemed to delimit empty strings. For example, source of `\"1<>2<><>3\"` and\nsep of `\"<>\"` returns `[\"1\", \"2\", \"\", \"3\"]`. If `sep` is None or an empty\nstring, consecutive whitespace are regarded as a single separator, and the\nresult will contain no empty strings at the startor end if the string has\nleading or trailing whitespace.\n\nNote that the above mentioned behavior matches python's str.split.",
      "inputs": [
        {
          "description": "`1-D` string `Tensor`, the strings to split.",
          "name": "input",
          "type": 7
        },
        {
          "description": "`0-D` string `Tensor`, the delimiter character.",
          "name": "sep",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "indices",
          "type": 9
        },
        {
          "name": "values",
          "type": 7
        },
        {
          "name": "shape",
          "type": 9
        }
      ],
      "summary": "Split elements of `source` based on `sep` into a `SparseTensor`."
    }
  },
  {
    "name": "StringStrip",
    "schema": {
      "inputs": [
        {
          "description": "A string `Tensor` of any shape.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A string `Tensor` of the same shape as the input.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Strip leading and trailing whitespaces from the Tensor."
    }
  },
  {
    "name": "StringToHashBucket",
    "schema": {
      "attributes": [
        {
          "description": "The number of buckets.",
          "minimum": 1,
          "name": "num_buckets",
          "type": "int"
        }
      ],
      "description": "The hash function is deterministic on the content of the string within the\nprocess.\n\nNote that the hash function may change from time to time.\nThis functionality will be deprecated and it's recommended to use\n`tf.string_to_hash_bucket_fast()` or `tf.string_to_hash_bucket_strong()`.",
      "inputs": [
        {
          "name": "string_tensor",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets."
    }
  },
  {
    "name": "StringToHashBucketFast",
    "schema": {
      "attributes": [
        {
          "description": "The number of buckets.",
          "minimum": 1,
          "name": "num_buckets",
          "type": "int"
        }
      ],
      "description": "The hash function is deterministic on the content of the string within the\nprocess and will never change. However, it is not suitable for cryptography.\nThis function may be used when CPU time is scarce and inputs are trusted or\nunimportant. There is a risk of adversaries constructing inputs that all hash\nto the same bucket. To prevent this problem, use a strong hash function with\n`tf.string_to_hash_bucket_strong`.",
      "inputs": [
        {
          "description": "The strings to assign a hash bucket.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets."
    }
  },
  {
    "name": "StringToHashBucketStrong",
    "schema": {
      "attributes": [
        {
          "description": "The number of buckets.",
          "minimum": 1,
          "name": "num_buckets",
          "type": "int"
        },
        {
          "description": "The key for the keyed hash function passed as a list of two uint64\nelements.",
          "name": "key",
          "type": "list(int)"
        }
      ],
      "description": "The hash function is deterministic on the content of the string within the\nprocess. The hash function is a keyed hash function, where attribute `key`\ndefines the key of the hash function. `key` is an array of 2 elements.\n\nA strong hash is important when inputs may be malicious, e.g. URLs with\nadditional components. Adversaries could try to make their inputs hash to the\nsame bucket for a denial-of-service attack or to skew the results. A strong\nhash prevents this by making it difficult, if not infeasible, to compute inputs\nthat hash to the same bucket. This comes at a cost of roughly 4x higher compute\ntime than `tf.string_to_hash_bucket_fast`.",
      "inputs": [
        {
          "description": "The strings to assign a hash bucket.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets."
    }
  },
  {
    "name": "StringToNumber",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "description": "The numeric type to interpret each string in `string_tensor` as.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "(Note that int32 overflow results in an error while float overflow\nresults in a rounded value.)",
      "inputs": [
        {
          "name": "string_tensor",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Converts each string in the input Tensor to the specified numeric type."
    }
  },
  {
    "name": "Sub",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Sub` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x - y element-wise."
    }
  },
  {
    "name": "Substr",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            "BYTE",
            "UTF8_CHAR"
          ],
          "default": "BYTE",
          "description": "The unit that is used to create the substring.  One of: `\"BYTE\"` (for\ndefining position and length by bytes) or `\"UTF8_CHAR\"` (for the UTF-8\nencoded Unicode code points).  The default is `\"BYTE\"`. Results are undefined if\n`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid\nUTF-8.",
          "name": "unit",
          "type": "string"
        }
      ],
      "description": "For each string in the input `Tensor`, creates a substring starting at index\n`pos` with a total length of `len`.\n\nIf `len` defines a substring that would extend beyond the length of the input\nstring, then as many characters as possible are used.\n\nA negative `pos` indicates distance within the string backwards from the end.\n\nIf `pos` specifies an index which is out of range for any of the input strings,\nthen an `InvalidArgumentError` is thrown.\n\n`pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on\nOp creation.\n\n*NOTE*: `Substr` supports broadcasting up to two dimensions. More about\nbroadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\n---\n\nExamples\n\nUsing scalar `pos` and `len`:\n\n```python\ninput = [b'Hello', b'World']\nposition = 1\nlength = 3\n\noutput = [b'ell', b'orl']\n```\n\nUsing `pos` and `len` with same shape as `input`:\n\n```python\ninput = [[b'ten', b'eleven', b'twelve'],\n         [b'thirteen', b'fourteen', b'fifteen'],\n         [b'sixteen', b'seventeen', b'eighteen']]\nposition = [[1, 2, 3],\n            [1, 2, 3],\n            [1, 2, 3]]\nlength =   [[2, 3, 4],\n            [4, 3, 2],\n            [5, 5, 5]]\n\noutput = [[b'en', b'eve', b'lve'],\n          [b'hirt', b'urt', b'te'],\n          [b'ixtee', b'vente', b'hteen']]\n```\n\nBroadcasting `pos` and `len` onto `input`:\n\n```\ninput = [[b'ten', b'eleven', b'twelve'],\n         [b'thirteen', b'fourteen', b'fifteen'],\n         [b'sixteen', b'seventeen', b'eighteen'],\n         [b'nineteen', b'twenty', b'twentyone']]\nposition = [1, 2, 3]\nlength =   [1, 2, 3]\n\noutput = [[b'e', b'ev', b'lve'],\n          [b'h', b'ur', b'tee'],\n          [b'i', b've', b'hte'],\n          [b'i', b'en', b'nty']]\n```\n\nBroadcasting `input` onto `pos` and `len`:\n\n```\ninput = b'thirteen'\nposition = [1, 5, 7]\nlength =   [3, 2, 1]\n\noutput = [b'hir', b'ee', b'n']\n```",
      "inputs": [
        {
          "description": "Tensor of strings",
          "name": "input",
          "type": 7
        },
        {
          "description": "Scalar defining the position of first character in each substring",
          "name": "pos",
          "typeAttr": "T"
        },
        {
          "description": "Scalar defining the number of characters to include in each substring",
          "name": "len",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Tensor of substrings",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Return substrings from `Tensor` of strings."
    }
  },
  {
    "name": "Sum",
    "schema": {
      "attributes": [
        {
          "default": false,
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum of elements across dimensions of a tensor."
    }
  },
  {
    "name": "SummaryWriter",
    "schema": {
      "attributes": [
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "writer",
          "type": 20
        }
      ]
    }
  },
  {
    "name": "Svd",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "If true, left and right singular vectors will be\ncomputed and returned in `u` and `v`, respectively.\nIf false, `u` and `v` are not set and should never referenced.",
          "name": "compute_uv",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If true, compute full-sized `u` and `v`. If false\n(the default), compute only the leading `P` singular vectors.\nIgnored if `compute_uv` is `False`.",
          "name": "full_matrices",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes the SVD of each inner matrix in `input` such that\n`input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])`\n\n```python\n# a is a tensor containing a batch of matrices.\n# s is a tensor of singular values for each matrix.\n# u is the tensor containing of left singular vectors for each matrix.\n# v is the tensor containing of right singular vectors for each matrix.\ns, u, v = svd(a)\ns, _, _ = svd(a, compute_uv=False)\n```",
      "inputs": [
        {
          "description": "A tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "Singular values. Shape is `[..., P]`.",
          "name": "s",
          "typeAttr": "T"
        },
        {
          "description": "Left singular vectors. If `full_matrices` is `False` then shape is\n`[..., M, P]`; if `full_matrices` is `True` then shape is\n`[..., M, M]`. Undefined if `compute_uv` is `False`.",
          "name": "u",
          "typeAttr": "T"
        },
        {
          "description": "Left singular vectors. If `full_matrices` is `False` then shape is\n`[..., N, P]`. If `full_matrices` is `True` then shape is `[..., N, N]`.\nUndefined if `compute_uv` is false.",
          "name": "v",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the singular value decompositions of one or more matrices."
    }
  },
  {
    "name": "Switch",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `RefSwitch` and `Merge`.",
      "inputs": [
        {
          "description": "The tensor to be forwarded to the appropriate output.",
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A scalar that specifies which output port will receive data.",
          "name": "pred",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "If `pred` is false, data will be forwarded to this output.",
          "name": "output_false",
          "typeAttr": "T"
        },
        {
          "description": "If `pred` is true, data will be forwarded to this output.",
          "name": "output_true",
          "typeAttr": "T"
        }
      ],
      "summary": "Forwards `data` to the output port determined by `pred`."
    }
  },
  {
    "name": "SymbolicGradient",
    "schema": {
      "attributes": [
        {
          "description": "the type list for the input list.",
          "minimum": 1,
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "the type list for the input list.",
          "minimum": 1,
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "The function we want to compute the gradient for.\n\nThe function 'f' must be a numerical function which takes N inputs and\nproduces M outputs. Its gradient function 'g', which is computed by\nthis SymbolicGradient op is a function taking N + M inputs and\nproduces N outputs.\n\nI.e. if we have\n   (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),\nthen, g is\n   (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,\n                                     dL/dy1, dL/dy2, ..., dL/dy_M),\n\nwhere L is a scalar-value function of (x1, x2, ..., xN) (e.g., the\nloss function). dL/dx_i is the partial derivative of L with respect\nto x_i.\n\n(Needs some math expert to say the comment above better.)",
          "name": "f",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "a list of input tensors of size N + M;",
          "name": "input",
          "typeListAttr": "Tin"
        }
      ],
      "outputs": [
        {
          "description": "a list of output tensors of size N;",
          "name": "output",
          "typeListAttr": "Tout"
        }
      ],
      "summary": "Computes the gradient function for function f via backpropagation."
    }
  },
  {
    "name": "TFRecordDataset",
    "schema": {
      "inputs": [
        {
          "description": "A scalar or vector containing the name(s) of the file(s) to be\nread.",
          "name": "filenames",
          "type": 7
        },
        {
          "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
          "name": "compression_type",
          "type": 7
        },
        {
          "description": "A scalar representing the number of bytes to buffer. A value of\n0 means no buffering will be performed.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the records from one or more TFRecord files."
    }
  },
  {
    "name": "TFRecordReader",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "compression_type",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the records from a TensorFlow Records file."
    }
  },
  {
    "name": "TFRecordReaderV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "default": "",
          "name": "compression_type",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the records from a TensorFlow Records file."
    }
  },
  {
    "name": "TakeDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements from the `input_dataset`\nthat should be taken. A value of `-1` indicates that all of `input_dataset`\nis taken.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that contains `count` elements from the `input_dataset`."
    }
  },
  {
    "name": "TakeManySparseFromTensorsMap",
    "schema": {
      "attributes": [
        {
          "description": "The `dtype` of the `SparseTensor` objects stored in the\n`SparseTensorsMap`.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": "",
          "description": "The container name for the `SparseTensorsMap` read by this op.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "The shared name for the `SparseTensorsMap` read by this op.\nIt should not be blank; rather the `shared_name` or unique Operation name\nof the Op that created the original `SparseTensorsMap` should be used.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The input `sparse_handles` must be an `int64` matrix of shape `[N, 1]` where\n`N` is the minibatch size and the rows correspond to the output handles of\n`AddSparseToTensorsMap` or `AddManySparseToTensorsMap`.  The ranks of the\noriginal `SparseTensor` objects that went into the given input ops must all\nmatch.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension on the left).\n\nThe output `SparseTensor` object's shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the handles represent an input, which is a `[2, 3]` matrix\nrepresenting two original `SparseTensor` objects:\n\n```\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n```\n\nand\n\n```\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n```\n\nthen the final `SparseTensor` will be:\n\n```\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]\n```",
      "inputs": [
        {
          "description": "1-D, The `N` serialized `SparseTensor` objects.\nShape: `[N]`.",
          "name": "sparse_handles",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  The `indices` of the minibatch `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
          "name": "sparse_values",
          "typeAttr": "dtype"
        },
        {
          "description": "1-D.  The `shape` of the minibatch `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "summary": "Read `SparseTensors` from a `SparseTensorsMap` and concatenate them."
    }
  },
  {
    "name": "Tan",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes tan of x element-wise."
    }
  },
  {
    "name": "Tanh",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes hyperbolic tangent of `x` element-wise."
    }
  },
  {
    "name": "TanhGrad",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * (1 - y*y)`, where `y = tanh(x)`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "name": "y",
          "typeAttr": "T"
        },
        {
          "name": "dy",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the gradient for the tanh of `x` wrt its input."
    }
  },
  {
    "name": "TemporaryVariable",
    "schema": {
      "attributes": [
        {
          "description": "The shape of the variable tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "The type of elements in the variable tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": "",
          "description": "Overrides the name used for the temporary variable resource. Default\nvalue is the name of the 'TemporaryVariable' op (which is guaranteed unique).",
          "name": "var_name",
          "type": "string"
        }
      ],
      "description": "This is an experimental op for internal use only and it is possible to use this\nop in unsafe ways.  DO NOT USE unless you fully understand the risks.\n\nIt is the caller's responsibility to ensure that 'ref' is eventually passed to a\nmatching 'DestroyTemporaryVariable' op after all other uses have completed.\n\nOutputs a ref to the tensor state so it may be read or modified.\n\n  E.g.\n      var = state_ops._temporary_variable([1, 2], types.float_)\n      var_name = var.op.name\n      var = state_ops.assign(var, [[4.0, 5.0]])\n      var = state_ops.assign_add(var, [[6.0, 7.0]])\n      final = state_ops._destroy_temporary_variable(var, var_name=var_name)",
      "outputs": [
        {
          "description": "A reference to the variable tensor.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Returns a tensor that may be mutated, but only persists within a single step."
    }
  },
  {
    "name": "TensorArray",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": false,
          "name": "dynamic_size",
          "type": "bool"
        },
        {
          "default": true,
          "name": "clear_after_read",
          "type": "bool"
        },
        {
          "default": "",
          "name": "tensor_array_name",
          "type": "string"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "TensorArrayClose",
    "schema": {
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "TensorArrayCloseV2",
    "schema": {
      "inputs": [
        {
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Use TensorArrayCloseV3"
    }
  },
  {
    "name": "TensorArrayCloseV3",
    "schema": {
      "description": "This enables the user to close and release the resource in the middle\nof a step/run.",
      "inputs": [
        {
          "description": "The handle to a TensorArray (output of TensorArray or TensorArrayGrad).",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Delete the TensorArray from its resource container."
    }
  },
  {
    "name": "TensorArrayConcat",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape_except0",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        },
        {
          "name": "lengths",
          "type": 9
        }
      ]
    }
  },
  {
    "name": "TensorArrayConcatV2",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape_except0",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        },
        {
          "name": "lengths",
          "type": 9
        }
      ],
      "summary": "Deprecated. Use TensorArrayConcatV3"
    }
  },
  {
    "name": "TensorArrayConcatV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is returned.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "description": "The expected shape of an element, if known,\nexcluding the first dimension. Used to validate the shapes of\nTensorArray elements. If this shape is not fully specified, concatenating\nzero-size TensorArrays is an error.",
          "name": "element_shape_except0",
          "type": "shape"
        }
      ],
      "description": "Takes `T` elements of shapes\n\n  ```\n  (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)\n  ```\n\nand concatenates them into a Tensor of shape:\n\n  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```\n\nAll elements must have the same shape (excepting the first dimension).",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "All of the elements in the TensorArray, concatenated along the first\naxis.",
          "name": "value",
          "typeAttr": "dtype"
        },
        {
          "description": "A vector of the row sizes of the original T elements in the\nvalue output.  In the example above, this would be the values:\n`(n1, n2, ..., n(T-1))`.",
          "name": "lengths",
          "type": 9
        }
      ],
      "summary": "Concat the elements from the TensorArray into value `value`."
    }
  },
  {
    "name": "TensorArrayGather",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        }
      ]
    }
  },
  {
    "name": "TensorArrayGatherV2",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Deprecated. Use TensorArrayGatherV3"
    }
  },
  {
    "name": "TensorArrayGatherV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is returned.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "description": "The expected shape of an element, if known. Used to\nvalidate the shapes of TensorArray elements. If this shape is not\nfully specified, gathering zero-size TensorArrays is an error.",
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "description": "All elements selected by `indices` must have the same shape.",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The locations in the TensorArray from which to read tensor elements.",
          "name": "indices",
          "type": 3
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "All of the elements in the TensorArray, concatenated along a new\naxis (the new dimension 0).",
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Gather specific elements from the TensorArray into output `value`."
    }
  },
  {
    "name": "TensorArrayGrad",
    "schema": {
      "attributes": [
        {
          "name": "source",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "isRef": true,
          "name": "grad_handle",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "TensorArrayGradV2",
    "schema": {
      "attributes": [
        {
          "name": "source",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "grad_handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Use TensorArrayGradV3"
    }
  },
  {
    "name": "TensorArrayGradV3",
    "schema": {
      "attributes": [
        {
          "description": "The gradient source string, used to decide which gradient TensorArray\nto return.",
          "name": "source",
          "type": "string"
        }
      ],
      "description": "If the given TensorArray gradient already exists, returns a reference to it.\n\nLocks the size of the original TensorArray by disabling its dynamic size flag.\n\n**A note about the input flow_in:**\n\nThe handle flow_in forces the execution of the gradient lookup to occur\nonly after certain other operations have occurred.  For example, when\nthe forward TensorArray is dynamically sized, writes to this TensorArray\nmay resize the object.  The gradient TensorArray is statically sized based\non the size of the forward TensorArray when this operation executes.\nFurthermore, the size of the forward TensorArray is frozen by this call.\nAs a result, the flow is used to ensure that the call to generate the gradient\nTensorArray only happens after all writes are executed.\n\nIn the case of dynamically sized TensorArrays, gradient computation should\nonly be performed on read operations that have themselves been chained via\nflow to occur only after all writes have executed. That way the final size\nof the forward TensorArray is known when this operation is called.\n\n**A note about the source attribute:**\n\nTensorArray gradient calls use an accumulator TensorArray object.  If\nmultiple gradients are calculated and run in the same session, the multiple\ngradient nodes may accidentally flow through the same accumulator TensorArray.\nThis double counts and generally breaks the TensorArray gradient flow.\n\nThe solution is to identify which gradient call this particular\nTensorArray gradient is being called in.  This is performed by identifying\na unique string (e.g. \"gradients\", \"gradients_1\", ...) from the input\ngradient Tensor's name.  This string is used as a suffix when creating\nthe TensorArray gradient object here (the attribute `source`).\n\nThe attribute `source` is added as a suffix to the forward TensorArray's\nname when performing the creation / lookup, so that each separate gradient\ncalculation gets its own TensorArray accumulator.",
      "inputs": [
        {
          "description": "The handle to the forward TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "grad_handle",
          "type": 20
        },
        {
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Creates a TensorArray for storing the gradients of values in the given handle."
    }
  },
  {
    "name": "TensorArrayGradWithShape",
    "schema": {
      "attributes": [
        {
          "description": "The gradient source string, used to decide which gradient TensorArray\nto return.",
          "name": "source",
          "type": "string"
        }
      ],
      "description": "Similar to TensorArrayGradV3. However it creates an accumulator with an\nexpanded shape compared to the input TensorArray whose gradient is being\ncomputed. This enables multiple gradients for the same TensorArray to be\ncalculated using the same accumulator.",
      "inputs": [
        {
          "description": "The handle to the forward TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        },
        {
          "description": "An int32 vector representing a shape. Elements in the gradient accumulator will\nhave shape which is this shape_to_prepend value concatenated with shape of the\nelements in the TensorArray corresponding to the input handle.",
          "name": "shape_to_prepend",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "grad_handle",
          "type": 20
        },
        {
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Creates a TensorArray for storing multiple gradients of values in the given handle."
    }
  },
  {
    "name": "TensorArrayPack",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        }
      ]
    }
  },
  {
    "name": "TensorArrayRead",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "index",
          "type": 3
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        }
      ]
    }
  },
  {
    "name": "TensorArrayReadV2",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "index",
          "type": 3
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Deprecated. Use TensorArrayReadV3"
    }
  },
  {
    "name": "TensorArrayReadV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is returned.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "name": "index",
          "type": 3
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The tensor that is read from the TensorArray.",
          "name": "value",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Read an element from the TensorArray into output `value`."
    }
  },
  {
    "name": "TensorArrayScatter",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArrayScatterV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Deprecated. Use TensorArrayScatterV3"
    }
  },
  {
    "name": "TensorArrayScatterV3",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`indices` must be a vector, its length must match the first dim of `value`.",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The locations at which to write the tensor elements.",
          "name": "indices",
          "type": 3
        },
        {
          "description": "The concatenated tensor to write to the TensorArray.",
          "name": "value",
          "typeAttr": "T"
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Scatter the data from the input value into specific TensorArray elements."
    }
  },
  {
    "name": "TensorArraySize",
    "schema": {
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ]
    }
  },
  {
    "name": "TensorArraySizeV2",
    "schema": {
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Deprecated. Use TensorArraySizeV3"
    }
  },
  {
    "name": "TensorArraySizeV3",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a TensorArray (output of TensorArray or TensorArrayGrad).",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The current size of the TensorArray.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Get the current size of the TensorArray."
    }
  },
  {
    "name": "TensorArraySplit",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "lengths",
          "type": 9
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArraySplitV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "lengths",
          "type": 9
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Deprecated. Use TensorArraySplitV3"
    }
  },
  {
    "name": "TensorArraySplitV3",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Assuming that `lengths` takes on values\n\n  ```(n0, n1, ..., n(T-1))```\n\nand that `value` has shape\n\n  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```,\n\nthis splits values into a TensorArray with T tensors.\n\nTensorArray index t will be the subtensor of values with starting position\n\n  ```(n0 + n1 + ... + n(t-1), 0, 0, ...)```\n\nand having size\n\n  ```nt x d0 x d1 x ...```",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The concatenated tensor to write to the TensorArray.",
          "name": "value",
          "typeAttr": "T"
        },
        {
          "description": "The vector of lengths, how to split the rows of value into the\nTensorArray.",
          "name": "lengths",
          "type": 9
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Split the data from the input value into TensorArray elements."
    }
  },
  {
    "name": "TensorArrayUnpack",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArrayV2",
    "schema": {
      "attributes": [
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape",
          "type": "shape"
        },
        {
          "default": false,
          "name": "dynamic_size",
          "type": "bool"
        },
        {
          "default": true,
          "name": "clear_after_read",
          "type": "bool"
        },
        {
          "default": "",
          "name": "tensor_array_name",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Use TensorArrayV3"
    }
  },
  {
    "name": "TensorArrayV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elements on the tensor_array.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "description": "The expected shape of an element, if known. Used to\nvalidate the shapes of TensorArray elements. If this shape is not\nfully specified, gathering zero-size TensorArrays is an error.",
          "name": "element_shape",
          "type": "shape"
        },
        {
          "default": false,
          "description": "A boolean that determines whether writes to the TensorArray\nare allowed to grow the size.  By default, this is not allowed.",
          "name": "dynamic_size",
          "type": "bool"
        },
        {
          "default": true,
          "description": "If true (default), Tensors in the TensorArray are cleared\nafter being read.  This disables multiple read semantics but allows early\nrelease of memory.",
          "name": "clear_after_read",
          "type": "bool"
        },
        {
          "default": false,
          "description": "If true (default is false), then all\nelements in the TensorArray will be expected to have have identical shapes.\nThis allows certain behaviors, like dynamically checking for\nconsistent shapes on write, and being able to fill in properly\nshaped zero tensors on stack -- even if the element_shape attribute\nis not fully defined.",
          "name": "identical_element_shapes",
          "type": "bool"
        },
        {
          "default": "",
          "description": "Overrides the name used for the temporary tensor_array\nresource. Default value is the name of the 'TensorArray' op (which\nis guaranteed unique).",
          "name": "tensor_array_name",
          "type": "string"
        }
      ],
      "description": "Write data via Write and read via Read or Pack.",
      "inputs": [
        {
          "description": "The size of the array.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The handle to the TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A scalar used to control gradient flow.",
          "name": "flow",
          "type": 1
        }
      ],
      "summary": "An array of Tensors of given size."
    }
  },
  {
    "name": "TensorArrayWrite",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "isRef": true,
          "name": "handle",
          "type": 7
        },
        {
          "name": "index",
          "type": 3
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArrayWriteV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "handle",
          "type": 7
        },
        {
          "name": "index",
          "type": 3
        },
        {
          "name": "value",
          "typeAttr": "T"
        },
        {
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Deprecated. Use TensorArrayGradV3"
    }
  },
  {
    "name": "TensorArrayWriteV3",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The position to write to inside the TensorArray.",
          "name": "index",
          "type": 3
        },
        {
          "description": "The tensor to write to the TensorArray.",
          "name": "value",
          "typeAttr": "T"
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Push an element onto the tensor_array."
    }
  },
  {
    "name": "TensorDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "components",
          "typeListAttr": "Toutput_types"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits `components` as a tuple of tensors once."
    }
  },
  {
    "name": "TensorForestCreateTreeVariable",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree resource to be created.",
          "name": "tree_handle",
          "type": 20
        },
        {
          "description": "Serialized proto string of the boosted_trees.Tree.",
          "name": "tree_config",
          "type": 7
        }
      ],
      "summary": "Creates a tree resource and returns a handle to it."
    }
  },
  {
    "name": "TensorForestTreeDeserialize",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree resource to be restored.",
          "name": "tree_handle",
          "type": 20
        },
        {
          "description": "Serialied proto string of the boosted_trees.Tree proto.",
          "name": "tree_config",
          "type": 7
        }
      ],
      "summary": "Deserializes a proto into the tree handle"
    }
  },
  {
    "name": "TensorForestTreeIsInitializedOp",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree.",
          "name": "tree_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Whether the tree is initialized.",
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a tree has been initialized."
    }
  },
  {
    "name": "TensorForestTreePredict",
    "schema": {
      "attributes": [
        {
          "description": "Scalar, dimension of the logits.",
          "name": "logits_dimension",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "Handle to the tree resource.",
          "name": "tree_handle",
          "type": 20
        },
        {
          "description": "Rank 2 dense features tensor.",
          "name": "dense_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The logits predictions from the tree for each instance in the batch.",
          "name": "logits",
          "type": 1
        }
      ],
      "summary": "Output the logits for the given input data"
    }
  },
  {
    "name": "TensorForestTreeResourceHandleOp",
    "schema": {
      "attributes": [
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Creates a handle to a TensorForestTreeResource"
    }
  },
  {
    "name": "TensorForestTreeSerialize",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree resource to be serialized.",
          "name": "tree_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Serialied proto string of the tree resource.",
          "name": "tree_config",
          "type": 7
        }
      ],
      "summary": "Serializes the tree handle to a proto"
    }
  },
  {
    "name": "TensorForestTreeSize",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the tree resource.",
          "name": "tree_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "The size of the tree.",
          "name": "tree_size",
          "type": 3
        }
      ],
      "summary": "Get the number of nodes in a tree"
    }
  },
  {
    "name": "TensorListConcat",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "default": {
            "type": "shape",
            "value": "?"
          },
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "description": "Requires that all tensors have the same shape except the first dimension.\n\ninput_handle: The input list.\ntensor: The concated result.\nlengths: Output tensor containing sizes of the 0th dimension of tensors in the list, used for computing the gradient.\n",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        },
        {
          "name": "lengths",
          "type": 9
        }
      ],
      "summary": "Concats all tensors in the list along the 0th dimension."
    }
  },
  {
    "name": "TensorListConcatLists",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input_a",
          "type": 21
        },
        {
          "name": "input_b",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "output",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "TensorListElementShape",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "shape_type",
          "type": "type"
        }
      ],
      "description": "  input_handle: the list\n  element_shape: the shape of elements of the list",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "element_shape",
          "typeAttr": "shape_type"
        }
      ],
      "summary": "The shape of the elements of the given list, as a tensor."
    }
  },
  {
    "name": "TensorListFromTensor",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "shape_type",
          "type": "type"
        }
      ],
      "description": "Each tensor in the result list corresponds to one row of the input tensor.\n\ntensor: The input tensor.\noutput_handle: The list.",
      "inputs": [
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        },
        {
          "name": "element_shape",
          "typeAttr": "shape_type"
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ],
      "summary": "Creates a TensorList which, when stacked, has the value of `tensor`."
    }
  },
  {
    "name": "TensorListGather",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "description": "Each row in the produced Tensor corresponds to the element in the TensorList\nspecified by the given index (see `tf.gather`).  \n\ninput_handle: The input tensor list.\nindices: The indices used to index into the list.\nvalues: The tensor.",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        },
        {
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "values",
          "typeAttr": "element_dtype"
        }
      ],
      "summary": "Creates a Tensor by indexing into the TensorList."
    }
  },
  {
    "name": "TensorListGetItem",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        },
        {
          "name": "index",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "item",
          "typeAttr": "element_dtype"
        }
      ]
    }
  },
  {
    "name": "TensorListLength",
    "schema": {
      "description": "input_handle: the input list\nlength: the number of tensors in the list",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "length",
          "type": 3
        }
      ],
      "summary": "Returns the number of tensors in the input tensor list."
    }
  },
  {
    "name": "TensorListPopBack",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "description": "Fails if the list is empty.\n\ninput_handle: the input list\ntensor: the withdrawn last element of the list\nelement_dtype: the type of elements in the list\nelement_shape: the shape of the output tensor",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        },
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        }
      ],
      "summary": "Returns the last element of the input list as well as a list with all but that element."
    }
  },
  {
    "name": "TensorListPushBack",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "description": "tensor: The tensor to put on the list.\ninput_handle: The old list.\noutput_handle: A list with the elements of the old list followed by tensor.\nelement_dtype: the type of elements in the list.\nelement_shape: a shape compatible with that of elements in the list.",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        },
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ],
      "summary": "Returns a list list which has the passed-in `Tensor` as last element and the other elements of the given list in `input_handle`."
    }
  },
  {
    "name": "TensorListPushBackBatch",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "input_handles",
          "type": 21
        },
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        }
      ],
      "outputs": [
        {
          "name": "output_handles",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "TensorListReserve",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "shape_type",
          "type": "type"
        }
      ],
      "description": "element_shape: the shape of the future elements of the list\nnum_elements: the number of elements to reserve\nhandle: the output list\nelement_dtype: the desired type of elements in the list.",
      "inputs": [
        {
          "name": "element_shape",
          "typeAttr": "shape_type"
        },
        {
          "name": "num_elements",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "List of the given size with empty elements."
    }
  },
  {
    "name": "TensorListResize",
    "schema": {
      "description": "\ninput_handle: the input list\nsize: size of the output list\n",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        },
        {
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ],
      "summary": "Resizes the list."
    }
  },
  {
    "name": "TensorListScatter",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "shape_type",
          "type": "type"
        }
      ],
      "description": "Each member of the TensorList corresponds to one row of the input tensor,\nspecified by the given index (see `tf.gather`).\n\ntensor: The input tensor.\nindices: The indices used to index into the list.\nelement_shape: The shape of the elements in the list (can be less specified than\n  the shape of the tensor).  \noutput_handle: The TensorList.",
      "inputs": [
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        },
        {
          "name": "indices",
          "type": 3
        },
        {
          "name": "element_shape",
          "typeAttr": "shape_type"
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ],
      "summary": "Creates a TensorList by indexing into a Tensor."
    }
  },
  {
    "name": "TensorListSetItem",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        }
      ],
      "description": "input_handle: the list\nindex: the position in the list to which the tensor will be assigned\nitem: the element to be assigned to that position\noutput_handle: the new list, with the element in the proper position\n",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        },
        {
          "name": "index",
          "type": 3
        },
        {
          "name": "item",
          "typeAttr": "element_dtype"
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ],
      "summary": "Sets the index-th position of the list to contain the given tensor."
    }
  },
  {
    "name": "TensorListSplit",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "shape_type",
          "type": "type"
        }
      ],
      "description": "list[i] corresponds to lengths[i] tensors from the input tensor.\nThe tensor must have rank at least 1 and contain exactly sum(lengths) elements.\n\ntensor: The input tensor.\nelement_shape: A shape compatible with that of elements in the tensor.\nlengths: Vector of sizes of the 0th dimension of tensors in the list.\noutput_handle: The list.",
      "inputs": [
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        },
        {
          "name": "element_shape",
          "typeAttr": "shape_type"
        },
        {
          "name": "lengths",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ],
      "summary": "Splits a tensor into a list."
    }
  },
  {
    "name": "TensorListStack",
    "schema": {
      "attributes": [
        {
          "name": "element_dtype",
          "type": "type"
        },
        {
          "default": -1,
          "name": "num_elements",
          "type": "int"
        }
      ],
      "description": "Requires that all tensors have the same shape.\n\ninput_handle: the input list\ntensor: the gathered result\nnum_elements: optional. If not -1, the number of elements in the list.\n",
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "tensor",
          "typeAttr": "element_dtype"
        }
      ],
      "summary": "Stacks all tensors in the list."
    }
  },
  {
    "name": "TensorScatterAdd",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation creates a new tensor by adding sparse `updates` to the passed\nin `tensor`.\nThis operation is very similar to `tf.scatter_nd_add`, except that the updates\nare added onto an existing tensor (as opposed to a variable). If the memory\nfor the existing tensor cannot be re-used, a copy is made and updated.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.  The last dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.  `updates` is a tensor with shape\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of tensor_scatter_add is to add individual elements to a\ntensor by index. For example, say we want to add 4 elements in a rank-1\ntensor with 8 elements.\n\nIn Python, this scatter add operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    tensor = tf.ones([8], dtype=tf.int32)\n    updated = tf.tensor_scatter_add(tensor, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [1, 12, 1, 11, 10, 1, 1, 13]\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\nIn Python, this scatter add operation would look like this:\n\n```python\n    indices = tf.constant([[0], [2]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    tensor = tf.ones([4, 4, 4])\n    updated = tf.tensor_scatter_add(tensor, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [[[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n     [[6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8], [9, 9, 9, 9]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
      "inputs": [
        {
          "description": "Tensor to copy/update.",
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "Index tensor.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Updates to scatter into output.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A new tensor copied from tensor and updates added according to the indices.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Adds sparse `updates` to an existing tensor according to `indices`."
    }
  },
  {
    "name": "TensorScatterSub",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation creates a new tensor by subtracting sparse `updates` from the\npassed in `tensor`.\nThis operation is very similar to `tf.scatter_nd_sub`, except that the updates\nare subtracted from an existing tensor (as opposed to a variable). If the memory\nfor the existing tensor cannot be re-used, a copy is made and updated.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.  The last dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.  `updates` is a tensor with shape\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of tensor_scatter_sub is to subtract individual elements\nfrom a tensor by index. For example, say we want to insert 4 scattered elements\nin a rank-1 tensor with 8 elements.\n\nIn Python, this scatter subtract operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    tensor = tf.ones([8], dtype=tf.int32)\n    updated = tf.tensor_scatter_sub(tensor, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [1, -10, 1, -9, -8, 1, 1, -11]\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\nIn Python, this scatter add operation would look like this:\n\n```python\n    indices = tf.constant([[0], [2]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    tensor = tf.ones([4, 4, 4])\n    updated = tf.tensor_scatter_sub(tensor, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [[[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n     [[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
      "inputs": [
        {
          "description": "Tensor to copy/update.",
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "Index tensor.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Updates to scatter into output.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A new tensor copied from tensor and updates subtracted according to the indices.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Subtracts sparse `updates` from an existing tensor according to `indices`."
    }
  },
  {
    "name": "TensorScatterUpdate",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation creates a new tensor by applying sparse `updates` to the passed\nin `tensor`.\nThis operation is very similar to `tf.scatter_nd`, except that the updates are\nscattered onto an existing tensor (as opposed to a zero-tensor). If the memory\nfor the existing tensor cannot be re-used, a copy is made and updated.\n\nIf `indices` contains duplicates, then their updates are accumulated (summed).\n\n**WARNING**: The order in which updates are applied is nondeterministic, so the\noutput will be nondeterministic if `indices` contains duplicates -- because\nof some numerical approximation issues, numbers summed in different order\nmay yield different results.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.  The last dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.  `updates` is a tensor with shape\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of scatter is to insert individual elements in a tensor by\nindex. For example, say we want to insert 4 scattered elements in a rank-1\ntensor with 8 elements.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd1.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    tensor = tf.ones([8], dtype=tf.int32)\n    updated = tf.tensor_scatter_update(tensor, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [1, 11, 1, 10, 9, 1, 1, 12]\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[0], [2]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    tensor = tf.ones([4, 4, 4])\n    updated = tf.tensor_scatter_update(tensor, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],\n     [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]\n\nNote that on CPU, if an out of bound index is found, an error is returned.\nOn GPU, if an out of bound index is found, the index is ignored.",
      "inputs": [
        {
          "description": "Tensor to copy/update.",
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "Index tensor.",
          "name": "indices",
          "typeAttr": "Tindices"
        },
        {
          "description": "Updates to scatter into output.",
          "name": "updates",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A new tensor with the given shape and updates applied according\nto the indices.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Scatter `updates` into an existing tensor according to `indices`."
    }
  },
  {
    "name": "TensorSliceDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "components",
          "typeListAttr": "Toutput_types"
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits each dim-0 slice of `components` once."
    }
  },
  {
    "name": "TensorSummary",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": "",
          "description": "A json-encoded SummaryDescription proto.",
          "name": "description",
          "type": "string"
        },
        {
          "default": [],
          "description": "An unused list of strings.",
          "name": "labels",
          "type": "list(string)"
        },
        {
          "default": "",
          "description": "An unused string.",
          "name": "display_name",
          "type": "string"
        }
      ],
      "description": "This op is being phased out in favor of TensorSummaryV2, which lets callers pass\na tag as well as a serialized SummaryMetadata proto string that contains\nplugin-specific data. We will keep this op to maintain backwards compatibility.",
      "inputs": [
        {
          "description": "A tensor to serialize.",
          "name": "tensor",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with a tensor."
    }
  },
  {
    "name": "TensorSummaryV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A string attached to this summary. Used for organization in TensorBoard.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "A tensor to serialize.",
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "description": "A serialized SummaryMetadata proto. Contains plugin\ndata.",
          "name": "serialized_summary_metadata",
          "type": 7
        }
      ],
      "outputs": [
        {
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with a tensor and per-plugin data."
    }
  },
  {
    "name": "TextLineDataset",
    "schema": {
      "inputs": [
        {
          "description": "A scalar or a vector containing the name(s) of the file(s) to be\nread.",
          "name": "filenames",
          "type": 7
        },
        {
          "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
          "name": "compression_type",
          "type": 7
        },
        {
          "description": "A scalar containing the number of bytes to buffer.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the lines of one or more text files."
    }
  },
  {
    "name": "TextLineReader",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of lines to skip from the beginning of every file.",
          "name": "skip_header_lines",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the lines of a file delimited by '\\n'."
    }
  },
  {
    "name": "TextLineReaderV2",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "Number of lines to skip from the beginning of every file.",
          "name": "skip_header_lines",
          "type": "int"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the lines of a file delimited by '\\n'."
    }
  },
  {
    "name": "ThreadUnsafeUnigramCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "minimum": 1,
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "minimum": 1,
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "minimum": 1,
          "name": "range_max",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "Tile",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tmultiples",
          "type": "type"
        }
      ],
      "description": "This operation creates a new tensor by replicating `input` `multiples` times.\nThe output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,\nand the values of `input` are replicated `multiples[i]` times along the 'i'th\ndimension. For example, tiling `[a b c d]` by `[2]` produces\n`[a b c d a b c d]`.",
      "inputs": [
        {
          "description": "1-D or higher.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "1-D. Length must be the same as the number of dimensions in `input`",
          "name": "multiples",
          "typeAttr": "Tmultiples"
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Constructs a tensor by tiling a given tensor."
    }
  },
  {
    "name": "TileGrad",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Since `Tile` takes an input and repeats the input `multiples` times\nalong each dimension, `TileGrad` takes in `multiples` and aggregates\neach repeated tile of `input` into `output`.",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        },
        {
          "name": "multiples",
          "type": 3
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns the gradient of `Tile`."
    }
  },
  {
    "name": "Timestamp",
    "schema": {
      "description": "Returns the timestamp as a `float64` for seconds since the Unix epoch.\n\nNote: the timestamp is computed when the op is executed, not when it is added\nto the graph.",
      "outputs": [
        {
          "name": "ts",
          "type": 2
        }
      ],
      "summary": "Provides the time since epoch in seconds."
    }
  },
  {
    "name": "TopK",
    "schema": {
      "attributes": [
        {
          "description": "Number of top elements to look for along the last dimension (along each\nrow for matrices).",
          "minimum": 0,
          "name": "k",
          "type": "int"
        },
        {
          "default": true,
          "description": "If true the resulting `k` elements will be sorted by the values in\ndescending order.",
          "name": "sorted",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.\n\nIf `k` varies dynamically, use `TopKV2` below.",
      "inputs": [
        {
          "description": "1-D or higher with last dimension at least `k`.",
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The `k` largest elements along each last dimensional slice.",
          "name": "values",
          "typeAttr": "T"
        },
        {
          "description": "The indices of `values` within the last dimension of `input`.",
          "name": "indices",
          "type": 3
        }
      ],
      "summary": "Finds values and indices of the `k` largest elements for the last dimension."
    }
  },
  {
    "name": "TopKV2",
    "schema": {
      "attributes": [
        {
          "default": true,
          "description": "If true the resulting `k` elements will be sorted by the values in\ndescending order.",
          "name": "sorted",
          "type": "bool"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.",
      "inputs": [
        {
          "description": "1-D or higher with last dimension at least `k`.",
          "name": "input",
          "typeAttr": "T"
        },
        {
          "description": "0-D.  Number of top elements to look for along the last dimension (along each\nrow for matrices).",
          "name": "k",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The `k` largest elements along each last dimensional slice.",
          "name": "values",
          "typeAttr": "T"
        },
        {
          "description": "The indices of `values` within the last dimension of `input`.",
          "name": "indices",
          "type": 3
        }
      ],
      "summary": "Finds values and indices of the `k` largest elements for the last dimension."
    }
  },
  {
    "name": "Transpose",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tperm",
          "type": "type"
        }
      ],
      "description": "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "perm",
          "typeAttr": "Tperm"
        }
      ],
      "outputs": [
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Shuffle dimensions of x according to a permutation."
    }
  },
  {
    "name": "TruncateDiv",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Truncation designates that negative numbers will round fractional quantities\ntoward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different\nthan Python semantics. See `FloorDiv` for a division function that matches\nPython Semantics.\n\n*NOTE*: `TruncateDiv` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns x / y element-wise for integer types."
    }
  },
  {
    "name": "TruncateMod",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "the result here is consistent with a truncating divide. E.g. `truncate(x / y) *\ny + truncate_mod(x, y) = x`.\n\n*NOTE*: `TruncateMod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns element-wise remainder of division. This emulates C semantics in that"
    }
  },
  {
    "name": "TruncatedNormal",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with random truncated normal\nvalues.",
          "name": "output",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Outputs random values from a truncated normal distribution."
    }
  },
  {
    "name": "TryRpc",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "RPC protocol to use.  Empty string means use the default protocol.\nOptions include 'grpc'.",
          "name": "protocol",
          "type": "string"
        },
        {
          "default": true,
          "description": "`boolean`. If `true` (default), then failures to connect\n(i.e., the server does not immediately respond) cause an RPC failure.",
          "name": "fail_fast",
          "type": "bool"
        },
        {
          "default": 0,
          "description": "`int`. If `0` (default), then the kernel will run the RPC\nrequest and only time out if the RPC deadline passes or the session times out.\nIf this value is greater than `0`, then the op will raise an exception if\nthe RPC takes longer than `timeout_in_ms`.",
          "name": "timeout_in_ms",
          "type": "int"
        }
      ],
      "description": "This op asynchronously performs either a single RPC request, or a batch\nof requests.  RPC requests are defined by three main parameters:\n\n  - `address` (the host+port or BNS address of the request)\n  - `method` (the method name for the request)\n  - `request` (the serialized proto string, or vector of strings,\n     of the RPC request argument).\n\nFor example, if you have an RPC service running on port localhost:2345,\nand its interface is configured with the following proto declaration:\n\n```\nservice MyService {\n  rpc MyMethod(MyRequestProto) returns (MyResponseProto) {\n  }\n};\n```\n\nthen call this op with arguments:\n\n```\naddress = \"localhost:2345\"\nmethod = \"MyService/MyMethod\"\n```\n\nThe `request` tensor is a string tensor representing serialized `MyRequestProto`\nstrings; and the output string tensor `response` will have the same shape\nand contain (upon successful completion) corresponding serialized\n`MyResponseProto` strings.\n\nFor example, to send a single, empty, `MyRequestProto`, call\nthis op with `request = \"\"`.  To send 5 **parallel** empty requests,\ncall this op with `request = [\"\", \"\", \"\", \"\", \"\"]`.\n\nMore generally, one can create a batch of `MyRequestProto` serialized protos\nfrom regular batched tensors using the `encode_proto` op, and convert\nthe response `MyResponseProto` serialized protos to batched tensors\nusing the `decode_proto` op.\n\n**NOTE** Working with serialized proto strings is faster than instantiating\nactual proto objects in memory, so no performance degradation is expected\ncompared to writing custom kernels for this workflow.\n\nUnlike the standard `Rpc` op, if the connection fails or the remote worker\nreturns an error status, this op does **not** reraise the exception.\nInstead, the `status_code` and `status_message` entry for the corresponding RPC\ncall is set with the error returned from the RPC call.  The `response` tensor\nwill contain valid response values for those minibatch entries whose RPCs did\nnot fail; the rest of the entries will have empty strings.",
      "inputs": [
        {
          "description": "`0-D` or `1-D`.  The address (i.e. host_name:port) of the RPC server.\nIf this tensor has more than 1 element, then multiple parallel rpc requests\nare sent.  This argument broadcasts with `method` and `request`.",
          "name": "address",
          "type": 7
        },
        {
          "description": "`0-D` or `1-D`.  The method address on the RPC server.\nIf this tensor has more than 1 element, then multiple parallel rpc requests\nare sent.  This argument broadcasts with `address` and `request`.",
          "name": "method",
          "type": 7
        },
        {
          "description": "`0-D` or `1-D`.  Serialized proto strings: the rpc request argument.\nIf this tensor has more than 1 element, then multiple parallel rpc requests\nare sent.  This argument broadcasts with `address` and `method`.",
          "name": "request",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `request`. Serialized proto strings: the rpc responses.",
          "name": "response",
          "type": 7
        },
        {
          "description": "Same shape as `request`.  Values correspond to tensorflow Status enum codes.",
          "name": "status_code",
          "type": 3
        },
        {
          "description": "Same shape as `request`.  Values correspond to Status messages\nreturned from the RPC calls.",
          "name": "status_message",
          "type": 7
        }
      ],
      "summary": "Perform batches of RPC requests."
    }
  },
  {
    "name": "Unbatch",
    "schema": {
      "attributes": [
        {
          "name": "timeout_micros",
          "type": "int"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "An instance of Unbatch either receives an empty batched_tensor, in which case it\nasynchronously waits until the values become available from a concurrently\nrunning instance of Unbatch with the same container and shared_name, or receives\na non-empty batched_tensor in which case it finalizes all other concurrently\nrunning instances and outputs its own element from the batch.\n\nbatched_tensor: The possibly transformed output of Batch. The size of the first\n dimension should remain unchanged by the transformations for the operation to\n work.\nbatch_index: The matching batch_index obtained from Batch.\nid: The id scalar emitted by Batch.\nunbatched_tensor: The Tensor corresponding to this execution.\ntimeout_micros: Maximum amount of time (in microseconds) to wait to receive the\n batched input tensor associated with a given invocation of the op.\ncontainer: Container to control resource sharing.\nshared_name: Instances of Unbatch with the same container and shared_name are\n assumed to possibly belong to the same batch. If left empty, the op name will\n be used as the shared name.",
      "inputs": [
        {
          "name": "batched_tensor",
          "typeAttr": "T"
        },
        {
          "name": "batch_index",
          "type": 9
        },
        {
          "name": "id",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "unbatched_tensor",
          "typeAttr": "T"
        }
      ],
      "summary": "Reverses the operation of Batch for a single output Tensor."
    }
  },
  {
    "name": "UnbatchGrad",
    "schema": {
      "attributes": [
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        },
        {
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Acts like Batch but using the given batch_index index of batching things as they\nbecome available. This ensures that the gradients are propagated back in the\nsame session which did the forward pass.\n\noriginal_input: The input to the Unbatch operation this is the gradient of.\nbatch_index: The batch_index given to the Unbatch operation this is the gradient\nof.\ngrad: The downstream gradient.\nid: The id scalar emitted by Batch.\nbatched_grad: The return value, either an empty tensor or the batched gradient.\ncontainer: Container to control resource sharing.\nshared_name: Instances of UnbatchGrad with the same container and shared_name\n are assumed to possibly belong to the same batch. If left empty, the op name\n will be used as the shared name.",
      "inputs": [
        {
          "name": "original_input",
          "typeAttr": "T"
        },
        {
          "name": "batch_index",
          "type": 9
        },
        {
          "name": "grad",
          "typeAttr": "T"
        },
        {
          "name": "id",
          "type": 9
        }
      ],
      "outputs": [
        {
          "name": "batched_grad",
          "typeAttr": "T"
        }
      ],
      "summary": "Gradient of Unbatch."
    }
  },
  {
    "name": "UnicodeDecode",
    "schema": {
      "attributes": [
        {
          "description": "Text encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: `\"UTF-16\", \"US ASCII\", \"UTF-8\"`.",
          "name": "input_encoding",
          "type": "string"
        },
        {
          "allowedValues": [
            "strict",
            "replace",
            "ignore"
          ],
          "default": "replace",
          "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter.",
          "name": "errors",
          "type": "string"
        },
        {
          "default": 65533,
          "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)",
          "name": "replacement_char",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether to replace the C0 control characters (00-1F) with the\n`replacement_char`. Default is false.",
          "name": "replace_control_characters",
          "type": "bool"
        }
      ],
      "description": "The character codepoints for all strings are returned using a single vector\n`char_values`, with strings expanded to characters in row-major order.\n\nThe `row_splits` tensor indicates where the codepoints for\neach input string begin and end within the `char_values` tensor.\nIn particular, the values for the `i`th\nstring (in row-major order) are stored in the slice\n`[row_splits[i]:row_splits[i+1]]`. Thus:\n\n* `char_values[row_splits[i]+j]` is the Unicode codepoint for the `j`th\n  character in the `i`th string (in row-major order).\n* `row_splits[i+1] - row_splits[i]` is the number of characters in the `i`th\n  string (in row-major order).",
      "inputs": [
        {
          "description": "The text to be decoded. Can have any shape. Note that the output is flattened\nto a vector of char values.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A 1D int32 tensor containing the row splits.",
          "name": "row_splits",
          "type": 9
        },
        {
          "description": "A 1D int32 Tensor containing the decoded codepoints.",
          "name": "char_values",
          "type": 3
        }
      ],
      "summary": "Decodes each string in `input` into a sequence of Unicode code points."
    }
  },
  {
    "name": "UnicodeDecodeWithOffsets",
    "schema": {
      "attributes": [
        {
          "description": "Text encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: `\"UTF-16\", \"US ASCII\", \"UTF-8\"`.",
          "name": "input_encoding",
          "type": "string"
        },
        {
          "allowedValues": [
            "strict",
            "replace",
            "ignore"
          ],
          "default": "replace",
          "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter.",
          "name": "errors",
          "type": "string"
        },
        {
          "default": 65533,
          "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)",
          "name": "replacement_char",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether to replace the C0 control characters (00-1F) with the\n`replacement_char`. Default is false.",
          "name": "replace_control_characters",
          "type": "bool"
        }
      ],
      "description": "The character codepoints for all strings are returned using a single vector\n`char_values`, with strings expanded to characters in row-major order.\nSimilarly, the character start byte offsets are returned using a single vector\n`char_to_byte_starts`, with strings expanded in row-major order.\n\nThe `row_splits` tensor indicates where the codepoints and start offsets for\neach input string begin and end within the `char_values` and\n`char_to_byte_starts` tensors.  In particular, the values for the `i`th\nstring (in row-major order) are stored in the slice\n`[row_splits[i]:row_splits[i+1]]`. Thus:\n\n* `char_values[row_splits[i]+j]` is the Unicode codepoint for the `j`th\n  character in the `i`th string (in row-major order).\n* `char_to_bytes_starts[row_splits[i]+j]` is the start byte offset for the `j`th\n  character in the `i`th string (in row-major order).\n* `row_splits[i+1] - row_splits[i]` is the number of characters in the `i`th\n  string (in row-major order).",
      "inputs": [
        {
          "description": "The text to be decoded. Can have any shape. Note that the output is flattened\nto a vector of char values.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A 1D int32 tensor containing the row splits.",
          "name": "row_splits",
          "type": 9
        },
        {
          "description": "A 1D int32 Tensor containing the decoded codepoints.",
          "name": "char_values",
          "type": 3
        },
        {
          "description": "A 1D int32 Tensor containing the byte index in the input string where each\ncharacter in `char_values` starts.",
          "name": "char_to_byte_starts",
          "type": 9
        }
      ],
      "summary": "Decodes each string in `input` into a sequence of Unicode code points."
    }
  },
  {
    "name": "UnicodeEncode",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            "ignore",
            "replace",
            "strict"
          ],
          "default": "replace",
          "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter.",
          "name": "errors",
          "type": "string"
        },
        {
          "allowedValues": [
            "UTF-8",
            "UTF-16-BE",
            "UTF-32-BE"
          ],
          "description": "Unicode encoding of the output strings. Valid encodings are: `\"UTF-8\",\n\"UTF-16-BE\", and \"UTF-32-BE\"`.",
          "name": "output_encoding",
          "type": "string"
        },
        {
          "default": 65533,
          "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD (U+65533).",
          "name": "replacement_char",
          "type": "int"
        }
      ],
      "description": "Returns a vector of strings, where `output[i]` is constructed by encoding the\nUnicode codepoints in `input_values[input_splits[i]:input_splits[i+1]]`\nusing `output_encoding`.\n\n---\n\nExample:\n\n```\ninput_values = [72, 101, 108, 108, 111, 87, 111, 114, 108, 100]\ninput_splits = [0, 5, 10]\noutput_encoding = 'UTF-8'\n\noutput = ['Hello', 'World']\n```",
      "inputs": [
        {
          "description": "A 1D tensor containing the unicode codepoints that should be encoded.",
          "name": "input_values",
          "type": 3
        },
        {
          "description": "A 1D tensor specifying how the unicode codepoints should be split into strings.\nIn particular, `output[i]` is constructed by encoding the codepoints in the\nslice `input_values[input_splits[i]:input_splits[i+1]]`.",
          "name": "input_splits",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "The 1-D Tensor of strings encoded from the provided unicode codepoints.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Encode a tensor of ints into unicode strings."
    }
  },
  {
    "name": "UnicodeScript",
    "schema": {
      "description": "This operation converts Unicode code points to script codes corresponding to\neach code point. Script codes correspond to International Components for\nUnicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html.\nReturns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will\nmatch input shape.",
      "inputs": [
        {
          "description": "A Tensor of int32 Unicode code points.",
          "name": "input",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of int32 script codes corresponding to each input code point.",
          "name": "output",
          "type": 3
        }
      ],
      "summary": "Determine the script codes of a given tensor of Unicode integer code points."
    }
  },
  {
    "name": "UnicodeTranscode",
    "schema": {
      "attributes": [
        {
          "description": "Text encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: `\"UTF-16\", \"US ASCII\", \"UTF-8\"`.",
          "name": "input_encoding",
          "type": "string"
        },
        {
          "allowedValues": [
            "UTF-8",
            "UTF-16-BE",
            "UTF-32-BE"
          ],
          "description": "The unicode encoding to use in the output. Must be one of\n`\"UTF-8\", \"UTF-16-BE\", \"UTF-32-BE\"`. Multi-byte encodings will be big-endian.",
          "name": "output_encoding",
          "type": "string"
        },
        {
          "allowedValues": [
            "strict",
            "replace",
            "ignore"
          ],
          "default": "replace",
          "description": "Error handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\n`replacement_char` codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter.",
          "name": "errors",
          "type": "string"
        },
        {
          "default": 65533,
          "description": "The replacement character codepoint to be used in place of any invalid\nformatting in the input when `errors='replace'`. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)\n\nNote that for UTF-8, passing a replacement character expressible in 1 byte, such\nas ' ', will preserve string alignment to the source since invalid bytes will be\nreplaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte\nreplacement character will preserve byte alignment to the source.",
          "name": "replacement_char",
          "type": "int"
        },
        {
          "default": false,
          "description": "Whether to replace the C0 control characters (00-1F) with the\n`replacement_char`. Default is false.",
          "name": "replace_control_characters",
          "type": "bool"
        }
      ],
      "description": "The input is a string tensor of any shape. The output is a string tensor of\nthe same shape containing the transcoded strings. Output strings are always\nvalid unicode. If the input contains invalid encoding positions, the\n`errors` attribute sets the policy for how to deal with them. If the default\nerror-handling policy is used, invalid formatting will be substituted in the\noutput by the `replacement_char`. If the errors policy is to `ignore`, any\ninvalid encoding positions in the input are skipped and not included in the\noutput. If it set to `strict` then any invalid formatting will result in an\nInvalidArgument error.\n\nThis operation can be used with `output_encoding = input_encoding` to enforce\ncorrect formatting for inputs even if they are already in the desired encoding.\n\nIf the input is prefixed by a Byte Order Mark needed to determine encoding\n(e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that\nBOM will be consumed and not emitted into the output. If the input encoding\nis marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is\ninterpreted as a non-breaking-space and is preserved in the output (including\nalways for UTF-8).\n\nThe end result is that if the input is marked as an explicit endianness the\ntranscoding is faithful to all codepoints in the source. If it is not marked\nwith an explicit endianness, the BOM is not considered part of the string itself\nbut as metadata, and so is not preserved in the output.",
      "inputs": [
        {
          "description": "The text to be processed. Can have any shape.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A string tensor containing unicode text encoded using `output_encoding`.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Transcode the input text from a source encoding to a destination encoding."
    }
  },
  {
    "name": "UniformCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "minimum": 1,
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "minimum": 1,
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "minimum": 1,
          "name": "range_max",
          "type": "int"
        },
        {
          "default": 0,
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "default": 0,
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a uniform distribution."
    }
  },
  {
    "name": "Unique",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```",
      "inputs": [
        {
          "description": "1-D.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "1-D.",
          "name": "idx",
          "typeAttr": "out_idx"
        }
      ],
      "summary": "Finds unique elements in a 1-D tensor."
    }
  },
  {
    "name": "UniqueV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Taxis",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "This operation either returns a tensor `y` containing unique elements\nalong the `axis` of a tensor. The returned unique elements is sorted\nin the same order as they occur along `axis` in `x`.\nThis operation also returns a tensor `idx` that is the same size as\nthe number of the elements in `x` along the `axis` dimension. It\ncontains the index in the unique output `y`.\nIn other words, for an `1-D` tensor `x` with `axis = None:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```\n\nFor an `2-D` tensor `x` with `axis = 0`:\n\n```\n# tensor 'x' is [[1, 0, 0],\n#                [1, 0, 0],\n#                [2, 0, 0]]\ny, idx = unique(x, axis=0)\ny ==> [[1, 0, 0],\n       [2, 0, 0]]\nidx ==> [0, 0, 1]\n```\n\nFor an `2-D` tensor `x` with `axis = 1`:\n\n```\n# tensor 'x' is [[1, 0, 0],\n#                [1, 0, 0],\n#                [2, 0, 0]]\ny, idx = unique(x, axis=1)\ny ==> [[1, 0],\n       [1, 0],\n       [2, 0]]\nidx ==> [0, 1, 1]\n```",
      "inputs": [
        {
          "description": "A `Tensor`.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A `Tensor` of type `int32` (default: None). The axis of the Tensor to\nfind the unique elements.",
          "name": "axis",
          "typeAttr": "Taxis"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor`. Unique elements along the `axis` of `Tensor` x.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D Tensor. Has the same type as x that contains the index of each\nvalue of x in the output y.",
          "name": "idx",
          "typeAttr": "out_idx"
        }
      ],
      "summary": "Finds unique elements along an axis of a tensor."
    }
  },
  {
    "name": "UniqueWithCounts",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. Finally, it returns a third tensor `count` that\ncontains the count of each element of `y` in `x`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx, count = unique_with_counts(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\ncount ==> [2, 1, 3, 1, 2]\n```",
      "inputs": [
        {
          "description": "1-D.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "1-D.",
          "name": "idx",
          "typeAttr": "out_idx"
        },
        {
          "description": "1-D.",
          "name": "count",
          "typeAttr": "out_idx"
        }
      ],
      "summary": "Finds unique elements in a 1-D tensor."
    }
  },
  {
    "name": "UniqueWithCountsV2",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 9
          },
          "name": "Taxis",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "This operation either returns a tensor `y` containing unique elements\nalong the `axis` of a tensor. The returned unique elements is sorted\nin the same order as they occur along `axis` in `x`.\nThis operation also returns a tensor `idx` and a tensor `count`\nthat are the same size as the number of the elements in `x` along the\n`axis` dimension. The `idx` contains the index in the unique output `y`\nand the `count` contains the count in the unique output `y`.\nIn other words, for an `1-D` tensor `x` with `axis = None:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx, count = unique_with_counts(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\ncount ==> [2, 1, 3, 1, 2]\n```\n\nFor an `2-D` tensor `x` with `axis = 0`:\n\n```\n# tensor 'x' is [[1, 0, 0],\n#                [1, 0, 0],\n#                [2, 0, 0]]\ny, idx, count = unique_with_counts(x, axis=0)\ny ==> [[1, 0, 0],\n       [2, 0, 0]]\nidx ==> [0, 0, 1]\ncount ==> [2, 1]\n```\n\nFor an `2-D` tensor `x` with `axis = 1`:\n\n```\n# tensor 'x' is [[1, 0, 0],\n#                [1, 0, 0],\n#                [2, 0, 0]]\ny, idx, count = unique_with_counts(x, axis=1)\ny ==> [[1, 0],\n       [1, 0],\n       [2, 0]]\nidx ==> [0, 1, 1]\ncount ==> [1, 2]\n```",
      "inputs": [
        {
          "description": "A `Tensor`.",
          "name": "x",
          "typeAttr": "T"
        },
        {
          "description": "A `Tensor` of type `int32` (default: None). The axis of the Tensor to\nfind the unique elements.",
          "name": "axis",
          "typeAttr": "Taxis"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor`. Unique elements along the `axis` of `Tensor` x.",
          "name": "y",
          "typeAttr": "T"
        },
        {
          "description": "A 1-D Tensor. Has the same type as x that contains the index of each\nvalue of x in the output y.",
          "name": "idx",
          "typeAttr": "out_idx"
        },
        {
          "description": "A 1-D Tensor. The count of each value of x in the output y.",
          "name": "count",
          "typeAttr": "out_idx"
        }
      ],
      "summary": "Finds unique elements along an axis of a tensor."
    }
  },
  {
    "name": "Unpack",
    "schema": {
      "attributes": [
        {
          "minimum": 0,
          "name": "num",
          "type": "int"
        },
        {
          "name": "T",
          "type": "type"
        },
        {
          "default": 0,
          "description": "Dimension along which to unpack.  Negative values wrap around, so the\nvalid range is `[-R, R)`.",
          "name": "axis",
          "type": "int"
        }
      ],
      "description": "Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.\nFor example, given a tensor of shape `(A, B, C, D)`;\n\nIf `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`\n  and each tensor in `output` will have shape `(B, C, D)`. (Note that the\n  dimension unpacked along is gone, unlike `split`).\n\nIf `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`\n  and each tensor in `output` will have shape `(A, C, D)`.\nEtc.\n\nThis is the opposite of `pack`.",
      "inputs": [
        {
          "description": "1-D or higher, with `axis` dimension size equal to `num`.",
          "name": "value",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "The list of tensors unpacked from `value`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors."
    }
  },
  {
    "name": "UnravelIndex",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "coordinate arrays.\n\n@compatibility(numpy)\nEquivalent to np.unravel_index\n@end_compatibility",
      "inputs": [
        {
          "description": "An 0-D or 1-D `int` Tensor whose elements are indices into the\nflattened version of an array of dimensions dims.",
          "name": "indices",
          "typeAttr": "Tidx"
        },
        {
          "description": "An 1-D `int` Tensor. The shape of the array to use for unraveling\nindices.",
          "name": "dims",
          "typeAttr": "Tidx"
        }
      ],
      "outputs": [
        {
          "description": "An 2-D (or 1-D if indices is 0-D) tensor where each row has the\nsame shape as the indices array.",
          "name": "output",
          "typeAttr": "Tidx"
        }
      ],
      "summary": "Converts a flat index or array of flat indices into a tuple of"
    }
  },
  {
    "name": "UnsortedSegmentMax",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nThis operator is similar to the unsorted segment sum operator found\n[(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\nInstead of computing the sum over segments, it computes the maximum such that:\n\n\\\\(output_i = \\max_{j...} data[j...]\\\\) where max is over tuples `j...` such\nthat `segment_ids[j...] == i`.\n\nIf the maximum is empty for a given segment ID `i`, it outputs the smallest\npossible value for the specific numeric type,\n`output[i] = numeric_limits<T>::lowest()`.\n\nIf the given segment ID `i` is negative, then the corresponding value is\ndropped, and will not be included in the result.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentMax.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A tensor whose shape is a prefix of `data.shape`.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        },
        {
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the maximum along segments of a tensor."
    }
  },
  {
    "name": "UnsortedSegmentMin",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#segmentation)\nfor an explanation of segments.\n\nThis operator is similar to the unsorted segment sum operator found\n[(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\nInstead of computing the sum over segments, it computes the minimum such that:\n\n\\\\(output_i = \\min_{j...} data_[j...]\\\\) where min is over tuples `j...` such\nthat `segment_ids[j...] == i`.\n\nIf the minimum is empty for a given segment ID `i`, it outputs the largest\npossible value for the specific numeric type,\n`output[i] = numeric_limits<T>::max()`.\n\nIf the given segment ID `i` is negative, then the corresponding value is\ndropped, and will not be included in the result.",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A tensor whose shape is a prefix of `data.shape`.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        },
        {
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the minimum along segments of a tensor."
    }
  },
  {
    "name": "UnsortedSegmentProd",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#segmentation)\nfor an explanation of segments.\n\nThis operator is similar to the unsorted segment sum operator found\n[(here)](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\nInstead of computing the sum over segments, it computes the product of all\nentries belonging to a segment such that:\n\n\\\\(output_i = \\prod_{j...} data[j...]\\\\) where the product is over tuples\n`j...` such that `segment_ids[j...] == i`.\n\nIf there is no entry for a given segment ID `i`, it outputs 1.\n\nIf the given segment ID `i` is negative, then the corresponding value is\ndropped, and will not be included in the result.",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A tensor whose shape is a prefix of `data.shape`.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        },
        {
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the product along segments of a tensor."
    }
  },
  {
    "name": "UnsortedSegmentSum",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "name": "Tindices",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "Tnumsegments",
          "type": "type"
        }
      ],
      "description": "Read\n[the section on segmentation](https://tensorflow.org/api_guides/python/math_ops#Segmentation)\nfor an explanation of segments.\n\nComputes a tensor such that\n\\\\(output[i] = \\sum_{j...} data[j...]\\\\) where the sum is over tuples `j...` such\nthat `segment_ids[j...] == i`.  Unlike `SegmentSum`, `segment_ids`\nneed not be sorted and need not cover all values in the full\nrange of valid values.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\nIf the given segment ID `i` is negative, the value is dropped and will not be\nadded to the sum of the segment.\n\n`num_segments` should equal the number of distinct segment IDs.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentSum.png\" alt>\n</div>",
      "inputs": [
        {
          "name": "data",
          "typeAttr": "T"
        },
        {
          "description": "A tensor whose shape is a prefix of `data.shape`.",
          "name": "segment_ids",
          "typeAttr": "Tindices"
        },
        {
          "name": "num_segments",
          "typeAttr": "Tnumsegments"
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
          "name": "output",
          "typeAttr": "T"
        }
      ],
      "summary": "Computes the sum along segments of a tensor."
    }
  },
  {
    "name": "Unstage",
    "schema": {
      "attributes": [
        {
          "default": 0,
          "minimum": 0,
          "name": "capacity",
          "type": "int"
        },
        {
          "default": 0,
          "minimum": 0,
          "name": "memory_limit",
          "type": "int"
        },
        {
          "minimum": 1,
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The basic functionality is similar to dequeue with many fewer\ncapabilities and options.  This Op is optimized for performance.",
      "outputs": [
        {
          "name": "values",
          "typeListAttr": "dtypes"
        }
      ],
      "summary": "Op is similar to a lightweight Dequeue."
    }
  },
  {
    "name": "UnwrapDatasetVariant",
    "schema": {
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "UpperBound",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "Each set of rows with the same index in (sorted_inputs, values) is treated\nindependently.  The resulting row is the equivalent of calling\n`np.searchsorted(sorted_inputs, values, side='right')`.\n\nThe result is not a global index to the entire \n`Tensor`, but rather just the index in the last dimension.\n\nA 2-D example:\n  sorted_sequence = [[0, 3, 9, 9, 10],\n                     [1, 2, 3, 4, 5]]\n  values = [[2, 4, 9],\n            [0, 2, 6]]\n\n  result = UpperBound(sorted_sequence, values)\n\n  result == [[1, 2, 4],\n             [0, 2, 5]]",
      "inputs": [
        {
          "description": "2-D Tensor where each row is ordered.",
          "name": "sorted_inputs",
          "typeAttr": "T"
        },
        {
          "description": "2-D Tensor with the same numbers of rows as `sorted_search_values`. Contains\nthe values that will be searched for in `sorted_search_values`.",
          "name": "values",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the same shape as `values`.  It contains the last scalar index\ninto the last dimension where values can be inserted without changing the\nordered property.",
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Applies upper_bound(sorted_search_values, values) along each row."
    }
  },
  {
    "name": "VarHandleOp",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "the container this variable is placed in.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "the name by which this variable is referred to.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "the type of this variable. Must agree with the dtypes\nof all ops using this variable.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The (possibly partially specified) shape of this variable.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "outputs": [
        {
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Creates a handle to a Variable resource."
    }
  },
  {
    "name": "VarIsInitializedOp",
    "schema": {
      "inputs": [
        {
          "description": "the input resource handle.",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "a scalar boolean which is true if the variable has been\ninitialized.",
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a resource handle-based variable has been initialized."
    }
  },
  {
    "name": "Variable",
    "schema": {
      "attributes": [
        {
          "name": "shape",
          "type": "shape"
        },
        {
          "name": "dtype",
          "type": "type"
        },
        {
          "default": "",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "category": "Control",
      "outputs": [
        {
          "isRef": true,
          "name": "ref",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Use VariableV2 instead."
    }
  },
  {
    "name": "VariableShape",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 9
            }
          ],
          "default": {
            "type": "type",
            "value": 3
          },
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```",
      "inputs": [
        {
          "name": "input",
          "type": 20
        }
      ],
      "outputs": [
        {
          "name": "output",
          "typeAttr": "out_type"
        }
      ],
      "summary": "Returns the shape of the variable pointed to by `resource`."
    }
  },
  {
    "name": "VariableV2",
    "schema": {
      "attributes": [
        {
          "description": "The shape of the variable tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "The type of elements in the variable tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "default": "",
          "description": "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "category": "Control",
      "description": "Outputs a ref to the tensor state so it may be read or modified.\nTODO(zhifengc/mrry): Adds a pointer to a more detail document\nabout sharing states in tensorflow.",
      "outputs": [
        {
          "description": "A reference to the variable tensor.",
          "isRef": true,
          "name": "ref",
          "typeAttr": "dtype"
        }
      ],
      "summary": "Holds state in the form of a tensor that persists across steps."
    }
  },
  {
    "name": "Where",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 11
            },
            {
              "type": "type",
              "value": 12
            },
            {
              "type": "type",
              "value": 13
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 18
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            },
            {
              "type": "type",
              "value": 10
            }
          ],
          "default": {
            "type": "type",
            "value": 10
          },
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns the coordinates of true elements in `input`. The\ncoordinates are returned in a 2-D tensor where the first dimension (rows)\nrepresents the number of true elements, and the second dimension (columns)\nrepresents the coordinates of the true elements. Keep in mind, the shape of\nthe output tensor can vary depending on how many true values there are in\n`input`. Indices are output in row-major order.\n\nFor example:\n\n```\n# 'input' tensor is [[True, False]\n#                    [True, False]]\n# 'input' has two true values, so output has two coordinates.\n# 'input' has rank of 2, so coordinates have two indices.\nwhere(input) ==> [[0, 0],\n                  [1, 0]]\n\n# `input` tensor is [[[True, False]\n#                     [True, False]]\n#                    [[False, True]\n#                     [False, True]]\n#                    [[False, False]\n#                     [False, True]]]\n# 'input' has 5 true values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n\n# `input` tensor is [[[1.5,  0.0]\n#                     [-0.5, 0.0]]\n#                    [[0.0,  0.25]\n#                     [0.0,  0.75]]\n#                    [[0.0,  0.0]\n#                     [0.0,  0.01]]]\n# 'input' has 5 nonzero values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n\n# `input` tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]\n#                     [0.0 + 0.5j, 0.0  + 0.0j]]\n#                    [[0.0 + 0.0j, 0.25 + 1.5j]\n#                     [0.0 + 0.0j, 0.75 + 0.0j]]\n#                    [[0.0 + 0.0j, 0.0  + 0.0j]\n#                     [0.0 + 0.0j, 0.01 + 0.0j]]]\n# 'input' has 5 nonzero magnitude values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n```",
      "inputs": [
        {
          "name": "input",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "index",
          "type": 9
        }
      ],
      "summary": "Returns locations of nonzero / true values in a tensor."
    }
  },
  {
    "name": "While",
    "schema": {
      "attributes": [
        {
          "description": "dtype in use.",
          "minimum": 0,
          "name": "T",
          "type": "list(type)"
        },
        {
          "description": "      A function takes 'input' and returns a tensor.  If the tensor is\n      a scalar of non-boolean, the scalar is converted to a boolean\n      according to the following rule: if the scalar is a numerical\n      value, non-zero means True and zero means False; if the scalar is\n      a string, non-empty means True and empty means False. If the\n      tensor is not a scalar, non-emptiness means True and False\n      otherwise.",
          "name": "cond",
          "type": "func"
        },
        {
          "description": "      A function that takes a list of tensors and returns another\n      list of tensors. Both lists have the same types as specified\n      by T.",
          "name": "body",
          "type": "func"
        },
        {
          "default": [],
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "default": 10,
          "name": "parallel_iterations",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "A list of input tensors whose types are T.",
          "name": "input",
          "typeListAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "A list of output tensors whose types are T.",
          "name": "output",
          "typeListAttr": "T"
        }
      ],
      "summary": "output = input; While (Cond(output)) { output = Body(output) }"
    }
  },
  {
    "name": "WholeFileReader",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "isRef": true,
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the entire contents of a file as a value."
    }
  },
  {
    "name": "WholeFileReaderV2",
    "schema": {
      "attributes": [
        {
          "default": "",
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "default": "",
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the entire contents of a file as a value."
    }
  },
  {
    "name": "WindowDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a window.",
          "name": "size",
          "type": 9
        },
        {
          "description": "A scalar representing the steps moving the sliding window forward in one\niteration. It must be positive.",
          "name": "shift",
          "type": 9
        },
        {
          "description": "A scalar representing the stride of the input elements of the sliding window.\nIt must be positive.",
          "name": "stride",
          "type": 9
        },
        {
          "description": "A scalar representing whether a window should be dropped in case its size is\nsmaller than desired.",
          "name": "drop_remainder",
          "type": 10
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "A dataset that creates window datasets from the input dataset."
    }
  },
  {
    "name": "WrapDatasetVariant",
    "schema": {
      "inputs": [
        {
          "name": "input_handle",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "output_handle",
          "type": 21
        }
      ]
    }
  },
  {
    "name": "WriteAudioSummary",
    "schema": {
      "attributes": [
        {
          "default": 3,
          "minimum": 1,
          "name": "max_outputs",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "step",
          "type": 9
        },
        {
          "name": "tag",
          "type": 7
        },
        {
          "name": "tensor",
          "type": 1
        },
        {
          "name": "sample_rate",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "WriteFile",
    "schema": {
      "description": "creates directory if not existing.",
      "inputs": [
        {
          "description": "scalar. The name of the file to which we write the contents.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "scalar. The content to be written to the output file.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "Writes contents to the file at input filename. Creates file and recursively"
    }
  },
  {
    "name": "WriteGraphSummary",
    "schema": {
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "step",
          "type": 9
        },
        {
          "name": "tensor",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "WriteHistogramSummary",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "step",
          "type": 9
        },
        {
          "name": "tag",
          "type": 7
        },
        {
          "name": "values",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "WriteImageSummary",
    "schema": {
      "attributes": [
        {
          "default": 3,
          "minimum": 1,
          "name": "max_images",
          "type": "int"
        },
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 19
            }
          ],
          "default": {
            "type": "type",
            "value": 1
          },
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "step",
          "type": 9
        },
        {
          "name": "tag",
          "type": 7
        },
        {
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "name": "bad_color",
          "type": 4
        }
      ]
    }
  },
  {
    "name": "WriteScalarSummary",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 3
            },
            {
              "type": "type",
              "value": 4
            },
            {
              "type": "type",
              "value": 5
            },
            {
              "type": "type",
              "value": 6
            },
            {
              "type": "type",
              "value": 9
            },
            {
              "type": "type",
              "value": 14
            },
            {
              "type": "type",
              "value": 17
            },
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 22
            },
            {
              "type": "type",
              "value": 23
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "step",
          "type": 9
        },
        {
          "name": "tag",
          "type": 7
        },
        {
          "name": "value",
          "typeAttr": "T"
        }
      ]
    }
  },
  {
    "name": "WriteSummary",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "writer",
          "type": 20
        },
        {
          "name": "step",
          "type": 9
        },
        {
          "name": "tensor",
          "typeAttr": "T"
        },
        {
          "name": "tag",
          "type": 7
        },
        {
          "name": "summary_metadata",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "Xdivy",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns 0 if x == 0, and x / y otherwise, elementwise."
    }
  },
  {
    "name": "Xlogy",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 19
            },
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            },
            {
              "type": "type",
              "value": 8
            },
            {
              "type": "type",
              "value": 18
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns 0 if x == 0, and x * log(y) otherwise, elementwise."
    }
  },
  {
    "name": "ZerosLike",
    "schema": {
      "attributes": [
        {
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "a tensor of type T.",
          "name": "x",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "description": "a tensor of the same shape and type as x but filled with zeros.",
          "name": "y",
          "typeAttr": "T"
        }
      ],
      "summary": "Returns a tensor of zeros with the same shape and type as x."
    }
  },
  {
    "name": "Zeta",
    "schema": {
      "attributes": [
        {
          "allowedValues": [
            {
              "type": "type",
              "value": 1
            },
            {
              "type": "type",
              "value": 2
            }
          ],
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The Hurwitz zeta function is defined as:\n\n\n\\\\(\\zeta(x, q) = \\sum_{n=0}^{\\infty} (q + n)^{-x}\\\\)",
      "inputs": [
        {
          "name": "x",
          "typeAttr": "T"
        },
        {
          "name": "q",
          "typeAttr": "T"
        }
      ],
      "outputs": [
        {
          "name": "z",
          "typeAttr": "T"
        }
      ],
      "summary": "Compute the Hurwitz zeta function \\\\(\\zeta(x, q)\\\\)."
    }
  },
  {
    "name": "ZipDataset",
    "schema": {
      "attributes": [
        {
          "minimum": 1,
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "minimum": 1,
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "minimum": 1,
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "name": "input_datasets",
          "numberAttr": "N",
          "type": 21
        }
      ],
      "outputs": [
        {
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that zips together `input_datasets`."
    }
  }
]
