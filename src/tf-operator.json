[
  {
    "name": "Abort",
    "schema": {
      "attributes": [
        {
          "description": "A string which is the message associated with the exception.",
          "name": "error_msg",
          "type": "string"
        },
        {
          "description": "",
          "name": "exit_without_error",
          "type": "bool"
        }
      ],
      "description": "If exit_without_error is true, the process will exit normally,\notherwise it will exit with a SIGABORT signal.\n\nReturns nothing but an exception.",
      "summary": "Raise a exception to abort the process when called."
    }
  },
  {
    "name": "Abs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `x`, this operation returns a tensor containing the absolute\nvalue of each element in `x`. For example, if x is an input element and y is\nan output element, this operation computes \\\\(y = |x|\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the absolute value of a tensor."
    }
  },
  {
    "name": "AccumulateNV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Shape of elements of `inputs`.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "`tf.accumulate_n_v2` performs the same operation as `tf.add_n`, but does not\nwait for all of its inputs to be ready before beginning to sum. This can\nsave memory if inputs are ready at different times, since minimum temporary\nstorage is proportional to the output size rather than the inputs size.\n\nUnlike the original `accumulate_n`, `accumulate_n_v2` is differentiable.\n\nReturns a `Tensor` of same shape and type as the elements of `inputs`.",
      "inputs": [
        {
          "description": "A list of `Tensor` objects, each with same shape and type.",
          "name": "inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "sum",
          "type": 0
        }
      ],
      "summary": "Returns the element-wise sum of a list of tensors."
    }
  },
  {
    "name": "AccumulatorApplyGradient",
    "schema": {
      "attributes": [
        {
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Does not add if local_step is lesser than the accumulator's global_step.",
      "inputs": [
        {
          "description": "The handle to a accumulator.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "The local_step value at which the gradient was computed.",
          "name": "local_step",
          "type": 9
        },
        {
          "description": "A tensor of the gradient to be accumulated.",
          "name": "gradient",
          "type": 0
        }
      ],
      "summary": "Applies a gradient to a given accumulator."
    }
  },
  {
    "name": "AccumulatorNumAccumulated",
    "schema": {
      "inputs": [
        {
          "description": "The handle to an accumulator.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of gradients aggregated in the given accumulator.",
          "name": "num_accumulated",
          "type": 3
        }
      ],
      "summary": "Returns the number of gradients aggregated in the given accumulators."
    }
  },
  {
    "name": "AccumulatorSetGlobalStep",
    "schema": {
      "description": "Logs warning if the accumulator's value is already higher than\nnew_global_step.",
      "inputs": [
        {
          "description": "The handle to an accumulator.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "The new global_step value to set.",
          "name": "new_global_step",
          "type": 9
        }
      ],
      "summary": "Updates the accumulator with a new value for global_step."
    }
  },
  {
    "name": "AccumulatorTakeGradient",
    "schema": {
      "attributes": [
        {
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The op blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated.  If the accumulator has already\naggregated more than num_required gradients, it returns the average of\nthe accumulated gradients.  Also automatically increments the recorded\nglobal_step in the accumulator by 1, and resets the aggregate to 0.",
      "inputs": [
        {
          "description": "The handle to an accumulator.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "Number of gradients required before we return an aggregate.",
          "name": "num_required",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The average of the accumulated gradients.",
          "name": "average",
          "type": 0
        }
      ],
      "summary": "Extracts the average gradient in the given ConditionalAccumulator."
    }
  },
  {
    "name": "Acos",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes acos of x element-wise."
    }
  },
  {
    "name": "Acosh",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes inverse hyperbolic cosine of x element-wise."
    }
  },
  {
    "name": "Add",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x + y element-wise."
    }
  },
  {
    "name": "AddManySparseToTensorsMap",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The container name for the `SparseTensorsMap` created by this op.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "The shared name for the `SparseTensorsMap` created by this op.\nIf blank, the new Operation's unique name is used.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A `SparseTensor` of rank `R` is represented by three tensors: `sparse_indices`,\n`sparse_values`, and `sparse_shape`, where\n\n```sparse_indices.shape[1] == sparse_shape.shape[0] == R```\n\nAn `N`-minibatch of `SparseTensor` objects is represented as a `SparseTensor`\nhaving a first `sparse_indices` column taking values between `[0, N)`, where\nthe minibatch size `N == sparse_shape[0]`.\n\nThe input `SparseTensor` must have rank `R` greater than 1, and the first\ndimension is treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The stored\n`SparseTensor` objects pointed to by each row of the output `sparse_handles`\nwill have rank `R-1`.\n\nThe `SparseTensor` values can then be read out as part of a minibatch by passing\nthe given keys as vector elements to `TakeManySparseFromTensorsMap`.  To ensure\nthe correct `SparseTensorsMap` is accessed, ensure that the same\n`container` and `shared_name` are passed to that Op.  If no `shared_name`\nis provided here, instead use the *name* of the Operation created by calling\n`AddManySparseToTensorsMap` as the `shared_name` passed to\n`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the minibatch `SparseTensor`.\n`sparse_indices[:, 0]` must be ordered values in `[0, N)`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the minibatch `SparseTensor`.\nThe minibatch size `N == sparse_shape[0]`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The handles of the `SparseTensor` now stored in the\n`SparseTensorsMap`.  Shape: `[N]`.",
          "name": "sparse_handles",
          "type": 9
        }
      ],
      "summary": "Add an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N` handles."
    }
  },
  {
    "name": "AddN",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Must all be the same size and shape.",
          "name": "inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "sum",
          "type": 0
        }
      ],
      "summary": "Add all input tensors element wise."
    }
  },
  {
    "name": "AddSparseToTensorsMap",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The container name for the `SparseTensorsMap` created by this op.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "The shared name for the `SparseTensorsMap` created by this op.\nIf blank, the new Operation's unique name is used.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A `SparseTensor` is represented by three tensors: `sparse_indices`,\n`sparse_values`, and `sparse_shape`.\n\nThis operator takes the given `SparseTensor` and adds it to a container\nobject (a `SparseTensorsMap`).  A unique key within this container is generated\nin the form of an `int64`, and this is the value that is returned.\n\nThe `SparseTensor` can then be read out as part of a minibatch by passing\nthe key as a vector element to `TakeManySparseFromTensorsMap`.  To ensure\nthe correct `SparseTensorsMap` is accessed, ensure that the same\n`container` and `shared_name` are passed to that Op.  If no `shared_name`\nis provided here, instead use the *name* of the Operation created by calling\n`AddSparseToTensorsMap` as the `shared_name` passed to\n`TakeManySparseFromTensorsMap`.  Ensure the Operations are colocated.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`.",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "0-D.  The handle of the `SparseTensor` now stored in the\n`SparseTensorsMap`.",
          "name": "sparse_handle",
          "type": 9
        }
      ],
      "summary": "Add a `SparseTensor` to a `SparseTensorsMap` return its handle."
    }
  },
  {
    "name": "AddV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Add` supports broadcasting. `AddN` does not. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x + y element-wise."
    }
  },
  {
    "name": "AdjustContrast",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "images",
          "type": 0
        },
        {
          "description": "",
          "name": "contrast_factor",
          "type": 1
        },
        {
          "description": "",
          "name": "min_value",
          "type": 1
        },
        {
          "description": "",
          "name": "max_value",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Deprecated. Disallowed in GraphDef version >= 2."
    }
  },
  {
    "name": "AdjustContrastv2",
    "schema": {
      "description": "`images` is a tensor of at least 3 dimensions.  The last 3 dimensions are\ninterpreted as `[height, width, channels]`.  The other dimensions only\nrepresent a collection of images, such as `[batch, height, width, channels].`\n\nContrast is adjusted independently for each channel of each image.\n\nFor each channel, the Op first computes the mean of the image pixels in the\nchannel and then adjusts each component of each pixel to\n`(x - mean) * contrast_factor + mean`.",
      "inputs": [
        {
          "description": "Images to adjust.  At least 3-D.",
          "name": "images",
          "type": 1
        },
        {
          "description": "A float multiplier for adjusting contrast.",
          "name": "contrast_factor",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The contrast-adjusted image or images.",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Adjust the contrast of one or more images."
    }
  },
  {
    "name": "AdjustHue",
    "schema": {
      "description": "`images` is a tensor of at least 3 dimensions.  The last dimension is\ninterpretted as channels, and must be three.\n\nThe input image is considered in the RGB colorspace. Conceptually, the RGB\ncolors are first mapped into HSV. A delta is then applied all the hue values,\nand then remapped back to RGB colorspace.",
      "inputs": [
        {
          "description": "Images to adjust.  At least 3-D.",
          "name": "images",
          "type": 1
        },
        {
          "description": "A float delta to add to the hue.",
          "name": "delta",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The hue-adjusted image or images.",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Adjust the hue of one or more images."
    }
  },
  {
    "name": "AdjustSaturation",
    "schema": {
      "description": "`images` is a tensor of at least 3 dimensions.  The last dimension is\ninterpretted as channels, and must be three.\n\nThe input image is considered in the RGB colorspace. Conceptually, the RGB\ncolors are first mapped into HSV. A scale is then applied all the saturation\nvalues, and then remapped back to RGB colorspace.",
      "inputs": [
        {
          "description": "Images to adjust.  At least 3-D.",
          "name": "images",
          "type": 1
        },
        {
          "description": "A float scale to add to the saturation.",
          "name": "scale",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The hue-adjusted image or images.",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Adjust the saturation of one or more images."
    }
  },
  {
    "name": "All",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 10
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Computes the \"logical and\" of elements across dimensions of a tensor."
    }
  },
  {
    "name": "AllCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to produce.",
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "Angle",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the argument of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part.\n\nThe argument returned by this operation is of the form \\\\(atan2(b, a)\\\\).\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.angle(input) ==> [2.0132, 1.056]\n```\n\n@compatibility(numpy)\nEquivalent to np.angle.\n@end_compatibility",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the argument of a complex number."
    }
  },
  {
    "name": "Any",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 10
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Computes the \"logical or\" of elements across dimensions of a tensor."
    }
  },
  {
    "name": "ApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum_update",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the adadelta scheme."
    }
  },
  {
    "name": "ApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the adagrad scheme."
    }
  },
  {
    "name": "ApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_accumulator",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_squared_accumulator",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "ApplyAdam",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "description": "If `True`, uses the nesterov update.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)\nm_t <- beta1 * m_{t-1} + (1 - beta1) * g_t\nv_t <- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t\nvariable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "v",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta2_power",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "type": 0
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the Adam algorithm."
    }
  },
  {
    "name": "ApplyAddSign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- (alpha + sign_decay * sign(g) *sign(m)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\n\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nmg <- rho * mg_{t-1} + (1-rho) * grad\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "mg",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "ApplyFtrl",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regulariation. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "grad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "",
          "name": "l2_shrinkage",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ApplyGradientDescent",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "The change.",
          "name": "delta",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' by subtracting 'alpha' * 'delta' from it."
    }
  },
  {
    "name": "ApplyMomentum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "want to use Nesterov momentum.\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the momentum scheme. Set use_nesterov = True if you"
    }
  },
  {
    "name": "ApplyPowerSign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "logbase",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nprox_v = var - lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' and '*accum' according to FOBOS with Adagrad learning rate."
    }
  },
  {
    "name": "ApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "prox_v = var - alpha * delta\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The change.",
          "name": "delta",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "ApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "ApproximateEqual",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "tolerance",
          "type": "float"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of abs(x-y) < tolerance element-wise."
    }
  },
  {
    "name": "ArgMax",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        },
        {
          "description": "",
          "name": "output_type",
          "type": "type"
        }
      ],
      "description": "Note that in case of ties the identity of the return value is not guaranteed.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "int32 or int64, must be in the range `[-rank(input), rank(input))`.\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0.",
          "name": "dimension",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the index with the largest value across dimensions of a tensor."
    }
  },
  {
    "name": "ArgMin",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        },
        {
          "description": "",
          "name": "output_type",
          "type": "type"
        }
      ],
      "description": "Note that in case of ties the identity of the return value is not guaranteed.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "int32 or int64, must be in the range `[-rank(input), rank(input))`.\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0.",
          "name": "dimension",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the index with the smallest value across dimensions of a tensor."
    }
  },
  {
    "name": "AsString",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The post-decimal precision to use for floating point numbers.\nOnly used if precision > -1.",
          "name": "precision",
          "type": "int"
        },
        {
          "description": "Use scientific notation for floating point numbers.",
          "name": "scientific",
          "type": "bool"
        },
        {
          "description": "Use shortest representation (either scientific or standard) for\nfloating point numbers.",
          "name": "shortest",
          "type": "bool"
        },
        {
          "description": "Pad pre-decimal numbers to this width.\nApplies to both floating point and integer numbers.\nOnly used if width > -1.",
          "name": "width",
          "type": "int"
        },
        {
          "description": "The value to pad if width > -1.  If empty, pads with spaces.\nAnother typical value is '0'.  String cannot be longer than 1 character.",
          "name": "fill",
          "type": "string"
        }
      ],
      "description": "types and boolean.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Converts each entry in the given tensor to strings.  Supports many numeric"
    }
  },
  {
    "name": "Asin",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes asin of x element-wise."
    }
  },
  {
    "name": "Asinh",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes inverse hyperbolic sine of x element-wise."
    }
  },
  {
    "name": "Assert",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "list(type)"
        },
        {
          "description": "Print this many entries of each tensor.",
          "name": "summarize",
          "type": "int"
        }
      ],
      "description": "If `condition` evaluates to false, print the list of tensors in `data`.\n`summarize` determines how many entries of the tensors to print.",
      "inputs": [
        {
          "description": "The condition to evaluate.",
          "name": "condition",
          "type": 10
        },
        {
          "description": "The tensors to print out when condition is false.",
          "name": "data",
          "type": 0
        }
      ],
      "summary": "Asserts that the given condition is true."
    }
  },
  {
    "name": "Assign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, the operation will validate that the shape\nof 'value' matches the shape of the Tensor being assigned to.  If false,\n'ref' will take on the shape of 'value'.",
          "name": "validate_shape",
          "type": "bool"
        },
        {
          "description": "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation outputs \"ref\" after the assignment is done.\nThis makes it easier to chain operations that need to use the reset value.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node. May be uninitialized.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "The value to be assigned to the variable.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been reset.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Update 'ref' by assigning 'value' to it."
    }
  },
  {
    "name": "AssignAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "The value to be added to the variable.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Update 'ref' by adding 'value' to it."
    }
  },
  {
    "name": "AssignAddVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Any ReadVariableOp which depends directly or indirectly on this assign is\nguaranteed to see the incremented value or a subsequent newer one.\n\nOutputs the incremented value, which can be used to totally order the\nincrements to this variable.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "the value by which the variable will be incremented.",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Adds a value to the current value of a variable."
    }
  },
  {
    "name": "AssignSub",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation outputs \"ref\" after the update is done.\nThis makes it easier to chain operations that need to use the reset value.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "The value to be subtracted to the variable.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as \"ref\".  Returned as a convenience for operations that want\nto use the new value after the variable has been updated.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Update 'ref' by subtracting 'value' from it."
    }
  },
  {
    "name": "AssignSubVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Any ReadVariableOp which depends directly or indirectly on this assign is\nguaranteed to see the incremented value or a subsequent newer one.\n\nOutputs the incremented value, which can be used to totally order the\nincrements to this variable.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "the value by which the variable will be incremented.",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Subtracts a value from the current value of a variable."
    }
  },
  {
    "name": "AssignVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Any ReadVariableOp with a control dependency on this op is guaranteed to return\nthis value or a subsequent newer value of the variable.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "the value to set the new tensor to use.",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Assigns a new value to a variable."
    }
  },
  {
    "name": "Atan",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes atan of x element-wise."
    }
  },
  {
    "name": "Atan2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is the angle \\( \\theta \\in [-\\pi, \\pi] \\) such that\n\\[ x = r \\cos(\\theta) \\]\nand\n\\[ y = r \\sin(\\theta) \\]\nwhere \\(r = \\sqrt(x^2 + y^2) \\).",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes arctangent of `y/x` element-wise, respecting signs of the arguments."
    }
  },
  {
    "name": "Atanh",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes inverse hyperbolic tangent of x element-wise."
    }
  },
  {
    "name": "AudioSpectrogram",
    "schema": {
      "attributes": [
        {
          "description": "How wide the input window is in samples. For the highest efficiency\nthis should be a power of two, but other values are accepted.",
          "name": "window_size",
          "type": "int"
        },
        {
          "description": "How widely apart the center of adjacent sample windows should be.",
          "name": "stride",
          "type": "int"
        },
        {
          "description": "Whether to return the squared magnitude or just the\nmagnitude. Using squared magnitude can avoid extra calculations.",
          "name": "magnitude_squared",
          "type": "bool"
        }
      ],
      "description": "Spectrograms are a standard way of representing audio information as a series of\nslices of frequency information, one slice for each window of time. By joining\nthese together into a sequence, they form a distinctive fingerprint of the sound\nover time.\n\nThis op expects to receive audio data as an input, stored as floats in the range\n-1 to 1, together with a window width in samples, and a stride specifying how\nfar to move the window between slices. From this it generates a three\ndimensional output. The lowest dimension has an amplitude value for each\nfrequency during that time slice. The next dimension is time, with successive\nfrequency slices. The final dimension is for the channels in the input, so a\nstereo audio input would have two here for example.\n\nThis means the layout when converted and saved as an image is rotated 90 degrees\nclockwise from a typical spectrogram. Time is descending down the Y axis, and\nthe frequency decreases from left to right.\n\nEach value in the result represents the square root of the sum of the real and\nimaginary parts of an FFT on the current window of samples. In this way, the\nlowest dimension represents the power of each frequency in the current window,\nand adjacent windows are concatenated in the next dimension.\n\nTo get a more intuitive and visual look at what this operation does, you can run\ntensorflow/examples/wav_to_spectrogram to read in an audio file and save out the\nresulting spectrogram as a PNG image.",
      "inputs": [
        {
          "description": "Float representation of audio data.",
          "name": "input",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "3D representation of the audio frequencies as an image.",
          "name": "spectrogram",
          "type": 1
        }
      ],
      "summary": "Produces a visualization of audio data over time."
    }
  },
  {
    "name": "AudioSummary",
    "schema": {
      "attributes": [
        {
          "description": "The sample rate of the signal in hertz.",
          "name": "sample_rate",
          "type": "float"
        },
        {
          "description": "Max number of batch elements to generate audio for.",
          "name": "max_outputs",
          "type": "int"
        }
      ],
      "description": "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.",
      "inputs": [
        {
          "description": "Scalar. Used to build the `tag` attribute of the summary values.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "2-D of shape `[batch_size, frames]`.",
          "name": "tensor",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with audio."
    }
  },
  {
    "name": "AudioSummaryV2",
    "schema": {
      "attributes": [
        {
          "description": "Max number of batch elements to generate audio for.",
          "name": "max_outputs",
          "type": "int"
        }
      ],
      "description": "The summary has up to `max_outputs` summary values containing audio. The\naudio is built from `tensor` which must be 3-D with shape `[batch_size,\nframes, channels]` or 2-D with shape `[batch_size, frames]`. The values are\nassumed to be in the range of `[-1.0, 1.0]` with a sample rate of `sample_rate`.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_outputs` is 1, the summary value tag is '*tag*/audio'.\n*  If `max_outputs` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/audio/0', '*tag*/audio/1', etc.",
      "inputs": [
        {
          "description": "Scalar. Used to build the `tag` attribute of the summary values.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "2-D of shape `[batch_size, frames]`.",
          "name": "tensor",
          "type": 1
        },
        {
          "description": "The sample rate of the signal in hertz.",
          "name": "sample_rate",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with audio."
    }
  },
  {
    "name": "AvgPool",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of `value`.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of `value`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Each entry in `output` is the mean of the corresponding size `ksize`\nwindow in `value`.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The average pooled output tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs average pooling on the input."
    }
  },
  {
    "name": "AvgPool3D",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, channels]` tensor to pool over.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The average pooled output tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs 3D average pooling on the input."
    }
  },
  {
    "name": "AvgPool3DGrad",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input dimensions.",
          "name": "orig_input_shape",
          "type": 3
        },
        {
          "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The backprop for input.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients of average pooling function."
    }
  },
  {
    "name": "AvgPoolGrad",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of the input.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "1-D.  Shape of the original input to `avg_pool`.",
          "name": "orig_input_shape",
          "type": 3
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t.\nthe output of `avg_pool`.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D.  Gradients w.r.t. the input of `avg_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients of the average pooling function."
    }
  },
  {
    "name": "Barrier",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. Each shape must be 1 in the\nfirst dimension. The length of this attr must be the same as the length of\ncomponent_types.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The capacity of the barrier.  The default capacity is MAX_INT32,\nwhich is the largest capacity of the underlying queue.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this barrier is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this barrier will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A barrier represents a key-value map, where each key is a string, and\neach value is a tuple of tensors.\n\nAt runtime, the barrier contains 'complete' and 'incomplete'\nelements. A complete element has defined tensors for all components of\nits value tuple, and may be accessed using BarrierTakeMany. An\nincomplete element has some undefined components in its value tuple,\nand may be updated using BarrierInsertMany.",
      "outputs": [
        {
          "description": "The handle to the barrier.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Defines a barrier that persists across different graph executions."
    }
  },
  {
    "name": "BarrierClose",
    "schema": {
      "attributes": [
        {
          "description": "If true, all pending enqueue requests that are\nblocked on the barrier's queue will be canceled. InsertMany will fail, even\nif no new key is introduced.",
          "name": "cancel_pending_enqueues",
          "type": "bool"
        }
      ],
      "description": "This operation signals that no more new elements will be inserted in the\ngiven barrier. Subsequent InsertMany that try to introduce a new key will fail.\nSubsequent InsertMany operations that just add missing components to already\nexisting elements will continue to succeed. Subsequent TakeMany operations will\ncontinue to succeed if sufficient completed elements remain in the barrier.\nSubsequent TakeMany operations that would block will fail immediately.",
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Closes the given barrier."
    }
  },
  {
    "name": "BarrierIncompleteSize",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of incomplete elements (i.e. those with some of their value\ncomponents not set) in the barrier.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of incomplete elements in the given barrier."
    }
  },
  {
    "name": "BarrierInsertMany",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The component of the barrier elements that is being assigned.",
          "name": "component_index",
          "type": "int"
        }
      ],
      "description": "If a key is not found in the barrier, this operation will create a new\nincomplete element. If a key is found in the barrier, and the element\nalready has a value at component_index, this operation will fail with\nINVALID_ARGUMENT, and leave the barrier in an undefined state.",
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "A one-dimensional tensor of keys, with length n.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "An any-dimensional tensor of values, which are associated with the\nrespective keys. The 0th dimension must have length n.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "For each key, assigns the respective value to the specified component."
    }
  },
  {
    "name": "BarrierReadySize",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of complete elements (i.e. those with all of their value\ncomponents set) in the barrier.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of complete elements in the given barrier."
    }
  },
  {
    "name": "BarrierTakeMany",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "Allow to return less than num_elements items if barrier is\nalready closed.",
          "name": "allow_small_batch",
          "type": "bool"
        },
        {
          "description": "",
          "name": "wait_for_incomplete",
          "type": "bool"
        },
        {
          "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation concatenates completed-element component tensors along\nthe 0th dimension to make a single component tensor.\n\nElements come out of the barrier when they are complete, and in the order\nin which they were placed into the barrier.  The indices output provides\ninformation about the batch in which each element was originally inserted\ninto the barrier.",
      "inputs": [
        {
          "description": "The handle to a barrier.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "A single-element tensor containing the number of elements to\ntake.",
          "name": "num_elements",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A one-dimensional tensor of indices, with length num_elems.\nThese indices refer to the batch in which the values were placed into the\nbarrier (starting with MIN_LONG and increasing with each BarrierInsertMany).",
          "name": "indices",
          "type": 9
        },
        {
          "description": "A one-dimensional tensor of keys, with length num_elements.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "One any-dimensional tensor per component in a barrier element. All\nvalues have length num_elements in the 0th dimension.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Takes the given number of completed elements from a barrier."
    }
  },
  {
    "name": "BatchCholesky",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchCholeskyGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "l",
          "type": 0
        },
        {
          "description": "",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches `batch_size` elements from `input_dataset`."
    }
  },
  {
    "name": "BatchFFT",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchFFT2D",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchFFT3D",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchIFFT",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchIFFT2D",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchIFFT3D",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 8
        }
      ]
    }
  },
  {
    "name": "BatchMatMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, adjoint the slices of `x`. Defaults to `False`.",
          "name": "adj_x",
          "type": "bool"
        },
        {
          "description": "If `True`, adjoint the slices of `y`. Defaults to `False`.",
          "name": "adj_y",
          "type": "bool"
        }
      ],
      "description": "Multiplies all slices of `Tensor` `x` and `y` (each slice can be\nviewed as an element of a batch), and arranges the individual results\nin a single output tensor of the same batch size. Each of the\nindividual slices can optionally be adjointed (to adjoint a matrix\nmeans to transpose and conjugate it) before multiplication by setting\nthe `adj_x` or `adj_y` flag to `True`, which are by default `False`.\n\nThe input tensors `x` and `y` are 2-D or higher with shape `[..., r_x, c_x]`\nand `[..., r_y, c_y]`.\n\nThe output tensor is 2-D or higher with shape `[..., r_o, c_o]`, where:\n\n    r_o = c_x if adj_x else r_x\n    c_o = r_y if adj_y else c_y\n\nIt is computed as:\n\n    output[..., :, :] = matrix(x[..., :, :]) * matrix(y[..., :, :])",
      "inputs": [
        {
          "description": "2-D or higher with shape `[..., r_x, c_x]`.",
          "name": "x",
          "type": 0
        },
        {
          "description": "2-D or higher with shape `[..., r_y, c_y]`.",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "3-D or higher with shape `[..., r_o, c_o]`",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Multiplies slices of two tensors in batches."
    }
  },
  {
    "name": "BatchMatrixBandPart",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "num_lower",
          "type": 9
        },
        {
          "description": "",
          "name": "num_upper",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "band",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixDeterminant",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixDiag",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "diagonal",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixDiagPart",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "diagonal",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixInverse",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixSetDiag",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "diagonal",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixSolve",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "matrix",
          "type": 0
        },
        {
          "description": "",
          "name": "rhs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixSolveLs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "fast",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "matrix",
          "type": 0
        },
        {
          "description": "",
          "name": "rhs",
          "type": 0
        },
        {
          "description": "",
          "name": "l2_regularizer",
          "type": 2
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchMatrixTriangularSolve",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "lower",
          "type": "bool"
        },
        {
          "description": "",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "matrix",
          "type": 0
        },
        {
          "description": "",
          "name": "rhs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchNormWithGlobalNormalization",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma.",
          "name": "scale_after_normalization",
          "type": "bool"
        }
      ],
      "description": "This op is deprecated. Prefer `tf.nn.batch_normalization`.",
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "t",
          "type": 0
        },
        {
          "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "m",
          "type": 0
        },
        {
          "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "v",
          "type": 0
        },
        {
          "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor.",
          "name": "beta",
          "type": 0
        },
        {
          "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor.",
          "name": "gamma",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "result",
          "type": 0
        }
      ],
      "summary": "Batch normalization."
    }
  },
  {
    "name": "BatchNormWithGlobalNormalizationGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma.",
          "name": "scale_after_normalization",
          "type": "bool"
        }
      ],
      "description": "This op is deprecated. See `tf.nn.batch_normalization`.",
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "t",
          "type": 0
        },
        {
          "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "m",
          "type": 0
        },
        {
          "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "v",
          "type": 0
        },
        {
          "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this Tensor will be multiplied\nwith the normalized Tensor.",
          "name": "gamma",
          "type": 0
        },
        {
          "description": "4D backprop Tensor.",
          "name": "backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4D backprop tensor for input.",
          "name": "dx",
          "type": 0
        },
        {
          "description": "1D backprop tensor for mean.",
          "name": "dm",
          "type": 0
        },
        {
          "description": "1D backprop tensor for variance.",
          "name": "dv",
          "type": 0
        },
        {
          "description": "1D backprop tensor for beta.",
          "name": "db",
          "type": 0
        },
        {
          "description": "1D backprop tensor for gamma.",
          "name": "dg",
          "type": 0
        }
      ],
      "summary": "Gradients for batch normalization."
    }
  },
  {
    "name": "BatchSelfAdjointEig",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchSelfAdjointEigV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "compute_v",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "e",
          "type": 0
        },
        {
          "description": "",
          "name": "v",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchSvd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "compute_uv",
          "type": "bool"
        },
        {
          "description": "",
          "name": "full_matrices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "s",
          "type": 0
        },
        {
          "description": "",
          "name": "u",
          "type": 0
        },
        {
          "description": "",
          "name": "v",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "BatchToSpace",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "block_size",
          "type": "int"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "This is a legacy version of the more general BatchToSpaceND.\n\nRearranges (permutes) data from batch into blocks of spatial data, followed by\ncropping. This is the reverse transformation of SpaceToBatch. More specifically,\nthis op outputs a copy of the input tensor where values from the `batch`\ndimension are moved in spatial blocks to the `height` and `width` dimensions,\nfollowed by cropping along the `height` and `width` dimensions.",
      "inputs": [
        {
          "description": "4-D tensor with shape\n`[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n  depth]`. Note that the batch size of the input tensor must be divisible by\n`block_size * block_size`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\nhow many elements to crop from the intermediate result across the spatial\ndimensions as follows:\n\n    crops = [[crop_top, crop_bottom], [crop_left, crop_right]]",
          "name": "crops",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, height, width, depth]`, where:\n\n      height = height_pad - crop_top - crop_bottom\n      width = width_pad - crop_left - crop_right\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\nSome examples:\n\n(1) For the following input of shape `[4, 1, 1, 1]` and block_size of 2:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\n(2) For the following input of shape `[4, 1, 1, 3]` and block_size of 2:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 3]` and value:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[4, 2, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\nThe output tensor has shape `[1, 4, 4, 1]` and value:\n\n```\nx = [[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]\n```\n\n(4) For the following input of shape `[8, 1, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n```\n\nThe output tensor has shape `[2, 2, 4, 1]` and value:\n\n```\nx = [[[[1], [3]], [[5], [7]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "BatchToSpace for 4-D tensors of type T."
    }
  },
  {
    "name": "BatchToSpaceND",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tblock_shape",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tcrops",
          "type": "type"
        }
      ],
      "description": "This operation reshapes the \"batch\" dimension 0 into `M + 1` dimensions of shape\n`block_shape + [batch]`, interleaves these blocks back into the grid defined by\nthe spatial dimensions `[1, ..., M]`, to obtain a result with the same rank as\nthe input.  The spatial dimensions of this intermediate result are then\noptionally cropped according to `crops` to produce the output.  This is the\nreverse of SpaceToBatch.  See below for a precise description.",
      "inputs": [
        {
          "description": "N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,\nwhere spatial_shape has M dimensions.",
          "name": "input",
          "type": 0
        },
        {
          "description": "1-D with shape `[M]`, all values must be >= 1.",
          "name": "block_shape",
          "type": 0
        },
        {
          "description": "2-D with shape `[M, 2]`, all values must be >= 0.\n  `crops[i] = [crop_start, crop_end]` specifies the amount to crop from input\n  dimension `i + 1`, which corresponds to spatial dimension `i`.  It is\n  required that\n  `crop_start[i] + crop_end[i] <= block_shape[i] * input_shape[i + 1]`.\n\nThis operation is equivalent to the following steps:\n\n1. Reshape `input` to `reshaped` of shape:\n     [block_shape[0], ..., block_shape[M-1],\n      batch / prod(block_shape),\n      input_shape[1], ..., input_shape[N-1]]\n\n2. Permute dimensions of `reshaped` to produce `permuted` of shape\n     [batch / prod(block_shape),\n\n      input_shape[1], block_shape[0],\n      ...,\n      input_shape[M], block_shape[M-1],\n\n      input_shape[M+1], ..., input_shape[N-1]]\n\n3. Reshape `permuted` to produce `reshaped_permuted` of shape\n     [batch / prod(block_shape),\n\n      input_shape[1] * block_shape[0],\n      ...,\n      input_shape[M] * block_shape[M-1],\n\n      input_shape[M+1],\n      ...,\n      input_shape[N-1]]\n\n4. Crop the start and end of dimensions `[1, ..., M]` of\n   `reshaped_permuted` according to `crops` to produce the output of shape:\n     [batch / prod(block_shape),\n\n      input_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],\n      ...,\n      input_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],\n\n      input_shape[M+1], ..., input_shape[N-1]]\n\nSome examples:\n\n(1) For the following input of shape `[4, 1, 1, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\n(2) For the following input of shape `[4, 1, 1, 3]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\nThe output tensor has shape `[1, 2, 2, 3]` and value:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\n(3) For the following input of shape `[4, 2, 2, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\nThe output tensor has shape `[1, 4, 4, 1]` and value:\n\n```\nx = [[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]\n```\n\n(4) For the following input of shape `[8, 1, 3, 1]`, `block_shape = [2, 2]`, and\n    `crops = [[0, 0], [2, 0]]`:\n\n```\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n```\n\nThe output tensor has shape `[2, 2, 4, 1]` and value:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```",
          "name": "crops",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "BatchToSpace for N-D tensors of type T."
    }
  },
  {
    "name": "Betainc",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The regularized incomplete beta integral is defined as:\n\n\n\\\\(I_x(a, b) = \\frac{B(x; a, b)}{B(a, b)}\\\\)\n\nwhere\n\n\n\\\\(B(x; a, b) = \\int_0^x t^{a-1} (1 - t)^{b-1} dt\\\\)\n\n\nis the incomplete beta function and \\\\(B(a, b)\\\\) is the *complete*\nbeta function.",
      "inputs": [
        {
          "description": "",
          "name": "a",
          "type": 0
        },
        {
          "description": "",
          "name": "b",
          "type": 0
        },
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Compute the regularized incomplete beta integral \\\\(I_x(a, b)\\\\)."
    }
  },
  {
    "name": "BiasAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension.",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "This is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions.",
      "inputs": [
        {
          "description": "Any number of dimensions.",
          "name": "value",
          "type": 0
        },
        {
          "description": "1-D with size the last dimension of `value`.",
          "name": "bias",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Broadcasted sum of `value` and `bias`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Adds `bias` to `value`."
    }
  },
  {
    "name": "BiasAddGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the bias tensor will be added to the last dimension\nof the value tensor.\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].\nThe tensor will be added to \"in_channels\", the third-to-the-last\n    dimension.",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "It accumulates all the values from out_backprop into the feature dimension.\nFor NHWC data format, the feature dimension is the last. For NCHW data format,\nthe feature dimension is the third-to-last.",
      "inputs": [
        {
          "description": "Any number of dimensions.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D with size the feature dimension of `out_backprop`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "The backward operation for \"BiasAdd\" on the \"bias\" tensor."
    }
  },
  {
    "name": "BiasAddV1",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is a deprecated version of BiasAdd and will be soon removed.\n\nThis is a special case of `tf.add` where `bias` is restricted to be 1-D.\nBroadcasting is supported, so `value` may have any number of dimensions.",
      "inputs": [
        {
          "description": "Any number of dimensions.",
          "name": "value",
          "type": 0
        },
        {
          "description": "1-D with size the last dimension of `value`.",
          "name": "bias",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Broadcasted sum of `value` and `bias`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Adds `bias` to `value`."
    }
  },
  {
    "name": "Bincount",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a vector with length `size` and the same dtype as `weights`. If\n`weights` are empty, then index `i` stores the number of times the value `i` is\ncounted in `arr`. If `weights` are non-empty, then index `i` stores the sum of\nthe value in `weights` at each index where the corresponding value in `arr` is\n`i`.\n\nValues in `arr` outside of the range [0, size) are ignored.",
      "inputs": [
        {
          "description": "int32 `Tensor`.",
          "name": "arr",
          "type": 3
        },
        {
          "description": "non-negative int32 scalar `Tensor`.",
          "name": "size",
          "type": 3
        },
        {
          "description": "is an int32, int64, float32, or float64 `Tensor` with the same\nshape as `arr`, or a length-0 `Tensor`, in which case it acts as all weights\nequal to 1.",
          "name": "weights",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1D `Tensor` with length equal to `size`. The counts or summed weights for\neach value in the range [0, size).",
          "name": "bins",
          "type": 0
        }
      ],
      "summary": "Counts the number of occurrences of each value in an integer array."
    }
  },
  {
    "name": "Bitcast",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "type",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input`, this operation returns a tensor that has the same buffer\ndata as `input` with datatype `type`.\n\nIf the input datatype `T` is larger than the output datatype `type` then the\nshape changes from [...] to [..., sizeof(`T`)/sizeof(`type`)].\n\nIf `T` is smaller than `type`, the operator requires that the rightmost\ndimension be equal to sizeof(`type`)/sizeof(`T`). The shape then goes from\n[..., sizeof(`type`)/sizeof(`T`)] to [...].\n\n*NOTE*: Bitcast is implemented as a low-level cast, so machines with different\nendian orderings will give different results.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Bitcasts a tensor from one type to another without copying data."
    }
  },
  {
    "name": "BitwiseAnd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have those bits set, that are set in both `x` and `y`. The\ncomputation is performed on the underlying representations of `x` and `y`.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Elementwise computes the bitwise AND of `x` and `y`."
    }
  },
  {
    "name": "BitwiseOr",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have those bits set, that are set in `x`, `y` or both. The\ncomputation is performed on the underlying representations of `x` and `y`.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Elementwise computes the bitwise OR of `x` and `y`."
    }
  },
  {
    "name": "BitwiseXor",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have those bits set, that are different in `x` and `y`. The\ncomputation is performed on the underlying representations of `x` and `y`.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Elementwise computes the bitwise XOR of `x` and `y`."
    }
  },
  {
    "name": "BroadcastArgs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given `s0` and `s1`, tensors that represent shapes, compute `r0`, the\nbroadcasted shape. `s0`, `s1` and `r0` are all integer vectors.",
      "inputs": [
        {
          "description": "",
          "name": "s0",
          "type": 0
        },
        {
          "description": "",
          "name": "s1",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "r0",
          "type": 0
        }
      ],
      "summary": "Return the shape of s0 op s1 with broadcast."
    }
  },
  {
    "name": "BroadcastGradientArgs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is typically used by gradient computations for a broadcasting operation.",
      "inputs": [
        {
          "description": "",
          "name": "s0",
          "type": 0
        },
        {
          "description": "",
          "name": "s1",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "r0",
          "type": 0
        },
        {
          "description": "",
          "name": "r1",
          "type": 0
        }
      ],
      "summary": "Return the reduction indices for computing gradients of s0 op s1 with broadcast."
    }
  },
  {
    "name": "Bucketize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A sorted list of floats gives the boundary of the buckets.",
          "name": "boundaries",
          "type": "list(float)"
        }
      ],
      "description": "For example, if the inputs are\n    boundaries = [0, 10, 100]\n    input = [[-5, 10000]\n             [150,   10]\n             [5,    100]]\n\nthen the output will be\n    output = [[0, 3]\n              [3, 2]\n              [1, 3]]",
      "inputs": [
        {
          "description": "Any shape of Tensor contains with int or float type.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same shape with 'input', each value of input replaced with bucket index.\n\n@compatibility(numpy)\nEquivalent to np.digitize.\n@end_compatibility",
          "name": "output",
          "type": 3
        }
      ],
      "summary": "Bucketizes 'input' based on 'boundaries'."
    }
  },
  {
    "name": "BytesProducedStatsDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "tag",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Records the bytes size of each element of `input_dataset` in a StatsAggregator."
    }
  },
  {
    "name": "CTCBeamSearchDecoder",
    "schema": {
      "attributes": [
        {
          "description": "A scalar >= 0 (beam search beam width).",
          "name": "beam_width",
          "type": "int"
        },
        {
          "description": "A scalar >= 0, <= beam_width (controls output size).",
          "name": "top_paths",
          "type": "int"
        },
        {
          "description": "If true, merge repeated classes in output.",
          "name": "merge_repeated",
          "type": "bool"
        }
      ],
      "description": "A note about the attribute merge_repeated: For the beam search decoder,\nthis means that if consecutive entries in a beam are the same, only\nthe first of these is emitted.  That is, when the top path is \"A B B B B\",\n\"A B\" is returned if merge_repeated = True but \"A B B B B\" is\nreturned if merge_repeated = False.",
      "inputs": [
        {
          "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "A vector containing sequence lengths, size `(batch)`.",
          "name": "sequence_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A list (length: top_paths) of indices matrices.  Matrix j,\nsize `(total_decoded_outputs[j] x 2)`, has indices of a\n`SparseTensor<int64, 2>`.  The rows store: [batch, time].",
          "name": "decoded_indices",
          "type": 9
        },
        {
          "description": "A list (length: top_paths) of values vectors.  Vector j,\nsize `(length total_decoded_outputs[j])`, has the values of a\n`SparseTensor<int64, 2>`.  The vector stores the decoded classes for beam j.",
          "name": "decoded_values",
          "type": 9
        },
        {
          "description": "A list (length: top_paths) of shape vector.  Vector j,\nsize `(2)`, stores the shape of the decoded `SparseTensor[j]`.\nIts values are: `[batch_size, max_decoded_length[j]]`.",
          "name": "decoded_shape",
          "type": 9
        },
        {
          "description": "A matrix, shaped: `(batch_size x top_paths)`.  The\nsequence log-probabilities.",
          "name": "log_probability",
          "type": 1
        }
      ],
      "summary": "Performs beam search decoding on the logits given in input."
    }
  },
  {
    "name": "CTCGreedyDecoder",
    "schema": {
      "attributes": [
        {
          "description": "If True, merge repeated classes in output.",
          "name": "merge_repeated",
          "type": "bool"
        }
      ],
      "description": "A note about the attribute merge_repeated: if enabled, when\nconsecutive logits' maximum indices are the same, only the first of\nthese is emitted.  Labeling the blank '*', the sequence \"A B B * B B\"\nbecomes \"A B B\" if merge_repeated = True and \"A B B B B\" if\nmerge_repeated = False.\n\nRegardless of the value of merge_repeated, if the maximum index of a given\ntime and batch corresponds to the blank, index `(num_classes - 1)`, no new\nelement is emitted.",
      "inputs": [
        {
          "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "A vector containing sequence lengths, size `(batch_size)`.",
          "name": "sequence_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Indices matrix, size `(total_decoded_outputs x 2)`,\nof a `SparseTensor<int64, 2>`.  The rows store: [batch, time].",
          "name": "decoded_indices",
          "type": 9
        },
        {
          "description": "Values vector, size: `(total_decoded_outputs)`,\nof a `SparseTensor<int64, 2>`.  The vector stores the decoded classes.",
          "name": "decoded_values",
          "type": 9
        },
        {
          "description": "Shape vector, size `(2)`, of the decoded SparseTensor.\nValues are: `[batch_size, max_decoded_length]`.",
          "name": "decoded_shape",
          "type": 9
        },
        {
          "description": "Matrix, size `(batch_size x 1)`, containing sequence\nlog-probabilities.",
          "name": "log_probability",
          "type": 1
        }
      ],
      "summary": "Performs greedy decoding on the logits given in inputs."
    }
  },
  {
    "name": "CTCLoss",
    "schema": {
      "attributes": [
        {
          "description": "Scalar, if true then repeated labels are\ncollapsed prior to the CTC calculation.",
          "name": "preprocess_collapse_repeated",
          "type": "bool"
        },
        {
          "description": "Scalar.  If set to false, *during* CTC calculation\nrepeated non-blank labels will not be merged and are interpreted as\nindividual labels.  This is a simplified version of CTC.",
          "name": "ctc_merge_repeated",
          "type": "bool"
        },
        {
          "description": "Scalar. If set to true, during CTC\ncalculation, items that have longer output sequences than input sequences\nare skipped: they don't contribute to the loss term and have zero-gradient.",
          "name": "ignore_longer_outputs_than_inputs",
          "type": "bool"
        }
      ],
      "description": "the gradient.  This class performs the softmax operation for you, so inputs\nshould be e.g. linear projections of outputs by an LSTM.",
      "inputs": [
        {
          "description": "3-D, shape: `(max_time x batch_size x num_classes)`, the logits.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "The indices of a `SparseTensor<int32, 2>`.\n`labels_indices(i, :) == [b, t]` means `labels_values(i)` stores the id for\n`(batch b, time t)`.",
          "name": "labels_indices",
          "type": 9
        },
        {
          "description": "The values (labels) associated with the given batch and time.",
          "name": "labels_values",
          "type": 3
        },
        {
          "description": "A vector containing sequence lengths (batch).",
          "name": "sequence_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A vector (batch) containing log-probabilities.",
          "name": "loss",
          "type": 1
        },
        {
          "description": "The gradient of `loss`.  3-D, shape:\n`(max_time x batch_size x num_classes)`.",
          "name": "gradient",
          "type": 1
        }
      ],
      "summary": "Calculates the CTC Loss (log probability) for each batch entry.  Also calculates"
    }
  },
  {
    "name": "CacheDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "A CacheDataset will iterate over the input_dataset, and store tensors. If the\ncache already exists, the cache will be used. If the cache is inappropriate\n(e.g. cannot be opened, contains tensors of the wrong shape / size), an error\nwill the returned when used.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A path on the filesystem where we should cache the dataset. Note: this\nwill be a directory.",
          "name": "filename",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that caches elements from `input_dataset`."
    }
  },
  {
    "name": "Cast",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "SrcT",
          "type": "type"
        },
        {
          "description": "",
          "name": "DstT",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Cast x of type SrcT to y of DstT."
    }
  },
  {
    "name": "Ceil",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Returns element-wise smallest integer in not less than x."
    }
  },
  {
    "name": "CheckNumerics",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Prefix of the error message.",
          "name": "message",
          "type": "string"
        }
      ],
      "description": "When run, reports an `InvalidArgument` error if `tensor` has any values\nthat are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is.",
      "inputs": [
        {
          "description": "",
          "name": "tensor",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Checks a tensor for NaN and Inf values."
    }
  },
  {
    "name": "Cholesky",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices.\n\nThe input has to be symmetric and positive definite. Only the lower-triangular\npart of the input will be used for this operation. The upper-triangular part\nwill not be read.\n\nThe output is a tensor of the same shape as the input\ncontaining the Cholesky decompositions for all input submatrices `[..., :, :]`.\n\n**Note**: The gradient computation on GPU is faster for large matrices but\nnot for large batch dimensions when the submatrices are small. In this\ncase it might be faster to use the CPU.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the Cholesky decomposition of one or more square matrices."
    }
  },
  {
    "name": "CholeskyGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For an explanation see \"Differentiation of the Cholesky algorithm\" by\nIain Murray http://arxiv.org/abs/1602.07527.",
      "inputs": [
        {
          "description": "Output of batch Cholesky algorithm l = cholesky(A). Shape is `[..., M, M]`.\nAlgorithm depends only on lower triangular part of the innermost matrices of\nthis tensor.",
          "name": "l",
          "type": 0
        },
        {
          "description": "df/dl where f is some scalar function. Shape is `[..., M, M]`.\nAlgorithm depends only on lower triangular part of the innermost matrices of\nthis tensor.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Symmetrized version of df/dA . Shape is `[..., M, M]`",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the reverse mode backpropagated gradient of the Cholesky algorithm."
    }
  },
  {
    "name": "CompareAndBitpack",
    "schema": {
      "attributes": [
        {
          "description": "The type of the input and threshold.",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Each comparison returns a boolean `true` (if `input_value > threshold`)\nor and `false` otherwise.\n\nThis operation is useful for Locality-Sensitive-Hashing (LSH) and other\nalgorithms that use hashing approximations of cosine and `L2` distances;\ncodes can be generated from an input via:\n\n```python\ncodebook_size = 50\ncodebook_bits = codebook_size * 32\ncodebook = tf.get_variable('codebook', [x.shape[-1].value, codebook_bits],\n                           dtype=x.dtype,\n                           initializer=tf.orthogonal_initializer())\ncodes = compare_and_threshold(tf.matmul(x, codebook), threshold=0.)\ncodes = tf.bitcast(codes, tf.int32)  # go from uint8 to int32\n# now codes has shape x.shape[:-1] + [codebook_size]\n```\n\n**NOTE**: Currently, the innermost dimension of the tensor must be divisible\nby 8.\n\nGiven an `input` shaped `[s0, s1, ..., s_n]`, the output is\na `uint8` tensor shaped `[s0, s1, ..., s_n / 8]`.",
      "inputs": [
        {
          "description": "Values to compare against `threshold` and bitpack.",
          "name": "input",
          "type": 0
        },
        {
          "description": "Threshold to compare against.",
          "name": "threshold",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The bitpacked comparisons.",
          "name": "output",
          "type": 4
        }
      ],
      "summary": "Compare values of `input` to `threshold` and pack resulting bits into a `uint8`."
    }
  },
  {
    "name": "Complex",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `real` representing the real part of a complex number, and a\ntensor `imag` representing the imaginary part of a complex number, this\noperation returns complex numbers elementwise of the form \\\\(a + bj\\\\), where\n*a* represents the `real` part and *b* represents the `imag` part.\n\nThe input tensors `real` and `imag` must have the same shape.\n\nFor example:\n\n```\n# tensor 'real' is [2.25, 3.25]\n# tensor `imag` is [4.75, 5.75]\ntf.complex(real, imag) ==> [[2.25 + 4.75j], [3.25 + 5.75j]]\n```",
      "inputs": [
        {
          "description": "",
          "name": "real",
          "type": 0
        },
        {
          "description": "",
          "name": "imag",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Converts two real numbers to a complex number."
    }
  },
  {
    "name": "ComplexAbs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `x` of complex numbers, this operation returns a tensor of type\n`float` or `double` that is the absolute value of each element in `x`. All\nelements in `x` must be complex numbers of the form \\\\(a + bj\\\\). The absolute\nvalue is computed as \\\\( \\sqrt{a^2 + b^2}\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the complex absolute value of a tensor."
    }
  },
  {
    "name": "ComputeAccidentalHits",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "When doing log-odds NCE, the result of this op should be passed through a\nSparseToDense op, then added to the logits of the sampled candidates. This has\nthe effect of 'removing' the sampled labels that match the true labels by\nmaking the classifier sure that they are sampled labels.",
      "inputs": [
        {
          "description": "The true_classes output of UnpackSparseLabels.",
          "name": "true_classes",
          "type": 9
        },
        {
          "description": "The sampled_candidates output of CandidateSampler.",
          "name": "sampled_candidates",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of indices corresponding to rows of true_candidates.",
          "name": "indices",
          "type": 3
        },
        {
          "description": "A vector of IDs of positions in sampled_candidates that match a true_label\nfor the row with the corresponding index in indices.",
          "name": "ids",
          "type": 9
        },
        {
          "description": "A vector of the same length as indices and ids, in which each element\nis -FLOAT_MAX.",
          "name": "weights",
          "type": 1
        }
      ],
      "summary": "Computes the ids of the positions in sampled_candidates that match true_labels."
    }
  },
  {
    "name": "Concat",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values)).",
          "name": "concat_dim",
          "type": 3
        },
        {
          "description": "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
          "name": "values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Concatenates tensors along one dimension."
    }
  },
  {
    "name": "ConcatOffset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "description": "For example:\n\n```\n# 'x' is [2, 2, 7]\n# 'y' is [2, 3, 7]\n# 'z' is [2, 5, 7]\nconcat_offset(2, [x, y, z]) => [0, 0, 0], [0, 2, 0], [0, 5, 0]\n```\n\nThis is typically used by gradient computations for a concat operation.",
      "inputs": [
        {
          "description": "The dimension along which to concatenate.",
          "name": "concat_dim",
          "type": 3
        },
        {
          "description": "The `N` int32 vectors representing shape of tensors being concatenated.",
          "name": "shape",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The `N` int32 vectors representing the starting offset\nof input tensors within the concatenated output.",
          "name": "offset",
          "type": 3
        }
      ],
      "summary": "Computes offsets of concat inputs within its output."
    }
  },
  {
    "name": "ConcatV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "List of `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
          "name": "values",
          "type": 0
        },
        {
          "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [-rank(values), rank(values)).",
          "name": "axis",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Concatenates tensors along one dimension."
    }
  },
  {
    "name": "ConcatenateDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "another_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that concatenates `input_dataset` with `another_dataset`."
    }
  },
  {
    "name": "ConditionalAccumulator",
    "schema": {
      "attributes": [
        {
          "description": "The type of the value being accumulated.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The shape of the values, can be [], in which case shape is unknown.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this accumulator will be shared under the\ngiven name across multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.",
      "outputs": [
        {
          "description": "The handle to the accumulator.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A conditional accumulator for aggregating gradients."
    }
  },
  {
    "name": "Conj",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ncomplex numbers that are the complex conjugate of each element in `input`. The\ncomplex numbers in `input` must be of the form \\\\(a + bj\\\\), where *a* is the\nreal part and *b* is the imaginary part.\n\nThe complex conjugate returned by this operation is of the form \\\\(a - bj\\\\).\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.conj(input) ==> [-2.25 - 4.75j, 3.25 - 5.75j]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the complex conjugate of a complex number."
    }
  },
  {
    "name": "ConjugateTranspose",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tperm",
          "type": "type"
        }
      ],
      "description": "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`\n  `y[i,j,k,...,s,t,u] == conj(x[perm[i], perm[j], perm[k],...,perm[s], perm[t], perm[u]])`",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "perm",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Shuffle dimensions of x according to a permutation and conjugate the result."
    }
  },
  {
    "name": "Const",
    "schema": {
      "attributes": [
        {
          "description": "Attr `value` is the tensor to return.",
          "name": "value",
          "type": "tensor"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns a constant tensor."
    }
  },
  {
    "name": "ControlTrigger",
    "schema": {
      "description": "Only useful as a placeholder for control edges.",
      "summary": "Does nothing. Serves as a control trigger for scheduling."
    }
  },
  {
    "name": "Conv2D",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 4.  The stride of the sliding window for each\ndimension of `input`. The dimension order is determined by the value of\n  `data_format`, see below for details.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "",
          "name": "use_cudnn_on_gpu",
          "type": "bool"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`, this op\nperforms the following:\n\n1. Flattens the filter to a 2-D matrix with shape\n   `[filter_height * filter_width * in_channels, output_channels]`.\n2. Extracts image patches from the input tensor to form a *virtual*\n   tensor of shape `[batch, out_height, out_width,\n   filter_height * filter_width * in_channels]`.\n3. For each patch, right-multiplies the filter matrix and the image patch\n   vector.\n\nIn detail, with the default NHWC format,\n\n    output[b, i, j, k] =\n        sum_{di, dj, q} input[b, strides[1] * i + di, strides[2] * j + dj, q] *\n                        filter[di, dj, q, k]\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`.",
      "inputs": [
        {
          "description": "A 4-D tensor. The dimension order is interpreted according to the value\nof `data_format`, see below for details.",
          "name": "input",
          "type": 0
        },
        {
          "description": "A 4-D tensor of shape\n`[filter_height, filter_width, in_channels, out_channels]`",
          "name": "filter",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A 4-D tensor. The dimension order is determined by the value of\n`data_format`, see below for details.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes a 2-D convolution given 4-D `input` and `filter` tensors."
    }
  },
  {
    "name": "Conv2DBackpropFilter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "",
          "name": "use_cudnn_on_gpu",
          "type": "bool"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, out_channels]` tensor.",
          "name": "filter_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of convolution with respect to the filter."
    }
  },
  {
    "name": "Conv2DBackpropInput",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified with\nformat.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "",
          "name": "use_cudnn_on_gpu",
          "type": "bool"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "An integer vector representing the shape of `input`,\nwhere `input` is a 4-D `[batch, height, width, channels]` tensor.",
          "name": "input_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.  Gradient\nw.r.t. the input of the convolution.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of convolution with respect to the input."
    }
  },
  {
    "name": "Conv3D",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "In signal processing, cross-correlation is a measure of similarity of\ntwo waveforms as a function of a time-lag applied to one of them. This\nis also known as a sliding dot product or sliding inner-product.\n\nOur Conv3D implements a form of cross-correlation.",
      "inputs": [
        {
          "description": "Shape `[batch, in_depth, in_height, in_width, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "Shape `[filter_depth, filter_height, filter_width, in_channels,\nout_channels]`. `in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes a 3-D convolution given 5-D `input` and `filter` tensors."
    }
  },
  {
    "name": "Conv3DBackpropFilter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the filter."
    }
  },
  {
    "name": "Conv3DBackpropFilterV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 5-D\n`[filter_depth, filter_height, filter_width, in_channels, out_channels]`\ntensor.",
          "name": "filter_sizes",
          "type": 3
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the filter."
    }
  },
  {
    "name": "Conv3DBackpropInput",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the input."
    }
  },
  {
    "name": "Conv3DBackpropInputV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "An integer vector representing the tensor shape of `input`,\nwhere `input` is a 5-D\n`[batch, depth, rows, cols, in_channels]` tensor.",
          "name": "input_sizes",
          "type": 3
        },
        {
          "description": "Shape `[depth, rows, cols, in_channels, out_channels]`.\n`in_channels` must match between `input` and `filter`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "Backprop signal of shape `[batch, out_depth, out_rows, out_cols,\nout_channels]`.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of 3-D convolution with respect to the input."
    }
  },
  {
    "name": "Copy",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The name of the input tensor.",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "description": "A list of debug op spec (op, url, gated_grpc) for attached debug\nops. Each element of the list has the format\n<debug_op>;<grpc_url>;<gated_grpc>, wherein gated_grpc is boolean represented\nas 0/1. E.g., \"DebugIdentity;grpc://foo:3333;1\",\n\"DebugIdentity;file:///tmp/tfdbg_1;0\".",
          "name": "debug_ops_spec",
          "type": "list(string)"
        }
      ],
      "description": "Performs CPU-to-CPU or GPU-to-GPU deep-copying of tensor, depending on the\ndevice on which the tensor is allocated.\nN.B.: If the all downstream attached debug ops are disabled given the current\ngRPC gating status, the output will simply forward the input tensor without\ndeep-copying. See the documentation of Debug* ops for more details.\n\nUnlike the CopyHost Op, this op does not have HostMemory constraint on its\ninput or output.",
      "inputs": [
        {
          "description": "Input tensor.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Output tensor, deep-copied from input.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Copy Op."
    }
  },
  {
    "name": "CopyHost",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The name of the input tensor.",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "description": "A list of debug op spec (op, url, gated_grpc) for attached debug\nops. Each element of the list has the format\n<debug_op>;<grpc_url>;<gated_grpc>, wherein gated_grpc is boolean represented\nas 0/1. E.g., \"DebugIdentity;grpc://foo:3333;1\",\n\"DebugIdentity;file:///tmp/tfdbg_1;0\".",
          "name": "debug_ops_spec",
          "type": "list(string)"
        }
      ],
      "description": "Performs CPU-to-CPU deep-copying of tensor.\nN.B.: If the all downstream attached debug ops are disabled given the current\ngRPC gating status, the output will simply forward the input tensor without\ndeep-copying. See the documentation of Debug* ops for more details.\n\nUnlike the Copy Op, this op has HostMemory constraint on its input or output.",
      "inputs": [
        {
          "description": "Input tensor.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Output tensor, deep-copied from input.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Copy Host Op."
    }
  },
  {
    "name": "Cos",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes cos of x element-wise."
    }
  },
  {
    "name": "Cosh",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes hyperbolic cosine of x element-wise."
    }
  },
  {
    "name": "CountUpTo",
    "schema": {
      "attributes": [
        {
          "description": "If incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error.",
          "name": "limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a scalar `Variable` node.",
          "name": "ref",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Increments 'ref' until it reaches 'limit'."
    }
  },
  {
    "name": "CropAndResize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now.",
          "name": "method",
          "type": "string"
        },
        {
          "description": "Value used for extrapolation, when applicable.",
          "name": "extrapolation_value",
          "type": "float"
        }
      ],
      "description": "with aspect ratio change) to a common output size specified by `crop_size`. This\nis more general than the `crop_to_bounding_box` op which extracts a fixed size\nslice from the input image and does not allow resizing or aspect ratio change.\n\nReturns a tensor with `crops` from the input `image` at positions defined at the\nbounding box locations in `boxes`. The cropped boxes are all resized (with\nbilinear interpolation) to a fixed `size = [crop_height, crop_width]`. The\nresult is a 4-D tensor `[num_boxes, crop_height, crop_width, depth]`. The\nresizing is corner aligned. In particular, if `boxes = [[0, 0, 1, 1]]`, the\nmethod will give identical results to using `tf.image.resize_bilinear()`\nwith `align_corners=True`.",
      "inputs": [
        {
          "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.\nBoth `image_height` and `image_width` need to be positive.",
          "name": "image",
          "type": 0
        },
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1]` in image height coordinates. We do allow `y1` > `y2`, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
          "name": "box_ind",
          "type": 3
        },
        {
          "description": "A 1-D tensor of 2 elements, `size = [crop_height, crop_width]`. All\ncropped image patches are resized to this size. The aspect ratio of the image\ncontent is not preserved. Both `crop_height` and `crop_width` need to be\npositive.",
          "name": "crop_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
          "name": "crops",
          "type": 1
        }
      ],
      "summary": "Extracts crops from the input image tensor and bilinearly resizes them (possibly"
    }
  },
  {
    "name": "CropAndResizeGradBoxes",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now.",
          "name": "method",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.\nBoth `image_height` and `image_width` need to be positive.",
          "name": "image",
          "type": 0
        },
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1] in image height coordinates. We do allow y1 > y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
          "name": "box_ind",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`.",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Computes the gradient of the crop_and_resize op wrt the input boxes tensor."
    }
  },
  {
    "name": "CropAndResizeGradImage",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A string specifying the interpolation method. Only 'bilinear' is\nsupported for now.",
          "name": "method",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "A 4-D tensor of shape `[num_boxes, crop_height, crop_width, depth]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "A 2-D tensor of shape `[num_boxes, 4]`. The `i`-th row of the tensor\nspecifies the coordinates of a box in the `box_ind[i]` image and is specified\nin normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value of\n`y` is mapped to the image coordinate at `y * (image_height - 1)`, so as the\n`[0, 1]` interval of normalized image height is mapped to\n`[0, image_height - 1] in image height coordinates. We do allow y1 > y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the `[0, 1]` range are allowed, in which case we use\n`extrapolation_value` to extrapolate the input image values.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D tensor of shape `[num_boxes]` with int32 values in `[0, batch)`.\nThe value of `box_ind[i]` specifies the image that the `i`-th box refers to.",
          "name": "box_ind",
          "type": 3
        },
        {
          "description": "A 1-D tensor with value `[batch, image_height, image_width, depth]`\ncontaining the original image size. Both `image_height` and `image_width` need\nto be positive.",
          "name": "image_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 4-D tensor of shape `[batch, image_height, image_width, depth]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of the crop_and_resize op wrt the input image tensor."
    }
  },
  {
    "name": "Cross",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`a` and `b` must be the same shape; they can either be simple 3-element vectors,\nor any shape where the innermost dimension is 3. In the latter case, each pair\nof corresponding 3-element vectors is cross-multiplied independently.",
      "inputs": [
        {
          "description": "A tensor containing 3-element vectors.",
          "name": "a",
          "type": 0
        },
        {
          "description": "Another tensor, of same type and shape as `a`.",
          "name": "b",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Pairwise cross product of the vectors in `a` and `b`.",
          "name": "product",
          "type": 0
        }
      ],
      "summary": "Compute the pairwise cross product."
    }
  },
  {
    "name": "Cumprod",
    "schema": {
      "attributes": [
        {
          "description": "If `True`, perform exclusive cumprod.",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "description": "A `bool` (default: False).",
          "name": "reverse",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "By default, this op performs an inclusive cumprod, which means that the first\nelement of the input is identical to the first element of the output:\n\n```python\ntf.cumprod([a, b, c])  # => [a, a * b, a * b * c]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumprod is\nperformed instead:\n\n```python\ntf.cumprod([a, b, c], exclusive=True)  # => [1, a, a * b]\n```\n\nBy setting the `reverse` kwarg to `True`, the cumprod is performed in the\nopposite direction:\n\n```python\ntf.cumprod([a, b, c], reverse=True)  # => [a * b * c, b * c, c]\n```\n\nThis is more efficient than using separate `tf.reverse` ops.\n\nThe `reverse` and `exclusive` kwargs can also be combined:\n\n```python\ntf.cumprod([a, b, c], exclusive=True, reverse=True)  # => [b * c, c, 1]\n```",
      "inputs": [
        {
          "description": "A `Tensor`. Must be one of the following types: `float32`, `float64`,\n`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,\n`complex128`, `qint8`, `quint8`, `qint32`, `half`.",
          "name": "x",
          "type": 0
        },
        {
          "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
          "name": "axis",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Compute the cumulative product of the tensor `x` along `axis`."
    }
  },
  {
    "name": "Cumsum",
    "schema": {
      "attributes": [
        {
          "description": "If `True`, perform exclusive cumsum.",
          "name": "exclusive",
          "type": "bool"
        },
        {
          "description": "A `bool` (default: False).",
          "name": "reverse",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "By default, this op performs an inclusive cumsum, which means that the first\nelement of the input is identical to the first element of the output:\n\n```python\ntf.cumsum([a, b, c])  # => [a, a + b, a + b + c]\n```\n\nBy setting the `exclusive` kwarg to `True`, an exclusive cumsum is\nperformed instead:\n\n```python\ntf.cumsum([a, b, c], exclusive=True)  # => [0, a, a + b]\n```\n\nBy setting the `reverse` kwarg to `True`, the cumsum is performed in the\nopposite direction:\n\n```python\ntf.cumsum([a, b, c], reverse=True)  # => [a + b + c, b + c, c]\n```\n\nThis is more efficient than using separate `tf.reverse` ops.\n\nThe `reverse` and `exclusive` kwargs can also be combined:\n\n```python\ntf.cumsum([a, b, c], exclusive=True, reverse=True)  # => [b + c, c, 0]\n```",
      "inputs": [
        {
          "description": "A `Tensor`. Must be one of the following types: `float32`, `float64`,\n`int64`, `int32`, `uint8`, `uint16`, `int16`, `int8`, `complex64`,\n`complex128`, `qint8`, `quint8`, `qint32`, `half`.",
          "name": "x",
          "type": 0
        },
        {
          "description": "A `Tensor` of type `int32` (default: 0). Must be in the range\n`[-rank(x), rank(x))`.",
          "name": "axis",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Compute the cumulative sum of the tensor `x` along `axis`."
    }
  },
  {
    "name": "DatasetToSingleElement",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A handle to a dataset that contains a single element.",
          "name": "dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "The components of the single element of `input`.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Outputs the single element from the given dataset."
    }
  },
  {
    "name": "DebugGradientIdentity",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op is hidden from public in Python. It is used by TensorFlow Debugger to\nregister gradient tensors for gradient debugging.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Identity op for gradient debugging."
    }
  },
  {
    "name": "DebugIdentity",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "device_name",
          "type": "string"
        },
        {
          "description": "Name of the input tensor.",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "description": "List of URLs to debug targets, e.g.,\nfile:///foo/tfdbg_dump, grpc:://localhost:11011",
          "name": "debug_urls",
          "type": "list(string)"
        },
        {
          "description": "Whether this op will be gated. If any of the debug_urls of this\ndebug node is of the grpc:// scheme, when the value of this attribute is set\nto True, the data will not actually be sent via the grpc stream unless this\ndebug op has been enabled at the debug_url. If all of the debug_urls of this\ndebug node are of the grpc:// scheme and the debug op is enabled at none of\nthem, the output will be an empty Tensor.",
          "name": "gated_grpc",
          "type": "bool"
        }
      ],
      "description": "Provides an identity mapping of the non-Ref type input tensor for debugging.",
      "inputs": [
        {
          "description": "Input tensor, non-Reference type.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Output tensor that equals the input tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Debug Identity Op."
    }
  },
  {
    "name": "DebugNanCount",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "device_name",
          "type": "string"
        },
        {
          "description": "Name of the input tensor.",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "description": "List of URLs to debug targets, e.g.,\nfile:///foo/tfdbg_dump, grpc:://localhost:11011.",
          "name": "debug_urls",
          "type": "list(string)"
        },
        {
          "description": "Whether this op will be gated. If any of the debug_urls of this\ndebug node is of the grpc:// scheme, when the value of this attribute is set\nto True, the data will not actually be sent via the grpc stream unless this\ndebug op has been enabled at the debug_url. If all of the debug_urls of this\ndebug node are of the grpc:// scheme and the debug op is enabled at none of\nthem, the output will be an empty Tensor.",
          "name": "gated_grpc",
          "type": "bool"
        }
      ],
      "description": "Counts number of NaNs in the input tensor, for debugging.",
      "inputs": [
        {
          "description": "Input tensor, non-Reference type.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "An integer output tensor that is the number of NaNs in the input.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Debug NaN Value Counter Op"
    }
  },
  {
    "name": "DebugNumericSummary",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "device_name",
          "type": "string"
        },
        {
          "description": "Name of the input tensor.",
          "name": "tensor_name",
          "type": "string"
        },
        {
          "description": "List of URLs to debug targets, e.g.,\nfile:///foo/tfdbg_dump, grpc:://localhost:11011",
          "name": "debug_urls",
          "type": "list(string)"
        },
        {
          "description": "(float) The lower bound <= which values will be included in the\ngeneralized -inf count. Default: -inf.",
          "name": "lower_bound",
          "type": "float"
        },
        {
          "description": "(float) The upper bound >= which values will be included in the\ngeneralized +inf count. Default: +inf.",
          "name": "upper_bound",
          "type": "float"
        },
        {
          "description": "(bool) Do not send data to the debug URLs unless at least one\nof elements [2], [3] and [7] (i.e., the nan count and the generalized -inf and\ninf counts) is non-zero.",
          "name": "mute_if_healthy",
          "type": "bool"
        },
        {
          "description": "Whether this op will be gated. If any of the debug_urls of this\ndebug node is of the grpc:// scheme, when the value of this attribute is set\nto True, the data will not actually be sent via the grpc stream unless this\ndebug op has been enabled at the debug_url. If all of the debug_urls of this\ndebug node are of the grpc:// scheme and the debug op is enabled at none of\nthem, the output will be an empty Tensor.",
          "name": "gated_grpc",
          "type": "bool"
        }
      ],
      "description": "Provide a basic summary of numeric value types, range and distribution.",
      "inputs": [
        {
          "description": "Input tensor, non-Reference type, float or double.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A double tensor of shape [14 + nDimensions], where nDimensions is the\n  the number of dimensions of the tensor's shape. The elements of output are:\n  [0]: is initialized (1.0) or not (0.0).\n  [1]: total number of elements\n  [2]: NaN element count\n  [3]: generalized -inf count: elements <= lower_bound. lower_bound is -inf by\n    default.\n  [4]: negative element count (excluding -inf), if lower_bound is the default\n    -inf. Otherwise, this is the count of elements > lower_bound and < 0.\n  [5]: zero element count\n  [6]: positive element count (excluding +inf), if upper_bound is the default\n    -inf. Otherwise, this is the count of elements < upper_bound and > 0.\n  [7]: generalized +inf count, elements >= upper_bound. upper_bound is +inf by\n    default.\nOutput elements [1:8] are all zero, if the tensor is uninitialized.\n  [8]: minimum of all non-inf and non-NaN elements.\n       If uninitialized or no such element exists: +inf.\n  [9]: maximum of all non-inf and non-NaN elements.\n       If uninitialized or no such element exists: -inf.\n  [10]: mean of all non-inf and non-NaN elements.\n        If uninitialized or no such element exists: NaN.\n  [11]: variance of all non-inf and non-NaN elements.\n        If uninitialized or no such element exists: NaN.\n  [12]: Data type of the tensor encoded as an enum integer. See the DataType\n        proto for more details.\n  [13]: Number of dimensions of the tensor (ndims).\n  [14+]: Sizes of the dimensions.",
          "name": "output",
          "type": 2
        }
      ],
      "summary": "Debug Numeric Summary Op."
    }
  },
  {
    "name": "DecodeAndCropJpeg",
    "schema": {
      "attributes": [
        {
          "description": "Number of color channels for the decoded image.",
          "name": "channels",
          "type": "int"
        },
        {
          "description": "Downscaling ratio.",
          "name": "ratio",
          "type": "int"
        },
        {
          "description": "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only).",
          "name": "fancy_upscaling",
          "type": "bool"
        },
        {
          "description": "If true try to recover an image from truncated input.",
          "name": "try_recover_truncated",
          "type": "bool"
        },
        {
          "description": "The minimum required fraction of lines before a truncated\ninput is accepted.",
          "name": "acceptable_fraction",
          "type": "float"
        },
        {
          "description": "string specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)",
          "name": "dct_method",
          "type": "string"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later.\n\n\nIt is equivalent to a combination of decode and crop, but much faster by only\ndecoding partial jpeg image.",
      "inputs": [
        {
          "description": "0-D.  The JPEG-encoded image.",
          "name": "contents",
          "type": 7
        },
        {
          "description": "1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width].",
          "name": "crop_window",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`..",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode and Crop a JPEG-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodeBase64",
    "schema": {
      "description": "Input may or may not have padding at the end. See EncodeBase64 for padding.\nWeb-safe means that input must use - and _ instead of + and /.",
      "inputs": [
        {
          "description": "Base64 strings to decode.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Decoded strings.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Decode web-safe base64-encoded strings."
    }
  },
  {
    "name": "DecodeBmp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "channels",
          "type": "int"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the BMP-encoded image.\n*   3: output an RGB image.\n*   4: output an RGBA image.",
      "inputs": [
        {
          "description": "0-D.  The BMP-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`. RGB order",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode the first frame of a BMP-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodeCSV",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "OUT_TYPE",
          "type": "list(type)"
        },
        {
          "description": "char delimiter to separate fields in a record.",
          "name": "field_delim",
          "type": "string"
        },
        {
          "description": "If false, treats double quotation marks as regular\ncharacters inside of the string fields (ignoring RFC 4180, Section 2,\nBullet 5).",
          "name": "use_quote_delim",
          "type": "bool"
        },
        {
          "description": "Additional string to recognize as NA/NaN.",
          "name": "na_value",
          "type": "string"
        }
      ],
      "description": "RFC 4180 format is expected for the CSV records.\n(https://tools.ietf.org/html/rfc4180)\nNote that we allow leading and trailing spaces with int or float field.",
      "inputs": [
        {
          "description": "Each string is a record/row in the csv and all records should have\nthe same format.",
          "name": "records",
          "type": 7
        },
        {
          "description": "One tensor per column of the input record, with either a\nscalar default value for that column or empty if the column is required.",
          "name": "record_defaults",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Each tensor will have the same shape as records.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Convert CSV records to tensors. Each column maps to one tensor."
    }
  },
  {
    "name": "DecodeGif",
    "schema": {
      "description": "GIF with frame or transparency compression are not supported\nconvert animated GIF from compressed to uncompressed by:\n\n    convert $src.gif -coalesce $dst.gif\n\nThis op also supports decoding JPEGs and PNGs, though it is cleaner to use\n`tf.image.decode_image`.",
      "inputs": [
        {
          "description": "0-D.  The GIF-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[num_frames, height, width, 3]`. RGB order",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode the first frame of a GIF-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodeJSONExample",
    "schema": {
      "description": "This op translates a tensor containing Example records, encoded using\nthe [standard JSON\nmapping](https://developers.google.com/protocol-buffers/docs/proto3#json),\ninto a tensor containing the same records encoded as binary protocol\nbuffers. The resulting tensor can then be fed to any of the other\nExample-parsing ops.",
      "inputs": [
        {
          "description": "Each string is a JSON object serialized according to the JSON\nmapping of the Example proto.",
          "name": "json_examples",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Each string is a binary Example protocol buffer corresponding\nto the respective element of `json_examples`.",
          "name": "binary_examples",
          "type": 7
        }
      ],
      "summary": "Convert JSON-encoded Example records to binary protocol buffer strings."
    }
  },
  {
    "name": "DecodeJpeg",
    "schema": {
      "attributes": [
        {
          "description": "Number of color channels for the decoded image.",
          "name": "channels",
          "type": "int"
        },
        {
          "description": "Downscaling ratio.",
          "name": "ratio",
          "type": "int"
        },
        {
          "description": "If true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only).",
          "name": "fancy_upscaling",
          "type": "bool"
        },
        {
          "description": "If true try to recover an image from truncated input.",
          "name": "try_recover_truncated",
          "type": "bool"
        },
        {
          "description": "The minimum required fraction of lines before a truncated\ninput is accepted.",
          "name": "acceptable_fraction",
          "type": "float"
        },
        {
          "description": "string specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)",
          "name": "dct_method",
          "type": "string"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the JPEG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n\nIf needed, the JPEG-encoded image is transformed to match the requested number\nof color channels.\n\nThe attr `ratio` allows downscaling the image by an integer factor during\ndecoding.  Allowed values are: 1, 2, 4, and 8.  This is much faster than\ndownscaling the image later.\n\n\nThis op also supports decoding PNGs and non-animated GIFs since the interface is\nthe same, though it is cleaner to use `tf.image.decode_image`.",
      "inputs": [
        {
          "description": "0-D.  The JPEG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`..",
          "name": "image",
          "type": 4
        }
      ],
      "summary": "Decode a JPEG-encoded image to a uint8 tensor."
    }
  },
  {
    "name": "DecodePng",
    "schema": {
      "attributes": [
        {
          "description": "Number of color channels for the decoded image.",
          "name": "channels",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The attr `channels` indicates the desired number of color channels for the\ndecoded image.\n\nAccepted values are:\n\n*   0: Use the number of channels in the PNG-encoded image.\n*   1: output a grayscale image.\n*   3: output an RGB image.\n*   4: output an RGBA image.\n\nIf needed, the PNG-encoded image is transformed to match the requested number\nof color channels.\n\nThis op also supports decoding JPEGs and non-animated GIFs since the interface\nis the same, though it is cleaner to use `tf.image.decode_image`.",
      "inputs": [
        {
          "description": "0-D.  The PNG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[height, width, channels]`.",
          "name": "image",
          "type": 0
        }
      ],
      "summary": "Decode a PNG-encoded image to a uint8 or uint16 tensor."
    }
  },
  {
    "name": "DecodeRaw",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        },
        {
          "description": "Whether the input `bytes` are in little-endian order.\nIgnored for `out_type` values that are stored in a single byte like\n`uint8`.",
          "name": "little_endian",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "All the elements must have the same length.",
          "name": "bytes",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor with one more dimension than the input `bytes`.  The\nadded dimension will have size equal to the length of the elements\nof `bytes` divided by the number of bytes to represent `out_type`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Reinterpret the bytes of a string as a vector of numbers."
    }
  },
  {
    "name": "DecodeWav",
    "schema": {
      "attributes": [
        {
          "description": "Number of sample channels wanted.",
          "name": "desired_channels",
          "type": "int"
        },
        {
          "description": "Length of audio requested.",
          "name": "desired_samples",
          "type": "int"
        }
      ],
      "description": "The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.\n\nWhen desired_channels is set, if the input contains fewer channels than this\nthen the last channel will be duplicated to give the requested number, else if\nthe input has more channels than requested then the additional channels will be\nignored.\n\nIf desired_samples is set, then the audio will be cropped or padded with zeroes\nto the requested length.\n\nThe first output contains a Tensor with the content of the audio samples. The\nlowest dimension will be the number of channels, and the second will be the\nnumber of samples. For example, a ten-sample-long stereo WAV file should give an\noutput shape of [10, 2].",
      "inputs": [
        {
          "description": "The WAV-encoded audio, usually from a file.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "2-D with shape `[length, channels]`.",
          "name": "audio",
          "type": 1
        },
        {
          "description": "Scalar holding the sample rate found in the WAV header.",
          "name": "sample_rate",
          "type": 3
        }
      ],
      "summary": "Decode a 16-bit PCM WAV file to a float tensor."
    }
  },
  {
    "name": "DeleteSessionTensor",
    "schema": {
      "inputs": [
        {
          "description": "The handle for a tensor stored in the session state.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Delete the tensor specified by its handle in the session."
    }
  },
  {
    "name": "DenseToDenseSetOperation",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "set_operation",
          "type": "string"
        },
        {
          "description": "",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
      "inputs": [
        {
          "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
          "name": "set1",
          "type": 0
        },
        {
          "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set1`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
          "name": "set2",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "2D indices of a `SparseTensor`.",
          "name": "result_indices",
          "type": 9
        },
        {
          "description": "1D values of a `SparseTensor`.",
          "name": "result_values",
          "type": 0
        },
        {
          "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
          "name": "result_shape",
          "type": 9
        }
      ],
      "summary": "Applies set operation along last dimension of 2 `Tensor` inputs."
    }
  },
  {
    "name": "DenseToSparseBatchDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A handle to an input dataset. Must have a single component.",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A vector representing the dense shape of each row in the produced\nSparseTensor. The shape may be partially specified, using `-1` to indicate\nthat a particular dimension should use the maximum size of all batch elements.",
          "name": "row_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that yields a SparseTensor for each element of the input."
    }
  },
  {
    "name": "DenseToSparseSetOperation",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "set_operation",
          "type": "string"
        },
        {
          "description": "",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nInput `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,\nand `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same\nas `set1`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set2`\nindices.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
      "inputs": [
        {
          "description": "`Tensor` with rank `n`. 1st `n-1` dimensions must be the same as `set2`.\nDimension `n` contains values in a set, duplicates are allowed but ignored.",
          "name": "set1",
          "type": 0
        },
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_values",
          "type": 0
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must\nbe the same as the 1st `n-1` dimensions of `set1`, `result_shape[n]` is the\nmax set size across `n-1` dimensions.",
          "name": "set2_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2D indices of a `SparseTensor`.",
          "name": "result_indices",
          "type": 9
        },
        {
          "description": "1D values of a `SparseTensor`.",
          "name": "result_values",
          "type": 0
        },
        {
          "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
          "name": "result_shape",
          "type": 9
        }
      ],
      "summary": "Applies set operation along last dimension of `Tensor` and `SparseTensor`."
    }
  },
  {
    "name": "DepthToSpace",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the spatial block, same as in Space2Depth.",
          "name": "block_size",
          "type": "int"
        },
        {
          "description": "",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "Rearranges data from depth into blocks of spatial data.\nThis is the reverse transformation of SpaceToDepth. More specifically,\nthis op outputs a copy of the input tensor where values from the `depth`\ndimension are moved in spatial blocks to the `height` and `width` dimensions.\nThe attr `block_size` indicates the input block size and how the data is moved.\n\n  * Chunks of data of size `block_size * block_size` from depth are rearranged\n    into non-overlapping blocks of size `block_size x block_size`\n  * The width the output tensor is `input_depth * block_size`, whereas the\n    height is `input_height * block_size`.\n  * The Y, X coordinates within each block of the output image are determined\n    by the high order component of the input channel index.\n  * The depth of the input tensor must be divisible by\n    `block_size * block_size`.\n\nThe `data_format` attr specifies the layout of the input and output tensors\nwith the following options:\n  \"NHWC\": `[ batch, height, width, channels ]`\n  \"NCHW\": `[ batch, channels, height, width ]`\n  \"NCHW_VECT_C\":\n      `qint8 [ batch, channels / 4, height, width, channels % 4 ]`\n\nIt is useful to consider the operation as transforming a 6-D Tensor.\ne.g. for data_format = NHWC,\n     Each element in the input tensor can be specified via 6 coordinates,\n     ordered by decreasing memory layout significance as:\n     n,iY,iX,bY,bX,oC  (where n=batch index, iX, iY means X or Y coordinates\n                        within the input image, bX, bY means coordinates\n                        within the output block, oC means output channels).\n     The output would be the input transposed to the following layout:\n     n,iY,bY,iX,bX,oC\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given an input of shape `[1, 1, 1, 4]`, data_format = \"NHWC\" and\nblock_size = 2:\n\n```\nx = [[[[1, 2, 3, 4]]]]\n\n```\n\nThis operation will output a tensor of shape `[1, 2, 2, 1]`:\n\n```\n   [[[[1], [2]],\n     [[3], [4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[1, 1, 4]`,\nthe corresponding output will have 2x2 elements and will have a depth of\n1 channel (1 = `4 / (block_size * block_size)`).\nThe output element shape is `[2, 2, 1]`.\n\nFor an input tensor with larger depth, here of shape `[1, 1, 1, 12]`, e.g.\n\n```\nx = [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nThis operation, for block size of 2, will return the following tensor of shape\n`[1, 2, 2, 3]`\n\n```\n   [[[[1, 2, 3], [4, 5, 6]],\n     [[7, 8, 9], [10, 11, 12]]]]\n\n```\n\nSimilarly, for the following input of shape `[1 2 2 4]`, and a block size of 2:\n\n```\nx =  [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 4 4 1]`:\n\n```\nx = [[[ [1],   [2],  [5],  [6]],\n      [ [3],   [4],  [7],  [8]],\n      [ [9],  [10], [13],  [14]],\n      [ [11], [12], [15],  [16]]]]\n\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "DepthToSpace for tensors of type T."
    }
  },
  {
    "name": "DepthwiseConv2dNative",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "Given an input tensor of shape `[batch, in_height, in_width, in_channels]`\nand a filter / kernel tensor of shape\n`[filter_height, filter_width, in_channels, channel_multiplier]`, containing\n`in_channels` convolutional filters of depth 1, `depthwise_conv2d` applies\na different filter to each input channel (expanding from 1 channel to\n`channel_multiplier` channels for each), then concatenates the results\ntogether. Thus, the output has `in_channels * channel_multiplier` channels.\n\n```\nfor k in 0..in_channels-1\n  for q in 0..channel_multiplier-1\n    output[b, i, j, k * channel_multiplier + q] =\n      sum_{di, dj} input[b, strides[1] * i + di, strides[2] * j + dj, k] *\n                        filter[di, dj, k, q]\n```\n\nMust have `strides[0] = strides[3] = 1`.  For the most common case of the same\nhorizontal and vertices strides, `strides = [1, stride, stride, 1]`.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "filter",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes a 2-D depthwise convolution given 4-D `input` and `filter` tensors."
    }
  },
  {
    "name": "DepthwiseConv2dNativeBackpropFilter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape based on `data_format`.  For example, if\n`data_format` is 'NHWC' then `input` is a 4-D `[batch, in_height,\nin_width, in_channels]` tensor.",
          "name": "input",
          "type": 0
        },
        {
          "description": "An integer vector representing the tensor shape of `filter`,\nwhere `filter` is a 4-D\n`[filter_height, filter_width, in_channels, depthwise_multiplier]` tensor.",
          "name": "filter_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape  based on `data_format`.\nFor example, if `data_format` is 'NHWC' then\nout_backprop shape is `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.  Gradient w.r.t.\nthe `filter` input of the convolution.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of depthwise convolution with respect to the filter."
    }
  },
  {
    "name": "DepthwiseConv2dNativeBackpropInput",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\nof the convolution.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, channels, height, width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "An integer vector representing the shape of `input`, based\non `data_format`.  For example, if `data_format` is 'NHWC' then\n `input` is a 4-D `[batch, height, width, channels]` tensor.",
          "name": "input_sizes",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, depthwise_multiplier]`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "4-D with shape  based on `data_format`.\nFor example, if `data_format` is 'NHWC' then\nout_backprop shape is `[batch, out_height, out_width, out_channels]`.\nGradients w.r.t. the output of the convolution.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape according to `data_format`.  For example, if\n`data_format` is 'NHWC', output shape is `[batch, in_height,\nin_width, in_channels]`.  Gradient w.r.t. the input of the\nconvolution.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradients of depthwise convolution with respect to the input."
    }
  },
  {
    "name": "Dequantize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "mode",
          "type": "string"
        }
      ],
      "description": "[min_range, max_range] are scalar floats that specify the range for\nthe 'input' data. The 'mode' attribute controls exactly which calculations are\nused to convert the float values to their quantized equivalents.\n\nIn 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n\n```\nif T == qint8, in[i] += (range(T) + 1)/ 2.0\nout[i] = min_range + (in[i]* (max_range - min_range) / range(T))\n```\nhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`\n\n*MIN_COMBINED Mode Example*\n\nIf the input comes from a QuantizedRelu6, the output type is\nquint8 (range of 0-255) but the possible range of QuantizedRelu6 is\n0-6.  The min_range and max_range values are therefore 0.0 and 6.0.\nDequantize on quint8 will take each value, cast to float, and multiply\nby 6 / 255.\nNote that if quantizedtype is qint8, the operation will additionally add\neach value by 128 prior to casting.\n\nIf the mode is 'MIN_FIRST', then this approach is used:\n\n```c++\nnum_discrete_values = 1 << (# of bits in T)\nrange_adjust = num_discrete_values / (num_discrete_values - 1)\nrange = (range_max - range_min) * range_adjust\nrange_scale = range / num_discrete_values\nconst double offset_input = static_cast<double>(input) - lowest_quantized;\nresult = range_min + ((input - numeric_limits<T>::min()) * range_scale)\n```\n\n*SCALED mode Example*\n\n`SCALED` mode matches the quantization approach used in\n`QuantizeAndDequantize{V2|V3}`.\n\nIf the mode is `SCALED`, we do not use the full range of the output type,\nchoosing to elide the lowest possible value for symmetry (e.g., output range is\n-127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to\n0.\n\nWe first find the range of values in our tensor. The\nrange we use is always centered on 0, so we find m such that\n```c++\n  m = max(abs(input_min), abs(input_max))\n```\n\nOur input tensor range is then `[-m, m]`.\n\nNext, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.\nIf T is signed, this is\n```\n  num_bits = sizeof(T) * 8\n  [min_fixed, max_fixed] =\n      [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1]\n```\n\nOtherwise, if T is unsigned, the fixed-point range is\n```\n  [min_fixed, max_fixed] = [0, (1 << num_bits) - 1]\n```\n\nFrom this we compute our scaling factor, s:\n```c++\n  s = (2 * m) / (max_fixed - min_fixed)\n```\n\nNow we can dequantize the elements of our tensor:\n```c++\nresult = input * s\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "The minimum scalar value possibly produced for the input.",
          "name": "min_range",
          "type": 1
        },
        {
          "description": "The maximum scalar value possibly produced for the input.",
          "name": "max_range",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Dequantize the 'input' tensor into a float Tensor."
    }
  },
  {
    "name": "DeserializeIterator",
    "schema": {
      "inputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        },
        {
          "description": "A variant tensor storing the state of the iterator contained in the\nresource.",
          "name": "serialized",
          "type": 21
        }
      ],
      "summary": "Converts the given variant tensor to an iterator and stores it in the given resource."
    }
  },
  {
    "name": "DeserializeManySparse",
    "schema": {
      "attributes": [
        {
          "description": "The `dtype` of the serialized `SparseTensor` objects.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The input `serialized_sparse` must be a string matrix of shape `[N x 3]` where\n`N` is the minibatch size and the rows correspond to packed outputs of\n`SerializeSparse`.  The ranks of the original `SparseTensor` objects\nmust all match.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension).\n\nThe output `SparseTensor` object's shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the serialized input is a `[2 x 3]` matrix representing two\noriginal `SparseTensor` objects:\n\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n\nand\n\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n\nthen the final deserialized `SparseTensor` will be:\n\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]",
      "inputs": [
        {
          "description": "2-D, The `N` serialized `SparseTensor` objects.\nMust have 3 columns.",
          "name": "serialized_sparse",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "summary": "Deserialize and concatenate `SparseTensors` from a serialized minibatch."
    }
  },
  {
    "name": "DeserializeSparse",
    "schema": {
      "attributes": [
        {
          "description": "The `dtype` of the serialized `SparseTensor` objects.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The serialized `SparseTensor` objects. The last dimension\nmust have 3 columns.",
          "name": "serialized_sparse",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "summary": "Deserialize `SparseTensor` objects."
    }
  },
  {
    "name": "DestroyResourceOp",
    "schema": {
      "attributes": [
        {
          "description": "whether to ignore the error when the resource\ndoesn't exist.",
          "name": "ignore_lookup_error",
          "type": "bool"
        }
      ],
      "description": "All subsequent operations using the resource will result in a NotFound\nerror status.",
      "inputs": [
        {
          "description": "handle to the resource to delete.",
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Deletes the resource specified by the handle."
    }
  },
  {
    "name": "DestroyTemporaryVariable",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Name of the temporary variable, usually the name of the matching\n'TemporaryVariable' op.",
          "name": "var_name",
          "type": "string"
        }
      ],
      "description": "Sets output to the value of the Tensor pointed to by 'ref', then destroys\nthe temporary variable called 'var_name'.\nAll other uses of 'ref' *must* have executed before this op.\nThis is typically achieved by chaining the ref through each assign op, or by\nusing control dependencies.\n\nOutputs the final value of the tensor pointed to by 'ref'.",
      "inputs": [
        {
          "description": "A reference to the temporary variable tensor.",
          "name": "ref",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Destroys the temporary variable and returns its final value."
    }
  },
  {
    "name": "Diag",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has dimensions [D1,..., Dk], then the output is a tensor of\nrank 2k with dimensions [D1,..., Dk, D1,..., Dk] where:\n\n`output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]` and 0 everywhere else.\n\nFor example:\n\n```\n# 'diagonal' is [1, 2, 3, 4]\ntf.diag(diagonal) ==> [[1, 0, 0, 0]\n                       [0, 2, 0, 0]\n                       [0, 0, 3, 0]\n                       [0, 0, 0, 4]]\n```",
      "inputs": [
        {
          "description": "Rank k tensor where k is at most 1.",
          "name": "diagonal",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns a diagonal tensor with a given diagonal values."
    }
  },
  {
    "name": "DiagPart",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor with the `diagonal` part\nof the `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has dimensions `[D1,..., Dk, D1,..., Dk]`, then the output is a\ntensor of rank `k` with dimensions `[D1,..., Dk]` where:\n\n`diagonal[i1,..., ik] = input[i1, ..., ik, i1,..., ik]`.\n\nFor example:\n\n```\n# 'input' is [[1, 0, 0, 0]\n              [0, 2, 0, 0]\n              [0, 0, 3, 0]\n              [0, 0, 0, 4]]\n\ntf.diag_part(input) ==> [1, 2, 3, 4]\n```",
      "inputs": [
        {
          "description": "Rank k tensor where k is even and not zero.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The extracted diagonal.",
          "name": "diagonal",
          "type": 0
        }
      ],
      "summary": "Returns the diagonal part of the tensor."
    }
  },
  {
    "name": "Digamma",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`Gamma(x)`), element-wise.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes Psi, the derivative of Lgamma (the log of the absolute value of"
    }
  },
  {
    "name": "Dilation2D",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor. Must be: `[1, stride_height, stride_width, 1]`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The input stride for atrous morphological dilation. Must be:\n`[1, rate_height, rate_width, 1]`.",
          "name": "rates",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "The `input` tensor has shape `[batch, in_height, in_width, depth]` and the\n`filter` tensor has shape `[filter_height, filter_width, depth]`, i.e., each\ninput channel is processed independently of the others with its own structuring\nfunction. The `output` tensor has shape\n`[batch, out_height, out_width, depth]`. The spatial dimensions of the output\ntensor depend on the `padding` algorithm. We currently only support the default\n\"NHWC\" `data_format`.\n\nIn detail, the grayscale morphological 2-D dilation is the max-sum correlation\n(for consistency with `conv2d`, we use unmirrored filters):\n\n    output[b, y, x, c] =\n       max_{dy, dx} input[b,\n                          strides[1] * y + rates[1] * dy,\n                          strides[2] * x + rates[2] * dx,\n                          c] +\n                    filter[dy, dx, c]\n\nMax-pooling is a special case when the filter has size equal to the pooling\nkernel size and contains all zeros.\n\nNote on duality: The dilation of `input` by the `filter` is equal to the\nnegation of the erosion of `-input` by the reflected `filter`.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the grayscale dilation of 4-D `input` and 3-D `filter` tensors."
    }
  },
  {
    "name": "Dilation2DBackpropFilter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: `[1, stride_height, stride_width, 1]`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. The input stride for atrous morphological dilation.\nMust be: `[1, rate_height, rate_width, 1]`.",
          "name": "rates",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter_backprop",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of morphological 2-D dilation with respect to the filter."
    }
  },
  {
    "name": "Dilation2DBackpropInput",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: `[1, stride_height, stride_width, 1]`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. The input stride for atrous morphological dilation.\nMust be: `[1, rate_height, rate_width, 1]`.",
          "name": "rates",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "3-D with shape `[filter_height, filter_width, depth]`.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, out_height, out_width, depth]`.",
          "name": "out_backprop",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, depth]`.",
          "name": "in_backprop",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of morphological 2-D dilation with respect to the input."
    }
  },
  {
    "name": "Div",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Div` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x / y element-wise."
    }
  },
  {
    "name": "DrawBoundingBoxes",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a copy of `images` but draws on top of the pixels zero or more bounding\nboxes specified by the locations in `boxes`. The coordinates of the each\nbounding box in `boxes` are encoded as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example, if an image is 100 x 200 pixels (height x width) and the bounding\nbox is `[0.1, 0.2, 0.5, 0.9]`, the upper-left and bottom-right coordinates of\nthe bounding box will be `(40, 10)` to `(100, 50)` (in (x,y) coordinates).\n\nParts of the bounding box may fall outside the image.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, depth]`. A batch of images.",
          "name": "images",
          "type": 0
        },
        {
          "description": "3-D with shape `[batch, num_bounding_boxes, 4]` containing bounding\nboxes.",
          "name": "boxes",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "4-D with the same shape as `images`. The batch of input images with\nbounding boxes drawn on the images.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Draw bounding boxes on a batch of images."
    }
  },
  {
    "name": "DynamicPartition",
    "schema": {
      "attributes": [
        {
          "description": "The number of partitions to output.",
          "name": "num_partitions",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each index tuple `js` of size `partitions.ndim`, the slice `data[js, ...]`\nbecomes part of `outputs[partitions[js]]`.  The slices with `partitions[js] = i`\nare placed in `outputs[i]` in lexicographic order of `js`, and the first\ndimension of `outputs[i]` is the number of entries in `partitions` equal to `i`.\nIn detail,\n\n```python\n    outputs[i].shape = [sum(partitions == i)] + data.shape[partitions.ndim:]\n\n    outputs[i] = pack([data[js, ...] for js if partitions[js] == i])\n```\n\n`data.shape` must start with `partitions.shape`.\n\nFor example:\n\n```python\n    # Scalar partitions.\n    partitions = 1\n    num_partitions = 2\n    data = [10, 20]\n    outputs[0] = []  # Empty with shape [0, 2]\n    outputs[1] = [[10, 20]]\n\n    # Vector partitions.\n    partitions = [0, 0, 1, 1, 0]\n    num_partitions = 2\n    data = [10, 20, 30, 40, 50]\n    outputs[0] = [10, 20, 50]\n    outputs[1] = [30, 40]\n```\n\nSee `dynamic_stitch` for an example on how to merge partitions back.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicPartition.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "Any shape.  Indices in the range `[0, num_partitions)`.",
          "name": "partitions",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "outputs",
          "type": 0
        }
      ],
      "summary": "Partitions `data` into `num_partitions` tensors using indices from `partitions`."
    }
  },
  {
    "name": "DynamicStitch",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Builds a merged tensor such that\n\n```python\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n```\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n```python\n    # Scalar indices:\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices:\n    merged[indices[m][i], ...] = data[m][i, ...]\n```\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues are merged in order, so if an index appears in both `indices[m][i]` and\n`indices[n][j]` for `(m,i) < (n,j)` the slice `data[n][j]` will appear in the\nmerged result. If you do not need this guarantee, ParallelDynamicStitch might\nperform better on some devices.\n\nFor example:\n\n```python\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n```\n\nThis method can be used to merge partitions created by `dynamic_partition`\nas illustrated on the following example:\n\n```python\n    # Apply function (increments x_i) on elements for which a certain condition\n    # apply (x_i != -1 in this example).\n    x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n    condition_mask=tf.not_equal(x,tf.constant(-1.))\n    partitioned_data = tf.dynamic_partition(\n        x, tf.cast(condition_mask, tf.int32) , 2)\n    partitioned_data[1] = partitioned_data[1] + 1.0\n    condition_indices = tf.dynamic_partition(\n        tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n    x = tf.dynamic_stitch(condition_indices, partitioned_data)\n    # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n    # unchanged.\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "merged",
          "type": 0
        }
      ],
      "summary": "Interleave the values from the `data` tensors into a single tensor."
    }
  },
  {
    "name": "EditDistance",
    "schema": {
      "attributes": [
        {
          "description": "boolean (if true, edit distances are normalized by length of truth).\n\nThe output is:",
          "name": "normalize",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The inputs are variable-length sequences provided by SparseTensors\n  (hypothesis_indices, hypothesis_values, hypothesis_shape)\nand\n  (truth_indices, truth_values, truth_shape).\n\nThe inputs are:",
      "inputs": [
        {
          "description": "The indices of the hypothesis list SparseTensor.\nThis is an N x R int64 matrix.",
          "name": "hypothesis_indices",
          "type": 9
        },
        {
          "description": "The values of the hypothesis list SparseTensor.\nThis is an N-length vector.",
          "name": "hypothesis_values",
          "type": 0
        },
        {
          "description": "The shape of the hypothesis list SparseTensor.\nThis is an R-length vector.",
          "name": "hypothesis_shape",
          "type": 9
        },
        {
          "description": "The indices of the truth list SparseTensor.\nThis is an M x R int64 matrix.",
          "name": "truth_indices",
          "type": 9
        },
        {
          "description": "The values of the truth list SparseTensor.\nThis is an M-length vector.",
          "name": "truth_values",
          "type": 0
        },
        {
          "description": "truth indices, vector.",
          "name": "truth_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A dense float tensor with rank R - 1.\n\nFor the example input:\n\n    // hypothesis represents a 2x1 matrix with variable-length values:\n    //   (0,0) = [\"a\"]\n    //   (1,0) = [\"b\"]\n    hypothesis_indices = [[0, 0, 0],\n                          [1, 0, 0]]\n    hypothesis_values = [\"a\", \"b\"]\n    hypothesis_shape = [2, 1, 1]\n\n    // truth represents a 2x2 matrix with variable-length values:\n    //   (0,0) = []\n    //   (0,1) = [\"a\"]\n    //   (1,0) = [\"b\", \"c\"]\n    //   (1,1) = [\"a\"]\n    truth_indices = [[0, 1, 0],\n                     [1, 0, 0],\n                     [1, 0, 1],\n                     [1, 1, 0]]\n    truth_values = [\"a\", \"b\", \"c\", \"a\"]\n    truth_shape = [2, 2, 2]\n    normalize = true\n\nThe output will be:\n\n    // output is a 2x2 matrix with edit distances normalized by truth lengths.\n    output = [[inf, 1.0],  // (0,0): no truth, (0,1): no hypothesis\n              [0.5, 1.0]]  // (1,0): addition, (1,1): no hypothesis",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Computes the (possibly normalized) Levenshtein Edit Distance."
    }
  },
  {
    "name": "Elu",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See [Fast and Accurate Deep Network Learning by Exponential Linear Units (ELUs)\n](http://arxiv.org/abs/1511.07289)",
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "activations",
          "type": 0
        }
      ],
      "summary": "Computes exponential linear: `exp(features) - 1` if < 0, `features` otherwise."
    }
  },
  {
    "name": "EluGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Elu operation.",
          "name": "gradients",
          "type": 0
        },
        {
          "description": "The outputs of the corresponding Elu operation.",
          "name": "outputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients * (outputs + 1)` if outputs < 0,\n`gradients` otherwise.",
          "name": "backprops",
          "type": 0
        }
      ],
      "summary": "Computes gradients for the exponential linear (Elu) operation."
    }
  },
  {
    "name": "EncodeBase64",
    "schema": {
      "attributes": [
        {
          "description": "Bool whether padding is applied at the ends.",
          "name": "pad",
          "type": "bool"
        }
      ],
      "description": "Refer to the following article for more information on base64 format:\nen.wikipedia.org/wiki/Base64. Base64 strings may have padding with '=' at the\nend so that the encoded has length multiple of 4. See Padding section of the\nlink above.\n\nWeb-safe means that the encoder uses - and _ instead of + and /.",
      "inputs": [
        {
          "description": "Strings to be encoded.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Input strings encoded in base64.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Encode strings into web-safe base64 format."
    }
  },
  {
    "name": "EncodeJpeg",
    "schema": {
      "attributes": [
        {
          "description": "Per pixel image format.",
          "name": "format",
          "type": "string"
        },
        {
          "description": "Quality of the compression from 0 to 100 (higher is better and slower).",
          "name": "quality",
          "type": "int"
        },
        {
          "description": "If True, create a JPEG that loads progressively (coarse to fine).",
          "name": "progressive",
          "type": "bool"
        },
        {
          "description": "If True, spend CPU/RAM to reduce size with no quality change.",
          "name": "optimize_size",
          "type": "bool"
        },
        {
          "description": "See http://en.wikipedia.org/wiki/Chroma_subsampling.",
          "name": "chroma_downsampling",
          "type": "bool"
        },
        {
          "description": "Unit used to specify `x_density` and `y_density`:\npixels per inch (`'in'`) or centimeter (`'cm'`).",
          "name": "density_unit",
          "type": "string"
        },
        {
          "description": "Horizontal pixels per density unit.",
          "name": "x_density",
          "type": "int"
        },
        {
          "description": "Vertical pixels per density unit.",
          "name": "y_density",
          "type": "int"
        },
        {
          "description": "If not empty, embed this XMP metadata in the image header.",
          "name": "xmp_metadata",
          "type": "string"
        }
      ],
      "description": "`image` is a 3-D uint8 Tensor of shape `[height, width, channels]`.\n\nThe attr `format` can be used to override the color format of the encoded\noutput.  Values can be:\n\n*   `''`: Use a default format based on the number of channels in the image.\n*   `grayscale`: Output a grayscale JPEG image.  The `channels` dimension\n    of `image` must be 1.\n*   `rgb`: Output an RGB JPEG image. The `channels` dimension\n    of `image` must be 3.\n\nIf `format` is not specified or is the empty string, a default format is picked\nin function of the number of channels in `image`:\n\n*   1: Output a grayscale image.\n*   3: Output an RGB image.",
      "inputs": [
        {
          "description": "3-D with shape `[height, width, channels]`.",
          "name": "image",
          "type": 4
        }
      ],
      "outputs": [
        {
          "description": "0-D. JPEG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "JPEG-encode an image."
    }
  },
  {
    "name": "EncodePng",
    "schema": {
      "attributes": [
        {
          "description": "Compression level.",
          "name": "compression",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`image` is a 3-D uint8 or uint16 Tensor of shape `[height, width, channels]`\nwhere `channels` is:\n\n*   1: for grayscale.\n*   2: for grayscale + alpha.\n*   3: for RGB.\n*   4: for RGBA.\n\nThe ZLIB compression level, `compression`, can be -1 for the PNG-encoder\ndefault or a value from 0 to 9.  9 is the highest compression level, generating\nthe smallest output, but is slower.",
      "inputs": [
        {
          "description": "3-D with shape `[height, width, channels]`.",
          "name": "image",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "0-D. PNG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "PNG-encode an image."
    }
  },
  {
    "name": "EncodeWav",
    "schema": {
      "description": "This operation will generate a string suitable to be saved out to create a .wav\naudio file. It will be encoded in the 16-bit PCM format. It takes in float\nvalues in the range -1.0f to 1.0f, and any outside that value will be clamped to\nthat range.\n\n`audio` is a 2-D float Tensor of shape `[length, channels]`.\n`sample_rate` is a scalar Tensor holding the rate to use (e.g. 44100).",
      "inputs": [
        {
          "description": "2-D with shape `[length, channels]`.",
          "name": "audio",
          "type": 1
        },
        {
          "description": "Scalar containing the sample frequency.",
          "name": "sample_rate",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "0-D. WAV-encoded file contents.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "Encode audio data using the WAV file format."
    }
  },
  {
    "name": "Enter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The name of the child frame.",
          "name": "frame_name",
          "type": "string"
        },
        {
          "description": "If true, the output is constant within the child frame.",
          "name": "is_constant",
          "type": "bool"
        },
        {
          "description": "The number of iterations allowed to run in parallel.",
          "name": "parallel_iterations",
          "type": "int"
        }
      ],
      "description": "This op is used together with `Exit` to create loops in the graph.\nThe unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the child frame.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Creates or finds a child frame, and makes `data` available to the child frame."
    }
  },
  {
    "name": "Equal",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Equal` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x == y) element-wise."
    }
  },
  {
    "name": "Erf",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the Gauss error function of `x` element-wise."
    }
  },
  {
    "name": "Erfc",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the complementary error function of `x` element-wise."
    }
  },
  {
    "name": "Exit",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Exit makes its input `data` available to the parent frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the parent frame.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Exits the current frame to its parent frame."
    }
  },
  {
    "name": "Exp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes exponential of x element-wise.  \\\\(y = e^x\\\\)."
    }
  },
  {
    "name": "ExpandDims",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tdim",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input`, this operation inserts a dimension of 1 at the\ndimension index `dim` of `input`'s shape. The dimension index `dim` starts at\nzero; if you specify a negative number for `dim` it is counted backward from\nthe end.\n\nThis operation is useful if you want to add a batch dimension to a single\nelement. For example, if you have a single image of shape `[height, width,\nchannels]`, you can make it a batch of 1 image with `expand_dims(image, 0)`,\nwhich will make the shape `[1, height, width, channels]`.\n\nOther examples:\n\n```\n# 't' is a tensor of shape [2]\nshape(expand_dims(t, 0)) ==> [1, 2]\nshape(expand_dims(t, 1)) ==> [2, 1]\nshape(expand_dims(t, -1)) ==> [2, 1]\n\n# 't2' is a tensor of shape [2, 3, 5]\nshape(expand_dims(t2, 0)) ==> [1, 2, 3, 5]\nshape(expand_dims(t2, 2)) ==> [2, 3, 1, 5]\nshape(expand_dims(t2, 3)) ==> [2, 3, 5, 1]\n```\n\nThis operation requires that:\n\n`-1-input.dims() <= dim <= input.dims()`\n\nThis operation is related to `squeeze()`, which removes dimensions of\nsize 1.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "0-D (scalar). Specifies the dimension index at which to\nexpand the shape of `input`. Must be in the range\n`[-rank(input) - 1, rank(input)]`.",
          "name": "dim",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Contains the same data as `input`, but its shape has an additional\ndimension of size 1 added.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Inserts a dimension of 1 into a tensor's shape."
    }
  },
  {
    "name": "Expm1",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = (\\exp x) - 1\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes exponential of x - 1 element-wise."
    }
  },
  {
    "name": "ExtractGlimpse",
    "schema": {
      "attributes": [
        {
          "description": "indicates if the offset coordinates are centered relative to\nthe image, in which case the (0, 0) offset is relative to the center\nof the input images. If false, the (0,0) offset corresponds to the\nupper left corner of the input images.",
          "name": "centered",
          "type": "bool"
        },
        {
          "description": "indicates if the offset coordinates are normalized.",
          "name": "normalized",
          "type": "bool"
        },
        {
          "description": "indicates if the noise should be generated using a\nuniform distribution or a Gaussian distribution.",
          "name": "uniform_noise",
          "type": "bool"
        }
      ],
      "description": "Returns a set of windows called glimpses extracted at location\n`offsets` from the input tensor. If the windows only partially\noverlaps the inputs, the non overlapping areas will be filled with\nrandom noise.\n\nThe result is a 4-D tensor of shape `[batch_size, glimpse_height,\nglimpse_width, channels]`. The channels and batch dimensions are the\nsame as that of the input tensor. The height and width of the output\nwindows are specified in the `size` parameter.\n\nThe argument `normalized` and `centered` controls how the windows are built:\n\n* If the coordinates are normalized but not centered, 0.0 and 1.0\n  correspond to the minimum and maximum of each height and width\n  dimension.\n* If the coordinates are both normalized and centered, they range from\n  -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper\n  left corner, the lower right corner is located at (1.0, 1.0) and the\n  center is at (0, 0).\n* If the coordinates are not normalized they are interpreted as\n  numbers of pixels.",
      "inputs": [
        {
          "description": "A 4-D float tensor of shape `[batch_size, height, width, channels]`.",
          "name": "input",
          "type": 1
        },
        {
          "description": "A 1-D tensor of 2 elements containing the size of the glimpses\nto extract.  The glimpse height must be specified first, following\nby the glimpse width.",
          "name": "size",
          "type": 3
        },
        {
          "description": "A 2-D integer tensor of shape `[batch_size, 2]` containing\nthe y, x locations of the center of each window.",
          "name": "offsets",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A tensor representing the glimpses `[batch_size,\nglimpse_height, glimpse_width, channels]`.",
          "name": "glimpse",
          "type": 1
        }
      ],
      "summary": "Extracts a glimpse from the input tensor."
    }
  },
  {
    "name": "ExtractImagePatches",
    "schema": {
      "attributes": [
        {
          "description": "The size of the sliding window for each dimension of `images`.",
          "name": "ksizes",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. How far the centers of two consecutive patches are in\nthe images. Must be: `[1, stride_rows, stride_cols, 1]`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "1-D of length 4. Must be: `[1, rate_rows, rate_cols, 1]`. This is the\ninput stride, specifying how far two consecutive patch samples are in the\ninput. Equivalent to extracting patches with\n`patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)`, followed by\nsubsampling them spatially by a factor of `rates`. This is equivalent to\n`rate` in dilated (a.k.a. Atrous) convolutions.",
          "name": "rates",
          "type": "list(int)"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The type of padding algorithm to use.\n\nWe specify the size-related attributes as:\n\n```python\n      ksizes = [1, ksize_rows, ksize_cols, 1]\n      strides = [1, strides_rows, strides_cols, 1]\n      rates = [1, rates_rows, rates_cols, 1]\n```",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D Tensor with shape `[batch, in_rows, in_cols, depth]`.",
          "name": "images",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D Tensor with shape `[batch, out_rows, out_cols, ksize_rows *\nksize_cols * depth]` containing image patches with size\n`ksize_rows x ksize_cols x depth` vectorized in the \"depth\" dimension. Note\n`out_rows` and `out_cols` are the dimensions of the output patches.",
          "name": "patches",
          "type": 0
        }
      ],
      "summary": "Extract `patches` from `images` and put them in the \"depth\" output dimension."
    }
  },
  {
    "name": "ExtractJpegShape",
    "schema": {
      "attributes": [
        {
          "description": "(Optional) The output type of the operation (int32 or int64).\nDefaults to int32.",
          "name": "output_type",
          "type": "type"
        }
      ],
      "description": "This op only parses the image header, so it is much faster than DecodeJpeg.",
      "inputs": [
        {
          "description": "0-D. The JPEG-encoded image.",
          "name": "contents",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "1-D. The image shape with format [height, width, channels].",
          "name": "image_shape",
          "type": 0
        }
      ],
      "summary": "Extract the shape information of a JPEG-encoded image."
    }
  },
  {
    "name": "FFT",
    "schema": {
      "description": "Computes the 1-dimensional discrete Fourier transform over the inner-most\ndimension of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most\n  dimension of `input` is replaced with its 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fft\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "Fast Fourier transform."
    }
  },
  {
    "name": "FFT2D",
    "schema": {
      "description": "Computes the 2-dimensional discrete Fourier transform over the inner-most\n2 dimensions of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most 2\n  dimensions of `input` are replaced with their 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fft2\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "2D fast Fourier transform."
    }
  },
  {
    "name": "FFT3D",
    "schema": {
      "description": "Computes the 3-dimensional discrete Fourier transform over the inner-most 3\ndimensions of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most 3\n  dimensions of `input` are replaced with their 3D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.fftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "3D fast Fourier transform."
    }
  },
  {
    "name": "FIFOQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "FIFOQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "Fact",
    "schema": {
      "outputs": [
        {
          "description": "",
          "name": "fact",
          "type": 7
        }
      ],
      "summary": "Output a fact about factorials."
    }
  },
  {
    "name": "FakeQuantWithMinMaxArgs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "min",
          "type": "float"
        },
        {
          "description": "",
          "name": "max",
          "type": "float"
        },
        {
          "description": "",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "description": "Attributes `[min; max]` define the clamping range for the `inputs` data.\n`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`\nwhen `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and\nthen de-quantized and output as floats in `[min; max]` interval.\n`num_bits` is the bitwidth of the quantization; between 2 and 8, inclusive.\n\nQuantization is called fake since the output is still in floating point.",
      "inputs": [
        {
          "description": "",
          "name": "inputs",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "outputs",
          "type": 1
        }
      ],
      "summary": "Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type."
    }
  },
  {
    "name": "FakeQuantWithMinMaxArgsGradient",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "min",
          "type": "float"
        },
        {
          "description": "",
          "name": "max",
          "type": "float"
        },
        {
          "description": "",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Backpropagated gradients above the FakeQuantWithMinMaxArgs operation.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "Values passed as inputs to the FakeQuantWithMinMaxArgs operation.",
          "name": "inputs",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Backpropagated gradients below the FakeQuantWithMinMaxArgs operation:\n`gradients * (inputs >= min && inputs <= max)`.",
          "name": "backprops",
          "type": 1
        }
      ],
      "summary": "Compute gradients for a FakeQuantWithMinMaxArgs operation."
    }
  },
  {
    "name": "FakeQuantWithMinMaxVars",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "description": "and `max` to 'outputs' tensor of same shape as `inputs`.\n\n`[min; max]` define the clamping range for the `inputs` data.\n`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`\nwhen `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and\nthen de-quantized and output as floats in `[min; max]` interval.\n`num_bits` is the bitwidth of the quantization; between 2 and 8, inclusive.\n\nThis operation has a gradient and thus allows for training `min` and `max`\nvalues.",
      "inputs": [
        {
          "description": "",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "",
          "name": "min",
          "type": 1
        },
        {
          "description": "",
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "outputs",
          "type": 1
        }
      ],
      "summary": "Fake-quantize the 'inputs' tensor of type float via global float scalars `min`"
    }
  },
  {
    "name": "FakeQuantWithMinMaxVarsGradient",
    "schema": {
      "attributes": [
        {
          "description": "The bitwidth of the quantization; between 2 and 8, inclusive.",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "Whether to quantize into 2^num_bits - 1 distinct values.",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Backpropagated gradients above the FakeQuantWithMinMaxVars operation.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "Values passed as inputs to the FakeQuantWithMinMaxVars operation.\nmin, max: Quantization interval, scalar floats.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "",
          "name": "min",
          "type": 1
        },
        {
          "description": "",
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Backpropagated gradients w.r.t. inputs:\n`gradients * (inputs >= min && inputs <= max)`.",
          "name": "backprops_wrt_input",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. min parameter:\n`sum(gradients * (inputs < min))`.",
          "name": "backprop_wrt_min",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. max parameter:\n`sum(gradients * (inputs > max))`.",
          "name": "backprop_wrt_max",
          "type": 1
        }
      ],
      "summary": "Compute gradients for a FakeQuantWithMinMaxVars operation."
    }
  },
  {
    "name": "FakeQuantWithMinMaxVarsPerChannel",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "description": "`[b, d]` `[b, h, w, d]` via per-channel floats `min` and `max` of shape `[d]`\nto 'outputs' tensor of same shape as `inputs`.\n\n`[min; max]` define the clamping range for the `inputs` data.\n`inputs` values are quantized into the quantization range (`[0; 2^num_bits - 1]`\nwhen `narrow_range` is false and `[1; 2^num_bits - 1]` when it is true) and\nthen de-quantized and output as floats in `[min; max]` interval.\n`num_bits` is the bitwidth of the quantization; between 2 and 8, inclusive.\n\nThis operation has a gradient and thus allows for training `min` and `max`\nvalues.",
      "inputs": [
        {
          "description": "",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "",
          "name": "min",
          "type": 1
        },
        {
          "description": "",
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "outputs",
          "type": 1
        }
      ],
      "summary": "Fake-quantize the 'inputs' tensor of type float and one of the shapes: `[d]`,"
    }
  },
  {
    "name": "FakeQuantWithMinMaxVarsPerChannelGradient",
    "schema": {
      "attributes": [
        {
          "description": "The bitwidth of the quantization; between 2 and 8, inclusive.",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "Whether to quantize into 2^num_bits - 1 distinct values.",
          "name": "narrow_range",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Backpropagated gradients above the FakeQuantWithMinMaxVars operation,\nshape one of: `[d]`, `[b, d]`,  `[b, h, w, d]`.",
          "name": "gradients",
          "type": 1
        },
        {
          "description": "Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape\n  same as `gradients`.\nmin, max: Quantization interval, floats of shape `[d]`.",
          "name": "inputs",
          "type": 1
        },
        {
          "description": "",
          "name": "min",
          "type": 1
        },
        {
          "description": "",
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Backpropagated gradients w.r.t. inputs, shape same as\n`inputs`:\n  `gradients * (inputs >= min && inputs <= max)`.",
          "name": "backprops_wrt_input",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. min parameter, shape `[d]`:\n`sum_per_d(gradients * (inputs < min))`.",
          "name": "backprop_wrt_min",
          "type": 1
        },
        {
          "description": "Backpropagated gradients w.r.t. max parameter, shape `[d]`:\n`sum_per_d(gradients * (inputs > max))`.",
          "name": "backprop_wrt_max",
          "type": 1
        }
      ],
      "summary": "Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation."
    }
  },
  {
    "name": "FakeQueue",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Do not use."
    }
  },
  {
    "name": "Fill",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation creates a tensor of shape `dims` and fills it with `value`.\n\nFor example:\n\n```\n# Output tensor has shape [2, 3].\nfill([2, 3], 9) ==> [[9, 9, 9]\n                     [9, 9, 9]]\n```",
      "inputs": [
        {
          "description": "1-D. Represents the shape of the output tensor.",
          "name": "dims",
          "type": 3
        },
        {
          "description": "0-D (scalar). Value to fill the returned tensor.\n\n@compatibility(numpy)\nEquivalent to np.full\n@end_compatibility",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Creates a tensor filled with a scalar value."
    }
  },
  {
    "name": "FilterDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function returning a scalar boolean.",
          "name": "predicate",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "The `predicate` function must return a scalar boolean and accept the\nfollowing arguments:\n\n* One tensor for each component of an element of `input_dataset`.\n* One tensor for each value in `other_arguments`.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A list of tensors, typically values that were captured when\nbuilding a closure for `predicate`.",
          "name": "other_arguments",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset containing elements of `input_dataset` matching `predicate`."
    }
  },
  {
    "name": "FixedLengthRecordDataset",
    "schema": {
      "inputs": [
        {
          "description": "A scalar or a vector containing the name(s) of the file(s) to be\nread.",
          "name": "filenames",
          "type": 7
        },
        {
          "description": "A scalar representing the number of bytes to skip at the\nbeginning of a file.",
          "name": "header_bytes",
          "type": 9
        },
        {
          "description": "A scalar representing the number of bytes in each record.",
          "name": "record_bytes",
          "type": 9
        },
        {
          "description": "A scalar representing the number of bytes to skip at the end\nof a file.",
          "name": "footer_bytes",
          "type": 9
        },
        {
          "description": "A scalar representing the number of bytes to buffer. Must be > 0.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the records from one or more binary files."
    }
  },
  {
    "name": "FixedLengthRecordReader",
    "schema": {
      "attributes": [
        {
          "description": "Number of bytes in the header, defaults to 0.",
          "name": "header_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes in the record.",
          "name": "record_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes in the footer, defaults to 0.",
          "name": "footer_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes to hop before each read. Default of 0 means using\nrecord_bytes.",
          "name": "hop_bytes",
          "type": "int"
        },
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs fixed-length records from a file."
    }
  },
  {
    "name": "FixedLengthRecordReaderV2",
    "schema": {
      "attributes": [
        {
          "description": "Number of bytes in the header, defaults to 0.",
          "name": "header_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes in the record.",
          "name": "record_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes in the footer, defaults to 0.",
          "name": "footer_bytes",
          "type": "int"
        },
        {
          "description": "Number of bytes to hop before each read. Default of 0 means using\nrecord_bytes.",
          "name": "hop_bytes",
          "type": "int"
        },
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "The type of encoding for the file. Currently ZLIB and GZIP\nare supported. Defaults to none.",
          "name": "encoding",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs fixed-length records from a file."
    }
  },
  {
    "name": "FixedUnigramCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "name": "range_max",
          "type": "int"
        },
        {
          "description": "Each valid line in this file (which should have a CSV-like format)\ncorresponds to a valid word ID. IDs are in sequential order, starting from\nnum_reserved_ids. The last entry in each line is expected to be a value\ncorresponding to the count or relative probability. Exactly one of vocab_file\nand unigrams needs to be passed to this op.",
          "name": "vocab_file",
          "type": "string"
        },
        {
          "description": "The distortion is used to skew the unigram probability distribution.\nEach weight is first raised to the distortion's power before adding to the\ninternal unigram distribution. As a result, distortion = 1.0 gives regular\nunigram sampling (as defined by the vocab file), and distortion = 0.0 gives\na uniform distribution.",
          "name": "distortion",
          "type": "float"
        },
        {
          "description": "Optionally some reserved IDs can be added in the range [0,\n..., num_reserved_ids) by the users. One use case is that a special unknown\nword token is used as ID 0. These IDs will have a sampling probability of 0.",
          "name": "num_reserved_ids",
          "type": "int"
        },
        {
          "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with 'shard') indicates the number of partitions that are being\nused in the overall computation.",
          "name": "num_shards",
          "type": "int"
        },
        {
          "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This parameter\n(together with 'num_shards') indicates the particular partition number of a\nsampler op, when partitioning is being used.",
          "name": "shard",
          "type": "int"
        },
        {
          "description": "A list of unigram counts or probabilities, one per ID in sequential\norder. Exactly one of vocab_file and unigrams should be passed to this op.",
          "name": "unigrams",
          "type": "list(float)"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "A unigram sampler could use a fixed unigram distribution read from a\nfile or passed in as an in-memory array instead of building up the distribution\nfrom data on the fly. There is also an option to skew the distribution by\napplying a distortion power to the weights.\n\nThe vocabulary file should be in CSV-like format, with the last field\nbeing the weight associated with the word.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "FlatMapDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Unlike MapDataset, the `f` in FlatMapDataset is expected to return a\nDataset variant, and FlatMapDataset will flatten successive results\ninto a single Dataset.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "Floor",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Returns element-wise largest integer not greater than x."
    }
  },
  {
    "name": "FloorDiv",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `FloorDiv` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x // y element-wise."
    }
  },
  {
    "name": "FloorMod",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "true, this follows Python semantics in that the result here is consistent\nwith a flooring divide. E.g. `floor(x / y) * y + mod(x, y) = x`.\n\n*NOTE*: `FloorMod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns element-wise remainder of division. When `x < 0` xor `y < 0` is"
    }
  },
  {
    "name": "FractionalAvgPool",
    "schema": {
      "attributes": [
        {
          "description": "Pooling ratio for each dimension of `value`, currently only\nsupports row and col dimension and should be >= 1.0. For example, a valid\npooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements\nmust be 1.0 because we don't allow pooling on batch and channels\ndimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions\nrespectively.",
          "name": "pooling_ratio",
          "type": "list(float)"
        },
        {
          "description": "When set to True, generates the pooling sequence in a\npseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin\nGraham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for\ndifference between pseudorandom and random.",
          "name": "pseudo_random",
          "type": "bool"
        },
        {
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [41/3, 26/3] for fractional avg pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "description": "When set to True, a fixed pooling region will be used when\niterating over a FractionalAvgPool node in the computation graph. Mainly used\nin unit test to make FractionalAvgPool deterministic.",
          "name": "deterministic",
          "type": "bool"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Fractional average pooling is similar to Fractional max pooling in the pooling\nregion generation step. The only difference is that after pooling regions are\ngenerated, a mean operation is performed instead of a max operation in each\npooling region.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "output tensor after fractional avg pooling.",
          "name": "output",
          "type": 0
        },
        {
          "description": "row pooling sequence, needed to calculate gradient.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, needed to calculate gradient.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "summary": "Performs fractional average pooling on the input."
    }
  },
  {
    "name": "FractionalAvgPoolGrad",
    "schema": {
      "attributes": [
        {
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [41/3, 26/3] for fractional avg pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Unlike FractionalMaxPoolGrad, we don't need to find arg_max for\nFractionalAvgPoolGrad, we just need to evenly back-propagate each element of\nout_backprop to those indices that form the same pooling cell. Therefore, we\njust need to know the shape of original input tensor, instead of the whole\ntensor.",
      "inputs": [
        {
          "description": "Original input tensor shape for `fractional_avg_pool`",
          "name": "orig_input_tensor_shape",
          "type": 9
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients\nw.r.t. the output of `fractional_avg_pool`.",
          "name": "out_backprop",
          "type": 0
        },
        {
          "description": "row pooling sequence, form pooling region with\ncol_pooling_sequence.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, form pooling region with\nrow_pooling sequence.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "4-D.  Gradients w.r.t. the input of `fractional_avg_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradient of the FractionalAvgPool function."
    }
  },
  {
    "name": "FractionalMaxPool",
    "schema": {
      "attributes": [
        {
          "description": "Pooling ratio for each dimension of `value`, currently only\nsupports row and col dimension and should be >= 1.0. For example, a valid\npooling ratio looks like [1.0, 1.44, 1.73, 1.0]. The first and last elements\nmust be 1.0 because we don't allow pooling on batch and channels\ndimensions. 1.44 and 1.73 are pooling ratio on height and width dimensions\nrespectively.",
          "name": "pooling_ratio",
          "type": "list(float)"
        },
        {
          "description": "When set to True, generates the pooling sequence in a\npseudorandom fashion, otherwise, in a random fashion. Check paper [Benjamin\nGraham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071) for\ndifference between pseudorandom and random.",
          "name": "pseudo_random",
          "type": "bool"
        },
        {
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [20, 16] for fractional max pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "description": "When set to True, a fixed pooling region will be used when\niterating over a FractionalMaxPool node in the computation graph. Mainly used\nin unit test to make FractionalMaxPool deterministic.",
          "name": "deterministic",
          "type": "bool"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Fractional max pooling is slightly different than regular max pooling.  In\nregular max pooling, you downsize an input set by taking the maximum value of\nsmaller N x N subsections of the set (often 2x2), and try to reduce the set by\na factor of N, where N is an integer.  Fractional max pooling, as you might\nexpect from the word \"fractional\", means that the overall reduction ratio N\ndoes not have to be an integer.\n\nThe sizes of the pooling regions are generated randomly but are fairly uniform.\nFor example, let's look at the height dimension, and the constraints on the\nlist of rows that will be pool boundaries.\n\nFirst we define the following:\n\n1.  input_row_length : the number of rows from the input set\n2.  output_row_length : which will be smaller than the input\n3.  alpha = input_row_length / output_row_length : our reduction ratio\n4.  K = floor(alpha)\n5.  row_pooling_sequence : this is the result list of pool boundary rows\n\nThen, row_pooling_sequence should satisfy:\n\n1.  a[0] = 0 : the first value of the sequence is 0\n2.  a[end] = input_row_length : the last value of the sequence is the size\n3.  K <= (a[i+1] - a[i]) <= K+1 : all intervals are K or K+1 size\n4.  length(row_pooling_sequence) = output_row_length+1\n\nFor more details on fractional max pooling, see this paper:\n[Benjamin Graham, Fractional Max-Pooling](http://arxiv.org/abs/1412.6071)",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "output tensor after fractional max pooling.",
          "name": "output",
          "type": 0
        },
        {
          "description": "row pooling sequence, needed to calculate gradient.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, needed to calculate gradient.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "summary": "Performs fractional max pooling on the input."
    }
  },
  {
    "name": "FractionalMaxPoolGrad",
    "schema": {
      "attributes": [
        {
          "description": "When set to True, it means when pooling, the values at the boundary\nof adjacent pooling cells are used by both cells. For example:\n\n`index  0  1  2  3  4`\n\n`value  20 5  16 3  7`\n\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice.\nThe result would be [20, 16] for fractional max pooling.",
          "name": "overlapping",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Original input for `fractional_max_pool`",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "Original output for `fractional_max_pool`",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients\nw.r.t. the output of `fractional_max_pool`.",
          "name": "out_backprop",
          "type": 0
        },
        {
          "description": "row pooling sequence, form pooling region with\ncol_pooling_sequence.",
          "name": "row_pooling_sequence",
          "type": 9
        },
        {
          "description": "column pooling sequence, form pooling region with\nrow_pooling sequence.",
          "name": "col_pooling_sequence",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "4-D.  Gradients w.r.t. the input of `fractional_max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradient of the FractionalMaxPool function."
    }
  },
  {
    "name": "FusedBatchNorm",
    "schema": {
      "attributes": [
        {
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "type": 0
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "type": 0
        },
        {
          "description": "A 1D Tensor for offset, to shift to the normalized x.",
          "name": "offset",
          "type": 0
        },
        {
          "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
          "name": "mean",
          "type": 0
        },
        {
          "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
          "name": "variance",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for output data.",
          "name": "y",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
          "name": "batch_mean",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
          "name": "batch_variance",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
          "name": "reserve_space_1",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
          "name": "reserve_space_2",
          "type": 0
        }
      ],
      "summary": "Batch normalization."
    }
  },
  {
    "name": "FusedBatchNormGrad",
    "schema": {
      "attributes": [
        {
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to y.",
          "name": "y_backprop",
          "type": 0
        },
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "type": 0
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "type": 0
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
          "name": "reserve_space_1",
          "type": 0
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
          "name": "reserve_space_2",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to x.",
          "name": "x_backprop",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the gradient with respect to scale.",
          "name": "scale_backprop",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the gradient with respect to offset.",
          "name": "offset_backprop",
          "type": 0
        },
        {
          "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
          "name": "reserve_space_3",
          "type": 0
        },
        {
          "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
          "name": "reserve_space_4",
          "type": 0
        }
      ],
      "summary": "Gradient for batch normalization."
    }
  },
  {
    "name": "FusedBatchNormGradV2",
    "schema": {
      "attributes": [
        {
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The data type for the scale, offset, mean, and variance.",
          "name": "U",
          "type": "type"
        },
        {
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "description": "The data format for y_backprop, x, x_backprop.\nEither \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to y.",
          "name": "y_backprop",
          "type": 0
        },
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "type": 0
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "type": 1
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nmean to be reused in gradient computation. When is_training is\nFalse, a 1D Tensor for the population mean to be reused in both\n1st and 2nd order gradient computation.",
          "name": "reserve_space_1",
          "type": 0
        },
        {
          "description": "When is_training is True, a 1D Tensor for the computed batch\nvariance (inverted variance in the cuDNN case) to be reused in\ngradient computation. When is_training is False, a 1D Tensor\nfor the population variance to be reused in both 1st and 2nd\norder gradient computation.",
          "name": "reserve_space_2",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for the gradient with respect to x.",
          "name": "x_backprop",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the gradient with respect to scale.",
          "name": "scale_backprop",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the gradient with respect to offset.",
          "name": "offset_backprop",
          "type": 0
        },
        {
          "description": "Unused placeholder to match the mean input in FusedBatchNorm.",
          "name": "reserve_space_3",
          "type": 0
        },
        {
          "description": "Unused placeholder to match the variance input\nin FusedBatchNorm.",
          "name": "reserve_space_4",
          "type": 0
        }
      ],
      "summary": "Gradient for batch normalization."
    }
  },
  {
    "name": "FusedBatchNormV2",
    "schema": {
      "attributes": [
        {
          "description": "The data type for the elements of input and output Tensors.",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The data type for the scale, offset, mean, and variance.",
          "name": "U",
          "type": "type"
        },
        {
          "description": "A small float number added to the variance of x.",
          "name": "epsilon",
          "type": "float"
        },
        {
          "description": "The data format for x and y. Either \"NHWC\" (default) or \"NCHW\".",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "A bool value to indicate the operation is for training (default)\nor inference.",
          "name": "is_training",
          "type": "bool"
        }
      ],
      "description": "Note that the size of 4D Tensors are defined by either \"NHWC\" or \"NCHW\".\nThe size of 1D Tensors matches the dimension C of the 4D Tensors.",
      "inputs": [
        {
          "description": "A 4D Tensor for input data.",
          "name": "x",
          "type": 0
        },
        {
          "description": "A 1D Tensor for scaling factor, to scale the normalized x.",
          "name": "scale",
          "type": 0
        },
        {
          "description": "A 1D Tensor for offset, to shift to the normalized x.",
          "name": "offset",
          "type": 0
        },
        {
          "description": "A 1D Tensor for population mean. Used for inference only;\nmust be empty for training.",
          "name": "mean",
          "type": 0
        },
        {
          "description": "A 1D Tensor for population variance. Used for inference only;\nmust be empty for training.",
          "name": "variance",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor for output data.",
          "name": "y",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be used by TensorFlow\nto compute the running mean.",
          "name": "batch_mean",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch variance, to be used by\nTensorFlow to compute the running variance.",
          "name": "batch_variance",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch mean, to be reused\nin the gradient computation.",
          "name": "reserve_space_1",
          "type": 0
        },
        {
          "description": "A 1D Tensor for the computed batch variance (inverted variance\nin the cuDNN case), to be reused in the gradient computation.",
          "name": "reserve_space_2",
          "type": 0
        }
      ],
      "summary": "Batch normalization."
    }
  },
  {
    "name": "FusedPadConv2D",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "mode",
          "type": "string"
        },
        {
          "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "Similar to FusedResizeAndPadConv2d, this op allows for an optimized\nimplementation where the spatial padding transformation stage is fused with the\nim2col lookup, but in this case without the bilinear filtering required for\nresizing. Fusing the padding prevents the need to write out the intermediate\nresults as whole tensors, reducing memory pressure, and we can get some latency\ngains by merging the transformation calculations.\nThe data_format attribute for Conv2D isn't supported by this op, and 'NHWC'\norder is used instead.\nInternally this op uses a single per-graph scratch buffer, which means that it\nwill block if multiple versions are being run in parallel. This is because this\noperator is primarily an optimization to minimize memory usage.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
          "name": "filter",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs a padding as a preprocess during a convolution."
    }
  },
  {
    "name": "FusedResizeAndPadConv2D",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale input by (new_height - 1) / (height - 1),\nwhich exactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension.",
          "name": "resize_align_corners",
          "type": "bool"
        },
        {
          "description": "",
          "name": "mode",
          "type": "string"
        },
        {
          "description": "1-D of length 4.  The stride of the sliding window for each dimension\nof `input`. Must be in the same order as the dimension specified with format.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "It's often possible to do spatial transformations more efficiently as part of\nthe packing stage of a convolution, so this op allows for an optimized\nimplementation where these stages are fused together. This prevents the need to\nwrite out the intermediate results as whole tensors, reducing memory pressure,\nand we can get some latency gains by merging the transformation calculations.\nThe data_format attribute for Conv2D isn't supported by this op, and defaults to\n'NHWC' order.\nInternally this op uses a single per-graph scratch buffer, which means that it\nwill block if multiple versions are being run in parallel. This is because this\noperator is primarily an optimization to minimize memory usage.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, in_height, in_width, in_channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "type": 3
        },
        {
          "description": "4-D with shape\n`[filter_height, filter_width, in_channels, out_channels]`.",
          "name": "filter",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs a resize and padding as a preprocess during a convolution."
    }
  },
  {
    "name": "Gather",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "Tparams",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n```python\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n```\n\nIf `indices` is a permutation and `len(indices) == params.shape[0]` then\nthis operation will permute `params` accordingly.\n\n`validate_indices`: DEPRECATED. If this operation is assigned to CPU, values in\n`indices` are always validated to be within range. If assigned to GPU,\nout-of-bound indices result in safe but unspecified behavior, which may include\nraising an error.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "params",
          "type": 0
        },
        {
          "description": "",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Gather slices from `params` according to `indices`."
    }
  },
  {
    "name": "GatherNd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tparams",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "`indices` is an K-dimensional integer tensor, best thought of as a\n(K-1)-dimensional tensor of indices into `params`, where each element defines a\nslice of `params`:\n\n    output[i_0, ..., i_{K-2}] = params[indices[i0, ..., i_{K-2}]]\n\nWhereas in @{tf.gather} `indices` defines slices into the first\ndimension of `params`, in `tf.gather_nd`, `indices` defines slices into the\nfirst `N` dimensions of `params`, where `N = indices.shape[-1]`.\n\nThe last dimension of `indices` can be at most the rank of\n`params`:\n\n    indices.shape[-1] <= params.rank\n\nThe last dimension of `indices` corresponds to elements\n(if `indices.shape[-1] == params.rank`) or slices\n(if `indices.shape[-1] < params.rank`) along dimension `indices.shape[-1]`\nof `params`.  The output tensor has shape\n\n    indices.shape[:-1] + params.shape[indices.shape[-1]:]\n\nSome examples below.\n\nSimple indexing into a matrix:\n\n```python\n    indices = [[0, 0], [1, 1]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = ['a', 'd']\n```\n\nSlice indexing into a matrix:\n\n```python\n    indices = [[1], [0]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [['c', 'd'], ['a', 'b']]\n```\n\nIndexing into a 3-tensor:\n\n```python\n    indices = [[1]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[['a1', 'b1'], ['c1', 'd1']]]\n\n\n    indices = [[0, 1], [1, 0]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [['c0', 'd0'], ['a1', 'b1']]\n\n\n    indices = [[0, 0, 1], [1, 0, 1]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = ['b0', 'b1']\n```\n\nBatched indexing into a matrix:\n\n```python\n    indices = [[[0, 0]], [[0, 1]]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [['a'], ['b']]\n```\n\nBatched slice indexing into a matrix:\n\n```python\n    indices = [[[1]], [[0]]]\n    params = [['a', 'b'], ['c', 'd']]\n    output = [[['c', 'd']], [['a', 'b']]]\n```\n\nBatched indexing into a 3-tensor:\n\n```python\n    indices = [[[1]], [[0]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[[['a1', 'b1'], ['c1', 'd1']]],\n              [[['a0', 'b0'], ['c0', 'd0']]]]\n\n    indices = [[[0, 1], [1, 0]], [[0, 0], [1, 1]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [[['c0', 'd0'], ['a1', 'b1']],\n              [['a0', 'b0'], ['c1', 'd1']]]\n\n\n    indices = [[[0, 0, 1], [1, 0, 1]], [[0, 1, 1], [1, 1, 0]]]\n    params = [[['a0', 'b0'], ['c0', 'd0']],\n              [['a1', 'b1'], ['c1', 'd1']]]\n    output = [['b0', 'b1'], ['d0', 'c1']]\n```",
      "inputs": [
        {
          "description": "The tensor from which to gather values.",
          "name": "params",
          "type": 0
        },
        {
          "description": "Index tensor.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Values from `params` gathered from indices given by `indices`, with\nshape `indices.shape[:-1] + params.shape[indices.shape[-1]:]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Gather slices from `params` into a Tensor with shape specified by `indices`."
    }
  },
  {
    "name": "GatherV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tparams",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "",
          "name": "Taxis",
          "type": "type"
        }
      ],
      "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `params.shape[:axis] + indices.shape +\nparams.shape[axis + 1:]` where:\n\n```python\n    # Scalar indices (output is rank(params) - 1).\n    output[a_0, ..., a_n, b_0, ..., b_n] =\n      params[a_0, ..., a_n, indices, b_0, ..., b_n]\n\n    # Vector indices (output is rank(params)).\n    output[a_0, ..., a_n, i, b_0, ..., b_n] =\n      params[a_0, ..., a_n, indices[i], b_0, ..., b_n]\n\n    # Higher rank indices (output is rank(params) + rank(indices) - 1).\n    output[a_0, ..., a_n, i, ..., j, b_0, ... b_n] =\n      params[a_0, ..., a_n, indices[i, ..., j], b_0, ..., b_n]\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/Gather.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "The tensor from which to gather values. Must be at least rank\n`axis + 1`.",
          "name": "params",
          "type": 0
        },
        {
          "description": "Index tensor. Must be in range `[0, params.shape[axis])`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "The axis in `params` to gather `indices` from. Defaults to the first\ndimension. Supports negative indexes.",
          "name": "axis",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Values from `params` gathered from indices given by `indices`, with\nshape `params.shape[:axis] + indices.shape + params.shape[axis + 1:]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Gather slices from `params` axis `axis` according to `indices`."
    }
  },
  {
    "name": "GenerateVocabRemapping",
    "schema": {
      "attributes": [
        {
          "description": "How many entries into the new vocab file to start reading.",
          "name": "new_vocab_offset",
          "type": "int"
        },
        {
          "description": "Number of entries in the new vocab file to remap.",
          "name": "num_new_vocab",
          "type": "int"
        },
        {
          "description": "Number of entries in the old vocab file to consider.  If -1,\nuse the entire old vocabulary.",
          "name": "old_vocab_size",
          "type": "int"
        }
      ],
      "description": "length `num_new_vocab`, where `remapping[i]` contains the row number in the old\nvocabulary that corresponds to row `i` in the new vocabulary (starting at line\n`new_vocab_offset` and up to `num_new_vocab` entities), or `-1` if entry `i`\nin the new vocabulary is not in the old vocabulary.  The old vocabulary is\nconstrained to the first `old_vocab_size` entries if `old_vocab_size` is not the\ndefault value of -1.\n\n`num_vocab_offset` enables\nuse in the partitioned variable case, and should generally be set through\nexamining partitioning info.  The format of the files should be a text file,\nwith each line containing a single entity within the vocabulary.\n\nFor example, with `new_vocab_file` a text file containing each of the following\nelements on a single line: `[f0, f1, f2, f3]`, old_vocab_file = [f1, f0, f3],\n`num_new_vocab = 3, new_vocab_offset = 1`, the returned remapping would be\n`[0, -1, 2]`.\n\nThe op also returns a count of how many entries in the new vocabulary\nwere present in the old vocabulary, which is used to calculate the number of\nvalues to initialize in a weight matrix remapping\n\nThis functionality can be used to remap both row vocabularies (typically,\nfeatures) and column vocabularies (typically, classes) from TensorFlow\ncheckpoints.  Note that the partitioning logic relies on contiguous vocabularies\ncorresponding to div-partitioned variables.  Moreover, the underlying remapping\nuses an IndexTable (as opposed to an inexact CuckooTable), so client code should\nuse the corresponding index_table_from_file() as the FeatureColumn framework\ndoes (as opposed to tf.feature_to_id(), which uses a CuckooTable).",
      "inputs": [
        {
          "description": "Path to the new vocab file.",
          "name": "new_vocab_file",
          "type": 7
        },
        {
          "description": "Path to the old vocab file.",
          "name": "old_vocab_file",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of length num_new_vocab where the element at index i\nis equal to the old ID that maps to the new ID i.  This element is -1 for any\nnew ID that is not found in the old vocabulary.",
          "name": "remapping",
          "type": 9
        },
        {
          "description": "Number of new vocab entries found in old vocab.",
          "name": "num_present",
          "type": 3
        }
      ],
      "summary": "Given a path to new and old vocabulary files, returns a remapping Tensor of"
    }
  },
  {
    "name": "GetSessionHandle",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be stored.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The handle for the tensor stored in the session state, represented\nas a string.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Store the input tensor in the state of the current session."
    }
  },
  {
    "name": "GetSessionHandleV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be stored.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The handle for the tensor stored in the session state, represented\nas a ResourceHandle object.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Store the input tensor in the state of the current session."
    }
  },
  {
    "name": "GetSessionTensor",
    "schema": {
      "attributes": [
        {
          "description": "The type of the output value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle for a tensor stored in the session state.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The tensor for the given handle.",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Get the value of the tensor specified by its handle."
    }
  },
  {
    "name": "Greater",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Greater` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x > y) element-wise."
    }
  },
  {
    "name": "GreaterEqual",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `GreaterEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x >= y) element-wise."
    }
  },
  {
    "name": "GroupByWindowDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping an element of `input_dataset`, concatenated\nwith `key_func_other_arguments` to a scalar value of type DT_INT64.",
          "name": "key_func",
          "type": "func"
        },
        {
          "description": "",
          "name": "reduce_func",
          "type": "func"
        },
        {
          "description": "",
          "name": "window_size_func",
          "type": "func"
        },
        {
          "description": "",
          "name": "Tkey_func_other_arguments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Treduce_func_other_arguments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Twindow_size_func_other_arguments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "// TODO(mrry): Support non-int64 keys.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "key_func_other_arguments",
          "type": 0
        },
        {
          "description": "",
          "name": "reduce_func_other_arguments",
          "type": 0
        },
        {
          "description": "",
          "name": "window_size_func_other_arguments",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that computes a windowed group-by on `input_dataset`."
    }
  },
  {
    "name": "HSVToRGB",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a tensor of the same shape as the `images` tensor, containing the RGB\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\nSee `rgb_to_hsv` for a description of the HSV encoding.",
      "inputs": [
        {
          "description": "1-D or higher rank. HSV data to convert. Last dimension must be size 3.",
          "name": "images",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "`images` converted to RGB.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Convert one or more images from HSV to RGB."
    }
  },
  {
    "name": "HashTable",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates a non-initialized hash table."
    }
  },
  {
    "name": "HashTableV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a hash table, specifying the type of its keys and values.\nBefore using the table you will have to initialize it.  After initialization the\ntable will be immutable.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates a non-initialized hash table."
    }
  },
  {
    "name": "HistogramFixedWidth",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Given the tensor `values`, this operation returns a rank 1 histogram counting\nthe number of entries in `values` that fall into every bin.  The bins are\nequal width and determined by the arguments `value_range` and `nbins`.\n\n```python\n# Bins will be:  (-inf, 1), [1, 2), [2, 3), [3, 4), [4, inf)\nnbins = 5\nvalue_range = [0.0, 5.0]\nnew_values = [-1.0, 0.0, 1.5, 2.0, 5.0, 15]\n\nwith tf.get_default_session() as sess:\n  hist = tf.histogram_fixed_width(new_values, value_range, nbins=5)\n  variables.global_variables_initializer().run()\n  sess.run(hist) => [2, 1, 1, 0, 2]\n```",
      "inputs": [
        {
          "description": "Numeric `Tensor`.",
          "name": "values",
          "type": 0
        },
        {
          "description": "Shape [2] `Tensor` of same `dtype` as `values`.\nvalues <= value_range[0] will be mapped to hist[0],\nvalues >= value_range[1] will be mapped to hist[-1].",
          "name": "value_range",
          "type": 0
        },
        {
          "description": "Scalar `int32 Tensor`.  Number of histogram bins.",
          "name": "nbins",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 1-D `Tensor` holding histogram of values.",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Return histogram of values."
    }
  },
  {
    "name": "HistogramSummary",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nhas one summary value containing a histogram for `values`.\n\nThis op reports an `InvalidArgument` error if any value is not finite.",
      "inputs": [
        {
          "description": "Scalar.  Tag to use for the `Summary.Value`.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "Any shape. Values to use to build the histogram.",
          "name": "values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with a histogram."
    }
  },
  {
    "name": "IFFT",
    "schema": {
      "description": "Computes the inverse 1-dimensional discrete Fourier transform over the\ninner-most dimension of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most\n  dimension of `input` is replaced with its inverse 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifft\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "Inverse fast Fourier transform."
    }
  },
  {
    "name": "IFFT2D",
    "schema": {
      "description": "Computes the inverse 2-dimensional discrete Fourier transform over the\ninner-most 2 dimensions of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most 2\n  dimensions of `input` are replaced with their inverse 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifft2\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "Inverse 2D fast Fourier transform."
    }
  },
  {
    "name": "IFFT3D",
    "schema": {
      "description": "Computes the inverse 3-dimensional discrete Fourier transform over the\ninner-most 3 dimensions of `input`.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same shape as `input`. The inner-most 3\n  dimensions of `input` are replaced with their inverse 3D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.ifftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "Inverse 3D fast Fourier transform."
    }
  },
  {
    "name": "IRFFT",
    "schema": {
      "description": "Computes the inverse 1-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most dimension of `input`.\n\nThe inner-most dimension of `input` is assumed to be the result of `RFFT`: the\n`fft_length / 2 + 1` unique components of the DFT of a real-valued signal. If\n`fft_length` is not provided, it is computed from the size of the inner-most\ndimension of `input` (`fft_length = 2 * (inner - 1)`). If the FFT length used to\ncompute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong the axis `IRFFT` is computed on, if `fft_length / 2 + 1` is smaller\nthan the corresponding dimension of `input`, the dimension is cropped. If it is\nlarger, the dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        },
        {
          "description": "An int32 tensor of shape [1]. The FFT length.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A float32 tensor of the same rank as `input`. The inner-most\n  dimension of `input` is replaced with the `fft_length` samples of its inverse\n  1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfft\n@end_compatibility",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Inverse real-valued fast Fourier transform."
    }
  },
  {
    "name": "IRFFT2D",
    "schema": {
      "description": "Computes the inverse 2-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most 2 dimensions of `input`.\n\nThe inner-most 2 dimensions of `input` are assumed to be the result of `RFFT2D`:\nThe inner-most dimension contains the `fft_length / 2 + 1` unique components of\nthe DFT of a real-valued signal. If `fft_length` is not provided, it is computed\nfrom the size of the inner-most 2 dimensions of `input`. If the FFT length used\nto compute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong each axis `IRFFT2D` is computed on, if `fft_length` (or\n`fft_length / 2 + 1` for the inner-most dimension) is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        },
        {
          "description": "An int32 tensor of shape [2]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A float32 tensor of the same rank as `input`. The inner-most 2\n  dimensions of `input` are replaced with the `fft_length` samples of their\n  inverse 2D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.irfft2\n@end_compatibility",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Inverse 2D real-valued fast Fourier transform."
    }
  },
  {
    "name": "IRFFT3D",
    "schema": {
      "description": "Computes the inverse 3-dimensional discrete Fourier transform of a real-valued\nsignal over the inner-most 3 dimensions of `input`.\n\nThe inner-most 3 dimensions of `input` are assumed to be the result of `RFFT3D`:\nThe inner-most dimension contains the `fft_length / 2 + 1` unique components of\nthe DFT of a real-valued signal. If `fft_length` is not provided, it is computed\nfrom the size of the inner-most 3 dimensions of `input`. If the FFT length used\nto compute `input` is odd, it should be provided since it cannot be inferred\nproperly.\n\nAlong each axis `IRFFT3D` is computed on, if `fft_length` (or\n`fft_length / 2 + 1` for the inner-most dimension) is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A complex64 tensor.",
          "name": "input",
          "type": 8
        },
        {
          "description": "An int32 tensor of shape [3]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A float32 tensor of the same rank as `input`. The inner-most 3\n  dimensions of `input` are replaced with the `fft_length` samples of their\n  inverse 3D real Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.irfftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Inverse 3D real-valued fast Fourier transform."
    }
  },
  {
    "name": "Identity",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Return a tensor with the same shape and contents as the input tensor or value."
    }
  },
  {
    "name": "IdentityN",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "tensors.\n\nThis op can be used to override the gradient for complicated functions. For\nexample, suppose y = f(x) and we wish to apply a custom function g for backprop\nsuch that dx = g(dy). In Python,\n\n```python\nwith tf.get_default_graph().gradient_override_map(\n    {'IdentityN': 'OverrideGradientWithG'}):\n  y, _ = identity_n([f(x), x])\n\n@tf.RegisterGradient('OverrideGradientWithG')\ndef ApplyG(op, dy, _):\n  return [None, g(dy)]  # Do not backprop to f(x).\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns a list of tensors with the same shapes and contents as the input"
    }
  },
  {
    "name": "IdentityReader",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the queued work as both the key and value."
    }
  },
  {
    "name": "IdentityReaderV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue strings in a Queue.  ReaderRead will take the front\nwork string and output (work, work).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the queued work as both the key and value."
    }
  },
  {
    "name": "Igamma",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The lower regularized incomplete Gamma function is defined as:\n\n\n\\\\(P(a, x) = gamma(a, x) / Gamma(a) = 1 - Q(a, x)\\\\)\n\nwhere\n\n\\\\(gamma(a, x) = int_{0}^{x} t^{a-1} exp(-t) dt\\\\)\n\nis the lower incomplete Gamma function.\n\nNote, above `Q(a, x)` (`Igammac`) is the upper regularized complete\nGamma function.",
      "inputs": [
        {
          "description": "",
          "name": "a",
          "type": 0
        },
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Compute the lower regularized incomplete Gamma function `Q(a, x)`."
    }
  },
  {
    "name": "Igammac",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The upper regularized incomplete Gamma function is defined as:\n\n\\\\(Q(a, x) = Gamma(a, x) / Gamma(a) = 1 - P(a, x)\\\\)\n\nwhere\n\n\\\\(Gamma(a, x) = int_{x}^{\\infty} t^{a-1} exp(-t) dt\\\\)\n\nis the upper incomplete Gama function.\n\nNote, above `P(a, x)` (`Igamma`) is the lower regularized complete\nGamma function.",
      "inputs": [
        {
          "description": "",
          "name": "a",
          "type": 0
        },
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Compute the upper regularized incomplete Gamma function `Q(a, x)`."
    }
  },
  {
    "name": "IgnoreErrorsDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that contains the elements of `input_dataset` ignoring errors."
    }
  },
  {
    "name": "Imag",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the imaginary part of each element in `input`. All\nelements in `input` must be complex numbers of the form \\\\(a + bj\\\\), where *a*\nis the real part and *b* is the imaginary part returned by this operation.\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.imag(input) ==> [4.75, 5.75]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the imaginary part of a complex number."
    }
  },
  {
    "name": "ImageSummary",
    "schema": {
      "attributes": [
        {
          "description": "Max number of batch elements to generate images for.",
          "name": "max_images",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Color to use for pixels with non-finite values.",
          "name": "bad_color",
          "type": "tensor"
        }
      ],
      "description": "The summary has up to `max_images` summary values containing images. The\nimages are built from `tensor` which must be 4-D with shape `[batch_size,\nheight, width, channels]` and where `channels` can be:\n\n*  1: `tensor` is interpreted as Grayscale.\n*  3: `tensor` is interpreted as RGB.\n*  4: `tensor` is interpreted as RGBA.\n\nThe images have the same number of channels as the input tensor. For float\ninput, the values are normalized one image at a time to fit in the range\n`[0, 255]`.  `uint8` values are unchanged.  The op uses two different\nnormalization algorithms:\n\n*  If the input values are all positive, they are rescaled so the largest one\n   is 255.\n\n*  If any input value is negative, the values are shifted so input value 0.0\n   is at 127.  They are then rescaled so that either the smallest value is 0,\n   or the largest one is 255.\n\nThe `tag` argument is a scalar `Tensor` of type `string`.  It is used to\nbuild the `tag` of the summary values:\n\n*  If `max_images` is 1, the summary value tag is '*tag*/image'.\n*  If `max_images` is greater than 1, the summary value tags are\n   generated sequentially as '*tag*/image/0', '*tag*/image/1', etc.\n\nThe `bad_color` argument is the color to use in the generated images for\nnon-finite input values.  It is a `unit8` 1-D tensor of length `channels`.\nEach element must be in the range `[0, 255]` (It represents the value of a\npixel in the output image).  Non-finite values in the input tensor are\nreplaced by this tensor in the output image.  The default value is the color\nred.",
      "inputs": [
        {
          "description": "Scalar. Used to build the `tag` attribute of the summary values.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "4-D of shape `[batch_size, height, width, channels]` where\n`channels` is 1, 3, or 4.",
          "name": "tensor",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with images."
    }
  },
  {
    "name": "ImmutableConst",
    "schema": {
      "attributes": [
        {
          "description": "Type of the returned tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "Shape of the returned tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "Name of readonly memory region used by the tensor, see\nNewReadOnlyMemoryRegionFromFile in tensorflow::Env.",
          "name": "memory_region_name",
          "type": "string"
        }
      ],
      "description": "The current implementation memmaps the tensor from a file.",
      "outputs": [
        {
          "description": "",
          "name": "tensor",
          "type": 0
        }
      ],
      "summary": "Returns immutable tensor from memory region."
    }
  },
  {
    "name": "InTopK",
    "schema": {
      "attributes": [
        {
          "description": "Number of top elements to look at for computing precision.",
          "name": "k",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$",
      "inputs": [
        {
          "description": "A `batch_size` x `classes` tensor.",
          "name": "predictions",
          "type": 1
        },
        {
          "description": "A `batch_size` vector of class ids.",
          "name": "targets",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Computed Precision at `k` as a `bool Tensor`.",
          "name": "precision",
          "type": 10
        }
      ],
      "summary": "Says whether the targets are in the top `K` predictions."
    }
  },
  {
    "name": "InTopKV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This outputs a `batch_size` bool array, an entry `out[i]` is `true` if the\nprediction for the target class is among the top `k` predictions among\nall predictions for example `i`. Note that the behavior of `InTopK` differs\nfrom the `TopK` op in its handling of ties; if multiple classes have the\nsame prediction value and straddle the top-`k` boundary, all of those\nclasses are considered to be in the top `k`.\n\nMore formally, let\n\n  \\\\(predictions_i\\\\) be the predictions for all classes for example `i`,\n  \\\\(targets_i\\\\) be the target class for example `i`,\n  \\\\(out_i\\\\) be the output for example `i`,\n\n$$out_i = predictions_{i, targets_i} \\in TopKIncludingTies(predictions_i)$$",
      "inputs": [
        {
          "description": "A `batch_size` x `classes` tensor.",
          "name": "predictions",
          "type": 1
        },
        {
          "description": "A `batch_size` vector of class ids.",
          "name": "targets",
          "type": 0
        },
        {
          "description": "Number of top elements to look at for computing precision.",
          "name": "k",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Computed precision at `k` as a `bool Tensor`.",
          "name": "precision",
          "type": 10
        }
      ],
      "summary": "Says whether the targets are in the top `K` predictions."
    }
  },
  {
    "name": "InitializeTable",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tkey",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tval",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Keys of type Tkey.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Values of type Tval.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Table initializer that takes two tensors for keys and values respectively."
    }
  },
  {
    "name": "InitializeTableFromTextFile",
    "schema": {
      "attributes": [
        {
          "description": "Column index in a line to get the table `key` values from.",
          "name": "key_index",
          "type": "int"
        },
        {
          "description": "Column index that represents information of a line to get the table\n`value` values from.",
          "name": "value_index",
          "type": "int"
        },
        {
          "description": "Number of elements of the file, use -1 if unknown.",
          "name": "vocab_size",
          "type": "int"
        },
        {
          "description": "Delimiter to separate fields in a line.",
          "name": "delimiter",
          "type": "string"
        }
      ],
      "description": "It inserts one key-value pair into the table for each line of the file.\nThe key and value is extracted from the whole line content, elements from the\nsplit line based on `delimiter` or the line number (starting from zero).\nWhere to extract the key and value from a line is specified by `key_index` and\n`value_index`.\n\n- A value of -1 means use the line number(starting from zero), expects `int64`.\n- A value of -2 means use the whole line content, expects `string`.\n- A value >= 0 means use the index (starting at zero) of the split line based\n  on `delimiter`.",
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Filename of a vocabulary text file.",
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Initializes a table from a text file."
    }
  },
  {
    "name": "InitializeTableFromTextFileV2",
    "schema": {
      "attributes": [
        {
          "description": "Column index in a line to get the table `key` values from.",
          "name": "key_index",
          "type": "int"
        },
        {
          "description": "Column index that represents information of a line to get the table\n`value` values from.",
          "name": "value_index",
          "type": "int"
        },
        {
          "description": "Number of elements of the file, use -1 if unknown.",
          "name": "vocab_size",
          "type": "int"
        },
        {
          "description": "Delimiter to separate fields in a line.",
          "name": "delimiter",
          "type": "string"
        }
      ],
      "description": "It inserts one key-value pair into the table for each line of the file.\nThe key and value is extracted from the whole line content, elements from the\nsplit line based on `delimiter` or the line number (starting from zero).\nWhere to extract the key and value from a line is specified by `key_index` and\n`value_index`.\n\n- A value of -1 means use the line number(starting from zero), expects `int64`.\n- A value of -2 means use the whole line content, expects `string`.\n- A value >= 0 means use the index (starting at zero) of the split line based\n  on `delimiter`.",
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Filename of a vocabulary text file.",
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Initializes a table from a text file."
    }
  },
  {
    "name": "InitializeTableV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tkey",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tval",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to a table which will be initialized.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Keys of type Tkey.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Values of type Tval.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Table initializer that takes two tensors for keys and values respectively."
    }
  },
  {
    "name": "InterleaveDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Unlike MapDataset, the `f` in InterleaveDataset is expected to return\na Dataset variant, and InterleaveDataset will flatten successive\nresults into a single Dataset. Unlike FlatMapDataset,\nInterleaveDataset will interleave sequences of up to `block_length`\nconsecutive elements from `cycle_length` input elements.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        },
        {
          "description": "",
          "name": "cycle_length",
          "type": 9
        },
        {
          "description": "",
          "name": "block_length",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "Inv",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = 1 / x\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the reciprocal of x element-wise."
    }
  },
  {
    "name": "InvGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the gradient for the inverse of `x` wrt its input."
    }
  },
  {
    "name": "Invert",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The result will have exactly those bits set, that are not set in `x`. The\ncomputation is performed on the underlying representation of x.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Flips all bits elementwise."
    }
  },
  {
    "name": "InvertPermutation",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation computes the inverse of an index permutation. It takes a 1-D\ninteger tensor `x`, which represents the indices of a zero-based array, and\nswaps each value with its index position. In other words, for an output tensor\n`y` and an input tensor `x`, this operation computes the following:\n\n`y[x[i]] = i for i in [0, 1, ..., len(x) - 1]`\n\nThe values must include 0. There can be no duplicate values or negative values.\n\nFor example:\n\n```\n# tensor `x` is [3, 4, 0, 2, 1]\ninvert_permutation(x) ==> [2, 4, 3, 0, 1]\n```",
      "inputs": [
        {
          "description": "1-D.",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the inverse permutation of a tensor."
    }
  },
  {
    "name": "IsFinite",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "@compatibility(numpy)\nEquivalent to np.isfinite\n@end_compatibility",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns which elements of x are finite."
    }
  },
  {
    "name": "IsInf",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "@compatibility(numpy)\nEquivalent to np.isinf\n@end_compatibility",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns which elements of x are Inf."
    }
  },
  {
    "name": "IsNan",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "@compatibility(numpy)\nEquivalent to np.isnan\n@end_compatibility",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns which elements of x are NaN."
    }
  },
  {
    "name": "IsVariableInitialized",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the variable tensor.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "Outputs boolean scalar indicating whether the tensor has been initialized.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node. May be uninitialized.",
          "name": "ref",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a tensor has been initialized."
    }
  },
  {
    "name": "Iterator",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "outputs": [
        {
          "description": "A handle to the iterator that can be passed to a \"MakeIterator\"\nor \"IteratorGetNext\" op.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A container for an iterator resource."
    }
  },
  {
    "name": "IteratorFromStringHandle",
    "schema": {
      "attributes": [
        {
          "description": "If specified, defines the type of each tuple component in an\nelement produced by the resulting iterator.",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "If specified, defines the shape of each tuple component in an\nelement produced by the resulting iterator.",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A string representation of the given handle.",
          "name": "string_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        }
      ],
      "summary": "Converts the given string representing a handle to an iterator to a resource."
    }
  },
  {
    "name": "IteratorGetNext",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Gets the next output from the given iterator."
    }
  },
  {
    "name": "IteratorSetStatsAggregator",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "iterator_handle",
          "type": 20
        },
        {
          "description": "",
          "name": "stats_aggregator_handle",
          "type": 20
        }
      ],
      "summary": "Associates the given iterator with the given statistics aggregator."
    }
  },
  {
    "name": "IteratorToStringHandle",
    "schema": {
      "inputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A string representation of the given handle.",
          "name": "string_handle",
          "type": 7
        }
      ],
      "summary": "Converts the given `resource_handle` representing an iterator to a string."
    }
  },
  {
    "name": "L2Loss",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes half the L2 norm of a tensor without the `sqrt`:\n\n    output = sum(t ** 2) / 2",
      "inputs": [
        {
          "description": "Typically 2-D, but may have any dimensions.",
          "name": "t",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "0-D.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "L2 Loss."
    }
  },
  {
    "name": "LMDBReader",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the records from a LMDB file."
    }
  },
  {
    "name": "LRN",
    "schema": {
      "attributes": [
        {
          "description": "0-D.  Half-width of the 1-D normalization window.",
          "name": "depth_radius",
          "type": "int"
        },
        {
          "description": "An offset (usually positive to avoid dividing by 0).",
          "name": "bias",
          "type": "float"
        },
        {
          "description": "A scale factor, usually positive.",
          "name": "alpha",
          "type": "float"
        },
        {
          "description": "An exponent.",
          "name": "beta",
          "type": "float"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The 4-D `input` tensor is treated as a 3-D array of 1-D vectors (along the last\ndimension), and each vector is normalized independently.  Within a given vector,\neach component is divided by the weighted, squared sum of inputs within\n`depth_radius`.  In detail,\n\n    sqr_sum[a, b, c, d] =\n        sum(input[a, b, c, d - depth_radius : d + depth_radius + 1] ** 2)\n    output = input / (bias + alpha * sqr_sum) ** beta\n\nFor details, see [Krizhevsky et al., ImageNet classification with deep\nconvolutional neural networks (NIPS 2012)](http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks).",
      "inputs": [
        {
          "description": "4-D.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Local Response Normalization."
    }
  },
  {
    "name": "LRNGrad",
    "schema": {
      "attributes": [
        {
          "description": "A depth radius.",
          "name": "depth_radius",
          "type": "int"
        },
        {
          "description": "An offset (usually > 0 to avoid dividing by 0).",
          "name": "bias",
          "type": "float"
        },
        {
          "description": "A scale factor, usually positive.",
          "name": "alpha",
          "type": "float"
        },
        {
          "description": "An exponent.",
          "name": "beta",
          "type": "float"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "input_grads",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "input_image",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "output_image",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The gradients for LRN.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Gradients for Local Response Normalization."
    }
  },
  {
    "name": "LatencyStatsDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "tag",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Records the latency of producing `input_dataset` elements in a StatsAggregator."
    }
  },
  {
    "name": "LearnedUnigramCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "name": "range_max",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "LeftShift",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `y` is negative, or greater than or equal to the width of `x` in bits the\nresult is implementation defined.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Elementwise computes the bitwise left-shift of `x` and `y`."
    }
  },
  {
    "name": "Less",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Less` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x < y) element-wise."
    }
  },
  {
    "name": "LessEqual",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `LessEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x <= y) element-wise."
    }
  },
  {
    "name": "Lgamma",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the log of the absolute value of `Gamma(x)` element-wise."
    }
  },
  {
    "name": "LinSpace",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "A sequence of `num` evenly-spaced values are generated beginning at `start`.\nIf `num > 1`, the values in the sequence increase by `stop - start / num - 1`,\nso that the last one is exactly `stop`.\n\nFor example:\n\n```\ntf.linspace(10.0, 12.0, 3, name=\"linspace\") => [ 10.0  11.0  12.0]\n```",
      "inputs": [
        {
          "description": "First entry in the range.",
          "name": "start",
          "type": 0
        },
        {
          "description": "Last entry in the range.",
          "name": "stop",
          "type": 0
        },
        {
          "description": "Number of values to generate.",
          "name": "num",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D. The generated values.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Generates values in an interval."
    }
  },
  {
    "name": "ListDiff",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "Given a list `x` and a list `y`, this operation returns a list `out` that\nrepresents all values that are in `x` but not in `y`. The returned list `out`\nis sorted in the same order that the numbers appear in `x` (duplicates are\npreserved). This operation also returns a list `idx` that represents the\nposition of each `out` element in `x`. In other words:\n\n`out[i] = x[idx[i]] for i in [0, 1, ..., len(out) - 1]`\n\nFor example, given this input:\n\n```\nx = [1, 2, 3, 4, 5, 6]\ny = [1, 3, 5]\n```\n\nThis operation would return:\n\n```\nout ==> [2, 4, 6]\nidx ==> [1, 3, 5]\n```",
      "inputs": [
        {
          "description": "1-D. Values to keep.",
          "name": "x",
          "type": 0
        },
        {
          "description": "1-D. Values to remove.",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D. Values present in `x` but not in `y`.",
          "name": "out",
          "type": 0
        },
        {
          "description": "1-D. Positions of `x` values preserved in `out`.",
          "name": "idx",
          "type": 0
        }
      ],
      "summary": "Computes the difference between two lists of numbers or strings."
    }
  },
  {
    "name": "LoadAndRemapMatrix",
    "schema": {
      "attributes": [
        {
          "description": "Number of rows (length of the 1st dimension) in the output matrix.",
          "name": "num_rows",
          "type": "int"
        },
        {
          "description": "Number of columns (length of the 2nd dimension) in the output matrix.",
          "name": "num_cols",
          "type": "int"
        },
        {
          "description": "The maximum number of rows to load from the checkpoint at\nonce. If less than or equal to 0, the entire matrix will be loaded into\nmemory. Setting this arg trades increased disk reads for lower memory usage.",
          "name": "max_rows_in_memory",
          "type": "int"
        }
      ],
      "description": "at `ckpt_path` and potentially reorders its rows and columns using the\nspecified remappings.\n\nMost users should use one of the wrapper initializers (such as\n`tf.contrib.framework.load_and_remap_matrix_initializer`) instead of this\nfunction directly.\n\nThe remappings are 1-D tensors with the following properties:\n\n* `row_remapping` must have exactly `num_rows` entries. Row `i` of the output\n  matrix will be initialized from the row corresponding to index\n  `row_remapping[i]` in the old `Tensor` from the checkpoint.\n* `col_remapping` must have either 0 entries (indicating that no column\n  reordering is needed) or `num_cols` entries. If specified, column `j` of the\n  output matrix will be initialized from the column corresponding to index\n  `col_remapping[j]` in the old `Tensor` from the checkpoint.\n* A value of -1 in either of the remappings signifies a \"missing\" entry. In that\n  case, values from the `initializing_values` tensor will be used to fill that\n  missing row or column. If `row_remapping` has `r` missing entries and\n  `col_remapping` has `c` missing entries, then the following condition must be\n  true:\n\n`(r * num_cols) + (c * num_rows) - (r * c) == len(initializing_values)`\n\nThe remapping tensors can be generated using the GenerateVocabRemapping op.\n\nAs an example, with row_remapping = [1, 0, -1], col_remapping = [0, 2, -1],\ninitializing_values = [0.5, -0.5, 0.25, -0.25, 42], and w(i, j) representing\nthe value from row i, column j of the old tensor in the checkpoint, the output\nmatrix will look like the following:\n\n[[w(1, 0),  w(1, 2),  0.5],\n [w(0, 0),  w(0, 2), -0.5],\n [0.25,    -0.25,      42]]",
      "inputs": [
        {
          "description": "Path to the TensorFlow checkpoint (version 2, `TensorBundle`) from\nwhich the old matrix `Tensor` will be loaded.",
          "name": "ckpt_path",
          "type": 7
        },
        {
          "description": "Name of the 2-D `Tensor` to load from checkpoint.",
          "name": "old_tensor_name",
          "type": 7
        },
        {
          "description": "An int `Tensor` of row remappings (generally created by\n`generate_vocab_remapping`).  Even if no row remapping is needed, this must\nstill be an index-valued Tensor (e.g. [0, 1, 2, ...]), or a shifted\nindex-valued `Tensor` (e.g. [8, 9, 10, ...], for partitioned `Variables`).",
          "name": "row_remapping",
          "type": 9
        },
        {
          "description": "An int `Tensor` of column remappings (generally created by\n`generate_vocab_remapping`).  May be a size-0 `Tensor` if only row remapping\nis to be done (e.g. column ordering is the same).",
          "name": "col_remapping",
          "type": 9
        },
        {
          "description": "A float `Tensor` containing  values to fill in for cells\nin the output matrix that are not loaded from the checkpoint. Length must be\nexactly the same as the number of missing / new cells.",
          "name": "initializing_values",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Output matrix containing existing values loaded from the\ncheckpoint, and with any missing values filled in from initializing_values.",
          "name": "output_matrix",
          "type": 1
        }
      ],
      "summary": "Loads a 2-D (matrix) `Tensor` with name `old_tensor_name` from the checkpoint"
    }
  },
  {
    "name": "Log",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = \\log_e x\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes natural logarithm of x element-wise."
    }
  },
  {
    "name": "Log1p",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = \\log_e (1 + x)\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes natural logarithm of (1 + x) element-wise."
    }
  },
  {
    "name": "LogMatrixDeterminant",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "one or more square matrices.\n\nThe input is a tensor of shape `[N, M, M]` whose inner-most 2 dimensions\nform square matrices. The outputs are two tensors containing the signs and\nabsolute values of the log determinants for all N input submatrices\n`[..., :, :]` such that the determinant = sign*exp(log_abs_determinant).\nThe log_abs_determinant is computed as det(P)*sum(log(diag(LU))) where LU\nis the LU decomposition of the input and P is the corresponding\npermutation matrix.",
      "inputs": [
        {
          "description": "Shape is `[N, M, M]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The signs of the log determinants of the inputs. Shape is `[N]`.",
          "name": "sign",
          "type": 0
        },
        {
          "description": "The logs of the absolute values of the determinants\nof the N input matrices.  Shape is `[N]`.",
          "name": "log_abs_determinant",
          "type": 0
        }
      ],
      "summary": "Computes the sign and the log of the absolute value of the determinant of"
    }
  },
  {
    "name": "LogSoftmax",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each batch `i` and class `j` we have\n\n    logsoftmax[i, j] = logits[i, j] - log(sum(exp(logits[i])))",
      "inputs": [
        {
          "description": "2-D with shape `[batch_size, num_classes]`.",
          "name": "logits",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `logits`.",
          "name": "logsoftmax",
          "type": 0
        }
      ],
      "summary": "Computes log softmax activations."
    }
  },
  {
    "name": "LogUniformCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "name": "range_max",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a log-uniform distribution."
    }
  },
  {
    "name": "LogicalAnd",
    "schema": {
      "description": "*NOTE*: `LogicalAnd` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 10
        },
        {
          "description": "",
          "name": "y",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of x AND y element-wise."
    }
  },
  {
    "name": "LogicalNot",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of NOT x element-wise."
    }
  },
  {
    "name": "LogicalOr",
    "schema": {
      "description": "*NOTE*: `LogicalOr` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 10
        },
        {
          "description": "",
          "name": "y",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of x OR y element-wise."
    }
  },
  {
    "name": "LookupTableExport",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tkeys",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tvalues",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Vector of all keys present in the table.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Tensor of all values in the table. Indexed in parallel with `keys`.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Outputs all keys and values in the table."
    }
  },
  {
    "name": "LookupTableExportV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tkeys",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tvalues",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Vector of all keys present in the table.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Tensor of all values in the table. Indexed in parallel with `keys`.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Outputs all keys and values in the table."
    }
  },
  {
    "name": "LookupTableFind",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tin",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "",
          "name": "default_value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Looks up keys in a table, outputs the corresponding values."
    }
  },
  {
    "name": "LookupTableFindV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tin",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must of the same type as the keys of the table.\nThe output `values` is of the type of the table values.\n\nThe scalar `default_value` is the value output for keys not present in the\ntable. It must also be of the same type as the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "",
          "name": "default_value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `keys`.  Values found in the table, or `default_values`\nfor missing keys.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Looks up keys in a table, outputs the corresponding values."
    }
  },
  {
    "name": "LookupTableImport",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tin",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Replaces the contents of the table with the specified keys and values."
    }
  },
  {
    "name": "LookupTableImportV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tin",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Replaces the contents of the table with the specified keys and values."
    }
  },
  {
    "name": "LookupTableInsert",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tin",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 7
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Updates the table to associates keys with values."
    }
  },
  {
    "name": "LookupTableInsertV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tin",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "The tensor `keys` must be of the same type as the keys of the table.\nThe tensor `values` must be of the type of the table values.",
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        },
        {
          "description": "Any shape.  Keys to look up.",
          "name": "keys",
          "type": 0
        },
        {
          "description": "Values to associate with keys.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Updates the table to associates keys with values."
    }
  },
  {
    "name": "LookupTableSize",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Scalar that contains number of elements in the table.",
          "name": "size",
          "type": 9
        }
      ],
      "summary": "Computes the number of elements in the given table."
    }
  },
  {
    "name": "LookupTableSizeV2",
    "schema": {
      "inputs": [
        {
          "description": "Handle to the table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "Scalar that contains number of elements in the table.",
          "name": "size",
          "type": 9
        }
      ],
      "summary": "Computes the number of elements in the given table."
    }
  },
  {
    "name": "LoopCond",
    "schema": {
      "description": "This operator represents the loop termination condition used by the\n\"pivot\" switches of a loop.",
      "inputs": [
        {
          "description": "A boolean scalar, representing the branch predicate of the Switch op.",
          "name": "input",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `input`.",
          "name": "output",
          "type": 10
        }
      ],
      "summary": "Forwards the input to the output."
    }
  },
  {
    "name": "MakeIterator",
    "schema": {
      "description": "This operation may be executed multiple times. Each execution will reset the\niterator in `iterator` to the first element of `dataset`.",
      "inputs": [
        {
          "description": "",
          "name": "dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "iterator",
          "type": 20
        }
      ],
      "summary": "Makes a new iterator from the given `dataset` and stores it in `iterator`."
    }
  },
  {
    "name": "MapAndBatchDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "batches `batch_size` of them.\n\nUnlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `batch_size * num_parallel_batches` copies of `f` in parallel.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch. It determines the number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A scalar representing the number of batches to create in\nparallel. Processing multiple batches in parallel benefits workloads prone to\nstragglers.",
          "name": "num_parallel_batches",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset` and then"
    }
  },
  {
    "name": "MapClear",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "summary": "Op removes all elements in the underlying container."
    }
  },
  {
    "name": "MapDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "MapIncompleteSize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of incomplete elements in the underlying container."
    }
  },
  {
    "name": "MapPeek",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "underlying container does not contain this key\nthis op will block until it does.",
      "inputs": [
        {
          "description": "",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op peeks at the values at the specified key.  If the"
    }
  },
  {
    "name": "MapSize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of elements in the underlying container."
    }
  },
  {
    "name": "MapStage",
    "schema": {
      "attributes": [
        {
          "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "fake_dtypes",
          "type": "list(type)"
        },
        {
          "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "It is necessary to match this name to the matching Unstage Op.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "int64",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Stage (key, values) in the underlying container which behaves like a hashtable."
    }
  },
  {
    "name": "MapUnstage",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "from the underlying container.   If the underlying container\ndoes not contain this key, the op will block until it does.",
      "inputs": [
        {
          "description": "",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op removes and returns the values associated with the key"
    }
  },
  {
    "name": "MapUnstageNoKey",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "from the underlying container.   If the underlying container\ndoes not contain elements, the op will block until it does.",
      "inputs": [
        {
          "description": "",
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op removes and returns a random (key, value)"
    }
  },
  {
    "name": "MatMul",
    "schema": {
      "attributes": [
        {
          "description": "If true, \"a\" is transposed before multiplication.",
          "name": "transpose_a",
          "type": "bool"
        },
        {
          "description": "If true, \"b\" is transposed before multiplication.",
          "name": "transpose_b",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The inputs must be two-dimensional matrices and the inner dimension of\n\"a\" (after being transposed if transpose_a is true) must match the\nouter dimension of \"b\" (after being transposed if transposed_b is\ntrue).\n\n*Note*: The default kernel implementation for MatMul on GPUs uses\ncublas.",
      "inputs": [
        {
          "description": "",
          "name": "a",
          "type": 0
        },
        {
          "description": "",
          "name": "b",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "product",
          "type": 0
        }
      ],
      "summary": "Multiply the matrix \"a\" by the matrix \"b\"."
    }
  },
  {
    "name": "MatchingFiles",
    "schema": {
      "description": "Note that this routine only supports wildcard characters in the\nbasename portion of the pattern, not in the directory portion.",
      "inputs": [
        {
          "description": "Shell wildcard pattern(s). Scalar or vector of type string.",
          "name": "pattern",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A vector of matching filenames.",
          "name": "filenames",
          "type": 7
        }
      ],
      "summary": "Returns the set of files matching one or more glob patterns."
    }
  },
  {
    "name": "MatrixBandPart",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "to zero.\n\nThe `band` part is computed as follows:\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor with the same shape where\n\n`band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n\nThe indicator function\n\n`in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower)) &&\n                 (num_upper < 0 || (n-m) <= num_upper)`.\n\nFor example:\n\n```\n# if 'input' is [[ 0,  1,  2, 3]\n                 [-1,  0,  1, 2]\n                 [-2, -1,  0, 1]\n                 [-3, -2, -1, 0]],\n\ntf.matrix_band_part(input, 1, -1) ==> [[ 0,  1,  2, 3]\n                                       [-1,  0,  1, 2]\n                                       [ 0, -1,  0, 1]\n                                       [ 0,  0, -1, 0]],\n\ntf.matrix_band_part(input, 2, 1) ==> [[ 0,  1,  0, 0]\n                                      [-1,  0,  1, 0]\n                                      [-2, -1,  0, 1]\n                                      [ 0, -2, -1, 0]]\n```\n\nUseful special cases:\n\n```\n tf.matrix_band_part(input, 0, -1) ==> Upper triangular part.\n tf.matrix_band_part(input, -1, 0) ==> Lower triangular part.\n tf.matrix_band_part(input, 0, 0) ==> Diagonal.\n```",
      "inputs": [
        {
          "description": "Rank `k` tensor.",
          "name": "input",
          "type": 0
        },
        {
          "description": "0-D tensor. Number of subdiagonals to keep. If negative, keep entire\nlower triangle.",
          "name": "num_lower",
          "type": 9
        },
        {
          "description": "0-D tensor. Number of superdiagonals to keep. If negative, keep\nentire upper triangle.",
          "name": "num_upper",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Rank `k` tensor of the same shape as input. The extracted banded tensor.",
          "name": "band",
          "type": 0
        }
      ],
      "summary": "Copy a tensor setting everything outside a central band in each innermost matrix"
    }
  },
  {
    "name": "MatrixDeterminant",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor containing the determinants\nfor all input submatrices `[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[...]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the determinant of one or more square matrices."
    }
  },
  {
    "name": "MatrixDiag",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a `diagonal`, this operation returns a tensor with the `diagonal` and\neverything else padded with zeros. The diagonal is computed as follows:\n\nAssume `diagonal` has `k` dimensions `[I, J, K, ..., N]`, then the output is a\ntensor of rank `k+1` with dimensions [I, J, K, ..., N, N]` where:\n\n`output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]`.\n\nFor example:\n\n```\n# 'diagonal' is [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nand diagonal.shape = (2, 4)\n\ntf.matrix_diag(diagonal) ==> [[[1, 0, 0, 0]\n                                     [0, 2, 0, 0]\n                                     [0, 0, 3, 0]\n                                     [0, 0, 0, 4]],\n                                    [[5, 0, 0, 0]\n                                     [0, 6, 0, 0]\n                                     [0, 0, 7, 0]\n                                     [0, 0, 0, 8]]]\n\nwhich has shape (2, 4, 4)\n```",
      "inputs": [
        {
          "description": "Rank `k`, where `k >= 1`.",
          "name": "diagonal",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Rank `k+1`, with `output.shape = diagonal.shape + [diagonal.shape[-1]]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns a batched diagonal tensor with a given batched diagonal values."
    }
  },
  {
    "name": "MatrixDiagPart",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor with the `diagonal` part\nof the batched `input`. The `diagonal` part is computed as follows:\n\nAssume `input` has `k` dimensions `[I, J, K, ..., M, N]`, then the output is a\ntensor of rank `k - 1` with dimensions `[I, J, K, ..., min(M, N)]` where:\n\n`diagonal[i, j, k, ..., n] = input[i, j, k, ..., n, n]`.\n\nThe input must be at least a matrix.\n\nFor example:\n\n```\n# 'input' is [[[1, 0, 0, 0]\n               [0, 2, 0, 0]\n               [0, 0, 3, 0]\n               [0, 0, 0, 4]],\n              [[5, 0, 0, 0]\n               [0, 6, 0, 0]\n               [0, 0, 7, 0]\n               [0, 0, 0, 8]]]\n\nand input.shape = (2, 4, 4)\n\ntf.matrix_diag_part(input) ==> [[1, 2, 3, 4], [5, 6, 7, 8]]\n\nwhich has shape (2, 4)\n```",
      "inputs": [
        {
          "description": "Rank `k` tensor where `k >= 2`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The extracted diagonal(s) having shape\n`diagonal.shape = input.shape[:-2] + [min(input.shape[-2:])]`.",
          "name": "diagonal",
          "type": 0
        }
      ],
      "summary": "Returns the batched diagonal part of a batched tensor."
    }
  },
  {
    "name": "MatrixExponential",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "exp(A) = \\sum_{n=0}^\\infty A^n/n!\n\nThe exponential is computed using a combination of the scaling and squaring\nmethod and the Pade approximation. Details can be founds in:\nNicholas J. Higham, \"The scaling and squaring method for the matrix exponential\nrevisited,\" SIAM J. Matrix Anal. Applic., 26:1179-1193, 2005.\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the exponential for all input submatrices `[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.\n\n@compatibility(scipy)\nEquivalent to scipy.linalg.expm\n@end_compatibility",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the matrix exponential of one or more square matrices:"
    }
  },
  {
    "name": "MatrixInverse",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "adjoints (conjugate transposes).\n\nThe input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. The output is a tensor of the same shape as the input\ncontaining the inverse for all input submatrices `[..., :, :]`.\n\nThe op uses LU decomposition with partial pivoting to compute the inverses.\n\nIf a matrix is not invertible there is no guarantee what the op does. It\nmay detect the condition and raise an exception or it may simply return a\ngarbage result.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, M]`.\n\n@compatibility(numpy)\nEquivalent to np.linalg.inv\n@end_compatibility",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the inverse of one or more square invertible matrices or their"
    }
  },
  {
    "name": "MatrixSetDiag",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given `input` and `diagonal`, this operation returns a tensor with the\nsame shape and values as `input`, except for the main diagonal of the\ninnermost matrices.  These will be overwritten by the values in `diagonal`.\n\nThe output is computed as follows:\n\nAssume `input` has `k+1` dimensions `[I, J, K, ..., M, N]` and `diagonal` has\n`k` dimensions `[I, J, K, ..., min(M, N)]`.  Then the output is a\ntensor of rank `k+1` with dimensions `[I, J, K, ..., M, N]` where:\n\n  * `output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]` for `m == n`.\n  * `output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]` for `m != n`.",
      "inputs": [
        {
          "description": "Rank `k+1`, where `k >= 1`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "Rank `k`, where `k >= 1`.",
          "name": "diagonal",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Rank `k+1`, with `output.shape = input.shape`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns a batched matrix tensor with new batched diagonal values."
    }
  },
  {
    "name": "MatrixSolve",
    "schema": {
      "attributes": [
        {
          "description": "Boolean indicating whether to solve with `matrix` or its (block-wise)\nadjoint.",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`Matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices. `Rhs` is a tensor of shape `[..., M, K]`. The `output` is\na tensor shape `[..., M, K]`.  If `adjoint` is `False` then each output matrix\nsatisfies `matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `True` then each output matrix satisfies\n`adjoint(matrix[..., :, :]) * output[..., :, :] = rhs[..., :, :]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "matrix",
          "type": 0
        },
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "rhs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Solves systems of linear equations."
    }
  },
  {
    "name": "MatrixSolveLs",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "fast",
          "type": "bool"
        }
      ],
      "description": "`matrix` is a tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform real or complex matrices of size `[M, N]`. `Rhs` is a tensor of the same\ntype as `matrix` and shape `[..., M, K]`.\nThe output is a tensor shape `[..., N, K]` where each output matrix solves\neach of the equations\n`matrix[..., :, :]` * `output[..., :, :]` = `rhs[..., :, :]`\nin the least squares sense.\n\nWe use the following notation for (complex) matrix and right-hand sides\nin the batch:\n\n`matrix`=\\\\(A \\in \\mathbb{C}^{m \\times n}\\\\),\n`rhs`=\\\\(B  \\in \\mathbb{C}^{m \\times k}\\\\),\n`output`=\\\\(X  \\in \\mathbb{C}^{n \\times k}\\\\),\n`l2_regularizer`=\\\\(\\lambda \\in \\mathbb{R}\\\\).\n\nIf `fast` is `True`, then the solution is computed by solving the normal\nequations using Cholesky decomposition. Specifically, if \\\\(m \\ge n\\\\) then\n\\\\(X = (A^H A + \\lambda I)^{-1} A^H B\\\\), which solves the least-squares\nproblem \\\\(X = \\mathrm{argmin}_{Z \\in \\Re^{n \\times k} } ||A Z - B||_F^2 +\n\\lambda ||Z||_F^2\\\\). If \\\\(m \\lt n\\\\) then `output` is computed as\n\\\\(X = A^H (A A^H + \\lambda I)^{-1} B\\\\), which (for \\\\(\\lambda = 0\\\\)) is the\nminimum-norm solution to the under-determined linear system, i.e.\n\\\\(X = \\mathrm{argmin}_{Z \\in \\mathbb{C}^{n \\times k} } ||Z||_F^2 \\\\),\nsubject to \\\\(A Z = B\\\\). Notice that the fast path is only numerically stable\nwhen \\\\(A\\\\) is numerically full rank and has a condition number\n\\\\(\\mathrm{cond}(A) \\lt \\frac{1}{\\sqrt{\\epsilon_{mach} } }\\\\) or\\\\(\\lambda\\\\) is\nsufficiently large.\n\nIf `fast` is `False` an algorithm based on the numerically robust complete\northogonal decomposition is used. This computes the minimum-norm\nleast-squares solution, even when \\\\(A\\\\) is rank deficient. This path is\ntypically 6-7 times slower than the fast path. If `fast` is `False` then\n`l2_regularizer` is ignored.",
      "inputs": [
        {
          "description": "Shape is `[..., M, N]`.",
          "name": "matrix",
          "type": 0
        },
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "rhs",
          "type": 0
        },
        {
          "description": "Scalar tensor.\n\n@compatibility(numpy)\nEquivalent to np.linalg.lstsq\n@end_compatibility",
          "name": "l2_regularizer",
          "type": 2
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., N, K]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Solves one or more linear least-squares problems."
    }
  },
  {
    "name": "MatrixTriangularSolve",
    "schema": {
      "attributes": [
        {
          "description": "Boolean indicating whether the innermost matrices in `matrix` are\nlower or upper triangular.",
          "name": "lower",
          "type": "bool"
        },
        {
          "description": "Boolean indicating whether to solve with `matrix` or its (block-wise)\n         adjoint.\n\n@compatibility(numpy)\nEquivalent to np.linalg.triangular_solve\n@end_compatibility",
          "name": "adjoint",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "backsubstitution.\n\n`matrix` is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions form\nsquare matrices. If `lower` is `True` then the strictly upper triangular part\nof each inner-most matrix is assumed to be zero and not accessed.\nIf `lower` is False then the strictly lower triangular part of each inner-most\nmatrix is assumed to be zero and not accessed.\n`rhs` is a tensor of shape `[..., M, K]`.\n\nThe output is a tensor of shape `[..., M, K]`. If `adjoint` is\n`True` then the innermost matrices in `output` satisfy matrix equations\n`matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]`.\nIf `adjoint` is `False` then the strictly then the  innermost matrices in\n`output` satisfy matrix equations\n`adjoint(matrix[..., i, k]) * output[..., k, j] = rhs[..., i, j]`.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "matrix",
          "type": 0
        },
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "rhs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M, K]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Solves systems of linear equations with upper or lower triangular matrices by"
    }
  },
  {
    "name": "Max",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the maximum of elements across dimensions of a tensor."
    }
  },
  {
    "name": "MaxPool",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D input to pool over.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs max pooling on the input."
    }
  },
  {
    "name": "MaxPool3D",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Shape `[batch, depth, rows, cols, channels]` tensor to pool over.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs 3D max pooling on the input."
    }
  },
  {
    "name": "MaxPool3DGrad",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "TInput",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients of max pooling function."
    }
  },
  {
    "name": "MaxPool3DGradGrad",
    "schema": {
      "attributes": [
        {
          "description": "1-D tensor of length 5. The size of the window for each dimension of\nthe input tensor. Must have `ksize[0] = ksize[4] = 1`.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "1-D tensor of length 5. The stride of the sliding window for each\ndimension of `input`. Must have `strides[0] = strides[4] = 1`.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "The data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n    [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n    [batch, in_channels, in_depth, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "Output backprop of shape `[batch, depth, rows, cols, channels]`.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGrad",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "4-D.  Gradients w.r.t. the output of `max_pool`.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradGrad",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "4-D.  Gradients of gradients w.r.t. the input of `max_pool`.",
          "name": "grad",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradGradV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "4-D.  Gradients of gradients w.r.t. the input of `max_pool`.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": 3
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradGradWithArgmax",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "",
          "name": "Targmax",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input.",
          "name": "input",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\ninput of `max_pool`.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "The indices of the maximum values chosen for each output of `max_pool`.",
          "name": "argmax",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Gradients of gradients w.r.t. the input of `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes second-order gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input tensor.",
          "name": "orig_input",
          "type": 0
        },
        {
          "description": "The original output tensor.",
          "name": "orig_output",
          "type": 0
        },
        {
          "description": "4-D.  Gradients w.r.t. the output of `max_pool`.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": 3
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Gradients w.r.t. the input to `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolGradWithArgmax",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "",
          "name": "Targmax",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The original input.",
          "name": "input",
          "type": 0
        },
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Gradients w.r.t. the\noutput of `max_pool`.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "The indices of the maximum values chosen for each output of `max_pool`.",
          "name": "argmax",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Gradients w.r.t. the input of `max_pool`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients of the maxpooling function."
    }
  },
  {
    "name": "MaxPoolV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "Specify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n    [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n    [batch, in_channels, in_height, in_width].",
          "name": "data_format",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D input to pool over.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": 3
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Performs max pooling on the input."
    }
  },
  {
    "name": "MaxPoolWithArgmax",
    "schema": {
      "attributes": [
        {
          "description": "The size of the window for each dimension of the input tensor.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the\ninput tensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "",
          "name": "Targmax",
          "type": "type"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The indices in `argmax` are flattened, so that a maximum value at position\n`[b, y, x, c]` becomes flattened index\n`((b * height + y) * width + x) * channels + c`.\n\nThe indices returned are always in `[0, height) x [0, width)` before flattening,\neven if padding is involved and the mathematically correct answer is outside\n(either negative or too large).  This is a bug, but fixing it is difficult to do\nin a safe backwards compatible way, especially due to flattening.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.  Input to pool over.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The max pooled output tensor.",
          "name": "output",
          "type": 0
        },
        {
          "description": "4-D.  The flattened indices of the max values chosen for each output.",
          "name": "argmax",
          "type": 0
        }
      ],
      "summary": "Performs max pooling on the input and outputs both max values and indices."
    }
  },
  {
    "name": "Maximum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Maximum` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns the max of x and y (i.e. x > y ? x : y) element-wise."
    }
  },
  {
    "name": "Mean",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the mean of elements across dimensions of a tensor."
    }
  },
  {
    "name": "Merge",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "description": "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor to become available to `output`, and sets\n`value_index` to its index in `inputs`.",
      "inputs": [
        {
          "description": "The input tensors, exactly one of which will become available.",
          "name": "inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Will be set to the available input tensor.",
          "name": "output",
          "type": 0
        },
        {
          "description": "The index of the chosen input tensor in `inputs`.",
          "name": "value_index",
          "type": 3
        }
      ],
      "summary": "Forwards the value of an available tensor from `inputs` to `output`."
    }
  },
  {
    "name": "MergeSummary",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "description": "This op creates a\n[`Summary`](https://www.tensorflow.org/code/tensorflow/core/framework/summary.proto)\nprotocol buffer that contains the union of all the values in the input\nsummaries.\n\nWhen the Op is run, it reports an `InvalidArgument` error if multiple values\nin the summaries to merge use the same tag.",
      "inputs": [
        {
          "description": "Can be of any shape.  Each must contain serialized `Summary` protocol\nbuffers.",
          "name": "inputs",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "Scalar. Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Merges summaries."
    }
  },
  {
    "name": "MergeV2Checkpoints",
    "schema": {
      "attributes": [
        {
          "description": "see above.",
          "name": "delete_old_dirs",
          "type": "bool"
        }
      ],
      "description": "result is one logical checkpoint, with one physical metadata file and renamed\ndata files.\n\nIntended for \"grouping\" multiple checkpoints in a sharded checkpoint setup.\n\nIf delete_old_dirs is true, attempts to delete recursively the dirname of each\npath in the input checkpoint_prefixes.  This is useful when those paths are non\nuser-facing temporary locations.",
      "inputs": [
        {
          "description": "prefixes of V2 checkpoints to merge.",
          "name": "checkpoint_prefixes",
          "type": 7
        },
        {
          "description": "scalar.  The desired final prefix.  Allowed to be the same\nas one of the checkpoint_prefixes.",
          "name": "destination_prefix",
          "type": 7
        }
      ],
      "summary": "V2 format specific: merges the metadata files of sharded checkpoints.  The"
    }
  },
  {
    "name": "Mfcc",
    "schema": {
      "attributes": [
        {
          "description": "The highest frequency to use when calculating the\nceptstrum.",
          "name": "upper_frequency_limit",
          "type": "float"
        },
        {
          "description": "The lowest frequency to use when calculating the\nceptstrum.",
          "name": "lower_frequency_limit",
          "type": "float"
        },
        {
          "description": "Resolution of the Mel bank used internally.",
          "name": "filterbank_channel_count",
          "type": "int"
        },
        {
          "description": "How many output channels to produce per time slice.",
          "name": "dct_coefficient_count",
          "type": "int"
        }
      ],
      "description": "Mel Frequency Cepstral Coefficients are a way of representing audio data that's\nbeen effective as an input feature for machine learning. They are created by\ntaking the spectrum of a spectrogram (a 'cepstrum'), and discarding some of the\nhigher frequencies that are less significant to the human ear. They have a long\nhistory in the speech recognition world, and https://en.wikipedia.org/wiki/Mel-frequency_cepstrum\nis a good resource to learn more.",
      "inputs": [
        {
          "description": "Typically produced by the Spectrogram op, with magnitude_squared\nset to true.",
          "name": "spectrogram",
          "type": 1
        },
        {
          "description": "How many samples per second the source audio used.",
          "name": "sample_rate",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 1
        }
      ],
      "summary": "Transforms a spectrogram into a form that's useful for speech recognition."
    }
  },
  {
    "name": "Min",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the minimum of elements across dimensions of a tensor."
    }
  },
  {
    "name": "Minimum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Minimum` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns the min of x and y (i.e. x < y ? x : y) element-wise."
    }
  },
  {
    "name": "MirrorPad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tpaddings",
          "type": "type"
        },
        {
          "description": "Either `REFLECT` or `SYMMETRIC`. In reflect mode the padded regions\ndo not include the borders, while in symmetric mode the padded regions\ndo include the borders. For example, if `input` is `[1, 2, 3]` and `paddings`\nis `[0, 2]`, then the output is `[1, 2, 3, 2, 1]` in reflect mode, and\nit is `[1, 2, 3, 3, 2]` in symmetric mode.",
          "name": "mode",
          "type": "string"
        }
      ],
      "description": "This operation pads a `input` with mirrored values according to the `paddings`\nyou specify. `paddings` is an integer tensor with shape `[n, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many values to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many values to add after the contents of `input`\nin that dimension. Both `paddings[D, 0]` and `paddings[D, 1]` must be no greater\nthan `input.dim_size(D)` (or `input.dim_size(D) - 1`) if `copy_border` is true\n(if false, respectively).\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 2, 3], [4, 5, 6]].\n# 'paddings' is [[1, 1]], [2, 2]].\n# 'mode' is SYMMETRIC.\n# rank of 't' is 2.\npad(t, paddings) ==> [[2, 1, 1, 2, 3, 3, 2]\n                      [2, 1, 1, 2, 3, 3, 2]\n                      [5, 4, 4, 5, 6, 6, 5]\n                      [5, 4, 4, 5, 6, 6, 5]]\n```",
      "inputs": [
        {
          "description": "The input tensor to be padded.",
          "name": "input",
          "type": 0
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The padded tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Pads a tensor with mirrored values."
    }
  },
  {
    "name": "MirrorPadGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tpaddings",
          "type": "type"
        },
        {
          "description": "The mode used in the `MirrorPad` op.",
          "name": "mode",
          "type": "string"
        }
      ],
      "description": "This operation folds the padded areas of `input` by `MirrorPad` according to the\n`paddings` you specify. `paddings` must be the same as `paddings` argument\ngiven to the corresponding `MirrorPad` op.\n\nThe folded size of each dimension D of the output is:\n\n`input.dim_size(D) - paddings(D, 0) - paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 2, 3], [4, 5, 6], [7, 8, 9]].\n# 'paddings' is [[0, 1]], [0, 1]].\n# 'mode' is SYMMETRIC.\n# rank of 't' is 2.\npad(t, paddings) ==> [[ 1,  5]\n                      [11, 28]]\n```",
      "inputs": [
        {
          "description": "The input tensor to be folded.",
          "name": "input",
          "type": 0
        },
        {
          "description": "A two-column matrix specifying the padding sizes. The number of\nrows must be the same as the rank of `input`.",
          "name": "paddings",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The folded tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Gradient op for `MirrorPad` op. This op folds a mirror-padded tensor."
    }
  },
  {
    "name": "Mod",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "the result here is consistent with a truncating divide. E.g.\n`tf.truncatediv(x, y) * y + truncate_mod(x, y) = x`.\n\n*NOTE*: `Mod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns element-wise remainder of division. This emulates C semantics in that"
    }
  },
  {
    "name": "Mul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Mul` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x * y element-wise."
    }
  },
  {
    "name": "Multinomial",
    "schema": {
      "attributes": [
        {
          "description": "If either seed or seed2 is set to be non-zero, the internal random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "2-D Tensor with shape `[batch_size, num_classes]`.  Each slice `[i, :]`\nrepresents the unnormalized log probabilities for all classes.",
          "name": "logits",
          "type": 0
        },
        {
          "description": "0-D.  Number of independent samples to draw for each row slice.",
          "name": "num_samples",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "2-D Tensor with shape `[batch_size, num_samples]`.  Each slice `[i, :]`\ncontains the drawn class labels with range `[0, num_classes)`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Draws samples from a multinomial distribution."
    }
  },
  {
    "name": "MutableDenseHashTable",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "description": "The shape of each value.",
          "name": "value_shape",
          "type": "shape"
        },
        {
          "description": "The initial number of hash table buckets. Must be a power\nto 2.",
          "name": "initial_num_buckets",
          "type": "int"
        },
        {
          "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
          "name": "max_load_factor",
          "type": "float"
        }
      ],
      "description": "It uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThis op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "inputs": [
        {
          "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
          "name": "empty_key",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates an empty hash table that uses tensors as the backing store."
    }
  },
  {
    "name": "MutableDenseHashTableV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "description": "The shape of each value.",
          "name": "value_shape",
          "type": "shape"
        },
        {
          "description": "The initial number of hash table buckets. Must be a power\nto 2.",
          "name": "initial_num_buckets",
          "type": "int"
        },
        {
          "description": "The maximum ratio between number of entries and number of\nbuckets before growing the table. Must be between 0 and 1.",
          "name": "max_load_factor",
          "type": "float"
        }
      ],
      "description": "It uses \"open addressing\" with quadratic reprobing to resolve\ncollisions.\n\nThis op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "inputs": [
        {
          "description": "The key used to represent empty key buckets internally. Must not\nbe used in insert or lookup operations.",
          "name": "empty_key",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates an empty hash table that uses tensors as the backing store."
    }
  },
  {
    "name": "MutableHashTable",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutableHashTableOfTensors",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "value_shape",
          "type": "shape"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a vector. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 7
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutableHashTableOfTensorsV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "value_shape",
          "type": "shape"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a vector. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "MutableHashTableV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this table is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this table is shared under the given name across\nmultiple sessions.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "If true and shared_name is empty, the table is shared\nusing the node name.",
          "name": "use_node_name_sharing",
          "type": "bool"
        },
        {
          "description": "Type of the table keys.",
          "name": "key_dtype",
          "type": "type"
        },
        {
          "description": "Type of the table values.",
          "name": "value_dtype",
          "type": "type"
        }
      ],
      "description": "This op creates a mutable hash table, specifying the type of its keys and\nvalues. Each value must be a scalar. Data can be inserted into the table using\nthe insert operations. It does not support the initialization operation.",
      "outputs": [
        {
          "description": "Handle to a table.",
          "name": "table_handle",
          "type": 20
        }
      ],
      "summary": "Creates an empty hash table."
    }
  },
  {
    "name": "Neg",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = -x\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes numerical negative value element-wise."
    }
  },
  {
    "name": "NegTrain",
    "schema": {
      "attributes": [
        {
          "description": "Count of words in the vocabulary.",
          "name": "vocab_count",
          "type": "list(int)"
        },
        {
          "description": "Number of negative samples per example.",
          "name": "num_negative_samples",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "input word embedding.",
          "name": "w_in",
          "type": 1
        },
        {
          "description": "output word embedding.",
          "name": "w_out",
          "type": 1
        },
        {
          "description": "A vector of word ids.",
          "name": "examples",
          "type": 3
        },
        {
          "description": "A vector of word ids.",
          "name": "labels",
          "type": 3
        },
        {
          "description": "",
          "name": "lr",
          "type": 1
        }
      ],
      "summary": "Training via negative sampling."
    }
  },
  {
    "name": "NextIteration",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be made available to the next iteration.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Makes its input available to the next iteration."
    }
  },
  {
    "name": "NoOp",
    "schema": {
      "summary": "Does nothing. Only useful as a placeholder for control edges."
    }
  },
  {
    "name": "NonMaxSuppression",
    "schema": {
      "attributes": [
        {
          "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU.",
          "name": "iou_threshold",
          "type": "float"
        }
      ],
      "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system.  Note that this\nalgorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n  selected_indices = tf.image.non_max_suppression(\n      boxes, scores, max_output_size, iou_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "type": 1
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NonMaxSuppressionV2",
    "schema": {
      "description": "pruning away boxes that have high intersection-over-union (IOU) overlap\nwith previously selected boxes.  Bounding boxes are supplied as\n[y1, x1, y2, x2], where (y1, x1) and (y2, x2) are the coordinates of any\ndiagonal pair of box corners and the coordinates can be provided as normalized\n(i.e., lying in the interval [0, 1]) or absolute.  Note that this algorithm\nis agnostic to where the origin is in the coordinate system.  Note that this\nalgorithm is invariant to orthogonal transformations and translations\nof the coordinate system; thus translating or reflections of the coordinate\nsystem result in the same boxes being selected by the algorithm.\n\nThe output of this operation is a set of integers indexing into the input\ncollection of bounding boxes representing the selected boxes.  The bounding\nbox coordinates corresponding to the selected indices can then be obtained\nusing the `tf.gather operation`.  For example:\n\n  selected_indices = tf.image.non_max_suppression_v2(\n      boxes, scores, max_output_size, iou_threshold)\n  selected_boxes = tf.gather(boxes, selected_indices)",
      "inputs": [
        {
          "description": "A 2-D float tensor of shape `[num_boxes, 4]`.",
          "name": "boxes",
          "type": 1
        },
        {
          "description": "A 1-D float tensor of shape `[num_boxes]` representing a single\nscore corresponding to each box (each row of boxes).",
          "name": "scores",
          "type": 1
        },
        {
          "description": "A scalar integer tensor representing the maximum number of\nboxes to be selected by non max suppression.",
          "name": "max_output_size",
          "type": 3
        },
        {
          "description": "A 0-D float tensor representing the threshold for deciding whether\nboxes overlap too much with respect to IOU.",
          "name": "iou_threshold",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 1-D integer tensor of shape `[M]` representing the selected\nindices from the boxes tensor, where `M <= max_output_size`.",
          "name": "selected_indices",
          "type": 3
        }
      ],
      "summary": "Greedily selects a subset of bounding boxes in descending order of score,"
    }
  },
  {
    "name": "NotEqual",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `NotEqual` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 10
        }
      ],
      "summary": "Returns the truth value of (x != y) element-wise."
    }
  },
  {
    "name": "NthElement",
    "schema": {
      "attributes": [
        {
          "description": "When set to True, find the nth-largest value in the vector and vice\nversa.",
          "name": "reverse",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the input is a vector (rank-1), finds the entries which is the nth-smallest\nvalue in the vector and outputs their values as scalar tensor.\n\nFor matrices (resp. higher rank input), computes the entries which is the\nnth-smallest value in each row (resp. vector along the last dimension). Thus,\n\n    values.shape = input.shape[:-1]",
      "inputs": [
        {
          "description": "1-D or higher with last dimension at least `n+1`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "0-D. Position of sorted vector to select along the last dimension (along\neach row for matrices). Valid range of n is `[0, input.shape[:-1])`",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The `n`-th order statistic along each last dimensional slice.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Finds values of the `n`-th order statistic for the last dimension."
    }
  },
  {
    "name": "OneHot",
    "schema": {
      "attributes": [
        {
          "description": "The axis to fill (default: -1, a new inner-most axis).",
          "name": "axis",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "TI",
          "type": "type"
        }
      ],
      "description": "The locations represented by indices in `indices` take value `on_value`,\nwhile all other locations take value `off_value`.\n\nIf the input `indices` is rank `N`, the output will have rank `N+1`,\nThe new axis is created at dimension `axis` (default: the new axis is\nappended at the end).\n\nIf `indices` is a scalar the output shape will be a vector of length `depth`.\n\nIf `indices` is a vector of length `features`, the output shape will be:\n```\n  features x depth if axis == -1\n  depth x features if axis == 0\n```\n\nIf `indices` is a matrix (batch) with shape `[batch, features]`,\nthe output shape will be:\n```\n  batch x features x depth if axis == -1\n  batch x depth x features if axis == 1\n  depth x batch x features if axis == 0\n```\n\n\nExamples\n=========\n\nSuppose that\n\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 5.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[4 x 3]`:\n\n    ```output =\n      [5.0 0.0 0.0]  // one_hot(0)\n      [0.0 0.0 5.0]  // one_hot(2)\n      [0.0 0.0 0.0]  // one_hot(-1)\n      [0.0 5.0 0.0]  // one_hot(1)\n    ```\n\nSuppose that\n\n```\n  indices = [0, 2, -1, 1]\n  depth = 3\n  on_value = 0.0\n  off_value = 3.0\n  axis = 0\n```\n\nThen output is `[3 x 4]`:\n\n    ```output =\n      [0.0 3.0 3.0 3.0]\n      [3.0 3.0 3.0 0.0]\n      [3.0 3.0 3.0 3.0]\n      [3.0 0.0 3.0 3.0]\n    //  ^                one_hot(0)\n    //      ^            one_hot(2)\n    //          ^        one_hot(-1)\n    //              ^    one_hot(1)\n    ```\nSuppose that\n\n```\n  indices = [[0, 2], [1, -1]]\n  depth = 3\n  on_value = 1.0\n  off_value = 0.0\n  axis = -1\n```\n\nThen output is `[2 x 2 x 3]`:\n\n    ```output =\n      [\n        [1.0, 0.0, 0.0]  // one_hot(0)\n        [0.0, 0.0, 1.0]  // one_hot(2)\n      ][\n        [0.0, 1.0, 0.0]  // one_hot(1)\n        [0.0, 0.0, 0.0]  // one_hot(-1)\n      ]```",
      "inputs": [
        {
          "description": "A tensor of indices.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A scalar defining the depth of the one hot dimension.",
          "name": "depth",
          "type": 3
        },
        {
          "description": "A scalar defining the value to fill in output when `indices[j] = i`.",
          "name": "on_value",
          "type": 0
        },
        {
          "description": "A scalar defining the value to fill in output when `indices[j] != i`.",
          "name": "off_value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The one-hot tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns a one-hot tensor."
    }
  },
  {
    "name": "OneShotIterator",
    "schema": {
      "attributes": [
        {
          "description": "A function of type `() -> DT_VARIANT`, where the returned\nDT_VARIANT is a dataset.",
          "name": "dataset_factory",
          "type": "func"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "A one-shot iterator bundles the logic for defining the dataset and\nthe state of the iterator in a single op, which allows simple input\npipelines to be defined without an additional initialization\n(\"MakeIterator\") step.\n\nOne-shot iterators have the following limitations:\n\n* They do not support parameterization: all logic for creating the underlying\n  dataset must be bundled in the `dataset_factory` function.\n* They are not resettable. Once a one-shot iterator reaches the end of its\n  underlying dataset, subsequent \"IteratorGetNext\" operations on that\n  iterator will always produce an `OutOfRange` error.\n\nFor greater flexibility, use \"Iterator\" and \"MakeIterator\" to define\nan iterator using an arbitrary subgraph, which may capture tensors\n(including fed values) as parameters, and which may be reset multiple\ntimes by rerunning \"MakeIterator\".",
      "outputs": [
        {
          "description": "A handle to the iterator that can be passed to an \"IteratorGetNext\"\nop.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Makes a \"one-shot\" iterator that can be iterated only once."
    }
  },
  {
    "name": "OnesLike",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "a tensor of type T.",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "a tensor of the same shape and type as x but filled with ones.",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Returns a tensor of ones with the same shape and type as x."
    }
  },
  {
    "name": "OrderedMapClear",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "summary": "Op removes all elements in the underlying container."
    }
  },
  {
    "name": "OrderedMapIncompleteSize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of incomplete elements in the underlying container."
    }
  },
  {
    "name": "OrderedMapPeek",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "underlying container does not contain this key\nthis op will block until it does.   This Op is optimized for\nperformance.",
      "inputs": [
        {
          "description": "",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op peeks at the values at the specified key.  If the"
    }
  },
  {
    "name": "OrderedMapSize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of elements in the underlying container."
    }
  },
  {
    "name": "OrderedMapStage",
    "schema": {
      "attributes": [
        {
          "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "fake_dtypes",
          "type": "list(type)"
        },
        {
          "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "It is necessary to match this name to the matching Unstage Op.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "associative container.   Elements are ordered by key.",
      "inputs": [
        {
          "description": "int64",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Stage (key, values) in the underlying container which behaves like a ordered"
    }
  },
  {
    "name": "OrderedMapUnstage",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "from the underlying container.   If the underlying container\ndoes not contain this key, the op will block until it does.",
      "inputs": [
        {
          "description": "",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op removes and returns the values associated with the key"
    }
  },
  {
    "name": "OrderedMapUnstageNoKey",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "key from the underlying container.   If the underlying container\ndoes not contain elements, the op will block until it does.",
      "inputs": [
        {
          "description": "",
          "name": "indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "key",
          "type": 9
        },
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op removes and returns the (key, value) element with the smallest"
    }
  },
  {
    "name": "Pack",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Dimension along which to pack.  Negative values wrap around, so the\nvalid range is `[-(R+1), R+1)`.",
          "name": "axis",
          "type": "int"
        }
      ],
      "description": "Packs the `N` tensors in `values` into a tensor with rank one higher than each\ntensor in `values`, by packing them along the `axis` dimension.\nGiven a list of tensors of shape `(A, B, C)`;\n\nif `axis == 0` then the `output` tensor will have the shape `(N, A, B, C)`.\nif `axis == 1` then the `output` tensor will have the shape `(A, N, B, C)`.\nEtc.\n\nFor example:\n\n```\n# 'x' is [1, 4]\n# 'y' is [2, 5]\n# 'z' is [3, 6]\npack([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\npack([x, y, z], axis=1) => [[1, 2, 3], [4, 5, 6]]\n```\n\nThis is the opposite of `unpack`.",
      "inputs": [
        {
          "description": "Must be of same shape and type.",
          "name": "values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The packed tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Packs a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor."
    }
  },
  {
    "name": "Pad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tpaddings",
          "type": "type"
        }
      ],
      "description": "This operation pads a `input` with zeros according to the `paddings` you\nspecify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is the\nrank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many zeros to add before the contents of `input` in that dimension, and\n`paddings[D, 1]` indicates how many zeros to add after the contents of `input`\nin that dimension.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 1], [2, 2]]\n# 'paddings' is [[1, 1], [2, 2]]\n# rank of 't' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "paddings",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Pads a tensor with zeros."
    }
  },
  {
    "name": "PadV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tpaddings",
          "type": "type"
        }
      ],
      "description": "This operation pads `input` according to the `paddings` and `constant_values`\nyou specify. `paddings` is an integer tensor with shape `[Dn, 2]`, where n is\nthe rank of `input`. For each dimension D of `input`, `paddings[D, 0]` indicates\nhow many padding values to add before the contents of `input` in that dimension,\nand `paddings[D, 1]` indicates how many padding values to add after the contents\nof `input` in that dimension. `constant_values` is a scalar tensor of the same\ntype as `input` that indicates the value to use for padding `input`.\n\nThe padded size of each dimension D of the output is:\n\n`paddings(D, 0) + input.dim_size(D) + paddings(D, 1)`\n\nFor example:\n\n```\n# 't' is [[1, 1], [2, 2]]\n# 'paddings' is [[1, 1], [2, 2]]\n# 'constant_values' is 0\n# rank of 't' is 2\npad(t, paddings) ==> [[0, 0, 0, 0, 0, 0]\n                      [0, 0, 1, 1, 0, 0]\n                      [0, 0, 2, 2, 0, 0]\n                      [0, 0, 0, 0, 0, 0]]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "paddings",
          "type": 0
        },
        {
          "description": "",
          "name": "constant_values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Pads a tensor."
    }
  },
  {
    "name": "PaddedBatchDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements to accumulate in a\nbatch.",
          "name": "batch_size",
          "type": 9
        },
        {
          "description": "A list of int64 tensors representing the desired padded shapes\nof the corresponding output components. These shapes may be partially\nspecified, using `-1` to indicate that a particular dimension should be\npadded to the maximum size of all batch elements.",
          "name": "padded_shapes",
          "type": 9
        },
        {
          "description": "A list of scalars containing the padding value to use for\neach of the outputs.",
          "name": "padding_values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that batches and pads `batch_size` elements from the input."
    }
  },
  {
    "name": "PaddingFIFOQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "PaddingFIFOQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types.\nShapes of fixed rank but variable size are allowed by setting\nany shape dimension to -1.  In this case, the inputs' shape may vary along\nthe given dimension, and DequeueMany will pad the given dimension with\nzeros up to the maximum shape of all elements in the given batch.\nIf the length of this attr is 0, different queue elements may have\ndifferent ranks and shapes, but only one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Variable-size shapes are allowed by setting the corresponding shape dimensions\nto 0 in the shape attr.  In this case DequeueMany will pad up to the maximum\nsize of any given element in the minibatch.  See below for details.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that produces elements in first-in first-out order."
    }
  },
  {
    "name": "ParallelConcat",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "the final shape of the result; should be equal to the shapes of any input\nbut with the number of input values in the first dimension.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "The input tensors are all required to have size 1 in the first dimension.\n\nFor example:\n\n```\n# 'x' is [[1, 4]]\n# 'y' is [[2, 5]]\n# 'z' is [[3, 6]]\nparallel_concat([x, y, z]) => [[1, 4], [2, 5], [3, 6]]  # Pack along first dim.\n```\n\nThe difference between concat and parallel_concat is that concat requires all\nof the inputs be computed before the operation will begin but doesn't require\nthat the input shapes be known during graph construction.  Parallel concat\nwill copy pieces of the input into the output as they become available, in\nsome situations this can provide a performance benefit.",
      "inputs": [
        {
          "description": "Tensors to be concatenated. All must have size 1 in the first dimension\nand same shape.",
          "name": "values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The concatenated tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Concatenates a list of `N` tensors along the first dimension."
    }
  },
  {
    "name": "ParallelDynamicStitch",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Builds a merged tensor such that\n\n```python\n    merged[indices[m][i, ..., j], ...] = data[m][i, ..., j, ...]\n```\n\nFor example, if each `indices[m]` is scalar or vector, we have\n\n```python\n    # Scalar indices:\n    merged[indices[m], ...] = data[m][...]\n\n    # Vector indices:\n    merged[indices[m][i], ...] = data[m][i, ...]\n```\n\nEach `data[i].shape` must start with the corresponding `indices[i].shape`,\nand the rest of `data[i].shape` must be constant w.r.t. `i`.  That is, we\nmust have `data[i].shape = indices[i].shape + constant`.  In terms of this\n`constant`, the output shape is\n\n    merged.shape = [max(indices)] + constant\n\nValues may be merged in parallel, so if an index appears in both `indices[m][i]`\nand `indices[n][j]`, the result may be invalid. This differs from the normal\nDynamicStitch operator that defines the behavior in that case.\n\nFor example:\n\n```python\n    indices[0] = 6\n    indices[1] = [4, 1]\n    indices[2] = [[5, 2], [0, 3]]\n    data[0] = [61, 62]\n    data[1] = [[41, 42], [11, 12]]\n    data[2] = [[[51, 52], [21, 22]], [[1, 2], [31, 32]]]\n    merged = [[1, 2], [11, 12], [21, 22], [31, 32], [41, 42],\n              [51, 52], [61, 62]]\n```\n\nThis method can be used to merge partitions created by `dynamic_partition`\nas illustrated on the following example:\n\n```python\n    # Apply function (increments x_i) on elements for which a certain condition\n    # apply (x_i != -1 in this example).\n    x=tf.constant([0.1, -1., 5.2, 4.3, -1., 7.4])\n    condition_mask=tf.not_equal(x,tf.constant(-1.))\n    partitioned_data = tf.dynamic_partition(\n        x, tf.cast(condition_mask, tf.int32) , 2)\n    partitioned_data[1] = partitioned_data[1] + 1.0\n    condition_indices = tf.dynamic_partition(\n        tf.range(tf.shape(x)[0]), tf.cast(condition_mask, tf.int32) , 2)\n    x = tf.dynamic_stitch(condition_indices, partitioned_data)\n    # Here x=[1.1, -1., 6.2, 5.3, -1, 8.4], the -1. values remain\n    # unchanged.\n```\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/DynamicStitch.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "merged",
          "type": 0
        }
      ],
      "summary": "Interleave the values from the `data` tensors into a single tensor."
    }
  },
  {
    "name": "ParallelInterleaveDataset",
    "schema": {
      "attributes": [
        {
          "description": "A function mapping elements of `input_dataset`, concatenated with\n`other_arguments`, to a Dataset variant that contains elements matching\n`output_types` and `output_shapes`.",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "The resulting dataset is similar to the `InterleaveDataset`, with the exception\nthat if retrieving the next value from a dataset would cause the requester to\nblock, it will skip that input dataset. This dataset is especially useful\nwhen loading data from a variable-latency datastores (e.g. HDFS, GCS), as it\nallows the training step to proceed so long as some data is available.\n\n!! WARNING !! This dataset is not deterministic!",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        },
        {
          "description": "",
          "name": "cycle_length",
          "type": 9
        },
        {
          "description": "",
          "name": "block_length",
          "type": 9
        },
        {
          "description": "",
          "name": "sloppy",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "ParallelMapDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "description": "Unlike a \"MapDataset\", which applies `f` sequentially, this dataset invokes up\nto `num_parallel_calls` copies of `f` in parallel.",
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        },
        {
          "description": "The number of concurrent invocations of `f` that process\nelements from `input_dataset` in parallel.",
          "name": "num_parallel_calls",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that applies `f` to the outputs of `input_dataset`."
    }
  },
  {
    "name": "ParameterizedTruncatedNormal",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "scalar which applies to the entire output, or a vector of length shape[0] which\nstores the parameters for each batch.",
      "inputs": [
        {
          "description": "The shape of the output tensor. Batches are indexed by the 0th dimension.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "The mean parameter of each batch.",
          "name": "means",
          "type": 0
        },
        {
          "description": "The standard deviation parameter of each batch. Must be greater than 0.",
          "name": "stdevs",
          "type": 0
        },
        {
          "description": "The minimum cutoff. May be -infinity.",
          "name": "minvals",
          "type": 0
        },
        {
          "description": "The maximum cutoff. May be +infinity, and must be more than the minval\nfor each batch.",
          "name": "maxvals",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A matrix of shape num_batches x samples_per_batch, filled with random\ntruncated normal values using the parameters for each row.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random values from a normal distribution. The parameters may each be a"
    }
  },
  {
    "name": "ParseExample",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Nsparse",
          "type": "int"
        },
        {
          "description": "",
          "name": "Ndense",
          "type": "int"
        },
        {
          "description": "A list of Nsparse types; the data types of data in each Feature\ngiven in sparse_keys.\nCurrently the ParseExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "name": "sparse_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Tdense",
          "type": "list(type)"
        },
        {
          "description": "A list of Ndense shapes; the shapes of data in each Feature\ngiven in dense_keys.\nThe number of elements in the Feature corresponding to dense_key[j]\nmust always equal dense_shapes[j].NumEntries().\nIf dense_shapes[j] == (D0, D1, ..., DN) then the shape of output\nTensor dense_values[j] will be (|serialized|, D0, D1, ..., DN):\nThe dense outputs are just the inputs row-stacked by batch.\nThis works for dense_shapes[j] = (-1, D1, ..., DN).  In this case\nthe shape of the output Tensor dense_values[j] will be\n(|serialized|, M, D1, .., DN), where M is the maximum number of blocks\nof elements of length D1 * .... * DN, across all minibatch entries\nin the input.  Any minibatch entry with less than M blocks of elements of\nlength D1 * ... * DN will be padded with the corresponding default_value\nscalar element along the second dimension.",
          "name": "dense_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A vector containing a batch of binary serialized Example protos.",
          "name": "serialized",
          "type": 7
        },
        {
          "description": "A vector containing the names of the serialized protos.\nMay contain, for example, table key (descriptive) names for the\ncorresponding serialized protos.  These are purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty vector if no names are available.\nIf non-empty, this vector must be the same length as \"serialized\".",
          "name": "names",
          "type": 7
        },
        {
          "description": "A list of Nsparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with sparse values.",
          "name": "sparse_keys",
          "type": 7
        },
        {
          "description": "A list of Ndense string Tensors (scalars).\nThe keys expected in the Examples' features associated with dense values.",
          "name": "dense_keys",
          "type": 7
        },
        {
          "description": "A list of Ndense Tensors (some may be empty).\ndense_defaults[j] provides default values\nwhen the example's feature_map lacks dense_key[j].  If an empty Tensor is\nprovided for dense_defaults[j], then the Feature dense_keys[j] is required.\nThe input type is inferred from dense_defaults[j], even when it's empty.\nIf dense_defaults[j] is not empty, and dense_shapes[j] is fully defined,\nthen the shape of dense_defaults[j] must match that of dense_shapes[j].\nIf dense_shapes[j] has an undefined major dimension (variable strides dense\nfeature), dense_defaults[j] must contain a single element:\nthe padding element.",
          "name": "dense_defaults",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "",
          "name": "sparse_shapes",
          "type": 9
        },
        {
          "description": "",
          "name": "dense_values",
          "type": 0
        }
      ],
      "summary": "Transforms a vector of brain.Example protos (as strings) into typed tensors."
    }
  },
  {
    "name": "ParseSingleSequenceExample",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Ncontext_sparse",
          "type": "int"
        },
        {
          "description": "",
          "name": "Ncontext_dense",
          "type": "int"
        },
        {
          "description": "",
          "name": "Nfeature_list_sparse",
          "type": "int"
        },
        {
          "description": "",
          "name": "Nfeature_list_dense",
          "type": "int"
        },
        {
          "description": "A list of Ncontext_sparse types; the data types of data in\neach context Feature given in context_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "name": "context_sparse_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Tcontext_dense",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "feature_list_dense_types",
          "type": "list(type)"
        },
        {
          "description": "A list of Ncontext_dense shapes; the shapes of data in\neach context Feature given in context_dense_keys.\nThe number of elements in the Feature corresponding to context_dense_key[j]\nmust always equal context_dense_shapes[j].NumEntries().\nThe shape of context_dense_values[j] will match context_dense_shapes[j].",
          "name": "context_dense_shapes",
          "type": "list(shape)"
        },
        {
          "description": "A list of Nfeature_list_sparse types; the data types\nof data in each FeatureList given in feature_list_sparse_keys.\nCurrently the ParseSingleSequenceExample supports DT_FLOAT (FloatList),\nDT_INT64 (Int64List), and DT_STRING (BytesList).",
          "name": "feature_list_sparse_types",
          "type": "list(type)"
        },
        {
          "description": "A list of Nfeature_list_dense shapes; the shapes of\ndata in each FeatureList given in feature_list_dense_keys.\nThe shape of each Feature in the FeatureList corresponding to\nfeature_list_dense_key[j] must always equal\nfeature_list_dense_shapes[j].NumEntries().",
          "name": "feature_list_dense_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "A scalar containing a binary serialized SequenceExample proto.",
          "name": "serialized",
          "type": 7
        },
        {
          "description": "A vector listing the\nFeatureList keys which may be missing from the SequenceExample.  If the\nassociated FeatureList is missing, it is treated as empty.  By default,\nany FeatureList not listed in this vector must exist in the SequenceExample.",
          "name": "feature_list_dense_missing_assumed_empty",
          "type": 7
        },
        {
          "description": "A list of Ncontext_sparse string Tensors (scalars).\nThe keys expected in the Examples' features associated with context_sparse\nvalues.",
          "name": "context_sparse_keys",
          "type": 7
        },
        {
          "description": "A list of Ncontext_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' context features associated with\ndense values.",
          "name": "context_dense_keys",
          "type": 7
        },
        {
          "description": "A list of Nfeature_list_sparse string Tensors\n(scalars).  The keys expected in the FeatureLists associated with sparse\nvalues.",
          "name": "feature_list_sparse_keys",
          "type": 7
        },
        {
          "description": "A list of Nfeature_list_dense string Tensors (scalars).\nThe keys expected in the SequenceExamples' feature_lists associated\nwith lists of dense values.",
          "name": "feature_list_dense_keys",
          "type": 7
        },
        {
          "description": "A list of Ncontext_dense Tensors (some may be empty).\ncontext_dense_defaults[j] provides default values\nwhen the SequenceExample's context map lacks context_dense_key[j].\nIf an empty Tensor is provided for context_dense_defaults[j],\nthen the Feature context_dense_keys[j] is required.\nThe input type is inferred from context_dense_defaults[j], even when it's\nempty.  If context_dense_defaults[j] is not empty, its shape must match\ncontext_dense_shapes[j].",
          "name": "context_dense_defaults",
          "type": 0
        },
        {
          "description": "A scalar containing the name of the serialized proto.\nMay contain, for example, table key (descriptive) name for the\ncorresponding serialized proto.  This is purely useful for debugging\npurposes, and the presence of values here has no effect on the output.\nMay also be an empty scalar if no name is available.",
          "name": "debug_name",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "context_sparse_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "context_sparse_values",
          "type": 0
        },
        {
          "description": "",
          "name": "context_sparse_shapes",
          "type": 9
        },
        {
          "description": "",
          "name": "context_dense_values",
          "type": 0
        },
        {
          "description": "",
          "name": "feature_list_sparse_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "feature_list_sparse_values",
          "type": 0
        },
        {
          "description": "",
          "name": "feature_list_sparse_shapes",
          "type": 9
        },
        {
          "description": "",
          "name": "feature_list_dense_values",
          "type": 0
        }
      ],
      "summary": "Transforms a scalar brain.SequenceExample proto (as strings) into typed tensors."
    }
  },
  {
    "name": "ParseTensor",
    "schema": {
      "attributes": [
        {
          "description": "The type of the serialized tensor.  The provided type must match the\ntype of the serialized tensor and no implicit conversion will take place.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A scalar string containing a serialized TensorProto proto.",
          "name": "serialized",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of type `out_type`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Transforms a serialized tensorflow.TensorProto proto into a Tensor."
    }
  },
  {
    "name": "Placeholder",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "(Optional) The shape of the tensor. If the shape has 0 dimensions, the\nshape is unconstrained.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime.",
      "outputs": [
        {
          "description": "A placeholder tensor that must be replaced using the feed mechanism.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "A placeholder op for a value that will be fed into the computation."
    }
  },
  {
    "name": "PlaceholderV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The shape of the tensor. The shape can be any partially-specified\nshape.  To be unconstrained, pass in a shape with unknown rank.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "description": "N.B. This operation will fail with an error if it is executed. It is\nintended as a way to represent a value that will always be fed, and to\nprovide attrs that enable the fed value to be checked at runtime.",
      "outputs": [
        {
          "description": "A placeholder tensor that must be replaced using the feed mechanism.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "A placeholder op for a value that will be fed into the computation."
    }
  },
  {
    "name": "PlaceholderWithDefault",
    "schema": {
      "attributes": [
        {
          "description": "The type of elements in the tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The (possibly partial) shape of the tensor.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "The default value to produce when `output` is not fed.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A placeholder tensor that defaults to `input` if it is not fed.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "A placeholder op that passes through `input` when its output is not fed."
    }
  },
  {
    "name": "Polygamma",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The polygamma function is defined as:\n\n\n\\\\(\\psi^{(n)}(x) = \\frac{d^n}{dx^n} \\psi(x)\\\\)\n\nwhere \\\\(\\psi(x)\\\\) is the digamma function.",
      "inputs": [
        {
          "description": "",
          "name": "a",
          "type": 0
        },
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Compute the polygamma function \\\\(\\psi^{(n)}(x)\\\\)."
    }
  },
  {
    "name": "PopulationCount",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each entry in `x`, calculates the number of `1` (on) bits in the binary\nrepresentation of that entry.\n\n**NOTE**: It is more efficient to first `tf.bitcast` your tensors into\n`int32` or `int64` and perform the bitcount on the result, than to feed in\n8- or 16-bit inputs and then aggregate the resulting counts.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 4
        }
      ],
      "summary": "Computes element-wise population count (a.k.a. popcount, bitsum, bitcount)."
    }
  },
  {
    "name": "Pow",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a tensor `x` and a tensor `y`, this operation computes \\\\(x^y\\\\) for\ncorresponding elements in `x` and `y`. For example:\n\n```\n# tensor 'x' is [[2, 2]], [3, 3]]\n# tensor 'y' is [[8, 16], [2, 3]]\ntf.pow(x, y) ==> [[256, 65536], [9, 27]]\n```",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the power of one value to another."
    }
  },
  {
    "name": "PrefetchDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "The maximum number of elements to buffer in an iterator over\nthis dataset.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that asynchronously prefetches elements from `input_dataset`."
    }
  },
  {
    "name": "PreventGradient",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Will be printed in the error when anyone tries to differentiate\nthis operation.",
          "name": "message",
          "type": "string"
        }
      ],
      "description": "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, the TensorFlow gradient system\nwill return an error when trying to lookup the gradient of this op,\nbecause no gradient must ever be registered for this function.  This\nop exists to prevent subtle bugs from silently returning unimplemented\ngradients in some corner cases.",
      "inputs": [
        {
          "description": "any tensor.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "the same input tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "An identity op that triggers an error if a gradient is requested."
    }
  },
  {
    "name": "Print",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "U",
          "type": "list(type)"
        },
        {
          "description": "A string, prefix of the error message.",
          "name": "message",
          "type": "string"
        },
        {
          "description": "Only log `first_n` number of times. -1 disables logging.",
          "name": "first_n",
          "type": "int"
        },
        {
          "description": "Only print this many entries of each tensor.",
          "name": "summarize",
          "type": "int"
        }
      ],
      "description": "Passes `input` through to `output` and prints `data` when evaluating.",
      "inputs": [
        {
          "description": "The tensor passed to `output`",
          "name": "input",
          "type": 0
        },
        {
          "description": "A list of tensors to print out when op is evaluated.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= The unmodified `input` tensor",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Prints a list of tensors."
    }
  },
  {
    "name": "PriorityQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Note that the PriorityQueue requires the first component of any element\nto be a scalar int64, in addition to the other elements declared by\ncomponent_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue\nand DequeueMany) on a PriorityQueue will all require (resp. output) one extra\nentry in their input (resp. output) lists.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that produces elements sorted by the first component value."
    }
  },
  {
    "name": "PriorityQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Note that the PriorityQueue requires the first component of any element\nto be a scalar int64, in addition to the other elements declared by\ncomponent_types.  Therefore calls to Enqueue and EnqueueMany (resp. Dequeue\nand DequeueMany) on a PriorityQueue will all require (resp. output) one extra\nentry in their input (resp. output) lists.",
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that produces elements sorted by the first component value."
    }
  },
  {
    "name": "Prod",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the product of elements across dimensions of a tensor."
    }
  },
  {
    "name": "PyFunc",
    "schema": {
      "attributes": [
        {
          "description": "A token representing a registered python function in this address space.",
          "name": "token",
          "type": "string"
        },
        {
          "description": "Data types of the inputs to the op.",
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "Data types of the outputs from the op.\nThe length of the list specifies the number of outputs.",
          "name": "Tout",
          "type": "list(type)"
        }
      ],
      "description": "This operation is considered stateful. For a stateless version, see\nPyFuncStateless.",
      "inputs": [
        {
          "description": "List of Tensors that will provide input to the Op.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The outputs from the Op.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Invokes a python function to compute func(input)->output."
    }
  },
  {
    "name": "PyFuncStateless",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "token",
          "type": "string"
        },
        {
          "description": "",
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "list(type)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "A stateless version of PyFunc."
    }
  },
  {
    "name": "Qr",
    "schema": {
      "attributes": [
        {
          "description": "If true, compute full-sized `q` and `r`. If false\n(the default), compute only the leading `P` columns of `q`.",
          "name": "full_matrices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes the QR decomposition of each inner matrix in `tensor` such that\n`tensor[..., :, :] = q[..., :, :] * r[..., :,:])`\n\n```python\n# a is a tensor.\n# q is a tensor of orthonormal matrices.\n# r is a tensor of upper triangular matrices.\nq, r = qr(a)\nq_full, r_full = qr(a, full_matrices=True)\n```",
      "inputs": [
        {
          "description": "A tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Orthonormal basis for range of `a`. If `full_matrices` is `False` then\nshape is `[..., M, P]`; if `full_matrices` is `True` then shape is\n`[..., M, M]`.",
          "name": "q",
          "type": 0
        },
        {
          "description": "Triangular factor. If `full_matrices` is `False` then shape is\n`[..., P, N]`. If `full_matrices` is `True` then shape is `[..., M, N]`.",
          "name": "r",
          "type": 0
        }
      ],
      "summary": "Computes the QR decompositions of one or more matrices."
    }
  },
  {
    "name": "QuantizeAndDequantize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "signed_input",
          "type": "bool"
        },
        {
          "description": "",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "",
          "name": "range_given",
          "type": "bool"
        },
        {
          "description": "",
          "name": "input_min",
          "type": "float"
        },
        {
          "description": "",
          "name": "input_max",
          "type": "float"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Use QuantizeAndDequantizeV2 instead."
    }
  },
  {
    "name": "QuantizeAndDequantizeV2",
    "schema": {
      "attributes": [
        {
          "description": "If the quantization is signed or unsigned.",
          "name": "signed_input",
          "type": "bool"
        },
        {
          "description": "The bitwidth of the quantization.",
          "name": "num_bits",
          "type": "int"
        },
        {
          "description": "If the range is given or should be computed from the tensor.",
          "name": "range_given",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op simulates the precision loss from the quantized forward pass by:\n1. Quantizing the tensor to fixed point numbers, which should match the target\n   quantization method when it is used in inference.\n2. Dequantizing it back to floating point numbers for the following ops, most\n   likely matmul.\n\nThere are different ways to quantize. This version does not use the full range\nof the output type, choosing to elide the lowest possible value for symmetry\n(e.g., output range is -127 to 127, not -128 to 127 for signed 8 bit\nquantization), so that 0.0 maps to 0.\n\nTo perform this op, we first find the range of values in our tensor. The range\nwe use is always centered on 0, so we find m such that\n\n1. m = max(abs(input_min), abs(input_max)) if range_given is true,\n2. m = max(abs(min_elem(input)), abs(max_elem(input))) otherwise.\n\nOur input tensor range is then [-m, m].\n\nNext, we choose our fixed-point quantization buckets, [min_fixed, max_fixed].\nIf signed_input is true, this is\n\n  [min_fixed, max_fixed ] =\n      [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1].\n\nOtherwise, if signed_input is false, the fixed-point range is\n\n  [min_fixed, max_fixed] = [0, (1 << num_bits) - 1].\n\nFrom this we compute our scaling factor, s:\n\n  s = (max_fixed - min_fixed) / (2 * m).\n\nNow we can quantize and dequantize the elements of our tensor.  An element e\nis transformed into e':\n\n  e' = (e * s).round_to_nearest() / s.\n\nNote that we have a different number of buckets in the signed vs. unsigned\ncases.  For example, if num_bits == 8, we get 254 buckets in the signed case\nvs. 255 in the unsigned case.\n\nFor example, suppose num_bits = 8 and m = 1.  Then\n\n  [min_fixed, max_fixed] = [-127, 127], and\n  s = (127 + 127) / 2 = 127.\n\nGiven the vector {-1, -0.5, 0, 0.3}, this is quantized to\n{-127, -63, 0, 38}, and dequantized to {-1, -63.0/127, 0, 38.0/127}.",
      "inputs": [
        {
          "description": "Tensor to quantize and then dequantize.",
          "name": "input",
          "type": 0
        },
        {
          "description": "If range_given, this is the min of the range, otherwise this input\nwill be ignored.",
          "name": "input_min",
          "type": 0
        },
        {
          "description": "If range_given, this is the max of the range, otherwise this input\nwill be ignored.",
          "name": "input_max",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Quantizes then dequantizes a tensor."
    }
  },
  {
    "name": "QuantizeAndDequantizeV3",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "signed_input",
          "type": "bool"
        },
        {
          "description": "",
          "name": "range_given",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This is almost identical to QuantizeAndDequantizeV2, except that num_bits is a\ntensor, so its value can change during training.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "input_min",
          "type": 0
        },
        {
          "description": "",
          "name": "input_max",
          "type": 0
        },
        {
          "description": "",
          "name": "num_bits",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Quantizes then dequantizes a tensor."
    }
  },
  {
    "name": "QuantizeDownAndShrinkRange",
    "schema": {
      "attributes": [
        {
          "description": "The type of the input.",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "The type of the output. Should be a lower bit depth than Tinput.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "actual distribution of the values to maximize the usage of the lower bit depth\nand adjusting the output min and max ranges accordingly.\n\n[input_min, input_max] are scalar floats that specify the range for the float\ninterpretation of the 'input' data. For example, if input_min is -1.0f and\ninput_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\nvalue in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.\n\nThis operator tries to squeeze as much precision as possible into an output with\na lower bit depth by calculating the actual min and max values found in the\ndata. For example, maybe that quint16 input has no values lower than 16,384 and\nnone higher than 49,152. That means only half the range is actually needed, all\nthe float interpretations are between -0.5f and 0.5f, so if we want to compress\nthe data into a quint8 output, we can use that range rather than the theoretical\n-1.0f to 1.0f that is suggested by the input min and max.\n\nIn practice, this is most useful for taking output from operations like\nQuantizedMatMul that can produce higher bit-depth outputs than their inputs and\nmay have large potential output ranges, but in practice have a distribution of\ninput values that only uses a small fraction of the possible range. By feeding\nthat output into this operator, we can reduce it from 32 bits down to 8 with\nminimal loss of accuracy.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "The float value that the minimum quantized input value represents.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized input value represents.",
          "name": "input_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "The float value that the minimum quantized output value represents.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized output value represents.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Convert the quantized 'input' tensor into a lower-precision 'output', using the"
    }
  },
  {
    "name": "QuantizeV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "mode",
          "type": "string"
        },
        {
          "description": "",
          "name": "round_mode",
          "type": "string"
        }
      ],
      "description": "[min_range, max_range] are scalar floats that specify the range for\nthe 'input' data. The 'mode' attribute controls exactly which calculations are\nused to convert the float values to their quantized equivalents.  The\n'round_mode' attribute controls which rounding tie-breaking algorithm is used\nwhen rounding float values to their quantized equivalents.\n\nIn 'MIN_COMBINED' mode, each value of the tensor will undergo the following:\n\n```\nout[i] = (in[i] - min_range) * range(T) / (max_range - min_range)\nif T == qint8, out[i] -= (range(T) + 1) / 2.0\n```\nhere `range(T) = numeric_limits<T>::max() - numeric_limits<T>::min()`\n\n*MIN_COMBINED Mode Example*\n\nAssume the input is type float and has a possible range of [0.0, 6.0] and the\noutput type is quint8 ([0, 255]). The min_range and max_range values should be\nspecified as 0.0 and 6.0. Quantizing from float to quint8 will multiply each\nvalue of the input by 255/6 and cast to quint8.\n\nIf the output type was qint8 ([-128, 127]), the operation will additionally\nsubtract each value by 128 prior to casting, so that the range of values aligns\nwith the range of qint8.\n\nIf the mode is 'MIN_FIRST', then this approach is used:\n\n```\nnum_discrete_values = 1 << (# of bits in T)\nrange_adjust = num_discrete_values / (num_discrete_values - 1)\nrange = (range_max - range_min) * range_adjust\nrange_scale = num_discrete_values / range\nquantized = round(input * range_scale) - round(range_min * range_scale) +\n  numeric_limits<T>::min()\nquantized = max(quantized, numeric_limits<T>::min())\nquantized = min(quantized, numeric_limits<T>::max())\n```\n\nThe biggest difference between this and MIN_COMBINED is that the minimum range\nis rounded first, before it's subtracted from the rounded value. With\nMIN_COMBINED, a small bias is introduced where repeated iterations of quantizing\nand dequantizing will introduce a larger and larger error.\n\n*SCALED mode Example*\n\n`SCALED` mode matches the quantization approach used in\n`QuantizeAndDequantize{V2|V3}`.\n\nIf the mode is `SCALED`, we do not use the full range of the output type,\nchoosing to elide the lowest possible value for symmetry (e.g., output range is\n-127 to 127, not -128 to 127 for signed 8 bit quantization), so that 0.0 maps to\n0.\n\nWe first find the range of values in our tensor. The\nrange we use is always centered on 0, so we find m such that\n```c++\n  m = max(abs(input_min), abs(input_max))\n```\n\nOur input tensor range is then `[-m, m]`.\n\nNext, we choose our fixed-point quantization buckets, `[min_fixed, max_fixed]`.\nIf T is signed, this is\n```\n  num_bits = sizeof(T) * 8\n  [min_fixed, max_fixed] =\n      [-(1 << (num_bits - 1) - 1), (1 << (num_bits - 1)) - 1]\n```\n\nOtherwise, if T is unsigned, the fixed-point range is\n```\n  [min_fixed, max_fixed] = [0, (1 << num_bits) - 1]\n```\n\nFrom this we compute our scaling factor, s:\n```c++\n  s = (max_fixed - min_fixed) / (2 * m)\n```\n\nNow we can quantize the elements of our tensor:\n```c++\nresult = round(input * s)\n```\n\nOne thing to watch out for is that the operator may choose to adjust the\nrequested minimum and maximum values slightly during the quantization process,\nso you should always use the output ports as the range for further calculations.\nFor example, if the requested minimum and maximum values are close to equal,\nthey will be separated by a small epsilon value to prevent ill-formed quantized\nbuffers from being created. Otherwise, you can end up with buffers where all the\nquantized values map to the same float value, which causes problems for\noperations that have to perform further calculations on them.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 1
        },
        {
          "description": "The minimum scalar value possibly produced for the input.",
          "name": "min_range",
          "type": 1
        },
        {
          "description": "The maximum scalar value possibly produced for the input.",
          "name": "max_range",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The quantized data produced from the float input.",
          "name": "output",
          "type": 0
        },
        {
          "description": "The actual minimum scalar value used for the output.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The actual maximum scalar value used for the output.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Quantize the 'input' tensor of type float to 'output' tensor of type 'T'."
    }
  },
  {
    "name": "QuantizedAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T1",
          "type": "type"
        },
        {
          "description": "",
          "name": "T2",
          "type": "type"
        },
        {
          "description": "",
          "name": "Toutput",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized `x` value represents.",
          "name": "min_x",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `x` value represents.",
          "name": "max_x",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized `y` value represents.",
          "name": "min_y",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `y` value represents.",
          "name": "max_y",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_z",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.\n\n*NOTE*: `QuantizedAdd` supports limited forms of broadcasting. More about\nbroadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
          "name": "max_z",
          "type": 1
        }
      ],
      "summary": "Returns x + y element-wise, working on quantized buffers."
    }
  },
  {
    "name": "QuantizedAvgPool",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor.  The length must be 4 to match the number of dimensions of the input.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_output",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_output",
          "type": 1
        }
      ],
      "summary": "Produces the average pool of the input tensor for quantized types."
    }
  },
  {
    "name": "QuantizedBatchNormWithGlobalNormalization",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma.",
          "name": "scale_after_normalization",
          "type": "bool"
        }
      ],
      "description": "This op is deprecated and will be removed in the future. Prefer\n`tf.nn.batch_normalization`.",
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "t",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized input.",
          "name": "t_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized input.",
          "name": "t_max",
          "type": 1
        },
        {
          "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "m",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized mean.",
          "name": "m_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized mean.",
          "name": "m_max",
          "type": 1
        },
        {
          "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof.",
          "name": "v",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized variance.",
          "name": "v_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized variance.",
          "name": "v_max",
          "type": 1
        },
        {
          "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor.",
          "name": "beta",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized offset.",
          "name": "beta_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized offset.",
          "name": "beta_max",
          "type": 1
        },
        {
          "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor.",
          "name": "gamma",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized gamma.",
          "name": "gamma_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized gamma.",
          "name": "gamma_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "result",
          "type": 0
        },
        {
          "description": "",
          "name": "result_min",
          "type": 1
        },
        {
          "description": "",
          "name": "result_max",
          "type": 1
        }
      ],
      "summary": "Quantized Batch normalization."
    }
  },
  {
    "name": "QuantizedBiasAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T1",
          "type": "type"
        },
        {
          "description": "",
          "name": "T2",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "Broadcasts the values of bias on dimensions 0..N-2 of 'input'.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "A 1D bias Tensor with size matching the last dimension of 'input'.",
          "name": "bias",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized bias value represents.",
          "name": "min_bias",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized bias value represents.",
          "name": "max_bias",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_out",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_out",
          "type": 1
        }
      ],
      "summary": "Adds Tensor 'bias' to Tensor 'input' for Quantized types."
    }
  },
  {
    "name": "QuantizedConcat",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values)).",
          "name": "concat_dim",
          "type": 3
        },
        {
          "description": "The `N` Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except `concat_dim`.",
          "name": "values",
          "type": 0
        },
        {
          "description": "The minimum scalar values for each of the input tensors.",
          "name": "input_mins",
          "type": 1
        },
        {
          "description": "The maximum scalar values for each of the input tensors.",
          "name": "input_maxes",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the concatenation of values stacked along the\n`concat_dim` dimension.  This tensor's shape matches that of `values` except\nin `concat_dim` where it has the sum of the sizes.",
          "name": "output",
          "type": 0
        },
        {
          "description": "The float value that the minimum quantized output value represents.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized output value represents.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Concatenates quantized tensors along one dimension."
    }
  },
  {
    "name": "QuantizedConv2D",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tfilter",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "description": "The inputs are quantized tensors where the lowest value represents the real\nnumber of the associated minimum, and the highest represents the maximum.\nThis means that you can only interpret the quantized output in the same way, by\ntaking the returned minimum and maximum values into account.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "filter's input_depth dimension must match input's depth dimensions.",
          "name": "filter",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized filter value represents.",
          "name": "min_filter",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized filter value represents.",
          "name": "max_filter",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_output",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_output",
          "type": 1
        }
      ],
      "summary": "Computes a 2D convolution given quantized 4D input and filter tensors."
    }
  },
  {
    "name": "QuantizedInstanceNorm",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, `given_y_min` and `given_y_min`\nand `given_y_max` are used as the output range. Otherwise,\nthe implementation computes the output range.",
          "name": "output_range_given",
          "type": "bool"
        },
        {
          "description": "Output in `y_min` if `output_range_given` is True.",
          "name": "given_y_min",
          "type": "float"
        },
        {
          "description": "Output in `y_max` if `output_range_given` is True.",
          "name": "given_y_max",
          "type": "float"
        },
        {
          "description": "A small float number to avoid dividing by 0.",
          "name": "variance_epsilon",
          "type": "float"
        },
        {
          "description": "Minimum value of `y_max - y_min`",
          "name": "min_separation",
          "type": "float"
        }
      ],
      "inputs": [
        {
          "description": "A 4D input Tensor.",
          "name": "x",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized input.",
          "name": "x_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized input.",
          "name": "x_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A 4D Tensor.",
          "name": "y",
          "type": 0
        },
        {
          "description": "The value represented by the lowest quantized output.",
          "name": "y_min",
          "type": 1
        },
        {
          "description": "The value represented by the highest quantized output.",
          "name": "y_max",
          "type": 1
        }
      ],
      "summary": "Quantized Instance normalization."
    }
  },
  {
    "name": "QuantizedMatMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T1",
          "type": "type"
        },
        {
          "description": "",
          "name": "T2",
          "type": "type"
        },
        {
          "description": "",
          "name": "Toutput",
          "type": "type"
        },
        {
          "description": "If true, `a` is transposed before multiplication.",
          "name": "transpose_a",
          "type": "bool"
        },
        {
          "description": "If true, `b` is transposed before multiplication.",
          "name": "transpose_b",
          "type": "bool"
        },
        {
          "description": "The type of output produced by activation function\nfollowing this operation.",
          "name": "Tactivation",
          "type": "type"
        }
      ],
      "description": "The inputs must be two-dimensional matrices and the inner dimension of\n`a` (after being transposed if `transpose_a` is non-zero) must match the\nouter dimension of `b` (after being transposed if `transposed_b` is\nnon-zero).",
      "inputs": [
        {
          "description": "Must be a two-dimensional tensor.",
          "name": "a",
          "type": 0
        },
        {
          "description": "Must be a two-dimensional tensor.",
          "name": "b",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized `a` value represents.",
          "name": "min_a",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `a` value represents.",
          "name": "max_a",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized `b` value represents.",
          "name": "min_b",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `b` value represents.",
          "name": "max_b",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "out",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_out",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_out",
          "type": 1
        }
      ],
      "summary": "Perform a quantized matrix multiplication of  `a` by the matrix `b`."
    }
  },
  {
    "name": "QuantizedMaxPool",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input.",
          "name": "ksize",
          "type": "list(int)"
        },
        {
          "description": "The stride of the sliding window for each dimension of the input\ntensor. The length must be 4 to match the number of dimensions of the input.",
          "name": "strides",
          "type": "list(int)"
        },
        {
          "description": "The type of padding algorithm to use.",
          "name": "padding",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized input value represents.",
          "name": "min_input",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized input value represents.",
          "name": "max_input",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_output",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.",
          "name": "max_output",
          "type": 1
        }
      ],
      "summary": "Produces the max pool of the input tensor for quantized types."
    }
  },
  {
    "name": "QuantizedMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T1",
          "type": "type"
        },
        {
          "description": "",
          "name": "T2",
          "type": "type"
        },
        {
          "description": "",
          "name": "Toutput",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized `x` value represents.",
          "name": "min_x",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `x` value represents.",
          "name": "max_x",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized `y` value represents.",
          "name": "min_y",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized `y` value represents.",
          "name": "max_y",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized output value represents.",
          "name": "min_z",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized output value represents.\n\n*NOTE*: `QuantizedMul` supports limited forms of broadcasting. More about\nbroadcasting [here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
          "name": "max_z",
          "type": 1
        }
      ],
      "summary": "Returns x * y element-wise, working on quantized buffers."
    }
  },
  {
    "name": "QuantizedRelu",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_features",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Has the same output shape as \"features\".",
          "name": "activations",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_activations",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_activations",
          "type": 1
        }
      ],
      "summary": "Computes Quantized Rectified Linear: `max(features, 0)`"
    }
  },
  {
    "name": "QuantizedRelu6",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_features",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Has the same output shape as \"features\".",
          "name": "activations",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_activations",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_activations",
          "type": 1
        }
      ],
      "summary": "Computes Quantized Rectified Linear 6: `min(max(features, 0), 6)`"
    }
  },
  {
    "name": "QuantizedReluX",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        },
        {
          "description": "",
          "name": "max_value",
          "type": 1
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_features",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_features",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "Has the same output shape as \"features\".",
          "name": "activations",
          "type": 0
        },
        {
          "description": "The float value that the lowest quantized value represents.",
          "name": "min_activations",
          "type": 1
        },
        {
          "description": "The float value that the highest quantized value represents.",
          "name": "max_activations",
          "type": 1
        }
      ],
      "summary": "Computes Quantized Rectified Linear X: `min(max(features, 0), max_value)`"
    }
  },
  {
    "name": "QuantizedReshape",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tshape",
          "type": "type"
        }
      ],
      "description": "```",
      "inputs": [
        {
          "description": "",
          "name": "tensor",
          "type": 0
        },
        {
          "description": "Defines the shape of the output tensor.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "The minimum value of the input.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The maximum value of the input.",
          "name": "input_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "This value is copied from input_min.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "This value is copied from input_max.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Reshapes a quantized tensor as per the Reshape op."
    }
  },
  {
    "name": "QuantizedResizeBilinear",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images and output images must be quantized types.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "type": 0
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        },
        {
          "description": "",
          "name": "min",
          "type": 1
        },
        {
          "description": "",
          "name": "max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 0
        },
        {
          "description": "",
          "name": "out_min",
          "type": 1
        },
        {
          "description": "",
          "name": "out_max",
          "type": 1
        }
      ],
      "summary": "Resize quantized `images` to `size` using quantized bilinear interpolation."
    }
  },
  {
    "name": "QueueClose",
    "schema": {
      "attributes": [
        {
          "description": "If true, all pending enqueue requests that are\nblocked on the given queue will be canceled.",
          "name": "cancel_pending_enqueues",
          "type": "bool"
        }
      ],
      "description": "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Closes the given queue."
    }
  },
  {
    "name": "QueueCloseV2",
    "schema": {
      "attributes": [
        {
          "description": "If true, all pending enqueue requests that are\nblocked on the given queue will be canceled.",
          "name": "cancel_pending_enqueues",
          "type": "bool"
        }
      ],
      "description": "This operation signals that no more elements will be enqueued in the\ngiven queue. Subsequent Enqueue(Many) operations will fail.\nSubsequent Dequeue(Many) operations will continue to succeed if\nsufficient elements remain in the queue. Subsequent Dequeue(Many)\noperations that would block will fail immediately.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Closes the given queue."
    }
  },
  {
    "name": "QueueDequeue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Dequeues a tuple of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueMany",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "If the queue is closed and there are fewer than `n` elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until `n` elements\nhave been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueManyV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "If the queue is closed and there are fewer than `n` elements, then an\nOutOfRange error is returned.\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until `n` elements\nhave been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueUpTo",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than `n`\nelements remaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, less than `n` elements are returned immediately.  If\nthe queue is closed and there are 0 elements left in the queue, then\nan OutOfRange error is returned just like in QueueDequeueMany.\nOtherwise the behavior is identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size `n` in the 0th dimension.\n\nThis operation has k outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueUpToV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "If the queue has fewer than n elements, this operation\nwill block for up to timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation is not supported by all queues.  If a queue does not support\nDequeueUpTo, then an Unimplemented error is returned.\n\nIf the queue is closed and there are more than 0 but less than `n`\nelements remaining, then instead of returning an OutOfRange error like\nQueueDequeueMany, less than `n` elements are returned immediately.  If\nthe queue is closed and there are 0 elements left in the queue, then\nan OutOfRange error is returned just like in QueueDequeueMany.\nOtherwise the behavior is identical to QueueDequeueMany:\n\nThis operation concatenates queue-element component tensors along the\n0th dimension to make a single component tensor.  All of the components\nin the dequeued tuple will have size n in the 0th dimension.\n\nThis operation has `k` outputs, where `k` is the number of components in\nthe tuples stored in the given queue, and output `i` is the ith\ncomponent of the dequeued tuple.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The number of tuples to dequeue.",
          "name": "n",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Dequeues `n` tuples of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueDequeueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a tuple.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "If the queue is empty, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation has k outputs, where k is the number of components\nin the tuples stored in the given queue, and output i is the ith\ncomponent of the dequeued tuple.\n\nN.B. If the queue is empty, this operation will block until an element\nhas been dequeued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "One or more tensors that were dequeued as a tuple.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Dequeues a tuple of one or more tensors from the given queue."
    }
  },
  {
    "name": "QueueEnqueue",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "description": "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "One or more tensors from which the enqueued tensors should be taken.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Enqueues a tuple of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueEnqueueMany",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "description": "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "One or more tensors from which the enqueued tensors should\nbe taken.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Enqueues zero or more tuples of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueEnqueueManyV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "description": "If the queue is too full, this operation will block for up\nto timeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "This operation slices each component tensor along the 0th dimension to\nmake multiple queue elements. All of the tuple components must have the\nsame size in the 0th dimension.\n\nThe components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelements have been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "One or more tensors from which the enqueued tensors should\nbe taken.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Enqueues zero or more tuples of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueEnqueueV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tcomponents",
          "type": "list(type)"
        },
        {
          "description": "If the queue is full, this operation will block for up to\ntimeout_ms milliseconds.\nNote: This option is not supported yet.",
          "name": "timeout_ms",
          "type": "int"
        }
      ],
      "description": "The components input has k elements, which correspond to the components of\ntuples stored in the given queue.\n\nN.B. If the queue is full, this operation will block until the given\nelement has been enqueued (or 'timeout_ms' elapses, if specified).",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "One or more tensors from which the enqueued tensors should be taken.",
          "name": "components",
          "type": 0
        }
      ],
      "summary": "Enqueues a tuple of one or more tensors in the given queue."
    }
  },
  {
    "name": "QueueIsClosed",
    "schema": {
      "description": "This operation returns true if the queue is closed and false if the queue\nis open.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "is_closed",
          "type": 10
        }
      ],
      "summary": "Returns true if queue is closed."
    }
  },
  {
    "name": "QueueIsClosedV2",
    "schema": {
      "description": "This operation returns true if the queue is closed and false if the queue\nis open.",
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "is_closed",
          "type": 10
        }
      ],
      "summary": "Returns true if queue is closed."
    }
  },
  {
    "name": "QueueSize",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The number of elements in the given queue.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of elements in the given queue."
    }
  },
  {
    "name": "QueueSizeV2",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "The number of elements in the given queue.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Computes the number of elements in the given queue."
    }
  },
  {
    "name": "RFFT",
    "schema": {
      "description": "Computes the 1-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most dimension of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT` only returns the\n`fft_length / 2 + 1` unique components of the FFT: the zero-frequency term,\nfollowed by the `fft_length / 2` positive-frequency terms.\n\nAlong the axis `RFFT` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A float32 tensor.",
          "name": "input",
          "type": 1
        },
        {
          "description": "An int32 tensor of shape [1]. The FFT length.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same rank as `input`. The inner-most\n  dimension of `input` is replaced with the `fft_length / 2 + 1` unique\n  frequency components of its 1D Fourier transform.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfft\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "Real-valued fast Fourier transform."
    }
  },
  {
    "name": "RFFT2D",
    "schema": {
      "description": "Computes the 2-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most 2 dimensions of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT2D` only returns the\n`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension\nof `output`: the zero-frequency term, followed by the `fft_length / 2`\npositive-frequency terms.\n\nAlong each axis `RFFT2D` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A float32 tensor.",
          "name": "input",
          "type": 1
        },
        {
          "description": "An int32 tensor of shape [2]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same rank as `input`. The inner-most 2\n  dimensions of `input` are replaced with their 2D Fourier transform. The\n  inner-most dimension contains `fft_length / 2 + 1` unique frequency\n  components.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfft2\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "2D real-valued fast Fourier transform."
    }
  },
  {
    "name": "RFFT3D",
    "schema": {
      "description": "Computes the 3-dimensional discrete Fourier transform of a real-valued signal\nover the inner-most 3 dimensions of `input`.\n\nSince the DFT of a real signal is Hermitian-symmetric, `RFFT3D` only returns the\n`fft_length / 2 + 1` unique components of the FFT for the inner-most dimension\nof `output`: the zero-frequency term, followed by the `fft_length / 2`\npositive-frequency terms.\n\nAlong each axis `RFFT3D` is computed on, if `fft_length` is smaller than the\ncorresponding dimension of `input`, the dimension is cropped. If it is larger,\nthe dimension is padded with zeros.",
      "inputs": [
        {
          "description": "A float32 tensor.",
          "name": "input",
          "type": 1
        },
        {
          "description": "An int32 tensor of shape [3]. The FFT length for each dimension.",
          "name": "fft_length",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "A complex64 tensor of the same rank as `input`. The inner-most 3\n  dimensions of `input` are replaced with the their 3D Fourier transform. The\n  inner-most dimension contains `fft_length / 2 + 1` unique frequency\n  components.\n\n@compatibility(numpy)\nEquivalent to np.fft.rfftn with 3 dimensions.\n@end_compatibility",
          "name": "output",
          "type": 8
        }
      ],
      "summary": "3D real-valued fast Fourier transform."
    }
  },
  {
    "name": "RGBToHSV",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Outputs a tensor of the same shape as the `images` tensor, containing the HSV\nvalue of the pixels. The output is only well defined if the value in `images`\nare in `[0,1]`.\n\n`output[..., 0]` contains hue, `output[..., 1]` contains saturation, and\n`output[..., 2]` contains value. All HSV values are in `[0,1]`. A hue of 0\ncorresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.",
      "inputs": [
        {
          "description": "1-D or higher rank. RGB data to convert. Last dimension must be size 3.",
          "name": "images",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "`images` converted to HSV.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Converts one or more images from RGB to HSV."
    }
  },
  {
    "name": "RandomCrop",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "`size` is a 1-D int64 tensor with 2 elements representing the crop height and\nwidth.  The values must be non negative.\n\nThis Op picks a random location in `image` and crops a `height` by `width`\nrectangle from that location.  The random location is picked so the cropped\narea will fit inside the original image.",
      "inputs": [
        {
          "description": "3-D of shape `[height, width, channels]`.",
          "name": "image",
          "type": 0
        },
        {
          "description": "1-D of length 2 containing: `crop_height`, `crop_width`..",
          "name": "size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "3-D of shape `[crop_height, crop_width, channels].`",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Randomly crop `image`."
    }
  },
  {
    "name": "RandomGamma",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "S",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This op uses the algorithm by Marsaglia et al. to acquire samples via\ntransformation-rejection from pairs of uniform and normal random variables.\nSee http://dl.acm.org/citation.cfm?id=358414",
      "inputs": [
        {
          "description": "1-D integer tensor. Shape of independent samples to draw from each\ndistribution described by the shape parameters given in alpha.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "A tensor in which each scalar is a \"shape\" parameter describing the\nassociated gamma distribution.",
          "name": "alpha",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor with shape `shape + shape(alpha)`. Each slice\n`[:, ..., :, i0, i1, ...iN]` contains the samples drawn for\n`alpha[i0, i1, ...iN]`. The dtype of the output matches the dtype of alpha.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random values from the Gamma distribution(s) described by alpha."
    }
  },
  {
    "name": "RandomPoisson",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "S",
          "type": "type"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "shape",
          "type": 0
        },
        {
          "description": "",
          "name": "rate",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Use RandomPoissonV2 instead."
    }
  },
  {
    "name": "RandomPoissonV2",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "S",
          "type": "type"
        },
        {
          "description": "",
          "name": "R",
          "type": "type"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "This op uses two algorithms, depending on rate. If rate >= 10, then\nthe algorithm by Hormann is used to acquire samples via\ntransformation-rejection.\nSee http://www.sciencedirect.com/science/article/pii/0167668793909974.\n\nOtherwise, Knuth's algorithm is used to acquire samples via multiplying uniform\nrandom variables.\nSee Donald E. Knuth (1969). Seminumerical Algorithms. The Art of Computer\nProgramming, Volume 2. Addison Wesley",
      "inputs": [
        {
          "description": "1-D integer tensor. Shape of independent samples to draw from each\ndistribution described by the shape parameters given in rate.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "A tensor in which each scalar is a \"rate\" parameter describing the\nassociated poisson distribution.",
          "name": "rate",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor with shape `shape + shape(rate)`. Each slice\n`[:, ..., :, i0, i1, ...iN]` contains the samples drawn for\n`rate[i0, i1, ...iN]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random values from the Poisson distribution(s) described by rate."
    }
  },
  {
    "name": "RandomShuffle",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "  The tensor is shuffled along dimension 0, such that each `value[j]` is mapped\n  to one and only one `output[i]`. For example, a mapping that might occur for a\n  3x2 tensor is:\n\n```\n[[1, 2],       [[5, 6],\n [3, 4],  ==>   [1, 2],\n [5, 6]]        [3, 4]]\n```",
      "inputs": [
        {
          "description": "The tensor to be shuffled.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor of same shape and type as `value`, shuffled along its first\ndimension.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Randomly shuffles a tensor along its first dimension."
    }
  },
  {
    "name": "RandomShuffleQueue",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements.",
          "name": "min_after_dequeue",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A queue that randomizes the order of elements."
    }
  },
  {
    "name": "RandomShuffleQueueV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of each component in a value.",
          "name": "component_types",
          "type": "list(type)"
        },
        {
          "description": "The shape of each component in a value. The length of this attr must\nbe either 0 or the same as the length of component_types. If the length of\nthis attr is 0, the shapes of queue elements are not constrained, and\nonly one element may be dequeued at a time.",
          "name": "shapes",
          "type": "list(shape)"
        },
        {
          "description": "The upper bound on the number of elements in this queue.\nNegative numbers mean no limit.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "Dequeue will block unless there would be this\nmany elements after the dequeue or the queue is closed. This\nensures a minimum level of mixing of elements.",
          "name": "min_after_dequeue",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 is set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "If non-empty, this queue is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this queue will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to the queue.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A queue that randomizes the order of elements."
    }
  },
  {
    "name": "RandomStandardNormal",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values will have mean 0 and standard deviation 1.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with random normal values.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random values from a normal distribution."
    }
  },
  {
    "name": "RandomUniform",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with uniform random values.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random values from a uniform distribution."
    }
  },
  {
    "name": "RandomUniformInt",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values are uniform integers in the range `[minval, maxval)`.\nThe lower bound `minval` is included in the range, while the upper bound\n`maxval` is excluded.\n\nThe random integers are slightly biased unless `maxval - minval` is an exact\npower of two.  The bias is small for values of `maxval - minval` significantly\nsmaller than the range of the output (either `2^32` or `2^64`).",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "0-D.  Inclusive lower bound on the generated integers.",
          "name": "minval",
          "type": 0
        },
        {
          "description": "0-D.  Exclusive upper bound on the generated integers.",
          "name": "maxval",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with uniform random integers.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random integers from a uniform distribution."
    }
  },
  {
    "name": "Range",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "This operation creates a sequence of numbers that begins at `start` and\nextends by increments of `delta` up to but not including `limit`.\n\nFor example:\n\n```\n# 'start' is 3\n# 'limit' is 18\n# 'delta' is 3\ntf.range(start, limit, delta) ==> [3, 6, 9, 12, 15]\n```",
      "inputs": [
        {
          "description": "0-D (scalar). First entry in the sequence.",
          "name": "start",
          "type": 0
        },
        {
          "description": "0-D (scalar). Upper limit of sequence, exclusive.",
          "name": "limit",
          "type": 0
        },
        {
          "description": "0-D (scalar). Optional. Default is 1. Number that increments `start`.",
          "name": "delta",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Creates a sequence of numbers."
    }
  },
  {
    "name": "RangeDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "corresponds to start in python's xrange().",
          "name": "start",
          "type": 9
        },
        {
          "description": "corresponds to stop in python's xrange().",
          "name": "stop",
          "type": 9
        },
        {
          "description": "corresponds to step in python's xrange().",
          "name": "step",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset with a range of values. Corresponds to python's xrange."
    }
  },
  {
    "name": "Rank",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns an integer representing the rank of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\n# shape of tensor 't' is [2, 2, 3]\nrank(t) ==> 3\n```\n\n**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank\nof a tensor is the number of indices required to uniquely select each element\nof the tensor. Rank is also known as \"order\", \"degree\", or \"ndims.\"",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 3
        }
      ],
      "summary": "Returns the rank of a tensor."
    }
  },
  {
    "name": "ReadFile",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "filename",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "Reads and outputs the entire contents of the input filename."
    }
  },
  {
    "name": "ReadVariableOp",
    "schema": {
      "attributes": [
        {
          "description": "the dtype of the value.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The tensor returned by this operation is immutable.\n\nThe value returned by this operation is guaranteed to be influenced by all the\nwrites on which this operation depends directly or indirectly, and to not be\ninfluenced by any of the writes which depend directly or indirectly on this\noperation.",
      "inputs": [
        {
          "description": "handle to the resource in which to store the variable.",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Reads the value of a variable."
    }
  },
  {
    "name": "ReaderNumRecordsProduced",
    "schema": {
      "description": "This is the same as the number of ReaderRead executions that have\nsucceeded.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "records_produced",
          "type": 9
        }
      ],
      "summary": "Returns the number of records this Reader has produced."
    }
  },
  {
    "name": "ReaderNumRecordsProducedV2",
    "schema": {
      "description": "This is the same as the number of ReaderRead executions that have\nsucceeded.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "records_produced",
          "type": 9
        }
      ],
      "summary": "Returns the number of records this Reader has produced."
    }
  },
  {
    "name": "ReaderNumWorkUnitsCompleted",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "units_completed",
          "type": 9
        }
      ],
      "summary": "Returns the number of work units this Reader has finished processing."
    }
  },
  {
    "name": "ReaderNumWorkUnitsCompletedV2",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "units_completed",
          "type": 9
        }
      ],
      "summary": "Returns the number of work units this Reader has finished processing."
    }
  },
  {
    "name": "ReaderRead",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 7
        },
        {
          "description": "Handle to a Queue, with string work items.",
          "name": "queue_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A scalar.",
          "name": "key",
          "type": 7
        },
        {
          "description": "A scalar.",
          "name": "value",
          "type": 7
        }
      ],
      "summary": "Returns the next record (key, value pair) produced by a Reader."
    }
  },
  {
    "name": "ReaderReadUpTo",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).\nIt may return less than `num_records` even before the last batch.",
      "inputs": [
        {
          "description": "Handle to a `Reader`.",
          "name": "reader_handle",
          "type": 7
        },
        {
          "description": "Handle to a `Queue`, with string work items.",
          "name": "queue_handle",
          "type": 7
        },
        {
          "description": "number of records to read from `Reader`.",
          "name": "num_records",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A 1-D tensor.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "A 1-D tensor.",
          "name": "values",
          "type": 7
        }
      ],
      "summary": "Returns up to `num_records` (key, value) pairs produced by a Reader."
    }
  },
  {
    "name": "ReaderReadUpToV2",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).\nIt may return less than `num_records` even before the last batch.",
      "inputs": [
        {
          "description": "Handle to a `Reader`.",
          "name": "reader_handle",
          "type": 20
        },
        {
          "description": "Handle to a `Queue`, with string work items.",
          "name": "queue_handle",
          "type": 20
        },
        {
          "description": "number of records to read from `Reader`.",
          "name": "num_records",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A 1-D tensor.",
          "name": "keys",
          "type": 7
        },
        {
          "description": "A 1-D tensor.",
          "name": "values",
          "type": 7
        }
      ],
      "summary": "Returns up to `num_records` (key, value) pairs produced by a Reader."
    }
  },
  {
    "name": "ReaderReadV2",
    "schema": {
      "description": "Will dequeue from the input queue if necessary (e.g. when the\nReader needs to start reading from a new file since it has finished\nwith the previous file).",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        },
        {
          "description": "Handle to a Queue, with string work items.",
          "name": "queue_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A scalar.",
          "name": "key",
          "type": 7
        },
        {
          "description": "A scalar.",
          "name": "value",
          "type": 7
        }
      ],
      "summary": "Returns the next record (key, value pair) produced by a Reader."
    }
  },
  {
    "name": "ReaderReset",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "Restore a Reader to its initial clean state."
    }
  },
  {
    "name": "ReaderResetV2",
    "schema": {
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "Restore a Reader to its initial clean state."
    }
  },
  {
    "name": "ReaderRestoreState",
    "schema": {
      "description": "Not all Readers support being restored, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 7
        },
        {
          "description": "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle.",
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Restore a reader to a previously saved state."
    }
  },
  {
    "name": "ReaderRestoreStateV2",
    "schema": {
      "description": "Not all Readers support being restored, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        },
        {
          "description": "Result of a ReaderSerializeState of a Reader with type\nmatching reader_handle.",
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Restore a reader to a previously saved state."
    }
  },
  {
    "name": "ReaderSerializeState",
    "schema": {
      "description": "Not all Readers support being serialized, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Produce a string tensor that encodes the state of a Reader."
    }
  },
  {
    "name": "ReaderSerializeStateV2",
    "schema": {
      "description": "Not all Readers support being serialized, so this can produce an\nUnimplemented error.",
      "inputs": [
        {
          "description": "Handle to a Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "state",
          "type": 7
        }
      ],
      "summary": "Produce a string tensor that encodes the state of a Reader."
    }
  },
  {
    "name": "Real",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tout",
          "type": "type"
        }
      ],
      "description": "Given a tensor `input` of complex numbers, this operation returns a tensor of\ntype `float` that is the real part of each element in `input`. All elements in\n`input` must be complex numbers of the form \\\\(a + bj\\\\), where *a* is the real\n part returned by this operation and *b* is the imaginary part.\n\nFor example:\n\n```\n# tensor 'input' is [-2.25 + 4.75j, 3.25 + 5.75j]\ntf.real(input) ==> [-2.25, 3.25]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the real part of a complex number."
    }
  },
  {
    "name": "RealDiv",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `x` and `y` are reals, this will return the floating-point division.\n\n*NOTE*: `Div` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x / y element-wise for real types."
    }
  },
  {
    "name": "Reciprocal",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = 1 / x\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes the reciprocal of x element-wise."
    }
  },
  {
    "name": "ReciprocalGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = -dy * y*y`, where `y = 1/x`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the gradient for the inverse of `x` wrt its input."
    }
  },
  {
    "name": "RecordInput",
    "schema": {
      "attributes": [
        {
          "description": "Glob pattern for the data files.",
          "name": "file_pattern",
          "type": "string"
        },
        {
          "description": "Random seeds used to produce randomized records.",
          "name": "file_random_seed",
          "type": "int"
        },
        {
          "description": "Shifts the list of files after the list is randomly\nshuffled.",
          "name": "file_shuffle_shift_ratio",
          "type": "float"
        },
        {
          "description": "The randomization shuffling buffer.",
          "name": "file_buffer_size",
          "type": "int"
        },
        {
          "description": "How many sstables are opened and concurrently iterated over.",
          "name": "file_parallelism",
          "type": "int"
        },
        {
          "description": "The batch size.",
          "name": "batch_size",
          "type": "int"
        }
      ],
      "outputs": [
        {
          "description": "A tensor of shape [batch_size].",
          "name": "records",
          "type": 7
        }
      ],
      "summary": "Emits randomized records."
    }
  },
  {
    "name": "ReduceJoin",
    "schema": {
      "attributes": [
        {
          "description": "If `True`, retain reduced dimensions with length `1`.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "The separator to use when joining.",
          "name": "separator",
          "type": "string"
        }
      ],
      "description": "Computes the string join across dimensions in the given string Tensor of shape\n`[d_0, d_1, ..., d_n-1]`.  Returns a new Tensor created by joining the input\nstrings with the given separator (default: empty string).  Negative indices are\ncounted backwards from the end, with `-1` being equivalent to `n - 1`.\n\nFor example:\n\n```python\n# tensor `a` is [[\"a\", \"b\"], [\"c\", \"d\"]]\ntf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, -2) = tf.reduce_join(a, 0) ==> [\"ac\", \"bd\"]\ntf.reduce_join(a, -1) = tf.reduce_join(a, 1) ==> [\"ab\", \"cd\"]\ntf.reduce_join(a, 0, keep_dims=True) ==> [[\"ac\", \"bd\"]]\ntf.reduce_join(a, 1, keep_dims=True) ==> [[\"ab\"], [\"cd\"]]\ntf.reduce_join(a, 0, separator=\".\") ==> [\"a.c\", \"b.d\"]\ntf.reduce_join(a, [0, 1]) ==> [\"acbd\"]\ntf.reduce_join(a, [1, 0]) ==> [\"abcd\"]\ntf.reduce_join(a, []) ==> [\"abcd\"]\n```",
      "inputs": [
        {
          "description": "The input to be joined.  All reduced indices must have non-zero size.",
          "name": "inputs",
          "type": 7
        },
        {
          "description": "The dimensions to reduce over.  Dimensions are reduced in the\norder specified.  Omitting `reduction_indices` is equivalent to passing\n`[n-1, n-2, ..., 0]`.  Negative indices from `-n` to `-1` are supported.",
          "name": "reduction_indices",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has shape equal to that of the input with reduced dimensions removed or\nset to `1` depending on `keep_dims`.",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Joins a string Tensor across the given dimensions."
    }
  },
  {
    "name": "RefEnter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The name of the child frame.",
          "name": "frame_name",
          "type": "string"
        },
        {
          "description": "If true, the output is constant within the child frame.",
          "name": "is_constant",
          "type": "bool"
        },
        {
          "description": "The number of iterations allowed to run in parallel.",
          "name": "parallel_iterations",
          "type": "int"
        }
      ],
      "description": "The unique `frame_name` is used by the `Executor` to identify frames. If\n`is_constant` is true, `output` is a constant in the child frame; otherwise\nit may be changed in the child frame. At most `parallel_iterations` iterations\nare run in parallel in the child frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the child frame.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Creates or finds a child frame, and makes `data` available to the child frame."
    }
  },
  {
    "name": "RefExit",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Exit makes its input `data` available to the parent frame.",
      "inputs": [
        {
          "description": "The tensor to be made available to the parent frame.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Exits the current frame to its parent frame."
    }
  },
  {
    "name": "RefIdentity",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Return the same ref tensor as the input ref tensor."
    }
  },
  {
    "name": "RefMerge",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "description": "`Merge` waits for at least one of the tensors in `inputs` to become available.\nIt is usually combined with `Switch` to implement branching.\n\n`Merge` forwards the first tensor for become available to `output`, and sets\n`value_index` to its index in `inputs`.",
      "inputs": [
        {
          "description": "The input tensors, exactly one of which will become available.",
          "name": "inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Will be set to the available input tensor.",
          "name": "output",
          "type": 0
        },
        {
          "description": "The index of the chosen input tensor in `inputs`.",
          "name": "value_index",
          "type": 3
        }
      ],
      "summary": "Forwards the value of an available tensor from `inputs` to `output`."
    }
  },
  {
    "name": "RefNextIteration",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to be made available to the next iteration.",
          "name": "data",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as `data`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Makes its input available to the next iteration."
    }
  },
  {
    "name": "RefSelect",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "A scalar that determines the input that gets selected.",
          "name": "index",
          "type": 3
        },
        {
          "description": "A list of ref tensors, one of which will be forwarded to `output`.",
          "name": "inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The forwarded tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Forwards the `index`th element of `inputs` to `output`."
    }
  },
  {
    "name": "RefSwitch",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `Switch` and `Merge`.",
      "inputs": [
        {
          "description": "The ref tensor to be forwarded to the appropriate output.",
          "name": "data",
          "type": 0
        },
        {
          "description": "A scalar that specifies which output port will receive data.",
          "name": "pred",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "If `pred` is false, data will be forwarded to this output.",
          "name": "output_false",
          "type": 0
        },
        {
          "description": "If `pred` is true, data will be forwarded to this output.",
          "name": "output_true",
          "type": 0
        }
      ],
      "summary": "Forwards the ref tensor `data` to the output port determined by `pred`."
    }
  },
  {
    "name": "Relu",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "activations",
          "type": 0
        }
      ],
      "summary": "Computes rectified linear: `max(features, 0)`."
    }
  },
  {
    "name": "Relu6",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "activations",
          "type": 0
        }
      ],
      "summary": "Computes rectified linear 6: `min(max(features, 0), 6)`."
    }
  },
  {
    "name": "Relu6Grad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Relu6 operation.",
          "name": "gradients",
          "type": 0
        },
        {
          "description": "The features passed as input to the corresponding Relu6 operation, or\nits output; using either one produces the same result.",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The gradients:\n`gradients * (features > 0) * (features < 6)`.",
          "name": "backprops",
          "type": 0
        }
      ],
      "summary": "Computes rectified linear 6 gradients for a Relu6 operation."
    }
  },
  {
    "name": "ReluGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Relu operation.",
          "name": "gradients",
          "type": 0
        },
        {
          "description": "The features passed as input to the corresponding Relu operation, OR\nthe outputs of that operation (both work equivalently).",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "`gradients * (features > 0)`.",
          "name": "backprops",
          "type": 0
        }
      ],
      "summary": "Computes rectified linear gradients for a Relu operation."
    }
  },
  {
    "name": "RemoteCall",
    "schema": {
      "attributes": [
        {
          "description": "The type list for the arguments.",
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "The type list for the return values.",
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "The function to run remotely.",
          "name": "f",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "A fully specified device name where we want to run the function.",
          "name": "target",
          "type": 7
        },
        {
          "description": "A list of arguments for the function.",
          "name": "args",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A list of return values.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Runs function `f` on a remote device indicated by `target`."
    }
  },
  {
    "name": "RemoteFusedGraphExecute",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tinputs",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Toutputs",
          "type": "list(type)"
        },
        {
          "description": "Serialized protocol buffer\nof RemoteFusedGraphExecuteInfo which contains graph specifications.",
          "name": "serialized_remote_fused_graph_execute_info",
          "type": "string"
        }
      ],
      "description": "The graph specifications(such as graph itself, input tensors and output names)\nare stored as a serialized protocol buffer of RemoteFusedGraphExecuteInfo\nas serialized_remote_fused_graph_execute_info.\nThe specifications will be passed to a dedicated registered\nremote fused graph executor.  The executor will send the graph specifications\nto a remote processor and execute that graph.  The execution results\nwill be passed to consumer nodes as outputs of this node.",
      "inputs": [
        {
          "description": "Arbitrary number of tensors with arbitrary data types",
          "name": "inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Arbitrary number of tensors with arbitrary data types",
          "name": "outputs",
          "type": 0
        }
      ],
      "summary": "Execute a sub graph on a remote processor."
    }
  },
  {
    "name": "RepeatDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of times that `input_dataset` should\nbe repeated. A value of `-1` indicates that it should be repeated infinitely.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the outputs of `input_dataset` `count` times."
    }
  },
  {
    "name": "RequantizationRange",
    "schema": {
      "attributes": [
        {
          "description": "The type of the input.",
          "name": "Tinput",
          "type": "type"
        }
      ],
      "description": "range that covers the actual values present in that tensor.  This op is\ntypically used to produce the requested_output_min and requested_output_max for\nRequantize.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "The float value that the minimum quantized input value represents.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized input value represents.",
          "name": "input_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The computed min output.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "the computed max output.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Given a quantized tensor described by (input, input_min, input_max), outputs a"
    }
  },
  {
    "name": "Requantize",
    "schema": {
      "attributes": [
        {
          "description": "The type of the input.",
          "name": "Tinput",
          "type": "type"
        },
        {
          "description": "The type of the output. Should be a lower bit depth than Tinput.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "output range specified with 'requested_output_min' and 'requested_output_max'.\n\n[input_min, input_max] are scalar floats that specify the range for the float\ninterpretation of the 'input' data. For example, if input_min is -1.0f and\ninput_max is 1.0f, and we are dealing with quint16 quantized data, then a 0\nvalue in the 16-bit data should be interpreted as -1.0f, and a 65535 means 1.0f.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "The float value that the minimum quantized input value represents.",
          "name": "input_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized input value represents.",
          "name": "input_max",
          "type": 1
        },
        {
          "description": "The float value that the minimum quantized output value represents.",
          "name": "requested_output_min",
          "type": 1
        },
        {
          "description": "The float value that the maximum quantized output value represents.",
          "name": "requested_output_max",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        },
        {
          "description": "The requested_output_min value is copied into this output.",
          "name": "output_min",
          "type": 1
        },
        {
          "description": "The requested_output_max value is copied into this output.",
          "name": "output_max",
          "type": 1
        }
      ],
      "summary": "Convert the quantized 'input' tensor into a lower-precision 'output', using the"
    }
  },
  {
    "name": "Reshape",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tshape",
          "type": "type"
        }
      ],
      "description": "Given `tensor`, this operation returns a tensor that has the same values\nas `tensor` with shape `shape`.\n\nIf one component of `shape` is the special value -1, the size of that dimension\nis computed so that the total size remains constant.  In particular, a `shape`\nof `[-1]` flattens into 1-D.  At most one component of `shape` can be -1.\n\nIf `shape` is 1-D or higher, then the operation returns a tensor with shape\n`shape` filled with the values of `tensor`. In this case, the number of elements\nimplied by `shape` must be the same as the number of elements in `tensor`.\n\nFor example:\n\n```\n# tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# tensor 't' has shape [9]\nreshape(t, [3, 3]) ==> [[1, 2, 3],\n                        [4, 5, 6],\n                        [7, 8, 9]]\n\n# tensor 't' is [[[1, 1], [2, 2]],\n#                [[3, 3], [4, 4]]]\n# tensor 't' has shape [2, 2, 2]\nreshape(t, [2, 4]) ==> [[1, 1, 2, 2],\n                        [3, 3, 4, 4]]\n\n# tensor 't' is [[[1, 1, 1],\n#                 [2, 2, 2]],\n#                [[3, 3, 3],\n#                 [4, 4, 4]],\n#                [[5, 5, 5],\n#                 [6, 6, 6]]]\n# tensor 't' has shape [3, 2, 3]\n# pass '[-1]' to flatten 't'\nreshape(t, [-1]) ==> [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]\n\n# -1 can also be used to infer the shape\n\n# -1 is inferred to be 9:\nreshape(t, [2, -1]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n# -1 is inferred to be 2:\nreshape(t, [-1, 9]) ==> [[1, 1, 1, 2, 2, 2, 3, 3, 3],\n                         [4, 4, 4, 5, 5, 5, 6, 6, 6]]\n# -1 is inferred to be 3:\nreshape(t, [ 2, -1, 3]) ==> [[[1, 1, 1],\n                              [2, 2, 2],\n                              [3, 3, 3]],\n                             [[4, 4, 4],\n                              [5, 5, 5],\n                              [6, 6, 6]]]\n\n# tensor 't' is [7]\n# shape `[]` reshapes to a scalar\nreshape(t, []) ==> 7\n```",
      "inputs": [
        {
          "description": "",
          "name": "tensor",
          "type": 0
        },
        {
          "description": "Defines the shape of the output tensor.",
          "name": "shape",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Reshapes a tensor."
    }
  },
  {
    "name": "ResizeArea",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images can be of different types but output images are always float.\n\nEach output pixel is computed by first transforming the pixel's footprint into\nthe input tensor and then averaging the pixels that intersect the footprint. An\ninput pixel's contribution to the average is weighted by the fraction of its\narea that intersects the footprint.  This is the same as OpenCV's INTER_AREA.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "type": 0
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 1
        }
      ],
      "summary": "Resize `images` to `size` using area interpolation."
    }
  },
  {
    "name": "ResizeBicubic",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images can be of different types but output images are always float.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "type": 0
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 1
        }
      ],
      "summary": "Resize `images` to `size` using bicubic interpolation."
    }
  },
  {
    "name": "ResizeBicubicGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale grads by (orig_height - 1) / (height - 1), which\nexactly aligns the 4 corners of grads and original_image. If false, rescale by\norig_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized.",
          "name": "original_image",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of bicubic interpolation."
    }
  },
  {
    "name": "ResizeBilinear",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "description": "Input images can be of different types but output images are always float.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "type": 0
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 1
        }
      ],
      "summary": "Resize `images` to `size` using bilinear interpolation."
    }
  },
  {
    "name": "ResizeBilinearGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale grads by (orig_height - 1) / (height - 1), which\nexactly aligns the 4 corners of grads and original_image. If false, rescale by\norig_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "grads",
          "type": 1
        },
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`,\nThe image tensor that was resized.",
          "name": "original_image",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`.\nGradients with respect to the input image. Input image must have been\nfloat or double.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of bilinear interpolation."
    }
  },
  {
    "name": "ResizeNearestNeighbor",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale input by (new_height - 1) / (height - 1), which\nexactly aligns the 4 corners of images and resized images. If false, rescale\nby new_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "images",
          "type": 0
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `new_height, new_width`.  The\nnew size for the images.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape\n`[batch, new_height, new_width, channels]`.",
          "name": "resized_images",
          "type": 0
        }
      ],
      "summary": "Resize `images` to `size` using nearest neighbor interpolation."
    }
  },
  {
    "name": "ResizeNearestNeighborGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If true, rescale grads by (orig_height - 1) / (height - 1), which\nexactly aligns the 4 corners of grads and original_image. If false, rescale by\norig_height / height. Treat similarly the width dimension.",
          "name": "align_corners",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, channels]`.",
          "name": "grads",
          "type": 0
        },
        {
          "description": "= A 1-D int32 Tensor of 2 elements: `orig_height, orig_width`. The\noriginal input size.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "4-D with shape `[batch, orig_height, orig_width, channels]`. Gradients\nwith respect to the input image.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of nearest neighbor interpolation."
    }
  },
  {
    "name": "ResourceApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, updating of the var, accum and update_accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum = rho() * accum + (1 - rho()) * grad.square();\nupdate = (update_accum + epsilon).sqrt() * (accum + epsilon()).rsqrt() * grad;\nupdate_accum = rho() * update_accum + (1 - rho()) * update.square();\nvar -= update;",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum_update",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the adadelta scheme."
    }
  },
  {
    "name": "ResourceApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the adagrad scheme."
    }
  },
  {
    "name": "ResourceApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_accumulator",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_squared_accumulator",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "summary": "Update '*var' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "ResourceApplyAdam",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, m, and v tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "description": "If `True`, uses the nesterov update.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "lr_t <- learning_rate * sqrt(1 - beta2^t) / (1 - beta1^t)\nm_t <- beta1 * m_{t-1} + (1 - beta1) * g_t\nv_t <- beta2 * v_{t-1} + (1 - beta2) * g_t * g_t\nvariable <- variable - lr_t * m_t / (sqrt(v_t) + epsilon)",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "v",
          "type": 20
        },
        {
          "description": "Must be a scalar.",
          "name": "beta1_power",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta2_power",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta1",
          "type": 0
        },
        {
          "description": "Momentum factor. Must be a scalar.",
          "name": "beta2",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the Adam algorithm."
    }
  },
  {
    "name": "ResourceApplyAddSign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- (alpha + sign_decay * sign(g) *sign(m)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ResourceApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\n\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nmg <- rho * mg_{t-1} + (1-rho) * grad\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms - mg * mg + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mg",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "ResourceApplyFtrl",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum_new = accum + grad * grad\nlinear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regulariation. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "grad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regulariation. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "",
          "name": "l2_shrinkage",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceApplyGradientDescent",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "The change.",
          "name": "delta",
          "type": 0
        }
      ],
      "summary": "Update '*var' by subtracting 'alpha' * 'delta' from it."
    }
  },
  {
    "name": "ResourceApplyMomentum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "want to use Nesterov momentum.\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the momentum scheme. Set use_nesterov = True if you"
    }
  },
  {
    "name": "ResourceApplyPowerSign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and m tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "m_t <- beta1 * m_{t-1} + (1 - beta1) * g\nupdate <- exp(logbase * sign_decay * sign(g) * sign(m_t)) * g\nvariable <- variable - lr_t * update",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "m",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "logbase",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "sign_decay",
          "type": 0
        },
        {
          "description": "Must be a scalar.",
          "name": "beta",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the AddSign update."
    }
  },
  {
    "name": "ResourceApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "accum += grad * grad\nprox_v = var - lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' and '*accum' according to FOBOS with Adagrad learning rate."
    }
  },
  {
    "name": "ResourceApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "prox_v = var - alpha * delta\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The change.",
          "name": "delta",
          "type": 0
        }
      ],
      "summary": "Update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "ResourceApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "ResourceCountUpTo",
    "schema": {
      "attributes": [
        {
          "description": "If incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error.",
          "name": "limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a scalar `Variable` node.",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A copy of the input before increment. If nothing else modifies the\ninput, the values produced will all be distinct.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Increments variable pointed to by 'resource' until it reaches 'limit'."
    }
  },
  {
    "name": "ResourceGather",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "`indices` must be an integer tensor of any dimension (usually 0-D or 1-D).\nProduces an output tensor with shape `indices.shape + params.shape[1:]` where:\n\n```python\n    # Scalar indices\n    output[:, ..., :] = params[indices, :, ... :]\n\n    # Vector indices\n    output[i, :, ..., :] = params[indices[i], :, ... :]\n\n    # Higher rank indices\n    output[i, ..., j, :, ... :] = params[indices[i, ..., j], :, ..., :]\n```",
      "inputs": [
        {
          "description": "",
          "name": "resource",
          "type": 20
        },
        {
          "description": "",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Gather slices from the variable pointed to by `resource` according to `indices`."
    }
  },
  {
    "name": "ResourceScatterAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src='https://www.tensorflow.org/images/ScatterAdd.png' alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "type": 0
        }
      ],
      "summary": "Adds sparse updates to the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceScatterUpdate",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "resource",
          "type": 20
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "type": 0
        }
      ],
      "summary": "Assigns sparse updates to the variable referenced by `resource`."
    }
  },
  {
    "name": "ResourceSparseApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": ": Should be from a Variable().",
          "name": "accum_update",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "summary": "var: Should be from a Variable()."
    }
  },
  {
    "name": "ResourceSparseApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme."
    }
  },
  {
    "name": "ResourceSparseApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_accumulator",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_squared_accumulator",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "summary": "Update entries in '*var' and '*accum' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "ResourceSparseApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mg",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "ResourceSparseApplyFtrl",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\naccum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceSparseApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 20
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "",
          "name": "l2_shrinkage",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "ResourceSparseApplyMomentum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme."
    }
  },
  {
    "name": "ResourceSparseApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nprox_v = var\nprox_v -= lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 20
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "summary": "Sparse update entries in '*var' and '*accum' according to FOBOS algorithm."
    }
  },
  {
    "name": "ResourceSparseApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var as follows:\nprox_v = var - alpha * grad\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "summary": "Sparse update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "ResourceSparseApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 20
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 20
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "ResourceStridedSliceAssign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Index",
          "type": "type"
        },
        {
          "description": "",
          "name": "begin_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "end_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "The values of `value` are assigned to the positions in the variable\n`ref` that are selected by the slice parameters. The slice parameters\n`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s\nshape must be exactly the shape produced by the slice of `ref`.",
      "inputs": [
        {
          "description": "",
          "name": "ref",
          "type": 20
        },
        {
          "description": "",
          "name": "begin",
          "type": 0
        },
        {
          "description": "",
          "name": "end",
          "type": 0
        },
        {
          "description": "",
          "name": "strides",
          "type": 0
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Assign `value` to the sliced l-value reference of `ref`."
    }
  },
  {
    "name": "Restore",
    "schema": {
      "attributes": [
        {
          "description": "The type of the tensor to be restored.",
          "name": "dt",
          "type": "type"
        },
        {
          "description": "Index of file to open first if multiple files match\n`file_pattern`.",
          "name": "preferred_shard",
          "type": "int"
        }
      ],
      "description": "Reads a tensor stored in one or several files. If there are several files (for\ninstance because a tensor was saved as slices), `file_pattern` may contain\nwildcard symbols (`*` and `?`) in the filename portion only, not in the\ndirectory portion.\n\nIf a `file_pattern` matches several files, `preferred_shard` can be used to hint\nin which file the requested tensor is likely to be found. This op will first\nopen the file at index `preferred_shard` in the list of matching files and try\nto restore tensors from that file.  Only if some tensors or tensor slices are\nnot found in that first file, then the Op opens all the files. Setting\n`preferred_shard` to match the value passed as the `shard` input\nof a matching `Save` Op may speed up Restore.  This attribute only affects\nperformance, not correctness.  The default value -1 means files are processed in\norder.\n\nSee also `RestoreSlice`.",
      "inputs": [
        {
          "description": "Must have a single element. The pattern of the files from\nwhich we read the tensor.",
          "name": "file_pattern",
          "type": 7
        },
        {
          "description": "Must have a single element. The name of the tensor to be\nrestored.",
          "name": "tensor_name",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The restored tensor.",
          "name": "tensor",
          "type": 0
        }
      ],
      "summary": "Restores a tensor from checkpoint files."
    }
  },
  {
    "name": "RestoreSlice",
    "schema": {
      "attributes": [
        {
          "description": "The type of the tensor to be restored.",
          "name": "dt",
          "type": "type"
        },
        {
          "description": "Index of file to open first if multiple files match\n`file_pattern`. See the documentation for `Restore`.",
          "name": "preferred_shard",
          "type": "int"
        }
      ],
      "description": "This is like `Restore` except that restored tensor can be listed as filling\nonly a slice of a larger tensor.  `shape_and_slice` specifies the shape of the\nlarger tensor and the slice that the restored tensor covers.\n\nThe `shape_and_slice` input has the same format as the\nelements of the `shapes_and_slices` input of the `SaveSlices` op.",
      "inputs": [
        {
          "description": "Must have a single element. The pattern of the files from\nwhich we read the tensor.",
          "name": "file_pattern",
          "type": 7
        },
        {
          "description": "Must have a single element. The name of the tensor to be\nrestored.",
          "name": "tensor_name",
          "type": 7
        },
        {
          "description": "Scalar. The shapes and slice specifications to use when\nrestoring a tensors.",
          "name": "shape_and_slice",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "The restored tensor.",
          "name": "tensor",
          "type": 0
        }
      ],
      "summary": "Restores a tensor from checkpoint files."
    }
  },
  {
    "name": "RestoreV2",
    "schema": {
      "attributes": [
        {
          "description": "shape {N}.  The list of expected dtype for the tensors.  Must match\nthose stored in the checkpoint.",
          "name": "dtypes",
          "type": "list(type)"
        }
      ],
      "description": "For backward compatibility with the V1 format, this Op currently allows\nrestoring from a V1 checkpoint as well:\n  - This Op first attempts to find the V2 index file pointed to by \"prefix\", and\n    if found proceed to read it as a V2 checkpoint;\n  - Otherwise the V1 read path is invoked.\nRelying on this behavior is not recommended, as the ability to fall back to read\nV1 might be deprecated and eventually removed.\n\nBy default, restores the named tensors in full.  If the caller wishes to restore\nspecific slices of stored tensors, \"shape_and_slices\" should be non-empty\nstrings and correspondingly well-formed.\n\nCallers must ensure all the named tensors are indeed stored in the checkpoint.",
      "inputs": [
        {
          "description": "Must have a single element.  The prefix of a V2 checkpoint.",
          "name": "prefix",
          "type": 7
        },
        {
          "description": "shape {N}.  The names of the tensors to be restored.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "shape {N}.  The slice specs of the tensors to be restored.\nEmpty strings indicate that they are non-partitioned tensors.",
          "name": "shape_and_slices",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "shape {N}.  The restored tensors, whose shapes are read from the\ncheckpoint directly.",
          "name": "tensors",
          "type": 0
        }
      ],
      "summary": "Restores tensors from a V2 checkpoint."
    }
  },
  {
    "name": "Reverse",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Given a `tensor`, and a `bool` tensor `dims` representing the dimensions\nof `tensor`, this operation reverses each dimension i of `tensor` where\n`dims[i]` is `True`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions\nof `tensor` must equal the number of elements in `dims`. In other words:\n\n`rank(tensor) = size(dims)`\n\nFor example:\n\n```\n# tensor 't' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor 't' shape is [1, 2, 3, 4]\n\n# 'dims' is [False, False, False, True]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# 'dims' is [False, True, False, False]\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# 'dims' is [False, False, True, False]\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```",
      "inputs": [
        {
          "description": "Up to 8-D.",
          "name": "tensor",
          "type": 0
        },
        {
          "description": "1-D. The dimensions to reverse.",
          "name": "dims",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "The same shape as `tensor`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Reverses specific dimensions of a tensor."
    }
  },
  {
    "name": "ReverseSequence",
    "schema": {
      "attributes": [
        {
          "description": "The dimension which is partially reversed.",
          "name": "seq_dim",
          "type": "int"
        },
        {
          "description": "The dimension along which reversal is performed.",
          "name": "batch_dim",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tlen",
          "type": "type"
        }
      ],
      "description": "This op first slices `input` along the dimension `batch_dim`, and for each\nslice `i`, reverses the first `seq_lengths[i]` elements along\nthe dimension `seq_dim`.\n\nThe elements of `seq_lengths` must obey `seq_lengths[i] <= input.dims[seq_dim]`,\nand `seq_lengths` must be a vector of length `input.dims[batch_dim]`.\n\nThe output slice `i` along dimension `batch_dim` is then given by input\nslice `i`, with the first `seq_lengths[i]` slices along dimension\n`seq_dim` reversed.\n\nFor example:\n\n```\n# Given this:\nbatch_dim = 0\nseq_dim = 1\ninput.dims = (4, 8, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...]\noutput[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...]\noutput[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...]\noutput[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[0, 7:, :, ...] = input[0, 7:, :, ...]\noutput[1, 2:, :, ...] = input[1, 2:, :, ...]\noutput[2, 3:, :, ...] = input[2, 3:, :, ...]\noutput[3, 2:, :, ...] = input[3, 2:, :, ...]\n```\n\nIn contrast, if:\n\n```\n# Given this:\nbatch_dim = 2\nseq_dim = 0\ninput.dims = (8, ?, 4, ...)\nseq_lengths = [7, 2, 3, 5]\n\n# then slices of input are reversed on seq_dim, but only up to seq_lengths:\noutput[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...]\noutput[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...]\noutput[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...]\noutput[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]\n\n# while entries past seq_lens are copied through:\noutput[7:, :, 0, :, ...] = input[7:, :, 0, :, ...]\noutput[2:, :, 1, :, ...] = input[2:, :, 1, :, ...]\noutput[3:, :, 2, :, ...] = input[3:, :, 2, :, ...]\noutput[2:, :, 3, :, ...] = input[2:, :, 3, :, ...]\n```",
      "inputs": [
        {
          "description": "The input to reverse.",
          "name": "input",
          "type": 0
        },
        {
          "description": "1-D with length `input.dims(batch_dim)` and\n`max(seq_lengths) <= input.dims(seq_dim)`",
          "name": "seq_lengths",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The partially reversed input. It has the same shape as `input`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Reverses variable length slices."
    }
  },
  {
    "name": "ReverseV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "NOTE `tf.reverse` has now changed behavior in preparation for 1.0.\n`tf.reverse_v2` is currently an alias that will be deprecated before TF 1.0.\n\nGiven a `tensor`, and a `int32` tensor `axis` representing the set of\ndimensions of `tensor` to reverse. This operation reverses each dimension\n`i` for which there exists `j` s.t. `axis[j] == i`.\n\n`tensor` can have up to 8 dimensions. The number of dimensions specified\nin `axis` may be 0 or more entries. If an index is specified more than\nonce, a InvalidArgument error is raised.\n\nFor example:\n\n```\n# tensor 't' is [[[[ 0,  1,  2,  3],\n#                  [ 4,  5,  6,  7],\n#                  [ 8,  9, 10, 11]],\n#                 [[12, 13, 14, 15],\n#                  [16, 17, 18, 19],\n#                  [20, 21, 22, 23]]]]\n# tensor 't' shape is [1, 2, 3, 4]\n\n# 'dims' is [3] or 'dims' is [-1]\nreverse(t, dims) ==> [[[[ 3,  2,  1,  0],\n                        [ 7,  6,  5,  4],\n                        [ 11, 10, 9, 8]],\n                       [[15, 14, 13, 12],\n                        [19, 18, 17, 16],\n                        [23, 22, 21, 20]]]]\n\n# 'dims' is '[1]' (or 'dims' is '[-3]')\nreverse(t, dims) ==> [[[[12, 13, 14, 15],\n                        [16, 17, 18, 19],\n                        [20, 21, 22, 23]\n                       [[ 0,  1,  2,  3],\n                        [ 4,  5,  6,  7],\n                        [ 8,  9, 10, 11]]]]\n\n# 'dims' is '[2]' (or 'dims' is '[-2]')\nreverse(t, dims) ==> [[[[8, 9, 10, 11],\n                        [4, 5, 6, 7],\n                        [0, 1, 2, 3]]\n                       [[20, 21, 22, 23],\n                        [16, 17, 18, 19],\n                        [12, 13, 14, 15]]]]\n```",
      "inputs": [
        {
          "description": "Up to 8-D.",
          "name": "tensor",
          "type": 0
        },
        {
          "description": "1-D. The indices of the dimensions to reverse. Must be in the range\n`[-rank(tensor), rank(tensor))`.",
          "name": "axis",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same shape as `tensor`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Reverses specific dimensions of a tensor."
    }
  },
  {
    "name": "RightShift",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Performs a logical shift for unsigned integer types, and an arithmetic shift\nfor signed integer types.\n\nIf `y` is negative, or greater than or equal to than the width of `x` in bits\nthe result is implementation defined.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Elementwise computes the bitwise right-shift of `x` and `y`."
    }
  },
  {
    "name": "Rint",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the result is midway between two representable values,\nthe even representable is chosen.\nFor example:\n\n```\nrint(-1.5) ==> -2.0\nrint(0.5000001) ==> 1.0\nrint([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) ==> [-2., -2., -0., 0., 2., 2., 2.]\n```",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Returns element-wise integer closest to x."
    }
  },
  {
    "name": "Round",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Rounds half to even.  Also known as bankers rounding. If you want to round\naccording to the current system rounding mode use std::cint.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Rounds the values of a tensor to the nearest integer, element-wise."
    }
  },
  {
    "name": "Rsqrt",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = 1 / \\sqrt{x}\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes reciprocal of square root of x element-wise."
    }
  },
  {
    "name": "RsqrtGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * -0.5 * y^3`, where `y = rsqrt(x)`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the gradient for the rsqrt of `x` wrt its input."
    }
  },
  {
    "name": "SampleDistortedBoundingBox",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
          "name": "min_object_covered",
          "type": "float"
        },
        {
          "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
          "name": "aspect_ratio_range",
          "type": "list(float)"
        },
        {
          "description": "The cropped area of the image must contain a fraction of the\nsupplied image within in this range.",
          "name": "area_range",
          "type": "list(float)"
        },
        {
          "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
          "name": "max_attempts",
          "type": "int"
        },
        {
          "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
          "name": "use_image_if_no_bounding_boxes",
          "type": "bool"
        }
      ],
      "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n```python\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.image_summary('images_with_box', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n```\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
      "inputs": [
        {
          "description": "1-D, containing `[height, width, channels]`.",
          "name": "image_size",
          "type": 0
        },
        {
          "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
          "name": "bounding_boxes",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
          "name": "begin",
          "type": 0
        },
        {
          "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
          "name": "size",
          "type": 0
        },
        {
          "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
          "name": "bboxes",
          "type": 1
        }
      ],
      "summary": "Generate a single randomly distorted bounding box for an image."
    }
  },
  {
    "name": "SampleDistortedBoundingBoxV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If either `seed` or `seed2` are set to non-zero, the random number\ngenerator is seeded by the given `seed`.  Otherwise, it is seeded by a random\nseed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "The cropped area of the image must have an aspect ratio =\nwidth / height within this range.",
          "name": "aspect_ratio_range",
          "type": "list(float)"
        },
        {
          "description": "The cropped area of the image must contain a fraction of the\nsupplied image within in this range.",
          "name": "area_range",
          "type": "list(float)"
        },
        {
          "description": "Number of attempts at generating a cropped region of the image\nof the specified constraints. After `max_attempts` failures, return the entire\nimage.",
          "name": "max_attempts",
          "type": "int"
        },
        {
          "description": "Controls behavior if no bounding boxes supplied.\nIf true, assume an implicit bounding box covering the whole input. If false,\nraise an error.",
          "name": "use_image_if_no_bounding_boxes",
          "type": "bool"
        }
      ],
      "description": "Bounding box annotations are often supplied in addition to ground-truth labels\nin image recognition or object localization tasks. A common technique for\ntraining such a system is to randomly distort an image while preserving\nits content, i.e. *data augmentation*. This Op outputs a randomly distorted\nlocalization of an object, i.e. bounding box, given an `image_size`,\n`bounding_boxes` and a series of constraints.\n\nThe output of this Op is a single bounding box that may be used to crop the\noriginal image. The output is returned as 3 tensors: `begin`, `size` and\n`bboxes`. The first 2 tensors can be fed directly into `tf.slice` to crop the\nimage. The latter may be supplied to `tf.image.draw_bounding_boxes` to visualize\nwhat the bounding box looks like.\n\nBounding boxes are supplied and returned as `[y_min, x_min, y_max, x_max]`. The\nbounding box coordinates are floats in `[0.0, 1.0]` relative to the width and\nheight of the underlying image.\n\nFor example,\n\n```python\n    # Generate a single distorted bounding box.\n    begin, size, bbox_for_draw = tf.image.sample_distorted_bounding_box(\n        tf.shape(image),\n        bounding_boxes=bounding_boxes)\n\n    # Draw the bounding box in an image summary.\n    image_with_box = tf.image.draw_bounding_boxes(tf.expand_dims(image, 0),\n                                                  bbox_for_draw)\n    tf.image_summary('images_with_box', image_with_box)\n\n    # Employ the bounding box to distort the image.\n    distorted_image = tf.slice(image, begin, size)\n```\n\nNote that if no bounding box information is available, setting\n`use_image_if_no_bounding_boxes = true` will assume there is a single implicit\nbounding box covering the whole image. If `use_image_if_no_bounding_boxes` is\nfalse and no bounding boxes are supplied, an error is raised.",
      "inputs": [
        {
          "description": "1-D, containing `[height, width, channels]`.",
          "name": "image_size",
          "type": 0
        },
        {
          "description": "3-D with shape `[batch, N, 4]` describing the N bounding boxes\nassociated with the image.",
          "name": "bounding_boxes",
          "type": 1
        },
        {
          "description": "The cropped area of the image must contain at least this\nfraction of any bounding box supplied. The value of this parameter should be\nnon-negative. In the case of 0, the cropped area does not need to overlap\nany of the bounding boxes supplied.",
          "name": "min_object_covered",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "1-D, containing `[offset_height, offset_width, 0]`. Provide as input to\n`tf.slice`.",
          "name": "begin",
          "type": 0
        },
        {
          "description": "1-D, containing `[target_height, target_width, -1]`. Provide as input to\n`tf.slice`.",
          "name": "size",
          "type": 0
        },
        {
          "description": "3-D with shape `[1, 1, 4]` containing the distorted bounding box.\nProvide as input to `tf.image.draw_bounding_boxes`.",
          "name": "bboxes",
          "type": 1
        }
      ],
      "summary": "Generate a single randomly distorted bounding box for an image."
    }
  },
  {
    "name": "Save",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "The size of `tensor_names` must match the number of tensors in `data`. `data[i]`\nis written to `filename` with name `tensor_names[i]`.\n\nSee also `SaveSlices`.",
      "inputs": [
        {
          "description": "Must have a single element. The name of the file to which we write\nthe tensor.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "Shape `[N]`. The names of the tensors to be saved.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "`N` tensors to save.",
          "name": "data",
          "type": 0
        }
      ],
      "summary": "Saves the input tensors to disk."
    }
  },
  {
    "name": "SaveSlices",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "list(type)"
        }
      ],
      "description": "This is like `Save` except that tensors can be listed in the saved file as being\na slice of a larger tensor.  `shapes_and_slices` specifies the shape of the\nlarger tensor and the slice that this tensor covers. `shapes_and_slices` must\nhave as many elements as `tensor_names`.\n\nElements of the `shapes_and_slices` input must either be:\n\n*  The empty string, in which case the corresponding tensor is\n   saved normally.\n*  A string of the form `dim0 dim1 ... dimN-1 slice-spec` where the\n   `dimI` are the dimensions of the larger tensor and `slice-spec`\n   specifies what part is covered by the tensor to save.\n\n`slice-spec` itself is a `:`-separated list: `slice0:slice1:...:sliceN-1`\nwhere each `sliceI` is either:\n\n*  The string `-` meaning that the slice covers all indices of this dimension\n*  `start,length` where `start` and `length` are integers.  In that\n   case the slice covers `length` indices starting at `start`.\n\nSee also `Save`.",
      "inputs": [
        {
          "description": "Must have a single element. The name of the file to which we write the\ntensor.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "Shape `[N]`. The names of the tensors to be saved.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "Shape `[N]`.  The shapes and slice specifications to use when\nsaving the tensors.",
          "name": "shapes_and_slices",
          "type": 7
        },
        {
          "description": "`N` tensors to save.",
          "name": "data",
          "type": 0
        }
      ],
      "summary": "Saves input tensors slices to disk."
    }
  },
  {
    "name": "SaveV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        }
      ],
      "description": "By default, saves the named tensors in full.  If the caller wishes to save\nspecific slices of full tensors, \"shape_and_slices\" should be non-empty strings\nand correspondingly well-formed.",
      "inputs": [
        {
          "description": "Must have a single element. The prefix of the V2 checkpoint to which we\nwrite the tensors.",
          "name": "prefix",
          "type": 7
        },
        {
          "description": "shape {N}. The names of the tensors to be saved.",
          "name": "tensor_names",
          "type": 7
        },
        {
          "description": "shape {N}.  The slice specs of the tensors to be saved.\nEmpty strings indicate that they are non-partitioned tensors.",
          "name": "shape_and_slices",
          "type": 7
        },
        {
          "description": "`N` tensors to save.",
          "name": "tensors",
          "type": 0
        }
      ],
      "summary": "Saves tensors in V2 checkpoint format."
    }
  },
  {
    "name": "ScalarSummary",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input `tags` and `values` must have the same shape.  The generated summary\nhas a summary value for each tag-value pair in `tags` and `values`.",
      "inputs": [
        {
          "description": "Tags for the summary.",
          "name": "tags",
          "type": 7
        },
        {
          "description": "Same shape as `tags.  Values for the summary.",
          "name": "values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Scalar.  Serialized `Summary` protocol buffer.",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with scalar values."
    }
  },
  {
    "name": "ScanDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "f",
          "type": "func"
        },
        {
          "description": "",
          "name": "Tstate",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "Targuments",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "",
          "name": "initial_state",
          "type": 0
        },
        {
          "description": "",
          "name": "other_arguments",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset successively reduces `f` over the elements of `input_dataset`."
    }
  },
  {
    "name": "ScatterAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the addition will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n    # Scalar indices\n    ref[indices, ...] += updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] += updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] += updates[i, ..., j, ...]\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterAdd.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of updated values to add to `ref`.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Adds sparse updates to a variable reference."
    }
  },
  {
    "name": "ScatterDiv",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the operation will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] /= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] /= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] /= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions divide.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of values that `ref` is divided by.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Divides a variable reference by sparse updates."
    }
  },
  {
    "name": "ScatterMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the operation will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] *= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] *= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] *= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their contributions multiply.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of updated values to multiply to `ref`.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Multiplies sparse updates into a variable reference."
    }
  },
  {
    "name": "ScatterNd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Creates a new tensor by applying sparse `updates` to individual\nvalues or slices within a zero tensor of the given `shape` according to\nindices.  This operator is the inverse of the @{tf.gather_nd} operator which\nextracts values or slices from a given tensor.\n\n**WARNING**: The order in which updates are applied is nondeterministic, so the\noutput will be nondeterministic if `indices` contains duplicates.\n\n`indices` is an integer tensor containing indices into a new tensor of shape\n`shape`.  The last dimension of `indices` can be at most the rank of `shape`:\n\n    indices.shape[-1] <= shape.rank\n\nThe last dimension of `indices` corresponds to indices into elements\n(if `indices.shape[-1] = shape.rank`) or slices\n(if `indices.shape[-1] < shape.rank`) along dimension `indices.shape[-1]` of\n`shape`.  `updates` is a tensor with shape\n\n    indices.shape[:-1] + shape[indices.shape[-1]:]\n\nThe simplest form of scatter is to insert individual elements in a tensor by\nindex. For example, say we want to insert 4 scattered elements in a rank-1\ntensor with 8 elements.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd1.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    shape = tf.constant([8])\n    scatter = tf.scatter_nd(indices, updates, shape)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [0, 11, 0, 10, 9, 0, 0, 12]\n\nWe can also, insert entire slices of a higher rank tensor all at once. For\nexample, if we wanted to insert two slices in the first dimension of a\nrank-3 tensor with two matrices of new values.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterNd2.png\" alt>\n</div>\n\nIn Python, this scatter operation would look like this:\n\n```python\n    indices = tf.constant([[0], [2]])\n    updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]],\n                           [[5, 5, 5, 5], [6, 6, 6, 6],\n                            [7, 7, 7, 7], [8, 8, 8, 8]]])\n    shape = tf.constant([4, 4, 4])\n    scatter = tf.scatter_nd(indices, updates, shape)\n    with tf.Session() as sess:\n      print(sess.run(scatter))\n```\n\nThe resulting tensor would look like this:\n\n    [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],\n     [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n     [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]]",
      "inputs": [
        {
          "description": "Index tensor.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Updates to scatter into output.",
          "name": "updates",
          "type": 0
        },
        {
          "description": "1-D. The shape of the resulting tensor.",
          "name": "shape",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A new tensor with the given shape and updates applied according\nto the indices.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Scatter `updates` into a new (initially zero) tensor according to `indices`."
    }
  },
  {
    "name": "ScatterNdAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "within a given variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n```\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to 8\nelements. In Python, that addition would look like this:\n\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    add = tf.scatter_nd_add(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(add)\n\nThe resulting update to ref would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee @{tf.scatter_nd} for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A mutable Tensor. Should be from a Variable node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to ref.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Applies sparse addition between `updates` and individual values or slices"
    }
  },
  {
    "name": "ScatterNdNonAliasingAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "from `updates` according to indices `indices`.  The updates are non-aliasing:\n`input` is only modified in-place if no other operations will use it.\nOtherwise, a copy of `input` is made.  This operation has a gradient with\nrespect to both `input` and `updates`.\n\n`input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `input`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or `(P-K)`-dimensional slices\n(if `K < P`) along the `K`th dimension of `input`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].\n```\n\nFor example, say we want to add 4 scattered elements to a rank-1 tensor to 8\nelements. In Python, that addition would look like this:\n\n    input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    output = tf.scatter_nd_non_aliasing_add(input, indices, updates)\n    with tf.Session() as sess:\n      print(sess.run(output))\n\nThe resulting value `output` would look like this:\n\n    [1, 13, 3, 14, 14, 6, 7, 20]\n\nSee @{tf.scatter_nd} for more details about how to make updates to slices.",
      "inputs": [
        {
          "description": "A Tensor.",
          "name": "input",
          "type": 0
        },
        {
          "description": "A Tensor. Must be one of the following types: `int32`, `int64`.\nA tensor of indices into `input`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto add to `input`.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A `Tensor` with the same shape as `input`, containing values of `input`\nupdated with `updates`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Applies sparse addition to `input` using individual values or slices"
    }
  },
  {
    "name": "ScatterNdSub",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "within a given variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n```\n\nFor example, say we want to subtract 4 scattered elements from a rank-1 tensor\nwith 8 elements. In Python, that subtraction would look like this:\n\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1], [7]])\n    updates = tf.constant([9, 10, 11, 12])\n    sub = tf.scatter_nd_sub(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(sub)\n\nThe resulting update to ref would look like this:\n\n    [1, -9, 3, -6, -4, 6, 7, -4]\n\nSee @{tf.scatter_nd} for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A mutable Tensor. Should be from a Variable node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated values\nto subtract from ref.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as ref. Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Applies sparse subtraction between `updates` and individual values or slices"
    }
  },
  {
    "name": "ScatterNdUpdate",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "An optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "variable according to `indices`.\n\n`ref` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.\n\n`indices` must be integer tensor, containing indices into `ref`.\nIt must be shape `[d_0, ..., d_{Q-2}, K]` where `0 < K <= P`.\n\nThe innermost dimension of `indices` (with length `K`) corresponds to\nindices into elements (if `K = P`) or slices (if `K < P`) along the `K`th\ndimension of `ref`.\n\n`updates` is `Tensor` of rank `Q-1+P-K` with shape:\n\n```\n[d_0, ..., d_{Q-2}, ref.shape[K], ..., ref.shape[P-1]].\n```\n\nFor example, say we want to update 4 scattered elements to a rank-1 tensor to\n8 elements. In Python, that update would look like this:\n\n```python\n    ref = tf.Variable([1, 2, 3, 4, 5, 6, 7, 8])\n    indices = tf.constant([[4], [3], [1] ,[7]])\n    updates = tf.constant([9, 10, 11, 12])\n    update = tf.scatter_nd_update(ref, indices, updates)\n    with tf.Session() as sess:\n      print sess.run(update)\n```\n\nThe resulting update to ref would look like this:\n\n    [1, 11, 3, 10, 9, 6, 7, 12]\n\nSee @{tf.scatter_nd} for more details about how to make updates to\nslices.",
      "inputs": [
        {
          "description": "A mutable Tensor. Should be from a Variable node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to add to ref.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as ref. Returned as a convenience for operations that want to\nuse the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Applies sparse `updates` to individual values or slices within a given"
    }
  },
  {
    "name": "ScatterSub",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "```python\n    # Scalar indices\n    ref[indices, ...] -= updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] -= updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] -= updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nDuplicate entries are handled correctly: if multiple `indices` reference\nthe same location, their (negated) contributions add.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterSub.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of updated values to subtract from `ref`.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Subtracts sparse updates to a variable reference."
    }
  },
  {
    "name": "ScatterUpdate",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "This operation computes\n\n```python\n    # Scalar indices\n    ref[indices, ...] = updates[...]\n\n    # Vector indices (for each i)\n    ref[indices[i], ...] = updates[i, ...]\n\n    # High rank indices (for each i, ..., j)\n    ref[indices[i, ..., j], ...] = updates[i, ..., j, ...]\n```\n\nThis operation outputs `ref` after the update is done.\nThis makes it easier to chain operations that need to use the reset value.\n\nIf values in `ref` is to be updated more than once, because there are\nduplicate entries in `indices`, the order at which the updates happen\nfor each value is undefined.\n\nRequires `updates.shape = indices.shape + ref.shape[1:]`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/ScatterUpdate.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "Should be from a `Variable` node.",
          "name": "ref",
          "type": 0
        },
        {
          "description": "A tensor of indices into the first dimension of `ref`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A tensor of updated values to store in `ref`.",
          "name": "updates",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= Same as `ref`.  Returned as a convenience for operations that want\nto use the updated values after the update is done.",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Applies sparse updates to a variable reference."
    }
  },
  {
    "name": "SdcaFprint",
    "schema": {
      "inputs": [
        {
          "description": "vector of strings to compute fingerprints on.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "a (N,2) shaped matrix where N is the number of elements in the input\nvector. Each row contains the low and high parts of the fingerprint.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Computes fingerprints of the input strings."
    }
  },
  {
    "name": "SdcaOptimizer",
    "schema": {
      "attributes": [
        {
          "description": "Type of the primal loss. Currently SdcaSolver supports logistic,\nsquared and hinge losses.",
          "name": "loss_type",
          "type": "string"
        },
        {
          "description": "Whether to use Adapative SDCA for the inner loop.",
          "name": "adaptative",
          "type": "bool"
        },
        {
          "description": "Number of sparse feature groups to train on.",
          "name": "num_sparse_features",
          "type": "int"
        },
        {
          "description": "Number of sparse feature groups with values\nassociated with it, otherwise implicitly treats values as 1.0.",
          "name": "num_sparse_features_with_values",
          "type": "int"
        },
        {
          "description": "Number of dense feature groups to train on.",
          "name": "num_dense_features",
          "type": "int"
        },
        {
          "description": "Symmetric l1 regularization strength.",
          "name": "l1",
          "type": "float"
        },
        {
          "description": "Symmetric l2 regularization strength.",
          "name": "l2",
          "type": "float"
        },
        {
          "description": "Number of partitions of the global loss function.",
          "name": "num_loss_partitions",
          "type": "int"
        },
        {
          "description": "Number of iterations per mini-batch.",
          "name": "num_inner_iterations",
          "type": "int"
        }
      ],
      "description": "linear models with L1 + L2 regularization. As global optimization objective is\nstrongly-convex, the optimizer optimizes the dual objective at each step. The\noptimizer applies each update one example at a time. Examples are sampled\nuniformly, and the optimizer is learning rate free and enjoys linear convergence\nrate.\n\n[Proximal Stochastic Dual Coordinate Ascent](http://arxiv.org/pdf/1211.2717v1.pdf).<br>\nShai Shalev-Shwartz, Tong Zhang. 2012\n\n$$Loss Objective = \\sum f_{i} (wx_{i}) + (l2 / 2) * |w|^2 + l1 * |w|$$\n\n[Adding vs. Averaging in Distributed Primal-Dual Optimization](http://arxiv.org/abs/1502.03508).<br>\nChenxin Ma, Virginia Smith, Martin Jaggi, Michael I. Jordan,\nPeter Richtarik, Martin Takac. 2015\n\n[Stochastic Dual Coordinate Ascent with Adaptive Probabilities](https://arxiv.org/abs/1502.08053).<br>\nDominik Csiba, Zheng Qu, Peter Richtarik. 2015",
      "inputs": [
        {
          "description": "a list of vectors which contain example indices.",
          "name": "sparse_example_indices",
          "type": 9
        },
        {
          "description": "a list of vectors which contain feature indices.",
          "name": "sparse_feature_indices",
          "type": 9
        },
        {
          "description": "a list of vectors which contains feature value\nassociated with each feature group.",
          "name": "sparse_feature_values",
          "type": 1
        },
        {
          "description": "a list of matrices which contains the dense feature values.",
          "name": "dense_features",
          "type": 1
        },
        {
          "description": "a vector which contains the weight associated with each\nexample.",
          "name": "example_weights",
          "type": 1
        },
        {
          "description": "a vector which contains the label/target associated with each\nexample.",
          "name": "example_labels",
          "type": 1
        },
        {
          "description": "a list of vectors where each value is the indices which has\ncorresponding weights in sparse_weights. This field maybe omitted for the\ndense approach.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "a list of vectors where each value is the weight associated with\na sparse feature group.",
          "name": "sparse_weights",
          "type": 1
        },
        {
          "description": "a list of vectors where the values are the weights associated\nwith a dense feature group.",
          "name": "dense_weights",
          "type": 1
        },
        {
          "description": "a list of vectors containing the example state data.",
          "name": "example_state_data",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "a list of vectors containing the updated example state\ndata.",
          "name": "out_example_state_data",
          "type": 1
        },
        {
          "description": "a list of vectors where each value is the delta\nweights associated with a sparse feature group.",
          "name": "out_delta_sparse_weights",
          "type": 1
        },
        {
          "description": "a list of vectors where the values are the delta\nweights associated with a dense feature group.",
          "name": "out_delta_dense_weights",
          "type": 1
        }
      ],
      "summary": "Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for"
    }
  },
  {
    "name": "SdcaShrinkL1",
    "schema": {
      "attributes": [
        {
          "description": "Number of feature groups to apply shrinking step.",
          "name": "num_features",
          "type": "int"
        },
        {
          "description": "Symmetric l1 regularization strength.",
          "name": "l1",
          "type": "float"
        },
        {
          "description": "Symmetric l2 regularization strength. Should be a positive float.",
          "name": "l2",
          "type": "float"
        }
      ],
      "inputs": [
        {
          "description": "a list of vectors where each value is the weight associated with a\nfeature group.",
          "name": "weights",
          "type": 1
        }
      ],
      "summary": "Applies L1 regularization shrink step on the parameters."
    }
  },
  {
    "name": "SegmentMax",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nComputes a tensor such that\n\\\\(output_i = \\max_j(data_j)\\\\) where `max` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the max is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMax.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor whose rank is equal to the rank of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the maximum along segments of a tensor."
    }
  },
  {
    "name": "SegmentMean",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nComputes a tensor such that\n\\\\(output_i = \\frac{\\sum_j data_j}{N}\\\\) where `mean` is\nover `j` such that `segment_ids[j] == i` and `N` is the total number of\nvalues summed.\n\nIf the mean is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMean.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor whose rank is equal to the rank of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the mean along segments of a tensor."
    }
  },
  {
    "name": "SegmentMin",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nComputes a tensor such that\n\\\\(output_i = \\min_j(data_j)\\\\) where `min` is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the min is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentMin.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor whose rank is equal to the rank of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the minimum along segments of a tensor."
    }
  },
  {
    "name": "SegmentProd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nComputes a tensor such that\n\\\\(output_i = \\prod_j data_j\\\\) where the product is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the product is empty for a given segment ID `i`, `output[i] = 1`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentProd.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor whose rank is equal to the rank of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the product along segments of a tensor."
    }
  },
  {
    "name": "SegmentSum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nComputes a tensor such that\n\\\\(output_i = \\sum_j data_j\\\\) where sum is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/SegmentSum.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor whose rank is equal to the rank of `data`'s\nfirst dimension.  Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the sum along segments of a tensor."
    }
  },
  {
    "name": "Select",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The `t`, and `e` tensors must all have the same shape, and the\noutput will also have that shape.\n\nThe `condition` tensor must be a scalar if `t` and `e` are scalars.\nIf `t` and `e` are vectors or higher rank, then `condition` must be either a\nscalar, a vector with size matching the first dimension of `t`, or must have\nthe same shape as `t`.\n\nThe `condition` tensor acts as a mask that chooses, based on the value at each\nelement, whether the corresponding element / row in the output should be\ntaken from `t` (if true) or `e` (if false).\n\nIf `condition` is a vector and `t` and `e` are higher rank matrices, then\nit chooses which row (outer dimension) to copy from `t` and `e`.\nIf `condition` has the same shape as `t` and `e`, then it chooses which\nelement to copy from `t` and `e`.\n\nFor example:\n\n```python\n# 'condition' tensor is [[True,  False]\n#                        [False, True]]\n# 't' is [[1, 2],\n#         [3, 4]]\n# 'e' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e)  # => [[1, 6], [7, 4]]\n\n\n# 'condition' tensor is [True, False]\n# 't' is [[1, 2],\n#         [3, 4]]\n# 'e' is [[5, 6],\n#         [7, 8]]\nselect(condition, t, e) ==> [[1, 2],\n                             [7, 8]]\n\n```",
      "inputs": [
        {
          "description": "",
          "name": "condition",
          "type": 10
        },
        {
          "description": "= A `Tensor` which may have the same shape as `condition`.\nIf `condition` is rank 1, `t` may have higher rank,\nbut its first dimension must match the size of `condition`.",
          "name": "t",
          "type": 0
        },
        {
          "description": "= A `Tensor` with the same type and shape as `t`.",
          "name": "e",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "= A `Tensor` with the same type and shape as `t` and `e`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Selects elements from `t` or `e`, depending on `condition`."
    }
  },
  {
    "name": "SelfAdjointEig",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input is a tensor of shape `[..., M, M]` whose inner-most 2 dimensions\nform square matrices, with the same constraints as the single matrix\nSelfAdjointEig.\n\nThe result is a [..., M+1, M] matrix with [..., 0,:] containing the\neigenvalues, and subsequent [...,1:, :] containing the eigenvectors.",
      "inputs": [
        {
          "description": "Shape is `[..., M, M]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Shape is `[..., M+1, M]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the Eigen Decomposition of a batch of square self-adjoint matrices."
    }
  },
  {
    "name": "SelfAdjointEigV2",
    "schema": {
      "attributes": [
        {
          "description": "If `True` then eigenvectors will be computed and returned in `v`.\nOtherwise, only the eigenvalues will be computed.",
          "name": "compute_v",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes the eigenvalues and (optionally) eigenvectors of each inner matrix in\n`input` such that `input[..., :, :] = v[..., :, :] * diag(e[..., :])`.\n\n```python\n# a is a tensor.\n# e is a tensor of eigenvalues.\n# v is a tensor of eigenvectors.\ne, v = self_adjoint_eig(a)\ne = self_adjoint_eig(a, compute_v=False)\n```",
      "inputs": [
        {
          "description": "`Tensor` input of shape `[N, N]`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Eigenvalues. Shape is `[N]`.",
          "name": "e",
          "type": 0
        },
        {
          "description": "Eigenvectors. Shape is `[N, N]`.",
          "name": "v",
          "type": 0
        }
      ],
      "summary": "Computes the eigen decomposition of one or more square self-adjoint matrices."
    }
  },
  {
    "name": "Selu",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "if < 0, `scale * features` otherwise.\n\nSee [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)",
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "activations",
          "type": 0
        }
      ],
      "summary": "Computes scaled exponential linear: `scale * alpha * (exp(features) - 1)`"
    }
  },
  {
    "name": "SeluGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding Selu operation.",
          "name": "gradients",
          "type": 0
        },
        {
          "description": "The outputs of the corresponding Selu operation.",
          "name": "outputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients * (outputs + scale * alpha)`\nif outputs < 0, `scale * gradients` otherwise.",
          "name": "backprops",
          "type": 0
        }
      ],
      "summary": "Computes gradients for the scaled exponential linear (Selu) operation."
    }
  },
  {
    "name": "SerializeIterator",
    "schema": {
      "inputs": [
        {
          "description": "A handle to an iterator resource.",
          "name": "resource_handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "A variant tensor storing the state of the iterator contained in the\nresource.",
          "name": "serialized",
          "type": 21
        }
      ],
      "summary": "Converts the given `resource_handle` representing an iterator to a variant tensor."
    }
  },
  {
    "name": "SerializeManySparse",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The `SparseTensor` must have rank `R` greater than 1, and the first dimension\nis treated as the minibatch dimension.  Elements of the `SparseTensor`\nmust be sorted in increasing order of this first dimension.  The serialized\n`SparseTensor` objects going into each row of `serialized_sparse` will have\nrank `R-1`.\n\nThe minibatch size `N` is extracted from `sparse_shape[0]`.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the minibatch `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the minibatch `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "serialized_sparse",
          "type": 7
        }
      ],
      "summary": "Serialize an `N`-minibatch `SparseTensor` into an `[N, 3]` string `Tensor`."
    }
  },
  {
    "name": "SerializeSparse",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`.",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "serialized_sparse",
          "type": 7
        }
      ],
      "summary": "Serialize a `SparseTensor` into a string 3-vector (1-D `Tensor`) object."
    }
  },
  {
    "name": "SerializeTensor",
    "schema": {
      "attributes": [
        {
          "description": "The type of the input tensor.",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A Tensor of type `T`.",
          "name": "tensor",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A serialized TensorProto proto of the input tensor.",
          "name": "serialized",
          "type": 7
        }
      ],
      "summary": "Transforms a Tensor into a serialized TensorProto proto."
    }
  },
  {
    "name": "SetSize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Input `set` is a `SparseTensor` represented by `set_indices`, `set_values`,\nand `set_shape`. The last dimension contains values in a set, duplicates are\nallowed but ignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set`\nindices.",
      "inputs": [
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`.",
          "name": "set_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`.",
          "name": "set_values",
          "type": 0
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`.",
          "name": "set_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "For `set` ranked `n`, this is a `Tensor` with rank `n-1`, and the same 1st\n`n-1` dimensions as `set`. Each value is the number of unique elements in\nthe corresponding `[0...n-1]` dimension of `set`.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Number of unique elements along last dimension of input `set`."
    }
  },
  {
    "name": "Shape",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the shape of a tensor."
    }
  },
  {
    "name": "ShapeN",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns N 1-D integer tensors representing shape of `input[i]s`.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns shape of tensors."
    }
  },
  {
    "name": "ShardedFilename",
    "schema": {
      "description": "   %s-%05d-of-%05d, basename, shard, num_shards.",
      "inputs": [
        {
          "description": "",
          "name": "basename",
          "type": 7
        },
        {
          "description": "",
          "name": "shard",
          "type": 3
        },
        {
          "description": "",
          "name": "num_shards",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Generate a sharded filename. The filename is printf formatted as"
    }
  },
  {
    "name": "ShardedFilespec",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "basename",
          "type": 7
        },
        {
          "description": "",
          "name": "num_shards",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "filename",
          "type": 7
        }
      ],
      "summary": "Generate a glob pattern matching all sharded file names."
    }
  },
  {
    "name": "ShuffleDataset",
    "schema": {
      "attributes": [
        {
          "description": "If true, each iterator over this dataset will be given\na different pseudorandomly generated seed, based on a sequence seeded by the\n`seed` and `seed2` inputs. If false, each iterator will be given the same\nseed, and repeated iteration over this dataset will yield the exact same\nsequence of results.",
          "name": "reshuffle_each_iteration",
          "type": "bool"
        },
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "The number of output elements to buffer in an iterator over\nthis dataset. Compare with the `min_after_dequeue` attr when creating a\n`RandomShuffleQueue`.",
          "name": "buffer_size",
          "type": 9
        },
        {
          "description": "A scalar seed for the random number generator. If either seed or\nseed2 is set to be non-zero, the random number generator is seeded\nby the given seed.  Otherwise, a random seed is used.",
          "name": "seed",
          "type": 9
        },
        {
          "description": "A second scalar seed to avoid seed collision.",
          "name": "seed2",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that shuffles elements from `input_dataset` pseudorandomly."
    }
  },
  {
    "name": "Sigmoid",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `y = 1 / (1 + exp(-x))`.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes sigmoid of `x` element-wise."
    }
  },
  {
    "name": "SigmoidGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * y * (1 - y)`, where `y = sigmoid(x)`, and\n`dy` is the corresponding input gradient.",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the gradient of the sigmoid of `x` wrt its input."
    }
  },
  {
    "name": "Sign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`y = sign(x) = -1` if `x < 0`; 0 if `x == 0`; 1 if `x > 0`.\n\nFor complex numbers, `y = sign(x) = x / |x|` if `x != 0`, otherwise `y = 0`.",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Returns an element-wise indication of the sign of a number."
    }
  },
  {
    "name": "Sin",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes sin of x element-wise."
    }
  },
  {
    "name": "Sinh",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes hyperbolic sine of x element-wise."
    }
  },
  {
    "name": "Size",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns an integer representing the number of elements in\n`input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]\nsize(t) ==> 12\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the size of a tensor."
    }
  },
  {
    "name": "SkipDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements from the `input_dataset`\nthat should be skipped.  If count is -1, skips everything.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that skips `count` elements from the `input_dataset`."
    }
  },
  {
    "name": "Skipgram",
    "schema": {
      "attributes": [
        {
          "description": "The corpus's text file name.",
          "name": "filename",
          "type": "string"
        },
        {
          "description": "The size of produced batch.",
          "name": "batch_size",
          "type": "int"
        },
        {
          "description": "The number of words to predict to the left and right of the target.",
          "name": "window_size",
          "type": "int"
        },
        {
          "description": "The minimum number of word occurrences for it to be included in the\nvocabulary.",
          "name": "min_count",
          "type": "int"
        },
        {
          "description": "Threshold for word occurrence. Words that appear with higher\nfrequency will be randomly down-sampled. Set to 0 to disable.",
          "name": "subsample",
          "type": "float"
        }
      ],
      "outputs": [
        {
          "description": "A vector of words in the corpus.",
          "name": "vocab_word",
          "type": 7
        },
        {
          "description": "Frequencies of words. Sorted in the non-ascending order.",
          "name": "vocab_freq",
          "type": 3
        },
        {
          "description": "Number of words per epoch in the data file.",
          "name": "words_per_epoch",
          "type": 9
        },
        {
          "description": "The current epoch number.",
          "name": "current_epoch",
          "type": 3
        },
        {
          "description": "The total number of words processed so far.",
          "name": "total_words_processed",
          "type": 9
        },
        {
          "description": "A vector of word ids.",
          "name": "examples",
          "type": 3
        },
        {
          "description": "A vector of word ids.",
          "name": "labels",
          "type": 3
        }
      ],
      "summary": "Parses a text file and creates a batch of examples."
    }
  },
  {
    "name": "Slice",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Index",
          "type": "type"
        }
      ],
      "description": "The output tensor is a tensor with dimensions described by 'size'\nwhose values are extracted from 'input' starting at the offsets in\n'begin'.\n\n*Requirements*:\n  0 <= begin[i] <= begin[i] + size[i] <= Di  for i in [0, n)",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "begin[i] specifies the offset into the 'i'th dimension of\n'input' to slice from.",
          "name": "begin",
          "type": 0
        },
        {
          "description": "size[i] specifies the number of elements of the 'i'th dimension\nof 'input' to slice. If size[i] is -1, all remaining elements in dimension\ni are included in the slice (i.e. this is equivalent to setting\nsize[i] = input.dim_size(i) - begin[i]).",
          "name": "size",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Return a slice from 'input'."
    }
  },
  {
    "name": "Softmax",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each batch `i` and class `j` we have\n\n    softmax[i, j] = exp(logits[i, j]) / sum_j(exp(logits[i, j]))",
      "inputs": [
        {
          "description": "2-D with shape `[batch_size, num_classes]`.",
          "name": "logits",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same shape as `logits`.",
          "name": "softmax",
          "type": 0
        }
      ],
      "summary": "Computes softmax activations."
    }
  },
  {
    "name": "SoftmaxCrossEntropyWithLogits",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Inputs are the logits, not probabilities.",
      "inputs": [
        {
          "description": "batch_size x num_classes matrix",
          "name": "features",
          "type": 0
        },
        {
          "description": "batch_size x num_classes matrix\nThe caller must ensure that each batch of labels represents a valid\nprobability distribution.",
          "name": "labels",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Per example loss (batch_size vector).",
          "name": "loss",
          "type": 0
        },
        {
          "description": "backpropagated gradients (batch_size x num_classes matrix).",
          "name": "backprop",
          "type": 0
        }
      ],
      "summary": "Computes softmax cross entropy cost and gradients to backpropagate."
    }
  },
  {
    "name": "Softplus",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "activations",
          "type": 0
        }
      ],
      "summary": "Computes softplus: `log(exp(features) + 1)`."
    }
  },
  {
    "name": "SoftplusGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding softplus operation.",
          "name": "gradients",
          "type": 0
        },
        {
          "description": "The features passed as input to the corresponding softplus operation.",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients / (1 + exp(-features))`.",
          "name": "backprops",
          "type": 0
        }
      ],
      "summary": "Computes softplus gradients for a softplus operation."
    }
  },
  {
    "name": "Softsign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "activations",
          "type": 0
        }
      ],
      "summary": "Computes softsign: `features / (abs(features) + 1)`."
    }
  },
  {
    "name": "SoftsignGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The backpropagated gradients to the corresponding softsign operation.",
          "name": "gradients",
          "type": 0
        },
        {
          "description": "The features passed as input to the corresponding softsign operation.",
          "name": "features",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The gradients: `gradients / (1 + abs(features)) ** 2`.",
          "name": "backprops",
          "type": 0
        }
      ],
      "summary": "Computes softsign gradients for a softsign operation."
    }
  },
  {
    "name": "SpaceToBatch",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tpaddings",
          "type": "type"
        },
        {
          "description": "",
          "name": "block_size",
          "type": "int"
        }
      ],
      "description": "This is a legacy version of the more general SpaceToBatchND.\n\nZero-pads and then rearranges (permutes) blocks of spatial data into batch.\nMore specifically, this op outputs a copy of the input tensor where values from\nthe `height` and `width` dimensions are moved to the `batch` dimension. After\nthe zero-padding, both `height` and `width` of the input must be divisible by the\nblock size.",
      "inputs": [
        {
          "description": "4-D with shape `[batch, height, width, depth]`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "2-D tensor of non-negative integers with shape `[2, 2]`. It specifies\n  the padding of the input with zeros across the spatial dimensions as follows:\n\n      paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]\n\n  The effective spatial dimensions of the zero-padded input tensor will be:\n\n      height_pad = pad_top + height + pad_bottom\n      width_pad = pad_left + width + pad_right\n\nThe attr `block_size` must be greater than one. It indicates the block size.\n\n  * Non-overlapping blocks of size `block_size x block size` in the height and\n    width dimensions are rearranged into the batch dimension at each location.\n  * The batch of the output tensor is `batch * block_size * block_size`.\n  * Both height_pad and width_pad must be divisible by block_size.\n\nThe shape of the output will be:\n\n    [batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\n     depth]\n\nSome examples:\n\n(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 1]` and value:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\n(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 3]` and value:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\n(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[4, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\n(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[8, 1, 2, 1]` and value:\n\n```\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n```\n\nAmong others, this operation is useful for reducing atrous convolution into\nregular convolution.",
          "name": "paddings",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "SpaceToBatch for 4-D tensors of type T."
    }
  },
  {
    "name": "SpaceToBatchND",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tblock_shape",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tpaddings",
          "type": "type"
        }
      ],
      "description": "This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into a\ngrid of blocks of shape `block_shape`, and interleaves these blocks with the\n\"batch\" dimension (0) such that in the output, the spatial dimensions\n`[1, ..., M]` correspond to the position within the grid, and the batch\ndimension combines both the position within a spatial block and the original\nbatch position.  Prior to division into blocks, the spatial dimensions of the\ninput are optionally zero padded according to `paddings`.  See below for a\nprecise description.",
      "inputs": [
        {
          "description": "N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,\nwhere spatial_shape has `M` dimensions.",
          "name": "input",
          "type": 0
        },
        {
          "description": "1-D with shape `[M]`, all values must be >= 1.",
          "name": "block_shape",
          "type": 0
        },
        {
          "description": "2-D with shape `[M, 2]`, all values must be >= 0.\n  `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension\n  `i + 1`, which corresponds to spatial dimension `i`.  It is required that\n  `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.\n\nThis operation is equivalent to the following steps:\n\n1. Zero-pad the start and end of dimensions `[1, ..., M]` of the\n   input according to `paddings` to produce `padded` of shape `padded_shape`.\n\n2. Reshape `padded` to `reshaped_padded` of shape:\n\n     [batch] +\n     [padded_shape[1] / block_shape[0],\n       block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1],\n      block_shape[M-1]] +\n     remaining_shape\n\n3. Permute dimensions of `reshaped_padded` to produce\n   `permuted_reshaped_padded` of shape:\n\n     block_shape +\n     [batch] +\n     [padded_shape[1] / block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1]] +\n     remaining_shape\n\n4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch\n   dimension, producing an output tensor of shape:\n\n     [batch * prod(block_shape)] +\n     [padded_shape[1] / block_shape[0],\n      ...,\n      padded_shape[M] / block_shape[M-1]] +\n     remaining_shape\n\nSome examples:\n\n(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1], [2]], [[3], [4]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 1]` and value:\n\n```\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n```\n\n(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThe output tensor has shape `[4, 1, 1, 3]` and value:\n\n```\n[[[1, 2, 3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\n```\n\n(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and\n    `paddings = [[0, 0], [0, 0]]`:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[4, 2, 2, 1]` and value:\n\n```\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n```\n\n(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and\n    paddings = `[[0, 0], [2, 0]]`:\n\n```\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n```\n\nThe output tensor has shape `[8, 1, 3, 1]` and value:\n\n```\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n```\n\nAmong others, this operation is useful for reducing atrous convolution into\nregular convolution.",
          "name": "paddings",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "SpaceToBatch for N-D tensors of type T."
    }
  },
  {
    "name": "SpaceToDepth",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "The size of the spatial block.",
          "name": "block_size",
          "type": "int"
        },
        {
          "description": "",
          "name": "data_format",
          "type": "string"
        }
      ],
      "description": "Rearranges blocks of spatial data, into depth. More specifically,\nthis op outputs a copy of the input tensor where values from the `height`\nand `width` dimensions are moved to the `depth` dimension.\nThe attr `block_size` indicates the input block size.\n\n  * Non-overlapping blocks of size `block_size x block size` are rearranged\n    into depth at each location.\n  * The depth of the output tensor is `block_size * block_size * input_depth`.\n  * The Y, X coordinates within each block of the input become the high order\n    component of the output channel index.\n  * The input tensor's height and width must be divisible by block_size.\n\nThe `data_format` attr specifies the layout of the input and output tensors\nwith the following options:\n  \"NHWC\": `[ batch, height, width, channels ]`\n  \"NCHW\": `[ batch, channels, height, width ]`\n  \"NCHW_VECT_C\":\n      `qint8 [ batch, channels / 4, height, width, channels % 4 ]`\n\nIt is useful to consider the operation as transforming a 6-D Tensor.\ne.g. for data_format = NHWC,\n     Each element in the input tensor can be specified via 6 coordinates,\n     ordered by decreasing memory layout significance as:\n     n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates\n                        within the output image, bX, bY means coordinates\n                        within the input block, iC means input channels).\n     The output would be a transpose to the following layout:\n     n,oY,oX,bY,bX,iC\n\nThis operation is useful for resizing the activations between convolutions\n(but keeping all data), e.g. instead of pooling. It is also useful for training\npurely convolutional models.\n\nFor example, given an input of shape `[1, 2, 2, 1]`, data_format = \"NHWC\" and\nblock_size = 2:\n\n```\nx = [[[[1], [2]],\n      [[3], [4]]]]\n```\n\nThis operation will output a tensor of shape `[1, 1, 1, 4]`:\n\n```\n[[[[1, 2, 3, 4]]]]\n```\n\nHere, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,\nthe corresponding output will have a single element (i.e. width and height are\nboth 1) and will have a depth of 4 channels (1 * block_size * block_size).\nThe output element shape is `[1, 1, 4]`.\n\nFor an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.\n\n```\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n```\n\nThis operation, for block_size of 2, will return the following tensor of shape\n`[1, 1, 1, 12]`\n\n```\n[[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]]\n```\n\nSimilarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:\n\n```\nx = [[[[1],   [2],  [5],  [6]],\n      [[3],   [4],  [7],  [8]],\n      [[9],  [10], [13],  [14]],\n      [[11], [12], [15],  [16]]]]\n```\n\nthe operator will return the following tensor of shape `[1 2 2 4]`:\n\n```\nx = [[[[1, 2, 3, 4],\n       [5, 6, 7, 8]],\n      [[9, 10, 11, 12],\n       [13, 14, 15, 16]]]]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "SpaceToDepth for tensors of type T."
    }
  },
  {
    "name": "SparseAccumulatorApplyGradient",
    "schema": {
      "attributes": [
        {
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "Boolean indicating whether gradient_shape is unknown, in which\ncase the input is ignored during validation.",
          "name": "has_known_shape",
          "type": "bool"
        }
      ],
      "description": "Does not add if local_step is smaller than the accumulator's\nglobal_step.",
      "inputs": [
        {
          "description": "The handle to a accumulator.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "The local_step value at which the sparse gradient was computed.",
          "name": "local_step",
          "type": 9
        },
        {
          "description": "Indices of the sparse gradient to be accumulated. Must be a\nvector.",
          "name": "gradient_indices",
          "type": 9
        },
        {
          "description": "Values are the non-zero slices of the gradient, and must have\nthe same first dimension as indices, i.e., the nnz represented by indices and\nvalues must be consistent.",
          "name": "gradient_values",
          "type": 0
        },
        {
          "description": "Shape of the sparse gradient to be accumulated.",
          "name": "gradient_shape",
          "type": 9
        }
      ],
      "summary": "Applies a sparse gradient to a given accumulator."
    }
  },
  {
    "name": "SparseAccumulatorTakeGradient",
    "schema": {
      "attributes": [
        {
          "description": "The data type of accumulated gradients. Needs to correspond to the type\nof the accumulator.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "description": "The op will blocks until sufficient (i.e., more than num_required)\ngradients have been accumulated. If the accumulator has already\naggregated more than num_required gradients, it will return its\naverage of the accumulated gradients.  Also automatically increments\nthe recorded global_step in the accumulator by 1, and resets the\naggregate to 0.",
      "inputs": [
        {
          "description": "The handle to a SparseConditionalAccumulator.",
          "name": "handle",
          "type": 7
        },
        {
          "description": "Number of gradients required before we return an aggregate.",
          "name": "num_required",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Indices of the average of the accumulated sparse gradients.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "Values of the average of the accumulated sparse gradients.",
          "name": "values",
          "type": 0
        },
        {
          "description": "Shape of the average of the accumulated sparse gradients.",
          "name": "shape",
          "type": 9
        }
      ],
      "summary": "Extracts the average sparse gradient in a SparseConditionalAccumulator."
    }
  },
  {
    "name": "SparseAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Treal",
          "type": "type"
        }
      ],
      "description": "The input `SparseTensor` objects' indices are assumed ordered in standard\nlexicographic order.  If this is not the case, before this step run\n`SparseReorder` to restore index ordering.\n\nBy default, if two values sum to zero at some index, the output `SparseTensor`\nwould still include that particular location in its index, storing a zero in the\ncorresponding value slot.  To override this, callers can specify `thresh`,\nindicating that if the sum has a magnitude strictly smaller than `thresh`, its\ncorresponding value and index would then not be included.  In particular,\n`thresh == 0` (default) means everything is kept and actual thresholding happens\nonly for a positive value.\n\nIn the following shapes, `nnz` is the count after taking `thresh` into account.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the first `SparseTensor`, size `[nnz, ndims]` Matrix.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the first `SparseTensor`, size `[nnz]` Vector.",
          "name": "a_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the first `SparseTensor`, size `[ndims]` Vector.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the second `SparseTensor`, size `[nnz, ndims]` Matrix.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the second `SparseTensor`, size `[nnz]` Vector.",
          "name": "b_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the second `SparseTensor`, size `[ndims]` Vector.",
          "name": "b_shape",
          "type": 9
        },
        {
          "description": "0-D.  The magnitude threshold that determines if an output value/index\npair takes space.",
          "name": "thresh",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "sum_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "sum_values",
          "type": 0
        },
        {
          "description": "",
          "name": "sum_shape",
          "type": 9
        }
      ],
      "summary": "Adds two `SparseTensor` objects to produce another `SparseTensor`."
    }
  },
  {
    "name": "SparseAddGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The SparseAdd op calculates A + B, where A, B, and the sum are all represented\nas `SparseTensor` objects.  This op takes in the upstream gradient w.r.t.\nnon-empty values of the sum, and outputs the gradients w.r.t. the non-empty\nvalues of A and B.",
      "inputs": [
        {
          "description": "1-D with shape `[nnz(sum)]`.  The gradient with respect to\nthe non-empty values of the sum.",
          "name": "backprop_val_grad",
          "type": 0
        },
        {
          "description": "2-D.  The `indices` of the `SparseTensor` A, size `[nnz(A), ndims]`.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the `SparseTensor` B, size `[nnz(B), ndims]`.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "2-D.  The `indices` of the sum `SparseTensor`, size\n`[nnz(sum), ndims]`.",
          "name": "sum_indices",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D with shape `[nnz(A)]`. The gradient with respect to the\nnon-empty values of A.",
          "name": "a_val_grad",
          "type": 0
        },
        {
          "description": "1-D with shape `[nnz(B)]`. The gradient with respect to the\nnon-empty values of B.",
          "name": "b_val_grad",
          "type": 0
        }
      ],
      "summary": "The gradient operator for the SparseAdd op."
    }
  },
  {
    "name": "SparseApplyAdadelta",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": ": Should be from a Variable().",
          "name": "accum_update",
          "type": 0
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay factor. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "Constant factor. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "var: Should be from a Variable()."
    }
  },
  {
    "name": "SparseApplyAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nvar -= lr * grad * (1 / sqrt(accum))",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the adagrad scheme."
    }
  },
  {
    "name": "SparseApplyAdagradDA",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_accumulator",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "gradient_squared_accumulator",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Training step number. Must be a scalar.",
          "name": "global_step",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update entries in '*var' and '*accum' according to the proximal adagrad scheme."
    }
  },
  {
    "name": "SparseApplyCenteredRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, mg, ms, and mom tensors is\nprotected by a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "The centered RMSProp algorithm uses an estimate of the centered second moment\n(i.e., the variance) for normalization, as opposed to regular RMSProp, which\nuses the (uncentered) second moment. This often helps with training, but is\nslightly more expensive in terms of computation and memory.\n\nNote that in dense implementation of this algorithm, mg, ms, and mom will\nupdate even if the grad is zero, but in this sparse implementation, mg, ms,\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nmean_grad = decay * mean_grad + (1-decay) * gradient\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon - mean_grad ** 2)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "mg",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the centered RMSProp algorithm."
    }
  },
  {
    "name": "SparseApplyFtrl",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\naccum_new = accum + grad * grad\nlinear += grad + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "SparseApplyFtrlV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var, accum and linear as follows:\ngrad_with_shrinkage = grad + 2 * l2_shrinkage * var\naccum_new = accum + grad_with_shrinkage * grad_with_shrinkage\nlinear += grad_with_shrinkage +\n    (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var\nquadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2\nvar = (sign(linear) * l1 - linear) / quadratic if |linear| > l1 else 0.0\naccum = accum_new",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "linear",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 shrinkage regulariation. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "",
          "name": "l2_shrinkage",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr_power",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' according to the Ftrl-proximal scheme."
    }
  },
  {
    "name": "SparseApplyMomentum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var and accum tensors will be protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        },
        {
          "description": "If `True`, the tensor passed to compute grad will be\nvar - lr * momentum * accum, so in the end, the var you get is actually\nvar - lr * momentum * accum.",
          "name": "use_nesterov",
          "type": "bool"
        }
      ],
      "description": "Set use_nesterov = True if you want to use Nesterov momentum.\n\nThat is for rows we have grad for, we update var and accum as follows:\n\naccum = accum * momentum + grad\nvar -= lr * accum",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "Momentum. Must be a scalar.",
          "name": "momentum",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update relevant entries in '*var' and '*accum' according to the momentum scheme."
    }
  },
  {
    "name": "SparseApplyProximalAdagrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, updating of the var and accum tensors will be protected by\na lock; otherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var and accum as follows:\naccum += grad * grad\nprox_v = var\nprox_v -= lr * grad * (1 / sqrt(accum))\nvar = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "accum",
          "type": 0
        },
        {
          "description": "Learning rate. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Sparse update entries in '*var' and '*accum' according to FOBOS algorithm."
    }
  },
  {
    "name": "SparseApplyProximalGradientDescent",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "That is for rows we have grad for, we update var as follows:\nprox_v = var - alpha * grad\nvar = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "alpha",
          "type": 0
        },
        {
          "description": "L1 regularization. Must be a scalar.",
          "name": "l1",
          "type": 0
        },
        {
          "description": "L2 regularization. Must be a scalar.",
          "name": "l2",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var and accum.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Sparse update '*var' as FOBOS algorithm with fixed learning rate."
    }
  },
  {
    "name": "SparseApplyRMSProp",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "If `True`, updating of the var, ms, and mom tensors is protected\nby a lock; otherwise the behavior is undefined, but may exhibit less\ncontention.",
          "name": "use_locking",
          "type": "bool"
        }
      ],
      "description": "Note that in dense implementation of this algorithm, ms and mom will\nupdate even if the grad is zero, but in this sparse implementation, ms\nand mom will not update in iterations during which the grad is zero.\n\nmean_square = decay * mean_square + (1-decay) * gradient ** 2\nDelta = learning_rate * gradient / sqrt(mean_square + epsilon)\n\nms <- rho * ms_{t-1} + (1-rho) * grad * grad\nmom <- momentum * mom_{t-1} + lr * grad / sqrt(ms + epsilon)\nvar <- var - mom",
      "inputs": [
        {
          "description": "Should be from a Variable().",
          "name": "var",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "ms",
          "type": 0
        },
        {
          "description": "Should be from a Variable().",
          "name": "mom",
          "type": 0
        },
        {
          "description": "Scaling factor. Must be a scalar.",
          "name": "lr",
          "type": 0
        },
        {
          "description": "Decay rate. Must be a scalar.",
          "name": "rho",
          "type": 0
        },
        {
          "description": "",
          "name": "momentum",
          "type": 0
        },
        {
          "description": "Ridge term. Must be a scalar.",
          "name": "epsilon",
          "type": 0
        },
        {
          "description": "The gradient.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "A vector of indices into the first dimension of var, ms and mom.",
          "name": "indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Same as \"var\".",
          "name": "out",
          "type": 0
        }
      ],
      "summary": "Update '*var' according to the RMSProp algorithm."
    }
  },
  {
    "name": "SparseConcat",
    "schema": {
      "attributes": [
        {
          "description": "Dimension to concatenate along. Must be in range [-rank, rank),\nwhere rank is the number of dimensions in each input `SparseTensor`.",
          "name": "concat_dim",
          "type": "int"
        },
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Concatenation is with respect to the dense versions of these sparse tensors.\nIt is assumed that each input is a `SparseTensor` whose elements are ordered\nalong increasing dimension number.\n\nAll inputs' shapes must match, except for the concat dimension.  The\n`indices`, `values`, and `shapes` lists must have the same length.\n\nThe output shape is identical to the inputs', except along the concat\ndimension, where it is the sum of the inputs' sizes along that dimension.\n\nThe output elements will be resorted to preserve the sort order along\nincreasing dimension number.\n\nThis op runs in `O(M log M)` time, where `M` is the total number of non-empty\nvalues across all inputs. This is due to the need for an internal sort in\norder to concatenate efficiently across an arbitrary dimension.\n\nFor example, if `concat_dim = 1` and the inputs are\n\n    sp_inputs[0]: shape = [2, 3]\n    [0, 2]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    sp_inputs[1]: shape = [2, 4]\n    [0, 1]: \"d\"\n    [0, 2]: \"e\"\n\nthen the output will be\n\n    shape = [2, 7]\n    [0, 2]: \"a\"\n    [0, 4]: \"d\"\n    [0, 5]: \"e\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\nGraphically this is equivalent to doing\n\n    [    a] concat [  d e  ] = [    a   d e  ]\n    [b c  ]        [       ]   [b c          ]",
      "inputs": [
        {
          "description": "2-D.  Indices of each input `SparseTensor`.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D.  Non-empty values of each `SparseTensor`.",
          "name": "values",
          "type": 0
        },
        {
          "description": "1-D.  Shapes of each `SparseTensor`.",
          "name": "shapes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  Indices of the concatenated `SparseTensor`.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  Non-empty values of the concatenated `SparseTensor`.",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the concatenated `SparseTensor`.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Concatenates a list of `SparseTensor` along the specified dimension."
    }
  },
  {
    "name": "SparseConditionalAccumulator",
    "schema": {
      "attributes": [
        {
          "description": "The type of the value being accumulated.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The shape of the values.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "If non-empty, this accumulator is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this accumulator will be shared under the given name\nacross multiple sessions.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The accumulator accepts gradients marked with local_step greater or\nequal to the most recent global_step known to the accumulator. The\naverage can be extracted from the accumulator, provided sufficient\ngradients have been accumulated. Extracting the average automatically\nresets the aggregate to 0, and increments the global_step recorded by\nthe accumulator.",
      "outputs": [
        {
          "description": "The handle to the accumulator.",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "A conditional accumulator for aggregating sparse gradients."
    }
  },
  {
    "name": "SparseCross",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "If true, returns the hash of the cross instead of the string.\nThis will allow us avoiding string manipulations.",
          "name": "hashed_output",
          "type": "bool"
        },
        {
          "description": "It is used if hashed_output is true.\noutput = hashed_value%num_buckets if num_buckets > 0 else hashed_value.",
          "name": "num_buckets",
          "type": "int"
        },
        {
          "description": "Specify the hash_key that will be used by the `FingerprintCat64`\nfunction to combine the crosses fingerprints.",
          "name": "hash_key",
          "type": "int"
        },
        {
          "description": "",
          "name": "sparse_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "dense_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        },
        {
          "description": "",
          "name": "internal_type",
          "type": "type"
        }
      ],
      "description": "The op takes two lists, one of 2D `SparseTensor` and one of 2D `Tensor`, each\nrepresenting features of one feature column. It outputs a 2D `SparseTensor` with\nthe batchwise crosses of these features.\n\nFor example, if the inputs are\n\n    inputs[0]: SparseTensor with shape = [2, 2]\n    [0, 0]: \"a\"\n    [1, 0]: \"b\"\n    [1, 1]: \"c\"\n\n    inputs[1]: SparseTensor with shape = [2, 1]\n    [0, 0]: \"d\"\n    [1, 0]: \"e\"\n\n    inputs[2]: Tensor [[\"f\"], [\"g\"]]\n\nthen the output will be\n\n    shape = [2, 2]\n    [0, 0]: \"a_X_d_X_f\"\n    [1, 0]: \"b_X_e_X_g\"\n    [1, 1]: \"c_X_e_X_g\"\n\nif hashed_output=true then the output will be\n\n    shape = [2, 2]\n    [0, 0]: FingerprintCat64(\n                Fingerprint64(\"f\"), FingerprintCat64(\n                    Fingerprint64(\"d\"), Fingerprint64(\"a\")))\n    [1, 0]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"b\")))\n    [1, 1]: FingerprintCat64(\n                Fingerprint64(\"g\"), FingerprintCat64(\n                    Fingerprint64(\"e\"), Fingerprint64(\"c\")))",
      "inputs": [
        {
          "description": "2-D.  Indices of each input `SparseTensor`.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D.   values of each `SparseTensor`.",
          "name": "values",
          "type": 0
        },
        {
          "description": "1-D.   Shapes of each `SparseTensor`.",
          "name": "shapes",
          "type": 9
        },
        {
          "description": "2-D.    Columns represented by dense `Tensor`.",
          "name": "dense_inputs",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "2-D.  Indices of the concatenated `SparseTensor`.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  Non-empty values of the concatenated or hashed\n`SparseTensor`.",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the concatenated `SparseTensor`.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Generates sparse cross from a list of sparse and dense tensors."
    }
  },
  {
    "name": "SparseDenseCwiseAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "(1) Broadcasts the dense side to have the same shape as the sparse side, if\n    eligible;\n(2) Then, only the dense values pointed to by the indices of the SparseTensor\n    participate in the cwise addition.\n\nBy these rules, the result is a logical SparseTensor with exactly the same\nindices and shape, but possibly with different non-zero values.  The output of\nthis Op is the resultant non-zero values.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        },
        {
          "description": "`R`-D.  The dense Tensor operand.",
          "name": "dense",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `N` values that are operated on.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Adds up a SparseTensor and a dense Tensor, using these special rules:"
    }
  },
  {
    "name": "SparseDenseCwiseDiv",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        },
        {
          "description": "`R`-D.  The dense Tensor operand.",
          "name": "dense",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `N` values that are operated on.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Component-wise divides a SparseTensor by a dense Tensor."
    }
  },
  {
    "name": "SparseDenseCwiseMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The output locations corresponding to the implicitly zero elements in the sparse\ntensor will be zero (i.e., will not take up storage space), regardless of the\ncontents of the dense tensor (even if it's +/-INF and that INF*0 == NaN).\n\n*Limitation*: this Op only broadcasts the dense side to the sparse side, but not\nthe other direction.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        },
        {
          "description": "`R`-D.  The dense Tensor operand.",
          "name": "dense",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `N` values that are operated on.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Component-wise multiplies a SparseTensor by a dense Tensor."
    }
  },
  {
    "name": "SparseFillEmptyRows",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The input `SparseTensor` is represented via the tuple of inputs\n(`indices`, `values`, `dense_shape`).  The output `SparseTensor` has the\nsame `dense_shape` but with indices `output_indices` and values\n`output_values`.\n\nThis op inserts a single entry for every row that doesn't have any values.\nThe index is created as `[row, 0, ..., 0]` and the inserted value\nis `default_value`.\n\nFor example, suppose `sp_input` has shape `[5, 6]` and non-empty values:\n\n    [0, 1]: a\n    [0, 3]: b\n    [2, 0]: c\n    [3, 1]: d\n\nRows 1 and 4 are empty, so the output will be of shape `[5, 6]` with values:\n\n    [0, 1]: a\n    [0, 3]: b\n    [1, 0]: default_value\n    [2, 0]: c\n    [3, 1]: d\n    [4, 0]: default_value\n\nThe output `SparseTensor` will be in row-major order and will have the\nsame shape as the input.\n\nThis op also returns an indicator vector shaped `[dense_shape[0]]` such that\n\n    empty_row_indicator[i] = True iff row i was an empty row.\n\nAnd a reverse index map vector shaped `[indices.shape[0]]` that is used during\nbackpropagation,\n\n    reverse_index_map[j] = out_j s.t. indices[j, :] == output_indices[out_j, :]",
      "inputs": [
        {
          "description": "2-D. the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D. the values of the sparse tensor.",
          "name": "values",
          "type": 0
        },
        {
          "description": "1-D. the shape of the sparse tensor.",
          "name": "dense_shape",
          "type": 9
        },
        {
          "description": "0-D. default value to insert into location `[row, 0, ..., 0]`\n  for rows missing from the input sparse tensor.\noutput indices: 2-D. the indices of the filled sparse tensor.",
          "name": "default_value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D. the values of the filled sparse tensor.",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "1-D. whether the dense row was missing in the\ninput sparse tensor.",
          "name": "empty_row_indicator",
          "type": 10
        },
        {
          "description": "1-D. a map from the input indices to the output indices.",
          "name": "reverse_index_map",
          "type": 9
        }
      ],
      "summary": "Fills empty rows in the input 2-D `SparseTensor` with a default value."
    }
  },
  {
    "name": "SparseFillEmptyRowsGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Takes vectors reverse_index_map, shaped `[N]`, and grad_values,\nshaped `[N_full]`, where `N_full >= N` and copies data into either\n`d_values` or `d_default_value`.  Here `d_values` is shaped `[N]` and\n`d_default_value` is a scalar.\n\n  d_values[j] = grad_values[reverse_index_map[j]]\n  d_default_value = sum_{k : 0 .. N_full - 1} (\n     grad_values[k] * 1{k not in reverse_index_map})",
      "inputs": [
        {
          "description": "1-D.  The reverse index map from SparseFillEmptyRows.",
          "name": "reverse_index_map",
          "type": 9
        },
        {
          "description": "1-D.  The gradients from backprop.",
          "name": "grad_values",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The backprop into values.",
          "name": "d_values",
          "type": 0
        },
        {
          "description": "0-D.  The backprop into default_value.",
          "name": "d_default_value",
          "type": 0
        }
      ],
      "summary": "The gradient of SparseFillEmptyRows."
    }
  },
  {
    "name": "SparseMatMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "transpose_a",
          "type": "bool"
        },
        {
          "description": "",
          "name": "transpose_b",
          "type": "bool"
        },
        {
          "description": "",
          "name": "a_is_sparse",
          "type": "bool"
        },
        {
          "description": "",
          "name": "b_is_sparse",
          "type": "bool"
        },
        {
          "description": "",
          "name": "Ta",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tb",
          "type": "type"
        }
      ],
      "description": "The inputs must be two-dimensional matrices and the inner dimension of \"a\" must\nmatch the outer dimension of \"b\". This op is optimized for the case where at\nleast one of \"a\" or \"b\" is sparse. The breakeven for using this versus a dense\nmatrix multiply on one platform was 30% zero values in the sparse matrix.\n\nThe gradient computation of this operation will only take advantage of sparsity\nin the input gradient when that gradient comes from a Relu.",
      "inputs": [
        {
          "description": "",
          "name": "a",
          "type": 0
        },
        {
          "description": "",
          "name": "b",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "product",
          "type": 1
        }
      ],
      "summary": "Multiply matrix \"a\" by matrix \"b\"."
    }
  },
  {
    "name": "SparseReduceMax",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_max()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "`R-K`-D.  The reduced Tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the max of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReduceMaxSparse",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_max()`.  In contrast to SparseReduceMax, this Op returns a\nSparseTensor.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Computes the max of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReduceSum",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In particular, this Op also returns a dense `Tensor`\ninstead of a sparse one.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "`R-K`-D.  The reduced Tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the sum of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReduceSumSparse",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This Op takes a SparseTensor and is the sparse counterpart to\n`tf.reduce_sum()`.  In contrast to SparseReduceSum, this Op returns a\nSparseTensor.\n\nReduces `sp_input` along the dimensions given in `reduction_axes`.  Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_axes`. If `keep_dims` is true, the reduced dimensions are retained\nwith length 1.\n\nIf `reduction_axes` has no entries, all dimensions are reduced, and a tensor\nwith a single element is returned.  Additionally, the axes can be negative,\nwhich are interpreted according to the indexing rules in Python.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  Length-`K` vector containing the reduction axes.",
          "name": "reduction_axes",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Computes the sum of elements across dimensions of a SparseTensor."
    }
  },
  {
    "name": "SparseReorder",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Note that by convention, all sparse ops preserve the canonical ordering along\nincreasing dimension number. The only time ordering can be violated is during\nmanual manipulation of the indices and values vectors to add entries.\n\nReordering does not affect the shape of the SparseTensor.\n\nIf the tensor has rank `R` and `N` non-empty values, `input_indices` has\nshape `[N, R]`, input_values has length `N`, and input_shape has length `R`.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, possibly not in canonical ordering.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `input_indices`.",
          "name": "input_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "input_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  `N x R` matrix with the same indices as input_indices, but\nin canonical row-major ordering.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `output_indices`.",
          "name": "output_values",
          "type": 0
        }
      ],
      "summary": "Reorders a SparseTensor into the canonical, row-major ordering."
    }
  },
  {
    "name": "SparseReshape",
    "schema": {
      "description": "This operation has the same semantics as reshape on the represented dense\ntensor.  The `input_indices` are recomputed based on the requested `new_shape`.\n\nIf one component of `new_shape` is the special value -1, the size of that\ndimension is computed so that the total dense size remains constant.  At\nmost one component of `new_shape` can be -1.  The number of dense elements\nimplied by `new_shape` must be the same as the number of dense elements\noriginally implied by `input_shape`.\n\nReshaping does not affect the order of values in the SparseTensor.\n\nIf the input tensor has rank `R_in` and `N` non-empty values, and `new_shape`\nhas length `R_out`, then `input_indices` has shape `[N, R_in]`,\n`input_shape` has length `R_in`, `output_indices` has shape `[N, R_out]`, and\n`output_shape` has length `R_out`.",
      "inputs": [
        {
          "description": "2-D.  `N x R_in` matrix with the indices of non-empty values in a\nSparseTensor.",
          "name": "input_indices",
          "type": 9
        },
        {
          "description": "1-D.  `R_in` vector with the input SparseTensor's dense shape.",
          "name": "input_shape",
          "type": 9
        },
        {
          "description": "1-D.  `R_out` vector with the requested new dense shape.",
          "name": "new_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  `N x R_out` matrix with the updated indices of non-empty\nvalues in the output SparseTensor.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  `R_out` vector with the full dense shape of the output\nSparseTensor.  This is the same as `new_shape` but with any -1 dimensions\nfilled in.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Reshapes a SparseTensor to represent values in a new dense shape."
    }
  },
  {
    "name": "SparseSegmentMean",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nLike `SegmentMean`, but `segment_ids` can have rank less than `data`'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the mean along sparse segments of a tensor."
    }
  },
  {
    "name": "SparseSegmentMeanGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
      "inputs": [
        {
          "description": "gradient propagated to the SparseSegmentMean op.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "indices passed to the corresponding SparseSegmentMean op.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "segment_ids passed to the corresponding SparseSegmentMean op.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "dimension 0 of \"data\" passed to SparseSegmentMean op.",
          "name": "output_dim0",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients for SparseSegmentMean."
    }
  },
  {
    "name": "SparseSegmentSqrtN",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "N is the size of the segment being reduced.\n\nRead @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt of N."
    }
  },
  {
    "name": "SparseSegmentSqrtNGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Returns tensor \"output\" with same shape as grad, except for dimension 0 whose\nvalue is output_dim0.",
      "inputs": [
        {
          "description": "gradient propagated to the SparseSegmentSqrtN op.",
          "name": "grad",
          "type": 0
        },
        {
          "description": "indices passed to the corresponding SparseSegmentSqrtN op.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "segment_ids passed to the corresponding SparseSegmentSqrtN op.",
          "name": "segment_ids",
          "type": 3
        },
        {
          "description": "dimension 0 of \"data\" passed to SparseSegmentSqrtN op.",
          "name": "output_dim0",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes gradients for SparseSegmentSqrtN."
    }
  },
  {
    "name": "SparseSegmentSum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nLike `SegmentSum`, but `segment_ids` can have rank less than `data`'s first\ndimension, selecting a subset of dimension 0, specified by `indices`.\n\nFor example:\n\n```python\nc = tf.constant([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]])\n\n# Select two rows, one segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 0]))\n# => [[0 0 0 0]]\n\n# Select two rows, two segment.\ntf.sparse_segment_sum(c, tf.constant([0, 1]), tf.constant([0, 1]))\n# => [[ 1  2  3  4]\n#     [-1 -2 -3 -4]]\n\n# Select all rows, two segments.\ntf.sparse_segment_sum(c, tf.constant([0, 1, 2]), tf.constant([0, 0, 1]))\n# => [[0 0 0 0]\n#     [5 6 7 8]]\n\n# Which is equivalent to:\ntf.segment_sum(c, tf.constant([0, 0, 1]))\n```",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor. Has same rank as `segment_ids`.",
          "name": "indices",
          "type": 0
        },
        {
          "description": "A 1-D tensor. Values should be sorted and can be repeated.",
          "name": "segment_ids",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `k`, the number of segments.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the sum along sparse segments of a tensor."
    }
  },
  {
    "name": "SparseSlice",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For example, if the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    sparse_slice([0, 0], [2, 4]) = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    sparse_slice([0, 4], [2, 3]) = shape = [2, 3]\n    [ d e  ]\n    [      ]",
      "inputs": [
        {
          "description": "2-D tensor represents the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D tensor represents the values of the sparse tensor.",
          "name": "values",
          "type": 0
        },
        {
          "description": "1-D. tensor represents the shape of the sparse tensor.",
          "name": "shape",
          "type": 9
        },
        {
          "description": "1-D. tensor represents the start of the slice.",
          "name": "start",
          "type": 9
        },
        {
          "description": "1-D. tensor represents the size of the slice.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors.",
          "name": "size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "A list of 1-D tensors represents the values of the output sparse\ntensors.",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "A list of 1-D tensors represents the shape of the output sparse\ntensors.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Slice a `SparseTensor` based on the `start` and `size`."
    }
  },
  {
    "name": "SparseSoftmax",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The inputs represent an N-D SparseTensor  with logical shape `[..., B, C]`\n(where `N >= 2`), and with indices sorted in the canonical lexicographic order.\n\nThis op is equivalent to applying the normal `tf.nn.softmax()` to each innermost\nlogical submatrix with shape `[B, C]`, but with the catch that *the implicitly\nzero elements do not participate*.  Specifically, the algorithm is equivalent\nto the following:\n\n  (1) Applies `tf.nn.softmax()` to a densified view of each innermost submatrix\n      with shape `[B, C]`, along the size-C dimension;\n  (2) Masks out the original implicitly-zero locations;\n  (3) Renormalizes the remaining elements.\n\nHence, the `SparseTensor` result has exactly the same non-zero indices and\nshape.",
      "inputs": [
        {
          "description": "2-D.  `NNZ x R` matrix with the indices of non-empty values in a\nSparseTensor, in canonical ordering.",
          "name": "sp_indices",
          "type": 9
        },
        {
          "description": "1-D.  `NNZ` non-empty values corresponding to `sp_indices`.",
          "name": "sp_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "sp_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "1-D.  The `NNZ` values for the result `SparseTensor`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Applies softmax to a batched N-D `SparseTensor`."
    }
  },
  {
    "name": "SparseSoftmaxCrossEntropyWithLogits",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tlabels",
          "type": "type"
        }
      ],
      "description": "Unlike `SoftmaxCrossEntropyWithLogits`, this operation does not accept\na matrix of label probabilities, but rather a single label per row\nof features.  This label is considered to have probability 1.0 for the\ngiven row.\n\nInputs are the logits, not probabilities.",
      "inputs": [
        {
          "description": "batch_size x num_classes matrix",
          "name": "features",
          "type": 0
        },
        {
          "description": "batch_size vector with values in [0, num_classes).\nThis is the label for the given minibatch entry.",
          "name": "labels",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Per example loss (batch_size vector).",
          "name": "loss",
          "type": 0
        },
        {
          "description": "backpropagated gradients (batch_size x num_classes matrix).",
          "name": "backprop",
          "type": 0
        }
      ],
      "summary": "Computes softmax cross entropy cost and gradients to backpropagate."
    }
  },
  {
    "name": "SparseSparseMaximum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Assumes the two SparseTensors have the same shape, i.e., no broadcasting.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, in the canonical lexicographic ordering.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `a_indices`.",
          "name": "a_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "counterpart to `a_indices` for the other operand.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "counterpart to `a_values` for the other operand; must be of the same dtype.",
          "name": "b_values",
          "type": 0
        },
        {
          "description": "counterpart to `a_shape` for the other operand; the two shapes must be equal.",
          "name": "b_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  The indices of the output SparseTensor.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  The values of the output SparseTensor.",
          "name": "output_values",
          "type": 0
        }
      ],
      "summary": "Returns the element-wise max of two SparseTensors."
    }
  },
  {
    "name": "SparseSparseMinimum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Assumes the two SparseTensors have the same shape, i.e., no broadcasting.",
      "inputs": [
        {
          "description": "2-D.  `N x R` matrix with the indices of non-empty values in a\nSparseTensor, in the canonical lexicographic ordering.",
          "name": "a_indices",
          "type": 9
        },
        {
          "description": "1-D.  `N` non-empty values corresponding to `a_indices`.",
          "name": "a_values",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the input SparseTensor.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "counterpart to `a_indices` for the other operand.",
          "name": "b_indices",
          "type": 9
        },
        {
          "description": "counterpart to `a_values` for the other operand; must be of the same dtype.",
          "name": "b_values",
          "type": 0
        },
        {
          "description": "counterpart to `a_shape` for the other operand; the two shapes must be equal.",
          "name": "b_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  The indices of the output SparseTensor.",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "1-D.  The values of the output SparseTensor.",
          "name": "output_values",
          "type": 0
        }
      ],
      "summary": "Returns the element-wise min of two SparseTensors."
    }
  },
  {
    "name": "SparseSplit",
    "schema": {
      "attributes": [
        {
          "description": "The number of ways to split.",
          "name": "num_split",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the `shape[split_dim]` is not an integer multiple of `num_split`. Slices\n`[0 : shape[split_dim] % num_split]` gets one extra dimension.\nFor example, if `split_dim = 1` and `num_split = 2` and the input is\n\n    input_tensor = shape = [2, 7]\n    [    a   d e  ]\n    [b c          ]\n\nGraphically the output tensors are:\n\n    output_tensor[0] = shape = [2, 4]\n    [    a  ]\n    [b c    ]\n\n    output_tensor[1] = shape = [2, 3]\n    [ d e  ]\n    [      ]",
      "inputs": [
        {
          "description": "0-D.  The dimension along which to split.  Must be in the range\n`[0, rank(shape))`.",
          "name": "split_dim",
          "type": 9
        },
        {
          "description": "2-D tensor represents the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "1-D tensor represents the values of the sparse tensor.",
          "name": "values",
          "type": 0
        },
        {
          "description": "1-D. tensor represents the shape of the sparse tensor.\noutput indices: A list of 1-D tensors represents the indices of the output\nsparse tensors.",
          "name": "shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output_indices",
          "type": 9
        },
        {
          "description": "A list of 1-D tensors represents the values of the output sparse\ntensors.",
          "name": "output_values",
          "type": 0
        },
        {
          "description": "A list of 1-D tensors represents the shape of the output sparse\ntensors.",
          "name": "output_shape",
          "type": 9
        }
      ],
      "summary": "Split a `SparseTensor` into `num_split` tensors along one dimension."
    }
  },
  {
    "name": "SparseTensorDenseAdd",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "This Op does not require `a_indices` be sorted in standard lexicographic order.",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`, with shape `[nnz, ndims]`.",
          "name": "a_indices",
          "type": 0
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`, with shape `[nnz]`.",
          "name": "a_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`, with shape `[ndims]`.",
          "name": "a_shape",
          "type": 0
        },
        {
          "description": "`ndims`-D Tensor.  With shape `a_shape`.",
          "name": "b",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Adds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`."
    }
  },
  {
    "name": "SparseTensorDenseMatMul",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        },
        {
          "description": "Use the adjoint of A in the matrix multiply.  If A is complex, this\nis transpose(conj(A)).  Otherwise it's transpose(A).",
          "name": "adjoint_a",
          "type": "bool"
        },
        {
          "description": "Use the adjoint of B in the matrix multiply.  If B is complex, this\nis transpose(conj(B)).  Otherwise it's transpose(B).",
          "name": "adjoint_b",
          "type": "bool"
        }
      ],
      "description": "No validity checking is performed on the indices of A.  However, the following\ninput format is recommended for optimal behavior:\n\nif adjoint_a == false:\n  A should be sorted in lexicographically increasing order.  Use SparseReorder\n  if you're not sure.\nif adjoint_a == true:\n  A should be sorted in order of increasing dimension 1 (i.e., \"column major\"\n  order instead of \"row major\" order).",
      "inputs": [
        {
          "description": "2-D.  The `indices` of the `SparseTensor`, size `[nnz, 2]` Matrix.",
          "name": "a_indices",
          "type": 0
        },
        {
          "description": "1-D.  The `values` of the `SparseTensor`, size `[nnz]` Vector.",
          "name": "a_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the `SparseTensor`, size `[2]` Vector.",
          "name": "a_shape",
          "type": 9
        },
        {
          "description": "2-D.  A dense Matrix.",
          "name": "b",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "product",
          "type": 0
        }
      ],
      "summary": "Multiply SparseTensor (of rank 2) \"A\" by dense matrix \"B\"."
    }
  },
  {
    "name": "SparseTensorSliceDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Tvalues",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "indices",
          "type": 9
        },
        {
          "description": "",
          "name": "values",
          "type": 0
        },
        {
          "description": "",
          "name": "dense_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that splits a SparseTensor into elements row-wise."
    }
  },
  {
    "name": "SparseToDense",
    "schema": {
      "attributes": [
        {
          "description": "If true, indices are checked to make sure they are sorted in\nlexicographic order and that there are no repeats.",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Builds an array `dense` with shape `output_shape` such that\n\n```\n# If sparse_indices is scalar\ndense[i] = (i == sparse_indices ? sparse_values : default_value)\n\n# If sparse_indices is a vector, then for each i\ndense[sparse_indices[i]] = sparse_values[i]\n\n# If sparse_indices is an n by d matrix, then for each i in [0, n)\ndense[sparse_indices[i][0], ..., sparse_indices[i][d-1]] = sparse_values[i]\n```\n\nAll other values in `dense` are set to `default_value`.  If `sparse_values` is a\nscalar, all sparse indices are set to this single value.\n\nIndices should be sorted in lexicographic order, and indices must not\ncontain any repeats. If `validate_indices` is true, these properties\nare checked during execution.",
      "inputs": [
        {
          "description": "0-D, 1-D, or 2-D.  `sparse_indices[i]` contains the complete\nindex where `sparse_values[i]` will be placed.",
          "name": "sparse_indices",
          "type": 0
        },
        {
          "description": "1-D.  Shape of the dense output tensor.",
          "name": "output_shape",
          "type": 0
        },
        {
          "description": "1-D.  Values corresponding to each row of `sparse_indices`,\nor a scalar value to be used for all sparse indices.",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "Scalar value to set for indices not specified in\n`sparse_indices`.",
          "name": "default_value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Dense output tensor of shape `output_shape`.",
          "name": "dense",
          "type": 0
        }
      ],
      "summary": "Converts a sparse representation into a dense tensor."
    }
  },
  {
    "name": "SparseToSparseSetOperation",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "set_operation",
          "type": "string"
        },
        {
          "description": "",
          "name": "validate_indices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "See SetOperationOp::SetOperationFromContext for values of `set_operation`.\n\nIf `validate_indices` is `True`, `SparseToSparseSetOperation` validates the\norder and range of `set1` and `set2` indices.\n\nInput `set1` is a `SparseTensor` represented by `set1_indices`, `set1_values`,\nand `set1_shape`. For `set1` ranked `n`, 1st `n-1` dimensions must be the same\nas `set2`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nInput `set2` is a `SparseTensor` represented by `set2_indices`, `set2_values`,\nand `set2_shape`. For `set2` ranked `n`, 1st `n-1` dimensions must be the same\nas `set1`. Dimension `n` contains values in a set, duplicates are allowed but\nignored.\n\nIf `validate_indices` is `True`, this op validates the order and range of `set1`\nand `set2` indices.\n\nOutput `result` is a `SparseTensor` represented by `result_indices`,\n`result_values`, and `result_shape`. For `set1` and `set2` ranked `n`, this\nhas rank `n` and the same 1st `n-1` dimensions as `set1` and `set2`. The `nth`\ndimension contains the result of `set_operation` applied to the corresponding\n`[0...n-1]` dimension of `set`.",
      "inputs": [
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set1_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set1_values",
          "type": 0
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`. `set1_shape[0...n-1]` must\nbe the same as `set2_shape[0...n-1]`, `set1_shape[n]` is the\nmax set size across `0...n-1` dimensions.",
          "name": "set1_shape",
          "type": 9
        },
        {
          "description": "2D `Tensor`, indices of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_indices",
          "type": 9
        },
        {
          "description": "1D `Tensor`, values of a `SparseTensor`. Must be in row-major\norder.",
          "name": "set2_values",
          "type": 0
        },
        {
          "description": "1D `Tensor`, shape of a `SparseTensor`. `set2_shape[0...n-1]` must\nbe the same as `set1_shape[0...n-1]`, `set2_shape[n]` is the\nmax set size across `0...n-1` dimensions.",
          "name": "set2_shape",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2D indices of a `SparseTensor`.",
          "name": "result_indices",
          "type": 9
        },
        {
          "description": "1D values of a `SparseTensor`.",
          "name": "result_values",
          "type": 0
        },
        {
          "description": "1D `Tensor` shape of a `SparseTensor`. `result_shape[0...n-1]` is\nthe same as the 1st `n-1` dimensions of `set1` and `set2`, `result_shape[n]`\nis the max result set size across all `0...n-1` dimensions.",
          "name": "result_shape",
          "type": 9
        }
      ],
      "summary": "Applies set operation along last dimension of 2 `SparseTensor` inputs."
    }
  },
  {
    "name": "Split",
    "schema": {
      "attributes": [
        {
          "description": "The number of ways to split.  Must evenly divide\n`value.shape[split_dim]`.",
          "name": "num_split",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "0-D.  The dimension along which to split.  Must be in the range\n`[-rank(value), rank(value))`.",
          "name": "split_dim",
          "type": 3
        },
        {
          "description": "The tensor to split.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "They are identically shaped tensors, whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`values.shape[split_dim] / num_split`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Splits a tensor into `num_split` tensors along one dimension."
    }
  },
  {
    "name": "SplitV",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "num_split",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tlen",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The tensor to split.",
          "name": "value",
          "type": 0
        },
        {
          "description": "list containing the sizes of each output tensor along the split\ndimension. Must sum to the dimension of value along split_dim.\nCan contain one -1 indicating that dimension is to be inferred.",
          "name": "size_splits",
          "type": 0
        },
        {
          "description": "0-D.  The dimension along which to split.  Must be in the range\n`[-rank(value), rank(value))`.",
          "name": "split_dim",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Tensors whose shape matches that of `value`\nexcept along `split_dim`, where their sizes are\n`size_splits[i]`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Splits a tensor into `num_split` tensors along one dimension."
    }
  },
  {
    "name": "SqlDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "The database type. Currently, the only supported type is 'sqlite'.",
          "name": "driver_name",
          "type": 7
        },
        {
          "description": "A connection string to connect to the database.",
          "name": "data_source_name",
          "type": 7
        },
        {
          "description": "A SQL query to execute.",
          "name": "query",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that executes a SQL query and emits rows of the result set."
    }
  },
  {
    "name": "Sqrt",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = \\sqrt{x} = x^{1/2}\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes square root of x element-wise."
    }
  },
  {
    "name": "SqrtGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * 0.5 / y`, where `y = sqrt(x)`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the gradient for the sqrt of `x` wrt its input."
    }
  },
  {
    "name": "Square",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "I.e., \\\\(y = x * x = x^2\\\\).",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes square of x element-wise."
    }
  },
  {
    "name": "SquaredDifference",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `SquaredDifference` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns (x - y)(x - y) element-wise."
    }
  },
  {
    "name": "Squeeze",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "If specified, only squeezes the dimensions listed. The dimension\nindex starts at 0. It is an error to squeeze a dimension that is not 1. Must\nbe in the range `[-rank(input), rank(input))`.",
          "name": "squeeze_dims",
          "type": "list(int)"
        }
      ],
      "description": "Given a tensor `input`, this operation returns a tensor of the same type with\nall dimensions of size 1 removed. If you don't want to remove all size 1\ndimensions, you can remove specific size 1 dimensions by specifying\n`squeeze_dims`.\n\nFor example:\n\n```\n# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t)) ==> [2, 3]\n```\n\nOr, to remove specific size 1 dimensions:\n\n```\n# 't' is a tensor of shape [1, 2, 1, 3, 1, 1]\nshape(squeeze(t, [2, 4])) ==> [1, 2, 3, 1]\n```",
      "inputs": [
        {
          "description": "The `input` to squeeze.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Contains the same data as `input`, but has one or more dimensions of\nsize 1 removed.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Removes dimensions of size 1 from the shape of a tensor."
    }
  },
  {
    "name": "Stack",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "elem_type",
          "type": "type"
        },
        {
          "description": "",
          "name": "stack_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated, use StackV2."
    }
  },
  {
    "name": "StackClose",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated, use StackCloseV2."
    }
  },
  {
    "name": "StackCloseV2",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a stack.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Delete the stack from its resource container."
    }
  },
  {
    "name": "StackPop",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "elem_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "elem",
          "type": 0
        }
      ],
      "summary": "Deprecated, use StackPopV2."
    }
  },
  {
    "name": "StackPopV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is popped.",
          "name": "elem_type",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a stack.",
          "name": "handle",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "The tensor that is popped from the top of the stack.",
          "name": "elem",
          "type": 0
        }
      ],
      "summary": "Pop the element at the top of the stack."
    }
  },
  {
    "name": "StackPush",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "swap_memory",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "elem",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Deprecated, use StackPushV2."
    }
  },
  {
    "name": "StackPushV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Swap `elem` to CPU. Default to false.",
          "name": "swap_memory",
          "type": "bool"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a stack.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The tensor to be pushed onto the stack.",
          "name": "elem",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The same tensor as the input 'elem'.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Push an element onto the stack."
    }
  },
  {
    "name": "StackV2",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elements on the stack.",
          "name": "elem_type",
          "type": "type"
        },
        {
          "description": "Overrides the name used for the temporary stack resource. Default\nvalue is the name of the 'Stack' op (which is guaranteed unique).",
          "name": "stack_name",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "The maximum size of the stack if non-negative. If negative, the stack\nsize is unlimited.",
          "name": "max_size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The handle to the stack.",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "A stack that produces elements in first-in last-out order."
    }
  },
  {
    "name": "Stage",
    "schema": {
      "attributes": [
        {
          "description": "Maximum number of elements in the Staging Area. If > 0, inserts\non the container will block when the capacity is reached.",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "The maximum number of bytes allowed for Tensors in the Staging Area.\nIf > 0, inserts will block until sufficient space is available.",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "If non-empty, this queue is placed in the given container. Otherwise,\na default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "It is necessary to match this name to the matching Unstage Op.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The basic functionality of this Op is similar to a queue with many\nfewer capabilities and options.  This Op is optimized for performance.",
      "inputs": [
        {
          "description": "a list of tensors\ndtypes A list of data types that inserted values should adhere to.",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Stage values similar to a lightweight Enqueue."
    }
  },
  {
    "name": "StageClear",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "summary": "Op removes all elements in the underlying container."
    }
  },
  {
    "name": "StagePeek",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "underlying container does not contain sufficient elements\nthis op will block until it does.   This Op is optimized for\nperformance.",
      "inputs": [
        {
          "description": "",
          "name": "index",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op peeks at the values at the specified index.  If the"
    }
  },
  {
    "name": "StageSize",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Op returns the number of elements in the underlying container."
    }
  },
  {
    "name": "StatelessRandomNormal",
    "schema": {
      "attributes": [
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values will have mean 0 and standard deviation 1.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs deterministic pseudorandom values from a normal distribution."
    }
  },
  {
    "name": "StatelessRandomUniform",
    "schema": {
      "attributes": [
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values follow a uniform distribution in the range `[0, 1)`. The\nlower bound 0 is included in the range, while the upper bound 1 is excluded.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs deterministic pseudorandom random values from a uniform distribution."
    }
  },
  {
    "name": "StatelessTruncatedNormal",
    "schema": {
      "attributes": [
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.\n\nThe outputs are a deterministic function of `shape` and `seed`.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        },
        {
          "description": "2 seeds (shape [2]).",
          "name": "seed",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "Random values with specified shape.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs deterministic pseudorandom values from a truncated normal distribution."
    }
  },
  {
    "name": "StatsAggregatorHandle",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Creates a statistics manager resource."
    }
  },
  {
    "name": "StatsAggregatorSummary",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "iterator",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Produces a summary of any statistics recorded by the given statistics manager."
    }
  },
  {
    "name": "StopGradient",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "When executed in a graph, this op outputs its input tensor as-is.\n\nWhen building ops to compute gradients, this op prevents the contribution of\nits inputs to be taken into account.  Normally, the gradient generator adds ops\nto a graph to compute the derivatives of a specified 'loss' by recursively\nfinding out inputs that contributed to its computation.  If you insert this op\nin the graph it inputs are masked from the gradient generator.  They are not\ntaken into account for computing gradients.\n\nThis is useful any time you want to compute a value with TensorFlow but need\nto pretend that the value was a constant. Some examples include:\n\n*  The *EM* algorithm where the *M-step* should not involve backpropagation\n   through the output of the *E-step*.\n*  Contrastive divergence training of Boltzmann machines where, when\n   differentiating the energy function, the training must not backpropagate\n   through the graph that generated the samples from the model.\n*  Adversarial training, where no backprop should happen through the adversarial\n   example generation process.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Stops gradient computation."
    }
  },
  {
    "name": "StridedSlice",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Index",
          "type": "type"
        },
        {
          "description": "a bitmask where a bit i being 1 means to ignore the begin\nvalue and instead use the largest interval possible. At runtime\nbegin[i] will be replaced with `[0, n-1) if `stride[i] > 0` or\n`[-1, n-1]` if `stride[i] < 0`",
          "name": "begin_mask",
          "type": "int"
        },
        {
          "description": "analogous to `begin_mask`",
          "name": "end_mask",
          "type": "int"
        },
        {
          "description": "a bitmask where bit `i` being 1 means the `i`th\nposition is actually an ellipsis. One bit at most can be 1.\nIf `ellipsis_mask == 0`, then an implicit ellipsis mask of `1 << (m+1)`\nis provided. This means that `foo[3:5] == foo[3:5, ...]`. An ellipsis\nimplicitly creates as many range specifications as necessary to fully\nspecify the sliced range for every dimension. For example for a 4-dimensional\ntensor `foo` the slice `foo[2, ..., 5:8]` implies `foo[2, :, :, 5:8]`.",
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "description": "a bitmask where bit `i` being 1 means the `i`th\nspecification creates a new shape 1 dimension. For example\n`foo[:4, tf.newaxis, :2]` would produce a shape `(4, 1, 2)` tensor.",
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "description": "a bitmask where bit `i` implies that the `i`th\nspecification should shrink the dimensionality. begin and end\nmust imply a slice of size 1 in the dimension. For example in\npython one might do `foo[:, 3, :]` which would result in\n`shrink_axis_mask` being 2.",
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "Note, most python users will want to use the Python `Tensor.__getitem__`\nor `Variable.__getitem__` rather than this op directly.\n\nThe goal of this op is to produce a new tensor with a subset of\nthe elements from the `n` dimensional `input` tensor. The subset is chosen using\na sequence of `m` sparse range specifications encoded into the arguments\nof this function. Note, in some cases\n`m` could be equal to `n`, but this need not be the case. Each\nrange specification entry can be one of the following:\n\n- An ellipsis (...). Ellipses are used to imply zero or more\n  dimensions of full-dimension selection and are produced using\n  `ellipsis_mask`. For example, `foo[...]` is the identity slice.\n\n- A new axis. This is used to insert a new shape=1 dimension and is\n  produced using `new_axis_mask`. For example, `foo[:, ...]` where\n  `foo` is shape `(3, 4)` produces a `(1, 3, 4)` tensor.\n\n\n- A range `begin:end:stride`. This is used to specify how much to choose from\n  a given dimension. `stride` can be any integer but 0.  `begin` is an integer\n  which represents the index of the first value to select while `end` represents\n  the index of the last value to select. The number of values selected in each\n  dimension is `end - begin` if `stride > 0` and `begin - end` if `stride < 0`.\n  `begin` and `end` can be negative where `-1` is the last element, `-2` is\n  the second to last. `begin_mask` controls whether to replace the explicitly\n  given `begin` with an implicit effective value of `0` if `stride > 0` and\n  `-1` if `stride < 0`. `end_mask` is analogous but produces the number\n  required to create the largest open interval. For example, given a shape\n  `(3,)` tensor `foo[:]`, the effective `begin` and `end` are `0` and `3`. Do\n  not assume this is equivalent to `foo[0:-1]` which has an effective `begin`\n  and `end` of `0` and `2`. Another example is `foo[-2::-1]` which reverses the\n  first dimension of a tensor while dropping the last two (in the original\n  order elements). For example `foo = [1,2,3,4]; foo[-2::-1]` is `[4,3]`.\n\n- A single index. This is used to keep only elements that have a given\n  index. For example (`foo[2, :]` on a shape `(5,6)` tensor produces a\n  shape `(6,)` tensor. This is encoded in `begin` and `end` and\n  `shrink_axis_mask`.\n\nEach conceptual range specification is encoded in the op's argument. This\nencoding is best understand by considering a non-trivial example. In\nparticular,\n`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as\n\n```\nbegin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0)\nend = [2, 4, x, x, -3, x]\nstrides = [1, 1, x, x, -1, 1]\nbegin_mask = 1<<4 | 1 << 5 = 48\nend_mask = 1<<5 = 32\nellipsis_mask = 1<<3 = 8\nnew_axis_mask = 1<<2 4\nshrink_axis_mask = 1<<0\n```\n\nIn this case if `foo.shape` is (5, 5, 5, 5, 5, 5) the final shape of\nthe slice becomes (2, 1, 5, 5, 2, 5).\nLet us walk step by step through each argument specification.\n\n1.  The first argument in the example slice is turned into `begin = 1` and\n`end = begin + 1 = 2`. To disambiguate from the original spec `2:4` we\nalso set the appropriate bit in `shrink_axis_mask`.\n\n2. `2:4` is contributes 2, 4, 1 to begin, end, and stride. All masks have\nzero bits contributed.\n\n3. None is a synonym for `tf.newaxis`. This means insert a dimension of size 1\ndimension in the final shape. Dummy values are contributed to begin,\nend and stride, while the new_axis_mask bit is set.\n\n4. `...` grab the full ranges from as many dimensions as needed to\nfully specify a slice for every dimension of the input shape.\n\n5. `:-3:-1` shows the use of negative indices. A negative index `i` associated\nwith a dimension that has shape `s` is converted to a positive index\n`s + i`. So `-1` becomes `s-1` (i.e. the last element). This conversion\nis done internally so begin, end and strides receive x, -3, and -1.\nThe appropriate begin_mask bit is set to indicate the start range is the\nfull range (ignoring the x).\n\n6. `:` indicates that the entire contents of the corresponding dimension\nis selected. This is equivalent to `::` or `0::1`. begin, end, and strides\nreceive 0, 0, and 1, respectively. The appropriate bits in `begin_mask` and\n`end_mask` are also set.\n\n*Requirements*:\n  `0 != strides[i] for i in [0, m)`\n  `ellipsis_mask must be a power of two (only one ellipsis)`",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "`begin[k]` specifies the offset into the `k`th range specification.\nThe exact dimension this corresponds to will be determined by context.\nOut-of-bounds values will be silently clamped. If the `k`th bit of\n`begin_mask` then `begin[k]` is ignored and the full range of the\nappropriate dimension is used instead. Negative values causes indexing\nto start from the highest element e.g. If `foo==[1,2,3]` then `foo[-1]==3`.",
          "name": "begin",
          "type": 0
        },
        {
          "description": "`end[i]` is like `begin` with the exception that `end_mask` is\nused to determine full ranges.",
          "name": "end",
          "type": 0
        },
        {
          "description": "`strides[i]` specifies the increment in the `i`th specification\nafter extracting a given element. Negative indices will reverse\nthe original order. Out or range values are\nclamped to `[0,dim[i]) if slice[i]>0` or `[-1,dim[i]-1] if slice[i] < 0`",
          "name": "strides",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Return a strided slice from `input`."
    }
  },
  {
    "name": "StridedSliceAssign",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Index",
          "type": "type"
        },
        {
          "description": "",
          "name": "begin_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "end_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "The values of `value` are assigned to the positions in the variable\n`ref` that are selected by the slice parameters. The slice parameters\n`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.\n\nNOTE this op currently does not support broadcasting and so `value`'s\nshape must be exactly the shape produced by the slice of `ref`.",
      "inputs": [
        {
          "description": "",
          "name": "ref",
          "type": 0
        },
        {
          "description": "",
          "name": "begin",
          "type": 0
        },
        {
          "description": "",
          "name": "end",
          "type": 0
        },
        {
          "description": "",
          "name": "strides",
          "type": 0
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output_ref",
          "type": 0
        }
      ],
      "summary": "Assign `value` to the sliced l-value reference of `ref`."
    }
  },
  {
    "name": "StridedSliceGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Index",
          "type": "type"
        },
        {
          "description": "",
          "name": "begin_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "end_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "ellipsis_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "new_axis_mask",
          "type": "int"
        },
        {
          "description": "",
          "name": "shrink_axis_mask",
          "type": "int"
        }
      ],
      "description": "Since `StridedSlice` cuts out pieces of its `input` which is size\n`shape`, its gradient will have the same shape (which is passed here\nas `shape`). The gradient will be zero in any element that the slice\ndoes not select.\n\nArguments are the same as StridedSliceGrad with the exception that\n`dy` is the input gradient to be propagated and `shape` is the\nshape of `StridedSlice`'s `input`.",
      "inputs": [
        {
          "description": "",
          "name": "shape",
          "type": 0
        },
        {
          "description": "",
          "name": "begin",
          "type": 0
        },
        {
          "description": "",
          "name": "end",
          "type": 0
        },
        {
          "description": "",
          "name": "strides",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the gradient of `StridedSlice`."
    }
  },
  {
    "name": "StringJoin",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "N",
          "type": "int"
        },
        {
          "description": "string, an optional join separator.",
          "name": "separator",
          "type": "string"
        }
      ],
      "description": "with the given separator (default is an empty separator).",
      "inputs": [
        {
          "description": "A list of string tensors.  The tensors must all have the same shape,\nor be scalars.  Scalars may be mixed in; these will be broadcast to the shape\nof non-scalar inputs.",
          "name": "inputs",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Joins the strings in the given list of string tensors into one tensor;"
    }
  },
  {
    "name": "StringSplit",
    "schema": {
      "attributes": [
        {
          "description": "A `bool`. If `True`, skip the empty strings from the result.",
          "name": "skip_empty",
          "type": "bool"
        }
      ],
      "description": "Let N be the size of source (typically N will be the batch size). Split each\nelement of `input` based on `delimiter` and return a `SparseTensor`\ncontaining the splitted tokens. Empty tokens are ignored.\n\n`delimiter` can be empty, or a string of split characters. If `delimiter` is an\n empty string, each element of `input` is split into individual single-byte\n character strings, including splitting of UTF-8 multibyte sequences. Otherwise\n every character of `delimiter` is a potential split point.\n\nFor example:\n  N = 2, input[0] is 'hello world' and input[1] is 'a b c', then the output\n  will be\n\n  indices = [0, 0;\n             0, 1;\n             1, 0;\n             1, 1;\n             1, 2]\n  shape = [2, 3]\n  values = ['hello', 'world', 'a', 'b', 'c']",
      "inputs": [
        {
          "description": "1-D. Strings to split.",
          "name": "input",
          "type": 7
        },
        {
          "description": "0-D. Delimiter characters (bytes), or empty string.",
          "name": "delimiter",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A dense matrix of int64 representing the indices of the sparse tensor.",
          "name": "indices",
          "type": 9
        },
        {
          "description": "A vector of strings corresponding to the splited values.",
          "name": "values",
          "type": 7
        },
        {
          "description": "a length-2 vector of int64 representing the shape of the sparse\ntensor, where the first value is N and the second value is the maximum number\nof tokens in a single input entry.",
          "name": "shape",
          "type": 9
        }
      ],
      "summary": "Split elements of `input` based on `delimiter` into a `SparseTensor`."
    }
  },
  {
    "name": "StringToHashBucket",
    "schema": {
      "attributes": [
        {
          "description": "The number of buckets.",
          "name": "num_buckets",
          "type": "int"
        }
      ],
      "description": "The hash function is deterministic on the content of the string within the\nprocess.\n\nNote that the hash function may change from time to time.\nThis functionality will be deprecated and it's recommended to use\n`tf.string_to_hash_bucket_fast()` or `tf.string_to_hash_bucket_strong()`.",
      "inputs": [
        {
          "description": "",
          "name": "string_tensor",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets."
    }
  },
  {
    "name": "StringToHashBucketFast",
    "schema": {
      "attributes": [
        {
          "description": "The number of buckets.",
          "name": "num_buckets",
          "type": "int"
        }
      ],
      "description": "The hash function is deterministic on the content of the string within the\nprocess and will never change. However, it is not suitable for cryptography.\nThis function may be used when CPU time is scarce and inputs are trusted or\nunimportant. There is a risk of adversaries constructing inputs that all hash\nto the same bucket. To prevent this problem, use a strong hash function with\n`tf.string_to_hash_bucket_strong`.",
      "inputs": [
        {
          "description": "The strings to assign a hash bucket.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets."
    }
  },
  {
    "name": "StringToHashBucketStrong",
    "schema": {
      "attributes": [
        {
          "description": "The number of buckets.",
          "name": "num_buckets",
          "type": "int"
        },
        {
          "description": "The key for the keyed hash function passed as a list of two uint64\nelements.",
          "name": "key",
          "type": "list(int)"
        }
      ],
      "description": "The hash function is deterministic on the content of the string within the\nprocess. The hash function is a keyed hash function, where attribute `key`\ndefines the key of the hash function. `key` is an array of 2 elements.\n\nA strong hash is important when inputs may be malicious, e.g. URLs with\nadditional components. Adversaries could try to make their inputs hash to the\nsame bucket for a denial-of-service attack or to skew the results. A strong\nhash prevents this by making it difficult, if not infeasible, to compute inputs\nthat hash to the same bucket. This comes at a cost of roughly 4x higher compute\ntime than `tf.string_to_hash_bucket_fast`.",
      "inputs": [
        {
          "description": "The strings to assign a hash bucket.",
          "name": "input",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 9
        }
      ],
      "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets."
    }
  },
  {
    "name": "StringToNumber",
    "schema": {
      "attributes": [
        {
          "description": "The numeric type to interpret each string in `string_tensor` as.",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "(Note that int32 overflow results in an error while float overflow\nresults in a rounded value.)",
      "inputs": [
        {
          "description": "",
          "name": "string_tensor",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "A Tensor of the same shape as the input `string_tensor`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Converts each string in the input Tensor to the specified numeric type."
    }
  },
  {
    "name": "Sub",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "*NOTE*: `Sub` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x - y element-wise."
    }
  },
  {
    "name": "Substr",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "For each string in the input `Tensor`, creates a substring starting at index\n`pos` with a total length of `len`.\n\nIf `len` defines a substring that would extend beyond the length of the input\nstring, then as many characters as possible are used.\n\nIf `pos` is negative or specifies a character index larger than any of the input\nstrings, then an `InvalidArgumentError` is thrown.\n\n`pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on\nOp creation.\n\n*NOTE*: `Substr` supports broadcasting up to two dimensions. More about\nbroadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)\n\n---\n\nExamples\n\nUsing scalar `pos` and `len`:\n\n```python\ninput = [b'Hello', b'World']\nposition = 1\nlength = 3\n\noutput = [b'ell', b'orl']\n```\n\nUsing `pos` and `len` with same shape as `input`:\n\n```python\ninput = [[b'ten', b'eleven', b'twelve'],\n         [b'thirteen', b'fourteen', b'fifteen'],\n         [b'sixteen', b'seventeen', b'eighteen']]\nposition = [[1, 2, 3],\n            [1, 2, 3],\n            [1, 2, 3]]\nlength =   [[2, 3, 4],\n            [4, 3, 2],\n            [5, 5, 5]]\n\noutput = [[b'en', b'eve', b'lve'],\n          [b'hirt', b'urt', b'te'],\n          [b'ixtee', b'vente', b'hteen']]\n```\n\nBroadcasting `pos` and `len` onto `input`:\n\n```\ninput = [[b'ten', b'eleven', b'twelve'],\n         [b'thirteen', b'fourteen', b'fifteen'],\n         [b'sixteen', b'seventeen', b'eighteen'],\n         [b'nineteen', b'twenty', b'twentyone']]\nposition = [1, 2, 3]\nlength =   [1, 2, 3]\n\noutput = [[b'e', b'ev', b'lve'],\n          [b'h', b'ur', b'tee'],\n          [b'i', b've', b'hte'],\n          [b'i', b'en', b'nty']]\n```\n\nBroadcasting `input` onto `pos` and `len`:\n\n```\ninput = b'thirteen'\nposition = [1, 5, 7]\nlength =   [3, 2, 1]\n\noutput = [b'hir', b'ee', b'n']\n```",
      "inputs": [
        {
          "description": "Tensor of strings",
          "name": "input",
          "type": 7
        },
        {
          "description": "Scalar defining the position of first character in each substring",
          "name": "pos",
          "type": 0
        },
        {
          "description": "Scalar defining the number of characters to include in each substring",
          "name": "len",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Tensor of substrings",
          "name": "output",
          "type": 7
        }
      ],
      "summary": "Return substrings from `Tensor` of strings."
    }
  },
  {
    "name": "Sum",
    "schema": {
      "attributes": [
        {
          "description": "If true, retain reduced dimensions with length 1.",
          "name": "keep_dims",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tidx",
          "type": "type"
        }
      ],
      "description": "Reduces `input` along the dimensions given in `reduction_indices`. Unless\n`keep_dims` is true, the rank of the tensor is reduced by 1 for each entry in\n`reduction_indices`. If `keep_dims` is true, the reduced dimensions are\nretained with length 1.",
      "inputs": [
        {
          "description": "The tensor to reduce.",
          "name": "input",
          "type": 0
        },
        {
          "description": "The dimensions to reduce. Must be in the range\n`[-rank(input), rank(input))`.",
          "name": "reduction_indices",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The reduced tensor.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the sum of elements across dimensions of a tensor."
    }
  },
  {
    "name": "Svd",
    "schema": {
      "attributes": [
        {
          "description": "If true, left and right singular vectors will be\ncomputed and returned in `u` and `v`, respectively.\nIf false, `u` and `v` are not set and should never referenced.",
          "name": "compute_uv",
          "type": "bool"
        },
        {
          "description": "If true, compute full-sized `u` and `v`. If false\n(the default), compute only the leading `P` singular vectors.\nIgnored if `compute_uv` is `False`.",
          "name": "full_matrices",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Computes the SVD of each inner matrix in `input` such that\n`input[..., :, :] = u[..., :, :] * diag(s[..., :, :]) * transpose(v[..., :, :])`\n\n```python\n# a is a tensor containing a batch of matrices.\n# s is a tensor of singular values for each matrix.\n# u is the tensor containing of left singular vectors for each matrix.\n# v is the tensor containing of right singular vectors for each matrix.\ns, u, v = svd(a)\ns, _, _ = svd(a, compute_uv=False)\n```",
      "inputs": [
        {
          "description": "A tensor of shape `[..., M, N]` whose inner-most 2 dimensions\nform matrices of size `[M, N]`. Let `P` be the minimum of `M` and `N`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "Singular values. Shape is `[..., P]`.",
          "name": "s",
          "type": 0
        },
        {
          "description": "Left singular vectors. If `full_matrices` is `False` then shape is\n`[..., M, P]`; if `full_matrices` is `True` then shape is\n`[..., M, M]`. Undefined if `compute_uv` is `False`.",
          "name": "u",
          "type": 0
        },
        {
          "description": "Left singular vectors. If `full_matrices` is `False` then shape is\n`[..., N, P]`. If `full_matrices` is `True` then shape is `[..., N, N]`.\nUndefined if `compute_uv` is false.",
          "name": "v",
          "type": 0
        }
      ],
      "summary": "Computes the singular value decompositions of one or more matrices."
    }
  },
  {
    "name": "Switch",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If `pred` is true, the `data` input is forwarded to `output_true`. Otherwise,\nthe data goes to `output_false`.\n\nSee also `RefSwitch` and `Merge`.",
      "inputs": [
        {
          "description": "The tensor to be forwarded to the appropriate output.",
          "name": "data",
          "type": 0
        },
        {
          "description": "A scalar that specifies which output port will receive data.",
          "name": "pred",
          "type": 10
        }
      ],
      "outputs": [
        {
          "description": "If `pred` is false, data will be forwarded to this output.",
          "name": "output_false",
          "type": 0
        },
        {
          "description": "If `pred` is true, data will be forwarded to this output.",
          "name": "output_true",
          "type": 0
        }
      ],
      "summary": "Forwards `data` to the output port determined by `pred`."
    }
  },
  {
    "name": "SymbolicGradient",
    "schema": {
      "attributes": [
        {
          "description": "the type list for the input list.",
          "name": "Tin",
          "type": "list(type)"
        },
        {
          "description": "the type list for the input list.",
          "name": "Tout",
          "type": "list(type)"
        },
        {
          "description": "The function we want to compute the gradient for.\n\nThe function 'f' must be a numerical function which takes N inputs and\nproduces M outputs. Its gradient function 'g', which is computed by\nthis SymbolicGradient op is a function taking N + M inputs and\nproduces N outputs.\n\nI.e. if we have\n   (y1, y2, ..., y_M) = f(x1, x2, ..., x_N),\nthen, g is\n   (dL/dx1, dL/dx2, ..., dL/dx_N) = g(x1, x2, ..., x_N,\n                                     dL/dy1, dL/dy2, ..., dL/dy_M),\n\nwhere L is a scalar-value function of (x1, x2, ..., xN) (e.g., the\nloss function). dL/dx_i is the partial derivative of L with respect\nto x_i.\n\n(Needs some math expert to say the comment above better.)",
          "name": "f",
          "type": "func"
        }
      ],
      "inputs": [
        {
          "description": "a list of input tensors of size N + M;",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "a list of output tensors of size N;",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the gradient function for function f via backpropagation."
    }
  },
  {
    "name": "TFRecordDataset",
    "schema": {
      "inputs": [
        {
          "description": "A scalar or vector containing the name(s) of the file(s) to be\nread.",
          "name": "filenames",
          "type": 7
        },
        {
          "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
          "name": "compression_type",
          "type": 7
        },
        {
          "description": "A scalar representing the number of bytes to buffer. A value of\n0 means no buffering will be performed.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the records from one or more TFRecord files."
    }
  },
  {
    "name": "TFRecordReader",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "compression_type",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the records from a TensorFlow Records file."
    }
  },
  {
    "name": "TFRecordReaderV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "compression_type",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the records from a TensorFlow Records file."
    }
  },
  {
    "name": "TakeDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_dataset",
          "type": 21
        },
        {
          "description": "A scalar representing the number of elements from the `input_dataset`\nthat should be taken. A value of `-1` indicates that all of `input_dataset`\nis taken.",
          "name": "count",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that contains `count` elements from the `input_dataset`."
    }
  },
  {
    "name": "TakeManySparseFromTensorsMap",
    "schema": {
      "attributes": [
        {
          "description": "The `dtype` of the `SparseTensor` objects stored in the\n`SparseTensorsMap`.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The container name for the `SparseTensorsMap` read by this op.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "The shared name for the `SparseTensorsMap` read by this op.\nIt should not be blank; rather the `shared_name` or unique Operation name\nof the Op that created the original `SparseTensorsMap` should be used.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The input `sparse_handles` must be an `int64` matrix of shape `[N, 1]` where\n`N` is the minibatch size and the rows correspond to the output handles of\n`AddSparseToTensorsMap` or `AddManySparseToTensorsMap`.  The ranks of the\noriginal `SparseTensor` objects that went into the given input ops must all\nmatch.  When the final `SparseTensor` is created, it has rank one\nhigher than the ranks of the incoming `SparseTensor` objects\n(they have been concatenated along a new row dimension on the left).\n\nThe output `SparseTensor` object's shape values for all dimensions but the\nfirst are the max across the input `SparseTensor` objects' shape values\nfor the corresponding dimensions.  Its first shape value is `N`, the minibatch\nsize.\n\nThe input `SparseTensor` objects' indices are assumed ordered in\nstandard lexicographic order.  If this is not the case, after this\nstep run `SparseReorder` to restore index ordering.\n\nFor example, if the handles represent an input, which is a `[2, 3]` matrix\nrepresenting two original `SparseTensor` objects:\n\n```\n    index = [ 0]\n            [10]\n            [20]\n    values = [1, 2, 3]\n    shape = [50]\n```\n\nand\n\n```\n    index = [ 2]\n            [10]\n    values = [4, 5]\n    shape = [30]\n```\n\nthen the final `SparseTensor` will be:\n\n```\n    index = [0  0]\n            [0 10]\n            [0 20]\n            [1  2]\n            [1 10]\n    values = [1, 2, 3, 4, 5]\n    shape = [2 50]\n```",
      "inputs": [
        {
          "description": "1-D, The `N` serialized `SparseTensor` objects.\nShape: `[N]`.",
          "name": "sparse_handles",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "2-D.  The `indices` of the minibatch `SparseTensor`.",
          "name": "sparse_indices",
          "type": 9
        },
        {
          "description": "1-D.  The `values` of the minibatch `SparseTensor`.",
          "name": "sparse_values",
          "type": 0
        },
        {
          "description": "1-D.  The `shape` of the minibatch `SparseTensor`.",
          "name": "sparse_shape",
          "type": 9
        }
      ],
      "summary": "Read `SparseTensors` from a `SparseTensorsMap` and concatenate them."
    }
  },
  {
    "name": "Tan",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes tan of x element-wise."
    }
  },
  {
    "name": "Tanh",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Computes hyperbolic tangent of `x` element-wise."
    }
  },
  {
    "name": "TanhGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Specifically, `grad = dy * (1 - y*y)`, where `y = tanh(x)`, and `dy`\nis the corresponding input gradient.",
      "inputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        },
        {
          "description": "",
          "name": "dy",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Computes the gradient for the tanh of `x` wrt its input."
    }
  },
  {
    "name": "TemporaryVariable",
    "schema": {
      "attributes": [
        {
          "description": "The shape of the variable tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "The type of elements in the variable tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "Overrides the name used for the temporary variable resource. Default\nvalue is the name of the 'TemporaryVariable' op (which is guaranteed unique).",
          "name": "var_name",
          "type": "string"
        }
      ],
      "description": "This is an experimental op for internal use only and it is possible to use this\nop in unsafe ways.  DO NOT USE unless you fully understand the risks.\n\nIt is the caller's responsibility to ensure that 'ref' is eventually passed to a\nmatching 'DestroyTemporaryVariable' op after all other uses have completed.\n\nOutputs a ref to the tensor state so it may be read or modified.\n\n  E.g.\n      var = state_ops._temporary_variable([1, 2], types.float_)\n      var_name = var.op.name\n      var = state_ops.assign(var, [[4.0, 5.0]])\n      var = state_ops.assign_add(var, [[6.0, 7.0]])\n      final = state_ops._destroy_temporary_variable(var, var_name=var_name)",
      "outputs": [
        {
          "description": "A reference to the variable tensor.",
          "name": "ref",
          "type": 0
        }
      ],
      "summary": "Returns a tensor that may be mutated, but only persists within a single step."
    }
  },
  {
    "name": "TensorArray",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "dynamic_size",
          "type": "bool"
        },
        {
          "description": "",
          "name": "clear_after_read",
          "type": "bool"
        },
        {
          "description": "",
          "name": "tensor_array_name",
          "type": "string"
        },
        {
          "description": "",
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "TensorArrayClose",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "TensorArrayCloseV2",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Use TensorArrayCloseV3"
    }
  },
  {
    "name": "TensorArrayCloseV3",
    "schema": {
      "description": "This enables the user to close and release the resource in the middle\nof a step/run.",
      "inputs": [
        {
          "description": "The handle to a TensorArray (output of TensorArray or TensorArrayGrad).",
          "name": "handle",
          "type": 20
        }
      ],
      "summary": "Delete the TensorArray from its resource container."
    }
  },
  {
    "name": "TensorArrayConcat",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "element_shape_except0",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "lengths",
          "type": 9
        }
      ]
    }
  },
  {
    "name": "TensorArrayConcatV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "element_shape_except0",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "lengths",
          "type": 9
        }
      ],
      "summary": "Deprecated. Use TensorArrayConcatV3"
    }
  },
  {
    "name": "TensorArrayConcatV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is returned.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The expected shape of an element, if known,\nexcluding the first dimension. Used to validate the shapes of\nTensorArray elements. If this shape is not fully specified, concatenating\nzero-size TensorArrays is an error.",
          "name": "element_shape_except0",
          "type": "shape"
        }
      ],
      "description": "Takes `T` elements of shapes\n\n  ```\n  (n0 x d0 x d1 x ...), (n1 x d0 x d1 x ...), ..., (n(T-1) x d0 x d1 x ...)\n  ```\n\nand concatenates them into a Tensor of shape:\n\n  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```\n\nAll elements must have the same shape (excepting the first dimension).",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "All of the elements in the TensorArray, concatenated along the first\naxis.",
          "name": "value",
          "type": 0
        },
        {
          "description": "A vector of the row sizes of the original T elements in the\nvalue output.  In the example above, this would be the values:\n`(n1, n2, ..., n(T-1))`.",
          "name": "lengths",
          "type": 9
        }
      ],
      "summary": "Concat the elements from the TensorArray into value `value`."
    }
  },
  {
    "name": "TensorArrayGather",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "TensorArrayGatherV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Deprecated. Use TensorArrayGatherV3"
    }
  },
  {
    "name": "TensorArrayGatherV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is returned.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The expected shape of an element, if known. Used to\nvalidate the shapes of TensorArray elements. If this shape is not\nfully specified, gathering zero-size TensorArrays is an error.",
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "description": "All elements selected by `indices` must have the same shape.",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The locations in the TensorArray from which to read tensor elements.",
          "name": "indices",
          "type": 3
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "All of the elements in the TensorArray, concatenated along a new\naxis (the new dimension 0).",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Gather specific elements from the TensorArray into output `value`."
    }
  },
  {
    "name": "TensorArrayGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "source",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "grad_handle",
          "type": 7
        }
      ]
    }
  },
  {
    "name": "TensorArrayGradV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "source",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "grad_handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Use TensorArrayGradV3"
    }
  },
  {
    "name": "TensorArrayGradV3",
    "schema": {
      "attributes": [
        {
          "description": "The gradient source string, used to decide which gradient TensorArray\nto return.",
          "name": "source",
          "type": "string"
        }
      ],
      "description": "If the given TensorArray gradient already exists, returns a reference to it.\n\nLocks the size of the original TensorArray by disabling its dynamic size flag.\n\n**A note about the input flow_in:**\n\nThe handle flow_in forces the execution of the gradient lookup to occur\nonly after certain other operations have occurred.  For example, when\nthe forward TensorArray is dynamically sized, writes to this TensorArray\nmay resize the object.  The gradient TensorArray is statically sized based\non the size of the forward TensorArray when this operation executes.\nFurthermore, the size of the forward TensorArray is frozen by this call.\nAs a result, the flow is used to ensure that the call to generate the gradient\nTensorArray only happens after all writes are executed.\n\nIn the case of dynamically sized TensorArrays, gradient computation should\nonly be performed on read operations that have themselves been chained via\nflow to occur only after all writes have executed. That way the final size\nof the forward TensorArray is known when this operation is called.\n\n**A note about the source attribute:**\n\nTensorArray gradient calls use an accumulator TensorArray object.  If\nmultiple gradients are calculated and run in the same session, the multiple\ngradient nodes may accidentally flow through the same accumulator TensorArray.\nThis double counts and generally breaks the TensorArray gradient flow.\n\nThe solution is to identify which gradient call this particular\nTensorArray gradient is being called in.  This is performed by identifying\na unique string (e.g. \"gradients\", \"gradients_1\", ...) from the input\ngradient Tensor's name.  This string is used as a suffix when creating\nthe TensorArray gradient object here (the attribute `source`).\n\nThe attribute `source` is added as a suffix to the forward TensorArray's\nname when performing the creation / lookup, so that each separate gradient\ncalculation gets its own TensorArray accumulator.",
      "inputs": [
        {
          "description": "The handle to the forward TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "grad_handle",
          "type": 20
        },
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Creates a TensorArray for storing the gradients of values in the given handle."
    }
  },
  {
    "name": "TensorArrayPack",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "element_shape",
          "type": "shape"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "TensorArrayRead",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "index",
          "type": 3
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ]
    }
  },
  {
    "name": "TensorArrayReadV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "index",
          "type": 3
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Deprecated. Use TensorArrayReadV3"
    }
  },
  {
    "name": "TensorArrayReadV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elem that is returned.",
          "name": "dtype",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "",
          "name": "index",
          "type": 3
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The tensor that is read from the TensorArray.",
          "name": "value",
          "type": 0
        }
      ],
      "summary": "Read an element from the TensorArray into output `value`."
    }
  },
  {
    "name": "TensorArrayScatter",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArrayScatterV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "indices",
          "type": 3
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Deprecated. Use TensorArrayScatterV3"
    }
  },
  {
    "name": "TensorArrayScatterV3",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "`indices` must be a vector, its length must match the first dim of `value`.",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The locations at which to write the tensor elements.",
          "name": "indices",
          "type": 3
        },
        {
          "description": "The concatenated tensor to write to the TensorArray.",
          "name": "value",
          "type": 0
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Scatter the data from the input value into specific TensorArray elements."
    }
  },
  {
    "name": "TensorArraySize",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ]
    }
  },
  {
    "name": "TensorArraySizeV2",
    "schema": {
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Deprecated. Use TensorArraySizeV3"
    }
  },
  {
    "name": "TensorArraySizeV3",
    "schema": {
      "inputs": [
        {
          "description": "The handle to a TensorArray (output of TensorArray or TensorArrayGrad).",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "The current size of the TensorArray.",
          "name": "size",
          "type": 3
        }
      ],
      "summary": "Get the current size of the TensorArray."
    }
  },
  {
    "name": "TensorArraySplit",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "lengths",
          "type": 9
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArraySplitV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "lengths",
          "type": 9
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Deprecated. Use TensorArraySplitV3"
    }
  },
  {
    "name": "TensorArraySplitV3",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Assuming that `lengths` takes on values\n\n  ```(n0, n1, ..., n(T-1))```\n\nand that `value` has shape\n\n  ```(n0 + n1 + ... + n(T-1) x d0 x d1 x ...)```,\n\nthis splits values into a TensorArray with T tensors.\n\nTensorArray index t will be the subtensor of values with starting position\n\n  ```(n0 + n1 + ... + n(t-1), 0, 0, ...)```\n\nand having size\n\n  ```nt x d0 x d1 x ...```",
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The concatenated tensor to write to the TensorArray.",
          "name": "value",
          "type": 0
        },
        {
          "description": "The vector of lengths, how to split the rows of value into the\nTensorArray.",
          "name": "lengths",
          "type": 9
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Split the data from the input value into TensorArray elements."
    }
  },
  {
    "name": "TensorArrayUnpack",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArrayV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "element_shape",
          "type": "shape"
        },
        {
          "description": "",
          "name": "dynamic_size",
          "type": "bool"
        },
        {
          "description": "",
          "name": "clear_after_read",
          "type": "bool"
        },
        {
          "description": "",
          "name": "tensor_array_name",
          "type": "string"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        }
      ],
      "summary": "Deprecated. Use TensorArrayV3"
    }
  },
  {
    "name": "TensorArrayV3",
    "schema": {
      "attributes": [
        {
          "description": "The type of the elements on the tensor_array.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The expected shape of an element, if known. Used to\nvalidate the shapes of TensorArray elements. If this shape is not\nfully specified, gathering zero-size TensorArrays is an error.",
          "name": "element_shape",
          "type": "shape"
        },
        {
          "description": "A boolean that determines whether writes to the TensorArray\nare allowed to grow the size.  By default, this is not allowed.",
          "name": "dynamic_size",
          "type": "bool"
        },
        {
          "description": "If true (default), Tensors in the TensorArray are cleared\nafter being read.  This disables multiple read semantics but allows early\nrelease of memory.",
          "name": "clear_after_read",
          "type": "bool"
        },
        {
          "description": "If true (default is false), then all\nelements in the TensorArray will be expected to have have identical shapes.\nThis allows certain behaviors, like dynamically checking for\nconsistent shapes on write, and being able to fill in properly\nshaped zero tensors on stack -- even if the element_shape attribute\nis not fully defined.",
          "name": "identical_element_shapes",
          "type": "bool"
        },
        {
          "description": "Overrides the name used for the temporary tensor_array\nresource. Default value is the name of the 'TensorArray' op (which\nis guaranteed unique).",
          "name": "tensor_array_name",
          "type": "string"
        }
      ],
      "description": "Write data via Write and read via Read or Pack.",
      "inputs": [
        {
          "description": "The size of the array.",
          "name": "size",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The handle to the TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "A scalar used to control gradient flow.",
          "name": "flow",
          "type": 1
        }
      ],
      "summary": "An array of Tensors of given size."
    }
  },
  {
    "name": "TensorArrayWrite",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "index",
          "type": 3
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ]
    }
  },
  {
    "name": "TensorArrayWriteV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "handle",
          "type": 7
        },
        {
          "description": "",
          "name": "index",
          "type": 3
        },
        {
          "description": "",
          "name": "value",
          "type": 0
        },
        {
          "description": "",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Deprecated. Use TensorArrayGradV3"
    }
  },
  {
    "name": "TensorArrayWriteV3",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "The handle to a TensorArray.",
          "name": "handle",
          "type": 20
        },
        {
          "description": "The position to write to inside the TensorArray.",
          "name": "index",
          "type": 3
        },
        {
          "description": "The tensor to write to the TensorArray.",
          "name": "value",
          "type": 0
        },
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_in",
          "type": 1
        }
      ],
      "outputs": [
        {
          "description": "A float scalar that enforces proper chaining of operations.",
          "name": "flow_out",
          "type": 1
        }
      ],
      "summary": "Push an element onto the tensor_array."
    }
  },
  {
    "name": "TensorDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "components",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits `components` as a tuple of tensors once."
    }
  },
  {
    "name": "TensorSliceDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "Toutput_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "components",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits each dim-0 slice of `components` once."
    }
  },
  {
    "name": "TensorSummary",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "A json-encoded SummaryDescription proto.",
          "name": "description",
          "type": "string"
        },
        {
          "description": "An unused list of strings.",
          "name": "labels",
          "type": "list(string)"
        },
        {
          "description": "An unused string.",
          "name": "display_name",
          "type": "string"
        }
      ],
      "description": "This op is being phased out in favor of TensorSummaryV2, which lets callers pass\na tag as well as a serialized SummaryMetadata proto string that contains\nplugin-specific data. We will keep this op to maintain backwards compatibility.",
      "inputs": [
        {
          "description": "A tensor to serialize.",
          "name": "tensor",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with a tensor."
    }
  },
  {
    "name": "TensorSummaryV2",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "A string attached to this summary. Used for organization in TensorBoard.",
          "name": "tag",
          "type": 7
        },
        {
          "description": "A tensor to serialize.",
          "name": "tensor",
          "type": 0
        },
        {
          "description": "A serialized SummaryMetadata proto. Contains plugin\ndata.",
          "name": "serialized_summary_metadata",
          "type": 7
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "summary",
          "type": 7
        }
      ],
      "summary": "Outputs a `Summary` protocol buffer with a tensor and per-plugin data."
    }
  },
  {
    "name": "TextLineDataset",
    "schema": {
      "inputs": [
        {
          "description": "A scalar or a vector containing the name(s) of the file(s) to be\nread.",
          "name": "filenames",
          "type": 7
        },
        {
          "description": "A scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\".",
          "name": "compression_type",
          "type": 7
        },
        {
          "description": "A scalar containing the number of bytes to buffer.",
          "name": "buffer_size",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that emits the lines of one or more text files."
    }
  },
  {
    "name": "TextLineReader",
    "schema": {
      "attributes": [
        {
          "description": "Number of lines to skip from the beginning of every file.",
          "name": "skip_header_lines",
          "type": "int"
        },
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the lines of a file delimited by '\\n'."
    }
  },
  {
    "name": "TextLineReaderV2",
    "schema": {
      "attributes": [
        {
          "description": "Number of lines to skip from the beginning of every file.",
          "name": "skip_header_lines",
          "type": "int"
        },
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the lines of a file delimited by '\\n'."
    }
  },
  {
    "name": "ThreadUnsafeUnigramCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "name": "range_max",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a learned unigram distribution."
    }
  },
  {
    "name": "Tile",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tmultiples",
          "type": "type"
        }
      ],
      "description": "This operation creates a new tensor by replicating `input` `multiples` times.\nThe output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,\nand the values of `input` are replicated `multiples[i]` times along the 'i'th\ndimension. For example, tiling `[a b c d]` by `[2]` produces\n`[a b c d a b c d]`.",
      "inputs": [
        {
          "description": "1-D or higher.",
          "name": "input",
          "type": 0
        },
        {
          "description": "1-D. Length must be the same as the number of dimensions in `input`",
          "name": "multiples",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Constructs a tensor by tiling a given tensor."
    }
  },
  {
    "name": "TileGrad",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Since `Tile` takes an input and repeats the input `multiples` times\nalong each dimension, `TileGrad` takes in `multiples` and aggregates\neach repeated tile of `input` into `output`.",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        },
        {
          "description": "",
          "name": "multiples",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the gradient of `Tile`."
    }
  },
  {
    "name": "TopK",
    "schema": {
      "attributes": [
        {
          "description": "Number of top elements to look for along the last dimension (along each\nrow for matrices).",
          "name": "k",
          "type": "int"
        },
        {
          "description": "If true the resulting `k` elements will be sorted by the values in\ndescending order.",
          "name": "sorted",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.\n\nIf `k` varies dynamically, use `TopKV2` below.",
      "inputs": [
        {
          "description": "1-D or higher with last dimension at least `k`.",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The `k` largest elements along each last dimensional slice.",
          "name": "values",
          "type": 0
        },
        {
          "description": "The indices of `values` within the last dimension of `input`.",
          "name": "indices",
          "type": 3
        }
      ],
      "summary": "Finds values and indices of the `k` largest elements for the last dimension."
    }
  },
  {
    "name": "TopKV2",
    "schema": {
      "attributes": [
        {
          "description": "If true the resulting `k` elements will be sorted by the values in\ndescending order.",
          "name": "sorted",
          "type": "bool"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "If the input is a vector (rank-1), finds the `k` largest entries in the vector\nand outputs their values and indices as vectors.  Thus `values[j]` is the\n`j`-th largest entry in `input`, and its index is `indices[j]`.\n\nFor matrices (resp. higher rank input), computes the top `k` entries in each\nrow (resp. vector along the last dimension).  Thus,\n\n    values.shape = indices.shape = input.shape[:-1] + [k]\n\nIf two elements are equal, the lower-index element appears first.",
      "inputs": [
        {
          "description": "1-D or higher with last dimension at least `k`.",
          "name": "input",
          "type": 0
        },
        {
          "description": "0-D.  Number of top elements to look for along the last dimension (along each\nrow for matrices).",
          "name": "k",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "The `k` largest elements along each last dimensional slice.",
          "name": "values",
          "type": 0
        },
        {
          "description": "The indices of `values` within the last dimension of `input`.",
          "name": "indices",
          "type": 3
        }
      ],
      "summary": "Finds values and indices of the `k` largest elements for the last dimension."
    }
  },
  {
    "name": "Transpose",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tperm",
          "type": "type"
        }
      ],
      "description": "The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:\n  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "perm",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Shuffle dimensions of x according to a permutation."
    }
  },
  {
    "name": "TruncateDiv",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "Truncation designates that negative numbers will round fractional quantities\ntoward zero. I.e. -7 / 5 = -1. This matches C semantics but it is different\nthan Python semantics. See `FloorDiv` for a division function that matches\nPython Semantics.\n\n*NOTE*: `TruncateDiv` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns x / y element-wise for integer types."
    }
  },
  {
    "name": "TruncateMod",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "the result here is consistent with a truncating divide. E.g. `truncate(x / y) *\ny + truncate_mod(x, y) = x`.\n\n*NOTE*: `TruncateMod` supports broadcasting. More about broadcasting\n[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "y",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Returns element-wise remainder of division. This emulates C semantics in that"
    }
  },
  {
    "name": "TruncatedNormal",
    "schema": {
      "attributes": [
        {
          "description": "If either `seed` or `seed2` are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "A second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        },
        {
          "description": "The type of the output.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The generated values follow a normal distribution with mean 0 and standard\ndeviation 1, except that values whose magnitude is more than 2 standard\ndeviations from the mean are dropped and re-picked.",
      "inputs": [
        {
          "description": "The shape of the output tensor.",
          "name": "shape",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "A tensor of the specified shape filled with random truncated normal\nvalues.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Outputs random values from a truncated normal distribution."
    }
  },
  {
    "name": "UniformCandidateSampler",
    "schema": {
      "attributes": [
        {
          "description": "Number of true labels per context.",
          "name": "num_true",
          "type": "int"
        },
        {
          "description": "Number of candidates to randomly sample.",
          "name": "num_sampled",
          "type": "int"
        },
        {
          "description": "If unique is true, we sample with rejection, so that all sampled\ncandidates in a batch are unique. This requires some approximation to\nestimate the post-rejection sampling probabilities.",
          "name": "unique",
          "type": "bool"
        },
        {
          "description": "The sampler will sample integers from the interval [0, range_max).",
          "name": "range_max",
          "type": "int"
        },
        {
          "description": "If either seed or seed2 are set to be non-zero, the random number\ngenerator is seeded by the given seed.  Otherwise, it is seeded by a\nrandom seed.",
          "name": "seed",
          "type": "int"
        },
        {
          "description": "An second seed to avoid seed collision.",
          "name": "seed2",
          "type": "int"
        }
      ],
      "description": "See explanations of candidate sampling and the data formats at\ngo/candidate-sampling.\n\nFor each batch, this op picks a single set of sampled candidate labels.\n\nThe advantages of sampling candidates per-batch are simplicity and the\npossibility of efficient dense matrix multiplication. The disadvantage is that\nthe sampled candidates must be chosen independently of the context and of the\ntrue labels.",
      "inputs": [
        {
          "description": "A batch_size * num_true matrix, in which each row contains the\nIDs of the num_true target_classes in the corresponding original label.",
          "name": "true_classes",
          "type": 9
        }
      ],
      "outputs": [
        {
          "description": "A vector of length num_sampled, in which each element is\nthe ID of a sampled candidate.",
          "name": "sampled_candidates",
          "type": 9
        },
        {
          "description": "A batch_size * num_true matrix, representing\nthe number of times each candidate is expected to occur in a batch\nof sampled candidates. If unique=true, then this is a probability.",
          "name": "true_expected_count",
          "type": 1
        },
        {
          "description": "A vector of length num_sampled, for each sampled\ncandidate representing the number of times the candidate is expected\nto occur in a batch of sampled candidates.  If unique=true, then this is a\nprobability.",
          "name": "sampled_expected_count",
          "type": 1
        }
      ],
      "summary": "Generates labels for candidate sampling with a uniform distribution."
    }
  },
  {
    "name": "Unique",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx = unique(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\n```",
      "inputs": [
        {
          "description": "1-D.",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "y",
          "type": 0
        },
        {
          "description": "1-D.",
          "name": "idx",
          "type": 0
        }
      ],
      "summary": "Finds unique elements in a 1-D tensor."
    }
  },
  {
    "name": "UniqueWithCounts",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "out_idx",
          "type": "type"
        }
      ],
      "description": "This operation returns a tensor `y` containing all of the unique elements of `x`\nsorted in the same order that they occur in `x`. This operation also returns a\ntensor `idx` the same size as `x` that contains the index of each value of `x`\nin the unique output `y`. Finally, it returns a third tensor `count` that\ncontains the count of each element of `y` in `x`. In other words:\n\n`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`\n\nFor example:\n\n```\n# tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]\ny, idx, count = unique_with_counts(x)\ny ==> [1, 2, 4, 7, 8]\nidx ==> [0, 0, 1, 2, 2, 2, 3, 4, 4]\ncount ==> [2, 1, 3, 1, 2]\n```",
      "inputs": [
        {
          "description": "1-D.",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "1-D.",
          "name": "y",
          "type": 0
        },
        {
          "description": "1-D.",
          "name": "idx",
          "type": 0
        },
        {
          "description": "1-D.",
          "name": "count",
          "type": 0
        }
      ],
      "summary": "Finds unique elements in a 1-D tensor."
    }
  },
  {
    "name": "Unpack",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "num",
          "type": "int"
        },
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "Dimension along which to unpack.  Negative values wrap around, so the\nvalid range is `[-R, R)`.",
          "name": "axis",
          "type": "int"
        }
      ],
      "description": "Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.\nFor example, given a tensor of shape `(A, B, C, D)`;\n\nIf `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`\n  and each tensor in `output` will have shape `(B, C, D)`. (Note that the\n  dimension unpacked along is gone, unlike `split`).\n\nIf `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`\n  and each tensor in `output` will have shape `(A, C, D)`.\nEtc.\n\nThis is the opposite of `pack`.",
      "inputs": [
        {
          "description": "1-D or higher, with `axis` dimension size equal to `num`.",
          "name": "value",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "The list of tensors unpacked from `value`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors."
    }
  },
  {
    "name": "UnsortedSegmentMax",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nThis operator is similar to the [unsorted segment sum operator](../../../api_docs/python/math_ops.md#UnsortedSegmentSum).\nInstead of computing the sum over segments, it computes the maximum\nsuch that:\n\n\\\\(output_i = \\max_j data_j\\\\) where max is over `j` such\nthat `segment_ids[j] == i`.\n\nIf the maximum is empty for a given segment ID `i`, it outputs the smallest possible value for specific numeric type,\n `output[i] = numeric_limits<T>::min()`.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentMax.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A 1-D tensor whose rank is equal to the rank of `data`'s\nfirst dimension.",
          "name": "segment_ids",
          "type": 0
        },
        {
          "description": "",
          "name": "num_segments",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for dimension 0 which\nhas size `num_segments`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the Max along segments of a tensor."
    }
  },
  {
    "name": "UnsortedSegmentSum",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        },
        {
          "description": "",
          "name": "Tindices",
          "type": "type"
        }
      ],
      "description": "Read @{$math_ops#segmentation$the section on segmentation} for an explanation of\nsegments.\n\nComputes a tensor such that\n`(output[i] = sum_{j...} data[j...]` where the sum is over tuples `j...` such\nthat `segment_ids[j...] == i`.  Unlike `SegmentSum`, `segment_ids`\nneed not be sorted and need not cover all values in the full\nrange of valid values.\n\nIf the sum is empty for a given segment ID `i`, `output[i] = 0`.\n\n`num_segments` should equal the number of distinct segment IDs.\n\n<div style=\"width:70%; margin:auto; margin-bottom:10px; margin-top:20px;\">\n<img style=\"width:100%\" src=\"https://www.tensorflow.org/images/UnsortedSegmentSum.png\" alt>\n</div>",
      "inputs": [
        {
          "description": "",
          "name": "data",
          "type": 0
        },
        {
          "description": "A tensor whose shape is a prefix of `data.shape`.",
          "name": "segment_ids",
          "type": 0
        },
        {
          "description": "",
          "name": "num_segments",
          "type": 3
        }
      ],
      "outputs": [
        {
          "description": "Has same shape as data, except for the first `segment_ids.rank`\ndimensions, which are replaced with a single dimension which has size\n`num_segments`.",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Computes the sum along segments of a tensor."
    }
  },
  {
    "name": "Unstage",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "capacity",
          "type": "int"
        },
        {
          "description": "",
          "name": "memory_limit",
          "type": "int"
        },
        {
          "description": "",
          "name": "dtypes",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "The basic functionality is similar to dequeue with many fewer\ncapabilities and options.  This Op is optimized for performance.",
      "outputs": [
        {
          "description": "",
          "name": "values",
          "type": 0
        }
      ],
      "summary": "Op is similar to a lightweight Dequeue."
    }
  },
  {
    "name": "VarHandleOp",
    "schema": {
      "attributes": [
        {
          "description": "the container this variable is placed in.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "the name by which this variable is referred to.",
          "name": "shared_name",
          "type": "string"
        },
        {
          "description": "the type of this variable. Must agree with the dtypes\nof all ops using this variable.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "The (possibly partially specified) shape of this variable.",
          "name": "shape",
          "type": "shape"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "resource",
          "type": 20
        }
      ],
      "summary": "Creates a handle to a Variable resource."
    }
  },
  {
    "name": "VarIsInitializedOp",
    "schema": {
      "inputs": [
        {
          "description": "the input resource handle.",
          "name": "resource",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "a scalar boolean which is true if the variable has been\ninitialized.",
          "name": "is_initialized",
          "type": 10
        }
      ],
      "summary": "Checks whether a resource handle-based variable has been initialized."
    }
  },
  {
    "name": "Variable",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "",
          "name": "container",
          "type": "string"
        },
        {
          "description": "",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "ref",
          "type": 0
        }
      ],
      "summary": "Use VariableV2 instead."
    }
  },
  {
    "name": "VariableShape",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "out_type",
          "type": "type"
        }
      ],
      "description": "This operation returns a 1-D integer tensor representing the shape of `input`.\n\nFor example:\n\n```\n# 't' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]\nshape(t) ==> [2, 2, 3]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 20
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "output",
          "type": 0
        }
      ],
      "summary": "Returns the shape of the variable pointed to by `resource`."
    }
  },
  {
    "name": "VariableV2",
    "schema": {
      "attributes": [
        {
          "description": "The shape of the variable tensor.",
          "name": "shape",
          "type": "shape"
        },
        {
          "description": "The type of elements in the variable tensor.",
          "name": "dtype",
          "type": "type"
        },
        {
          "description": "If non-empty, this variable is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this variable is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "Outputs a ref to the tensor state so it may be read or modified.\nTODO(zhifengc/mrry): Adds a pointer to a more detail document\nabout sharing states in tensorflow.",
      "outputs": [
        {
          "description": "A reference to the variable tensor.",
          "name": "ref",
          "type": 0
        }
      ],
      "summary": "Holds state in the form of a tensor that persists across steps."
    }
  },
  {
    "name": "Where",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "This operation returns the coordinates of true elements in `input`. The\ncoordinates are returned in a 2-D tensor where the first dimension (rows)\nrepresents the number of true elements, and the second dimension (columns)\nrepresents the coordinates of the true elements. Keep in mind, the shape of\nthe output tensor can vary depending on how many true values there are in\n`input`. Indices are output in row-major order.\n\nFor example:\n\n```\n# 'input' tensor is [[True, False]\n#                    [True, False]]\n# 'input' has two true values, so output has two coordinates.\n# 'input' has rank of 2, so coordinates have two indices.\nwhere(input) ==> [[0, 0],\n                  [1, 0]]\n\n# `input` tensor is [[[True, False]\n#                     [True, False]]\n#                    [[False, True]\n#                     [False, True]]\n#                    [[False, False]\n#                     [False, True]]]\n# 'input' has 5 true values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n\n# `input` tensor is [[[1.5,  0.0]\n#                     [-0.5, 0.0]]\n#                    [[0.0,  0.25]\n#                     [0.0,  0.75]]\n#                    [[0.0,  0.0]\n#                     [0.0,  0.01]]]\n# 'input' has 5 nonzero values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n\n# `input` tensor is [[[1.5 + 0.0j, 0.0  + 0.0j]\n#                     [0.0 + 0.5j, 0.0  + 0.0j]]\n#                    [[0.0 + 0.0j, 0.25 + 1.5j]\n#                     [0.0 + 0.0j, 0.75 + 0.0j]]\n#                    [[0.0 + 0.0j, 0.0  + 0.0j]\n#                     [0.0 + 0.0j, 0.01 + 0.0j]]]\n# 'input' has 5 nonzero magnitude values, so output has 5 coordinates.\n# 'input' has rank of 3, so coordinates have three indices.\nwhere(input) ==> [[0, 0, 0],\n                  [0, 1, 0],\n                  [1, 0, 1],\n                  [1, 1, 1],\n                  [2, 1, 1]]\n```",
      "inputs": [
        {
          "description": "",
          "name": "input",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "index",
          "type": 9
        }
      ],
      "summary": "Returns locations of nonzero / true values in a tensor."
    }
  },
  {
    "name": "WholeFileReader",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 7
        }
      ],
      "summary": "A Reader that outputs the entire contents of a file as a value."
    }
  },
  {
    "name": "WholeFileReaderV2",
    "schema": {
      "attributes": [
        {
          "description": "If non-empty, this reader is placed in the given container.\nOtherwise, a default container is used.",
          "name": "container",
          "type": "string"
        },
        {
          "description": "If non-empty, this reader is named in the given bucket\nwith this shared_name. Otherwise, the node name is used instead.",
          "name": "shared_name",
          "type": "string"
        }
      ],
      "description": "To use, enqueue filenames in a Queue.  The output of ReaderRead will\nbe a filename (key) and the contents of that file (value).",
      "outputs": [
        {
          "description": "The handle to reference the Reader.",
          "name": "reader_handle",
          "type": 20
        }
      ],
      "summary": "A Reader that outputs the entire contents of a file as a value."
    }
  },
  {
    "name": "WriteFile",
    "schema": {
      "description": "creates directory if not existing.",
      "inputs": [
        {
          "description": "scalar. The name of the file to which we write the contents.",
          "name": "filename",
          "type": 7
        },
        {
          "description": "scalar. The content to be written to the output file.",
          "name": "contents",
          "type": 7
        }
      ],
      "summary": "Writes contents to the file at input filename. Creates file and recursively"
    }
  },
  {
    "name": "ZerosLike",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "inputs": [
        {
          "description": "a tensor of type T.",
          "name": "x",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "a tensor of the same shape and type as x but filled with zeros.",
          "name": "y",
          "type": 0
        }
      ],
      "summary": "Returns a tensor of zeros with the same shape and type as x."
    }
  },
  {
    "name": "Zeta",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "T",
          "type": "type"
        }
      ],
      "description": "The Hurwitz zeta function is defined as:\n\n\n\\\\(\\zeta(x, q) = \\sum_{n=0}^{\\infty} (q + n)^{-x}\\\\)",
      "inputs": [
        {
          "description": "",
          "name": "x",
          "type": 0
        },
        {
          "description": "",
          "name": "q",
          "type": 0
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "z",
          "type": 0
        }
      ],
      "summary": "Compute the Hurwitz zeta function \\\\(\\zeta(x, q)\\\\)."
    }
  },
  {
    "name": "ZipDataset",
    "schema": {
      "attributes": [
        {
          "description": "",
          "name": "output_types",
          "type": "list(type)"
        },
        {
          "description": "",
          "name": "output_shapes",
          "type": "list(shape)"
        },
        {
          "description": "",
          "name": "N",
          "type": "int"
        }
      ],
      "inputs": [
        {
          "description": "",
          "name": "input_datasets",
          "type": 21
        }
      ],
      "outputs": [
        {
          "description": "",
          "name": "handle",
          "type": 21
        }
      ],
      "summary": "Creates a dataset that zips together `input_datasets`."
    }
  }
]
