/*eslint-disable block-scoped-var, no-redeclare, no-control-regex, no-prototype-builtins*/
(function($protobuf) {
    "use strict";

    // Common aliases
    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
    
    // Exported root namespace
    var $root = $protobuf.roots.coreml || ($protobuf.roots.coreml = {});
    
    $root.CoreML = (function() {
    
        /**
         * Namespace CoreML.
         * @exports CoreML
         * @namespace
         */
        var CoreML = {};
    
        CoreML.Specification = (function() {
    
            /**
             * Namespace Specification.
             * @memberof CoreML
             * @namespace
             */
            var Specification = {};
    
            Specification.Pipeline = (function() {
    
                /**
                 * Properties of a Pipeline.
                 * @memberof CoreML.Specification
                 * @interface IPipeline
                 * @property {Array.<CoreML.Specification.IModel>|null} [models] Pipeline models
                 */
    
                /**
                 * Constructs a new Pipeline.
                 * @memberof CoreML.Specification
                 * @classdesc A pipeline consisting of one or more models.
                 * @implements IPipeline
                 * @constructor
                 * @param {CoreML.Specification.IPipeline=} [properties] Properties to set
                 */
                function Pipeline(properties) {
                    this.models = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Pipeline models.
                 * @member {Array.<CoreML.Specification.IModel>} models
                 * @memberof CoreML.Specification.Pipeline
                 * @instance
                 */
                Pipeline.prototype.models = $util.emptyArray;
    
                /**
                 * Creates a new Pipeline instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {CoreML.Specification.IPipeline=} [properties] Properties to set
                 * @returns {CoreML.Specification.Pipeline} Pipeline instance
                 */
                Pipeline.create = function create(properties) {
                    return new Pipeline(properties);
                };
    
                /**
                 * Encodes the specified Pipeline message. Does not implicitly {@link CoreML.Specification.Pipeline.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {CoreML.Specification.IPipeline} message Pipeline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pipeline.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.models != null && message.models.length)
                        for (var i = 0; i < message.models.length; ++i)
                            $root.CoreML.Specification.Model.encode(message.models[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Pipeline message, length delimited. Does not implicitly {@link CoreML.Specification.Pipeline.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {CoreML.Specification.IPipeline} message Pipeline message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Pipeline.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Pipeline message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Pipeline} Pipeline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pipeline.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Pipeline();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.models && message.models.length))
                                message.models = [];
                            message.models.push($root.CoreML.Specification.Model.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Pipeline message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Pipeline} Pipeline
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Pipeline.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Pipeline message.
                 * @function verify
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pipeline.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.models != null && message.hasOwnProperty("models")) {
                        if (!Array.isArray(message.models))
                            return "models: array expected";
                        for (var i = 0; i < message.models.length; ++i) {
                            var error = $root.CoreML.Specification.Model.verify(message.models[i]);
                            if (error)
                                return "models." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Pipeline message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Pipeline} Pipeline
                 */
                Pipeline.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Pipeline)
                        return object;
                    var message = new $root.CoreML.Specification.Pipeline();
                    if (object.models) {
                        if (!Array.isArray(object.models))
                            throw TypeError(".CoreML.Specification.Pipeline.models: array expected");
                        message.models = [];
                        for (var i = 0; i < object.models.length; ++i) {
                            if (typeof object.models[i] !== "object")
                                throw TypeError(".CoreML.Specification.Pipeline.models: object expected");
                            message.models[i] = $root.CoreML.Specification.Model.fromObject(object.models[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Pipeline message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Pipeline
                 * @static
                 * @param {CoreML.Specification.Pipeline} message Pipeline
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pipeline.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.models = [];
                    if (message.models && message.models.length) {
                        object.models = [];
                        for (var j = 0; j < message.models.length; ++j)
                            object.models[j] = $root.CoreML.Specification.Model.toObject(message.models[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this Pipeline to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Pipeline
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pipeline.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Pipeline;
            })();
    
            Specification.PipelineClassifier = (function() {
    
                /**
                 * Properties of a PipelineClassifier.
                 * @memberof CoreML.Specification
                 * @interface IPipelineClassifier
                 * @property {CoreML.Specification.IPipeline|null} [pipeline] PipelineClassifier pipeline
                 */
    
                /**
                 * Constructs a new PipelineClassifier.
                 * @memberof CoreML.Specification
                 * @classdesc A classifier pipeline.
                 * @implements IPipelineClassifier
                 * @constructor
                 * @param {CoreML.Specification.IPipelineClassifier=} [properties] Properties to set
                 */
                function PipelineClassifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PipelineClassifier pipeline.
                 * @member {CoreML.Specification.IPipeline|null|undefined} pipeline
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @instance
                 */
                PipelineClassifier.prototype.pipeline = null;
    
                /**
                 * Creates a new PipelineClassifier instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {CoreML.Specification.IPipelineClassifier=} [properties] Properties to set
                 * @returns {CoreML.Specification.PipelineClassifier} PipelineClassifier instance
                 */
                PipelineClassifier.create = function create(properties) {
                    return new PipelineClassifier(properties);
                };
    
                /**
                 * Encodes the specified PipelineClassifier message. Does not implicitly {@link CoreML.Specification.PipelineClassifier.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {CoreML.Specification.IPipelineClassifier} message PipelineClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PipelineClassifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        $root.CoreML.Specification.Pipeline.encode(message.pipeline, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PipelineClassifier message, length delimited. Does not implicitly {@link CoreML.Specification.PipelineClassifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {CoreML.Specification.IPipelineClassifier} message PipelineClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PipelineClassifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PipelineClassifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.PipelineClassifier} PipelineClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PipelineClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PipelineClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pipeline = $root.CoreML.Specification.Pipeline.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PipelineClassifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.PipelineClassifier} PipelineClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PipelineClassifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PipelineClassifier message.
                 * @function verify
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PipelineClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        var error = $root.CoreML.Specification.Pipeline.verify(message.pipeline);
                        if (error)
                            return "pipeline." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PipelineClassifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.PipelineClassifier} PipelineClassifier
                 */
                PipelineClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PipelineClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.PipelineClassifier();
                    if (object.pipeline != null) {
                        if (typeof object.pipeline !== "object")
                            throw TypeError(".CoreML.Specification.PipelineClassifier.pipeline: object expected");
                        message.pipeline = $root.CoreML.Specification.Pipeline.fromObject(object.pipeline);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PipelineClassifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @static
                 * @param {CoreML.Specification.PipelineClassifier} message PipelineClassifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PipelineClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pipeline = null;
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        object.pipeline = $root.CoreML.Specification.Pipeline.toObject(message.pipeline, options);
                    return object;
                };
    
                /**
                 * Converts this PipelineClassifier to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.PipelineClassifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PipelineClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PipelineClassifier;
            })();
    
            Specification.PipelineRegressor = (function() {
    
                /**
                 * Properties of a PipelineRegressor.
                 * @memberof CoreML.Specification
                 * @interface IPipelineRegressor
                 * @property {CoreML.Specification.IPipeline|null} [pipeline] PipelineRegressor pipeline
                 */
    
                /**
                 * Constructs a new PipelineRegressor.
                 * @memberof CoreML.Specification
                 * @classdesc A regressor pipeline.
                 * @implements IPipelineRegressor
                 * @constructor
                 * @param {CoreML.Specification.IPipelineRegressor=} [properties] Properties to set
                 */
                function PipelineRegressor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PipelineRegressor pipeline.
                 * @member {CoreML.Specification.IPipeline|null|undefined} pipeline
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @instance
                 */
                PipelineRegressor.prototype.pipeline = null;
    
                /**
                 * Creates a new PipelineRegressor instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {CoreML.Specification.IPipelineRegressor=} [properties] Properties to set
                 * @returns {CoreML.Specification.PipelineRegressor} PipelineRegressor instance
                 */
                PipelineRegressor.create = function create(properties) {
                    return new PipelineRegressor(properties);
                };
    
                /**
                 * Encodes the specified PipelineRegressor message. Does not implicitly {@link CoreML.Specification.PipelineRegressor.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {CoreML.Specification.IPipelineRegressor} message PipelineRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PipelineRegressor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        $root.CoreML.Specification.Pipeline.encode(message.pipeline, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PipelineRegressor message, length delimited. Does not implicitly {@link CoreML.Specification.PipelineRegressor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {CoreML.Specification.IPipelineRegressor} message PipelineRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PipelineRegressor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PipelineRegressor message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.PipelineRegressor} PipelineRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PipelineRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PipelineRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pipeline = $root.CoreML.Specification.Pipeline.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PipelineRegressor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.PipelineRegressor} PipelineRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PipelineRegressor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PipelineRegressor message.
                 * @function verify
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PipelineRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        var error = $root.CoreML.Specification.Pipeline.verify(message.pipeline);
                        if (error)
                            return "pipeline." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PipelineRegressor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.PipelineRegressor} PipelineRegressor
                 */
                PipelineRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PipelineRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.PipelineRegressor();
                    if (object.pipeline != null) {
                        if (typeof object.pipeline !== "object")
                            throw TypeError(".CoreML.Specification.PipelineRegressor.pipeline: object expected");
                        message.pipeline = $root.CoreML.Specification.Pipeline.fromObject(object.pipeline);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PipelineRegressor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @static
                 * @param {CoreML.Specification.PipelineRegressor} message PipelineRegressor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PipelineRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.pipeline = null;
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        object.pipeline = $root.CoreML.Specification.Pipeline.toObject(message.pipeline, options);
                    return object;
                };
    
                /**
                 * Converts this PipelineRegressor to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.PipelineRegressor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PipelineRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PipelineRegressor;
            })();
    
            Specification.FeatureDescription = (function() {
    
                /**
                 * Properties of a FeatureDescription.
                 * @memberof CoreML.Specification
                 * @interface IFeatureDescription
                 * @property {string|null} [name] FeatureDescription name
                 * @property {string|null} [shortDescription] FeatureDescription shortDescription
                 * @property {CoreML.Specification.IFeatureType|null} [type] FeatureDescription type
                 */
    
                /**
                 * Constructs a new FeatureDescription.
                 * @memberof CoreML.Specification
                 * @classdesc A feature description,
                 * consisting of a name, short description, and type.
                 * @implements IFeatureDescription
                 * @constructor
                 * @param {CoreML.Specification.IFeatureDescription=} [properties] Properties to set
                 */
                function FeatureDescription(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FeatureDescription name.
                 * @member {string} name
                 * @memberof CoreML.Specification.FeatureDescription
                 * @instance
                 */
                FeatureDescription.prototype.name = "";
    
                /**
                 * FeatureDescription shortDescription.
                 * @member {string} shortDescription
                 * @memberof CoreML.Specification.FeatureDescription
                 * @instance
                 */
                FeatureDescription.prototype.shortDescription = "";
    
                /**
                 * FeatureDescription type.
                 * @member {CoreML.Specification.IFeatureType|null|undefined} type
                 * @memberof CoreML.Specification.FeatureDescription
                 * @instance
                 */
                FeatureDescription.prototype.type = null;
    
                /**
                 * Creates a new FeatureDescription instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {CoreML.Specification.IFeatureDescription=} [properties] Properties to set
                 * @returns {CoreML.Specification.FeatureDescription} FeatureDescription instance
                 */
                FeatureDescription.create = function create(properties) {
                    return new FeatureDescription(properties);
                };
    
                /**
                 * Encodes the specified FeatureDescription message. Does not implicitly {@link CoreML.Specification.FeatureDescription.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {CoreML.Specification.IFeatureDescription} message FeatureDescription message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureDescription.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.shortDescription);
                    if (message.type != null && message.hasOwnProperty("type"))
                        $root.CoreML.Specification.FeatureType.encode(message.type, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FeatureDescription message, length delimited. Does not implicitly {@link CoreML.Specification.FeatureDescription.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {CoreML.Specification.IFeatureDescription} message FeatureDescription message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureDescription.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FeatureDescription message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.FeatureDescription} FeatureDescription
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureDescription.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureDescription();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.shortDescription = reader.string();
                            break;
                        case 3:
                            message.type = $root.CoreML.Specification.FeatureType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FeatureDescription message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.FeatureDescription} FeatureDescription
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureDescription.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FeatureDescription message.
                 * @function verify
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureDescription.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    if (message.type != null && message.hasOwnProperty("type")) {
                        var error = $root.CoreML.Specification.FeatureType.verify(message.type);
                        if (error)
                            return "type." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a FeatureDescription message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.FeatureDescription} FeatureDescription
                 */
                FeatureDescription.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FeatureDescription)
                        return object;
                    var message = new $root.CoreML.Specification.FeatureDescription();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.shortDescription != null)
                        message.shortDescription = String(object.shortDescription);
                    if (object.type != null) {
                        if (typeof object.type !== "object")
                            throw TypeError(".CoreML.Specification.FeatureDescription.type: object expected");
                        message.type = $root.CoreML.Specification.FeatureType.fromObject(object.type);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FeatureDescription message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.FeatureDescription
                 * @static
                 * @param {CoreML.Specification.FeatureDescription} message FeatureDescription
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureDescription.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.shortDescription = "";
                        object.type = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        object.shortDescription = message.shortDescription;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = $root.CoreML.Specification.FeatureType.toObject(message.type, options);
                    return object;
                };
    
                /**
                 * Converts this FeatureDescription to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.FeatureDescription
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureDescription.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FeatureDescription;
            })();
    
            Specification.Metadata = (function() {
    
                /**
                 * Properties of a Metadata.
                 * @memberof CoreML.Specification
                 * @interface IMetadata
                 * @property {string|null} [shortDescription] Metadata shortDescription
                 * @property {string|null} [versionString] Metadata versionString
                 * @property {string|null} [author] Metadata author
                 * @property {string|null} [license] Metadata license
                 * @property {Object.<string,string>|null} [userDefined] Metadata userDefined
                 */
    
                /**
                 * Constructs a new Metadata.
                 * @memberof CoreML.Specification
                 * @classdesc Model metadata,
                 * consisting of a short description, a version string,
                 * an author, a license, and any other user defined
                 * key/value meta data.
                 * @implements IMetadata
                 * @constructor
                 * @param {CoreML.Specification.IMetadata=} [properties] Properties to set
                 */
                function Metadata(properties) {
                    this.userDefined = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Metadata shortDescription.
                 * @member {string} shortDescription
                 * @memberof CoreML.Specification.Metadata
                 * @instance
                 */
                Metadata.prototype.shortDescription = "";
    
                /**
                 * Metadata versionString.
                 * @member {string} versionString
                 * @memberof CoreML.Specification.Metadata
                 * @instance
                 */
                Metadata.prototype.versionString = "";
    
                /**
                 * Metadata author.
                 * @member {string} author
                 * @memberof CoreML.Specification.Metadata
                 * @instance
                 */
                Metadata.prototype.author = "";
    
                /**
                 * Metadata license.
                 * @member {string} license
                 * @memberof CoreML.Specification.Metadata
                 * @instance
                 */
                Metadata.prototype.license = "";
    
                /**
                 * Metadata userDefined.
                 * @member {Object.<string,string>} userDefined
                 * @memberof CoreML.Specification.Metadata
                 * @instance
                 */
                Metadata.prototype.userDefined = $util.emptyObject;
    
                /**
                 * Creates a new Metadata instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {CoreML.Specification.IMetadata=} [properties] Properties to set
                 * @returns {CoreML.Specification.Metadata} Metadata instance
                 */
                Metadata.create = function create(properties) {
                    return new Metadata(properties);
                };
    
                /**
                 * Encodes the specified Metadata message. Does not implicitly {@link CoreML.Specification.Metadata.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {CoreML.Specification.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.shortDescription);
                    if (message.versionString != null && message.hasOwnProperty("versionString"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.versionString);
                    if (message.author != null && message.hasOwnProperty("author"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.author);
                    if (message.license != null && message.hasOwnProperty("license"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.license);
                    if (message.userDefined != null && message.hasOwnProperty("userDefined"))
                        for (var keys = Object.keys(message.userDefined), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 100, wireType 2 =*/802).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.userDefined[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Metadata message, length delimited. Does not implicitly {@link CoreML.Specification.Metadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {CoreML.Specification.IMetadata} message Metadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Metadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Metadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Metadata(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.shortDescription = reader.string();
                            break;
                        case 2:
                            message.versionString = reader.string();
                            break;
                        case 3:
                            message.author = reader.string();
                            break;
                        case 4:
                            message.license = reader.string();
                            break;
                        case 100:
                            reader.skip().pos++;
                            if (message.userDefined === $util.emptyObject)
                                message.userDefined = {};
                            key = reader.string();
                            reader.pos++;
                            message.userDefined[key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Metadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Metadata} Metadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Metadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Metadata message.
                 * @function verify
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        if (!$util.isString(message.shortDescription))
                            return "shortDescription: string expected";
                    if (message.versionString != null && message.hasOwnProperty("versionString"))
                        if (!$util.isString(message.versionString))
                            return "versionString: string expected";
                    if (message.author != null && message.hasOwnProperty("author"))
                        if (!$util.isString(message.author))
                            return "author: string expected";
                    if (message.license != null && message.hasOwnProperty("license"))
                        if (!$util.isString(message.license))
                            return "license: string expected";
                    if (message.userDefined != null && message.hasOwnProperty("userDefined")) {
                        if (!$util.isObject(message.userDefined))
                            return "userDefined: object expected";
                        var key = Object.keys(message.userDefined);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isString(message.userDefined[key[i]]))
                                return "userDefined: string{k:string} expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Metadata} Metadata
                 */
                Metadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Metadata)
                        return object;
                    var message = new $root.CoreML.Specification.Metadata();
                    if (object.shortDescription != null)
                        message.shortDescription = String(object.shortDescription);
                    if (object.versionString != null)
                        message.versionString = String(object.versionString);
                    if (object.author != null)
                        message.author = String(object.author);
                    if (object.license != null)
                        message.license = String(object.license);
                    if (object.userDefined) {
                        if (typeof object.userDefined !== "object")
                            throw TypeError(".CoreML.Specification.Metadata.userDefined: object expected");
                        message.userDefined = {};
                        for (var keys = Object.keys(object.userDefined), i = 0; i < keys.length; ++i)
                            message.userDefined[keys[i]] = String(object.userDefined[keys[i]]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Metadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Metadata
                 * @static
                 * @param {CoreML.Specification.Metadata} message Metadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.userDefined = {};
                    if (options.defaults) {
                        object.shortDescription = "";
                        object.versionString = "";
                        object.author = "";
                        object.license = "";
                    }
                    if (message.shortDescription != null && message.hasOwnProperty("shortDescription"))
                        object.shortDescription = message.shortDescription;
                    if (message.versionString != null && message.hasOwnProperty("versionString"))
                        object.versionString = message.versionString;
                    if (message.author != null && message.hasOwnProperty("author"))
                        object.author = message.author;
                    if (message.license != null && message.hasOwnProperty("license"))
                        object.license = message.license;
                    var keys2;
                    if (message.userDefined && (keys2 = Object.keys(message.userDefined)).length) {
                        object.userDefined = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.userDefined[keys2[j]] = message.userDefined[keys2[j]];
                    }
                    return object;
                };
    
                /**
                 * Converts this Metadata to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Metadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Metadata;
            })();
    
            Specification.ModelDescription = (function() {
    
                /**
                 * Properties of a ModelDescription.
                 * @memberof CoreML.Specification
                 * @interface IModelDescription
                 * @property {Array.<CoreML.Specification.IFeatureDescription>|null} [input] ModelDescription input
                 * @property {Array.<CoreML.Specification.IFeatureDescription>|null} [output] ModelDescription output
                 * @property {string|null} [predictedFeatureName] ModelDescription predictedFeatureName
                 * @property {string|null} [predictedProbabilitiesName] ModelDescription predictedProbabilitiesName
                 * @property {CoreML.Specification.IMetadata|null} [metadata] ModelDescription metadata
                 */
    
                /**
                 * Constructs a new ModelDescription.
                 * @memberof CoreML.Specification
                 * @classdesc A description of a model,
                 * consisting of descriptions of its input and output features.
                 * Both regressor and classifier models require the name of the
                 * primary predicted output feature (``predictedFeatureName``).
                 * Classifier models can specify the output feature containing
                 * probabilities for the predicted classes
                 * (``predictedProbabilitiesName``).
                 * @implements IModelDescription
                 * @constructor
                 * @param {CoreML.Specification.IModelDescription=} [properties] Properties to set
                 */
                function ModelDescription(properties) {
                    this.input = [];
                    this.output = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ModelDescription input.
                 * @member {Array.<CoreML.Specification.IFeatureDescription>} input
                 * @memberof CoreML.Specification.ModelDescription
                 * @instance
                 */
                ModelDescription.prototype.input = $util.emptyArray;
    
                /**
                 * ModelDescription output.
                 * @member {Array.<CoreML.Specification.IFeatureDescription>} output
                 * @memberof CoreML.Specification.ModelDescription
                 * @instance
                 */
                ModelDescription.prototype.output = $util.emptyArray;
    
                /**
                 * ModelDescription predictedFeatureName.
                 * @member {string} predictedFeatureName
                 * @memberof CoreML.Specification.ModelDescription
                 * @instance
                 */
                ModelDescription.prototype.predictedFeatureName = "";
    
                /**
                 * ModelDescription predictedProbabilitiesName.
                 * @member {string} predictedProbabilitiesName
                 * @memberof CoreML.Specification.ModelDescription
                 * @instance
                 */
                ModelDescription.prototype.predictedProbabilitiesName = "";
    
                /**
                 * ModelDescription metadata.
                 * @member {CoreML.Specification.IMetadata|null|undefined} metadata
                 * @memberof CoreML.Specification.ModelDescription
                 * @instance
                 */
                ModelDescription.prototype.metadata = null;
    
                /**
                 * Creates a new ModelDescription instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {CoreML.Specification.IModelDescription=} [properties] Properties to set
                 * @returns {CoreML.Specification.ModelDescription} ModelDescription instance
                 */
                ModelDescription.create = function create(properties) {
                    return new ModelDescription(properties);
                };
    
                /**
                 * Encodes the specified ModelDescription message. Does not implicitly {@link CoreML.Specification.ModelDescription.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {CoreML.Specification.IModelDescription} message ModelDescription message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModelDescription.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.input != null && message.input.length)
                        for (var i = 0; i < message.input.length; ++i)
                            $root.CoreML.Specification.FeatureDescription.encode(message.input[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.output != null && message.output.length)
                        for (var i = 0; i < message.output.length; ++i)
                            $root.CoreML.Specification.FeatureDescription.encode(message.output[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.predictedFeatureName != null && message.hasOwnProperty("predictedFeatureName"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.predictedFeatureName);
                    if (message.predictedProbabilitiesName != null && message.hasOwnProperty("predictedProbabilitiesName"))
                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.predictedProbabilitiesName);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        $root.CoreML.Specification.Metadata.encode(message.metadata, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ModelDescription message, length delimited. Does not implicitly {@link CoreML.Specification.ModelDescription.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {CoreML.Specification.IModelDescription} message ModelDescription message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ModelDescription.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ModelDescription message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ModelDescription} ModelDescription
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModelDescription.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ModelDescription();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.input && message.input.length))
                                message.input = [];
                            message.input.push($root.CoreML.Specification.FeatureDescription.decode(reader, reader.uint32()));
                            break;
                        case 10:
                            if (!(message.output && message.output.length))
                                message.output = [];
                            message.output.push($root.CoreML.Specification.FeatureDescription.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            message.predictedFeatureName = reader.string();
                            break;
                        case 12:
                            message.predictedProbabilitiesName = reader.string();
                            break;
                        case 100:
                            message.metadata = $root.CoreML.Specification.Metadata.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ModelDescription message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ModelDescription} ModelDescription
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ModelDescription.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ModelDescription message.
                 * @function verify
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ModelDescription.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.input != null && message.hasOwnProperty("input")) {
                        if (!Array.isArray(message.input))
                            return "input: array expected";
                        for (var i = 0; i < message.input.length; ++i) {
                            var error = $root.CoreML.Specification.FeatureDescription.verify(message.input[i]);
                            if (error)
                                return "input." + error;
                        }
                    }
                    if (message.output != null && message.hasOwnProperty("output")) {
                        if (!Array.isArray(message.output))
                            return "output: array expected";
                        for (var i = 0; i < message.output.length; ++i) {
                            var error = $root.CoreML.Specification.FeatureDescription.verify(message.output[i]);
                            if (error)
                                return "output." + error;
                        }
                    }
                    if (message.predictedFeatureName != null && message.hasOwnProperty("predictedFeatureName"))
                        if (!$util.isString(message.predictedFeatureName))
                            return "predictedFeatureName: string expected";
                    if (message.predictedProbabilitiesName != null && message.hasOwnProperty("predictedProbabilitiesName"))
                        if (!$util.isString(message.predictedProbabilitiesName))
                            return "predictedProbabilitiesName: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        var error = $root.CoreML.Specification.Metadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ModelDescription message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ModelDescription} ModelDescription
                 */
                ModelDescription.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ModelDescription)
                        return object;
                    var message = new $root.CoreML.Specification.ModelDescription();
                    if (object.input) {
                        if (!Array.isArray(object.input))
                            throw TypeError(".CoreML.Specification.ModelDescription.input: array expected");
                        message.input = [];
                        for (var i = 0; i < object.input.length; ++i) {
                            if (typeof object.input[i] !== "object")
                                throw TypeError(".CoreML.Specification.ModelDescription.input: object expected");
                            message.input[i] = $root.CoreML.Specification.FeatureDescription.fromObject(object.input[i]);
                        }
                    }
                    if (object.output) {
                        if (!Array.isArray(object.output))
                            throw TypeError(".CoreML.Specification.ModelDescription.output: array expected");
                        message.output = [];
                        for (var i = 0; i < object.output.length; ++i) {
                            if (typeof object.output[i] !== "object")
                                throw TypeError(".CoreML.Specification.ModelDescription.output: object expected");
                            message.output[i] = $root.CoreML.Specification.FeatureDescription.fromObject(object.output[i]);
                        }
                    }
                    if (object.predictedFeatureName != null)
                        message.predictedFeatureName = String(object.predictedFeatureName);
                    if (object.predictedProbabilitiesName != null)
                        message.predictedProbabilitiesName = String(object.predictedProbabilitiesName);
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".CoreML.Specification.ModelDescription.metadata: object expected");
                        message.metadata = $root.CoreML.Specification.Metadata.fromObject(object.metadata);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ModelDescription message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ModelDescription
                 * @static
                 * @param {CoreML.Specification.ModelDescription} message ModelDescription
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ModelDescription.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.input = [];
                        object.output = [];
                    }
                    if (options.defaults) {
                        object.predictedFeatureName = "";
                        object.predictedProbabilitiesName = "";
                        object.metadata = null;
                    }
                    if (message.input && message.input.length) {
                        object.input = [];
                        for (var j = 0; j < message.input.length; ++j)
                            object.input[j] = $root.CoreML.Specification.FeatureDescription.toObject(message.input[j], options);
                    }
                    if (message.output && message.output.length) {
                        object.output = [];
                        for (var j = 0; j < message.output.length; ++j)
                            object.output[j] = $root.CoreML.Specification.FeatureDescription.toObject(message.output[j], options);
                    }
                    if (message.predictedFeatureName != null && message.hasOwnProperty("predictedFeatureName"))
                        object.predictedFeatureName = message.predictedFeatureName;
                    if (message.predictedProbabilitiesName != null && message.hasOwnProperty("predictedProbabilitiesName"))
                        object.predictedProbabilitiesName = message.predictedProbabilitiesName;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.CoreML.Specification.Metadata.toObject(message.metadata, options);
                    return object;
                };
    
                /**
                 * Converts this ModelDescription to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ModelDescription
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ModelDescription.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ModelDescription;
            })();
    
            Specification.Model = (function() {
    
                /**
                 * Properties of a Model.
                 * @memberof CoreML.Specification
                 * @interface IModel
                 * @property {number|null} [specificationVersion] Model specificationVersion
                 * @property {CoreML.Specification.IModelDescription|null} [description] Model description
                 * @property {CoreML.Specification.IPipelineClassifier|null} [pipelineClassifier] Model pipelineClassifier
                 * @property {CoreML.Specification.IPipelineRegressor|null} [pipelineRegressor] Model pipelineRegressor
                 * @property {CoreML.Specification.IPipeline|null} [pipeline] Model pipeline
                 * @property {CoreML.Specification.IGLMRegressor|null} [glmRegressor] Model glmRegressor
                 * @property {CoreML.Specification.ISupportVectorRegressor|null} [supportVectorRegressor] Model supportVectorRegressor
                 * @property {CoreML.Specification.ITreeEnsembleRegressor|null} [treeEnsembleRegressor] Model treeEnsembleRegressor
                 * @property {CoreML.Specification.INeuralNetworkRegressor|null} [neuralNetworkRegressor] Model neuralNetworkRegressor
                 * @property {CoreML.Specification.IGLMClassifier|null} [glmClassifier] Model glmClassifier
                 * @property {CoreML.Specification.ISupportVectorClassifier|null} [supportVectorClassifier] Model supportVectorClassifier
                 * @property {CoreML.Specification.ITreeEnsembleClassifier|null} [treeEnsembleClassifier] Model treeEnsembleClassifier
                 * @property {CoreML.Specification.INeuralNetworkClassifier|null} [neuralNetworkClassifier] Model neuralNetworkClassifier
                 * @property {CoreML.Specification.INeuralNetwork|null} [neuralNetwork] Model neuralNetwork
                 * @property {CoreML.Specification.IOneHotEncoder|null} [oneHotEncoder] Model oneHotEncoder
                 * @property {CoreML.Specification.IImputer|null} [imputer] Model imputer
                 * @property {CoreML.Specification.IFeatureVectorizer|null} [featureVectorizer] Model featureVectorizer
                 * @property {CoreML.Specification.IDictVectorizer|null} [dictVectorizer] Model dictVectorizer
                 * @property {CoreML.Specification.IScaler|null} [scaler] Model scaler
                 * @property {CoreML.Specification.ICategoricalMapping|null} [categoricalMapping] Model categoricalMapping
                 * @property {CoreML.Specification.INormalizer|null} [normalizer] Model normalizer
                 * @property {CoreML.Specification.IArrayFeatureExtractor|null} [arrayFeatureExtractor] Model arrayFeatureExtractor
                 * @property {CoreML.Specification.IIdentity|null} [identity] Model identity
                 */
    
                /**
                 * Constructs a new Model.
                 * @memberof CoreML.Specification
                 * @classdesc A Core ML model,
                 * consisting of a specification version,
                 * a model description, and a model type.
                 * 
                 * Core ML model compatibility is indicated by
                 * a monotonically increasing specification version number,
                 * which is incremented anytime a backward-incompatible change is made
                 * (this is functionally equivalent to the MAJOR version number
                 * described by `Semantic Versioning 2.0.0 <http://semver.org/>`_).
                 * The Core ML framework in macOS currently supports specification version ``1``.
                 * @implements IModel
                 * @constructor
                 * @param {CoreML.Specification.IModel=} [properties] Properties to set
                 */
                function Model(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Model specificationVersion.
                 * @member {number} specificationVersion
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.specificationVersion = 0;
    
                /**
                 * Model description.
                 * @member {CoreML.Specification.IModelDescription|null|undefined} description
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.description = null;
    
                /**
                 * Model pipelineClassifier.
                 * @member {CoreML.Specification.IPipelineClassifier|null|undefined} pipelineClassifier
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.pipelineClassifier = null;
    
                /**
                 * Model pipelineRegressor.
                 * @member {CoreML.Specification.IPipelineRegressor|null|undefined} pipelineRegressor
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.pipelineRegressor = null;
    
                /**
                 * Model pipeline.
                 * @member {CoreML.Specification.IPipeline|null|undefined} pipeline
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.pipeline = null;
    
                /**
                 * Model glmRegressor.
                 * @member {CoreML.Specification.IGLMRegressor|null|undefined} glmRegressor
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.glmRegressor = null;
    
                /**
                 * Model supportVectorRegressor.
                 * @member {CoreML.Specification.ISupportVectorRegressor|null|undefined} supportVectorRegressor
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.supportVectorRegressor = null;
    
                /**
                 * Model treeEnsembleRegressor.
                 * @member {CoreML.Specification.ITreeEnsembleRegressor|null|undefined} treeEnsembleRegressor
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.treeEnsembleRegressor = null;
    
                /**
                 * Model neuralNetworkRegressor.
                 * @member {CoreML.Specification.INeuralNetworkRegressor|null|undefined} neuralNetworkRegressor
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.neuralNetworkRegressor = null;
    
                /**
                 * Model glmClassifier.
                 * @member {CoreML.Specification.IGLMClassifier|null|undefined} glmClassifier
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.glmClassifier = null;
    
                /**
                 * Model supportVectorClassifier.
                 * @member {CoreML.Specification.ISupportVectorClassifier|null|undefined} supportVectorClassifier
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.supportVectorClassifier = null;
    
                /**
                 * Model treeEnsembleClassifier.
                 * @member {CoreML.Specification.ITreeEnsembleClassifier|null|undefined} treeEnsembleClassifier
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.treeEnsembleClassifier = null;
    
                /**
                 * Model neuralNetworkClassifier.
                 * @member {CoreML.Specification.INeuralNetworkClassifier|null|undefined} neuralNetworkClassifier
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.neuralNetworkClassifier = null;
    
                /**
                 * Model neuralNetwork.
                 * @member {CoreML.Specification.INeuralNetwork|null|undefined} neuralNetwork
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.neuralNetwork = null;
    
                /**
                 * Model oneHotEncoder.
                 * @member {CoreML.Specification.IOneHotEncoder|null|undefined} oneHotEncoder
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.oneHotEncoder = null;
    
                /**
                 * Model imputer.
                 * @member {CoreML.Specification.IImputer|null|undefined} imputer
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.imputer = null;
    
                /**
                 * Model featureVectorizer.
                 * @member {CoreML.Specification.IFeatureVectorizer|null|undefined} featureVectorizer
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.featureVectorizer = null;
    
                /**
                 * Model dictVectorizer.
                 * @member {CoreML.Specification.IDictVectorizer|null|undefined} dictVectorizer
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.dictVectorizer = null;
    
                /**
                 * Model scaler.
                 * @member {CoreML.Specification.IScaler|null|undefined} scaler
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.scaler = null;
    
                /**
                 * Model categoricalMapping.
                 * @member {CoreML.Specification.ICategoricalMapping|null|undefined} categoricalMapping
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.categoricalMapping = null;
    
                /**
                 * Model normalizer.
                 * @member {CoreML.Specification.INormalizer|null|undefined} normalizer
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.normalizer = null;
    
                /**
                 * Model arrayFeatureExtractor.
                 * @member {CoreML.Specification.IArrayFeatureExtractor|null|undefined} arrayFeatureExtractor
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.arrayFeatureExtractor = null;
    
                /**
                 * Model identity.
                 * @member {CoreML.Specification.IIdentity|null|undefined} identity
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Model.prototype.identity = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Model Type.
                 * @member {"pipelineClassifier"|"pipelineRegressor"|"pipeline"|"glmRegressor"|"supportVectorRegressor"|"treeEnsembleRegressor"|"neuralNetworkRegressor"|"glmClassifier"|"supportVectorClassifier"|"treeEnsembleClassifier"|"neuralNetworkClassifier"|"neuralNetwork"|"oneHotEncoder"|"imputer"|"featureVectorizer"|"dictVectorizer"|"scaler"|"categoricalMapping"|"normalizer"|"arrayFeatureExtractor"|"identity"|undefined} Type
                 * @memberof CoreML.Specification.Model
                 * @instance
                 */
                Object.defineProperty(Model.prototype, "Type", {
                    get: $util.oneOfGetter($oneOfFields = ["pipelineClassifier", "pipelineRegressor", "pipeline", "glmRegressor", "supportVectorRegressor", "treeEnsembleRegressor", "neuralNetworkRegressor", "glmClassifier", "supportVectorClassifier", "treeEnsembleClassifier", "neuralNetworkClassifier", "neuralNetwork", "oneHotEncoder", "imputer", "featureVectorizer", "dictVectorizer", "scaler", "categoricalMapping", "normalizer", "arrayFeatureExtractor", "identity"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Model instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {CoreML.Specification.IModel=} [properties] Properties to set
                 * @returns {CoreML.Specification.Model} Model instance
                 */
                Model.create = function create(properties) {
                    return new Model(properties);
                };
    
                /**
                 * Encodes the specified Model message. Does not implicitly {@link CoreML.Specification.Model.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {CoreML.Specification.IModel} message Model message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Model.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.specificationVersion != null && message.hasOwnProperty("specificationVersion"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.specificationVersion);
                    if (message.description != null && message.hasOwnProperty("description"))
                        $root.CoreML.Specification.ModelDescription.encode(message.description, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.pipelineClassifier != null && message.hasOwnProperty("pipelineClassifier"))
                        $root.CoreML.Specification.PipelineClassifier.encode(message.pipelineClassifier, writer.uint32(/* id 200, wireType 2 =*/1602).fork()).ldelim();
                    if (message.pipelineRegressor != null && message.hasOwnProperty("pipelineRegressor"))
                        $root.CoreML.Specification.PipelineRegressor.encode(message.pipelineRegressor, writer.uint32(/* id 201, wireType 2 =*/1610).fork()).ldelim();
                    if (message.pipeline != null && message.hasOwnProperty("pipeline"))
                        $root.CoreML.Specification.Pipeline.encode(message.pipeline, writer.uint32(/* id 202, wireType 2 =*/1618).fork()).ldelim();
                    if (message.glmRegressor != null && message.hasOwnProperty("glmRegressor"))
                        $root.CoreML.Specification.GLMRegressor.encode(message.glmRegressor, writer.uint32(/* id 300, wireType 2 =*/2402).fork()).ldelim();
                    if (message.supportVectorRegressor != null && message.hasOwnProperty("supportVectorRegressor"))
                        $root.CoreML.Specification.SupportVectorRegressor.encode(message.supportVectorRegressor, writer.uint32(/* id 301, wireType 2 =*/2410).fork()).ldelim();
                    if (message.treeEnsembleRegressor != null && message.hasOwnProperty("treeEnsembleRegressor"))
                        $root.CoreML.Specification.TreeEnsembleRegressor.encode(message.treeEnsembleRegressor, writer.uint32(/* id 302, wireType 2 =*/2418).fork()).ldelim();
                    if (message.neuralNetworkRegressor != null && message.hasOwnProperty("neuralNetworkRegressor"))
                        $root.CoreML.Specification.NeuralNetworkRegressor.encode(message.neuralNetworkRegressor, writer.uint32(/* id 303, wireType 2 =*/2426).fork()).ldelim();
                    if (message.glmClassifier != null && message.hasOwnProperty("glmClassifier"))
                        $root.CoreML.Specification.GLMClassifier.encode(message.glmClassifier, writer.uint32(/* id 400, wireType 2 =*/3202).fork()).ldelim();
                    if (message.supportVectorClassifier != null && message.hasOwnProperty("supportVectorClassifier"))
                        $root.CoreML.Specification.SupportVectorClassifier.encode(message.supportVectorClassifier, writer.uint32(/* id 401, wireType 2 =*/3210).fork()).ldelim();
                    if (message.treeEnsembleClassifier != null && message.hasOwnProperty("treeEnsembleClassifier"))
                        $root.CoreML.Specification.TreeEnsembleClassifier.encode(message.treeEnsembleClassifier, writer.uint32(/* id 402, wireType 2 =*/3218).fork()).ldelim();
                    if (message.neuralNetworkClassifier != null && message.hasOwnProperty("neuralNetworkClassifier"))
                        $root.CoreML.Specification.NeuralNetworkClassifier.encode(message.neuralNetworkClassifier, writer.uint32(/* id 403, wireType 2 =*/3226).fork()).ldelim();
                    if (message.neuralNetwork != null && message.hasOwnProperty("neuralNetwork"))
                        $root.CoreML.Specification.NeuralNetwork.encode(message.neuralNetwork, writer.uint32(/* id 500, wireType 2 =*/4002).fork()).ldelim();
                    if (message.oneHotEncoder != null && message.hasOwnProperty("oneHotEncoder"))
                        $root.CoreML.Specification.OneHotEncoder.encode(message.oneHotEncoder, writer.uint32(/* id 600, wireType 2 =*/4802).fork()).ldelim();
                    if (message.imputer != null && message.hasOwnProperty("imputer"))
                        $root.CoreML.Specification.Imputer.encode(message.imputer, writer.uint32(/* id 601, wireType 2 =*/4810).fork()).ldelim();
                    if (message.featureVectorizer != null && message.hasOwnProperty("featureVectorizer"))
                        $root.CoreML.Specification.FeatureVectorizer.encode(message.featureVectorizer, writer.uint32(/* id 602, wireType 2 =*/4818).fork()).ldelim();
                    if (message.dictVectorizer != null && message.hasOwnProperty("dictVectorizer"))
                        $root.CoreML.Specification.DictVectorizer.encode(message.dictVectorizer, writer.uint32(/* id 603, wireType 2 =*/4826).fork()).ldelim();
                    if (message.scaler != null && message.hasOwnProperty("scaler"))
                        $root.CoreML.Specification.Scaler.encode(message.scaler, writer.uint32(/* id 604, wireType 2 =*/4834).fork()).ldelim();
                    if (message.categoricalMapping != null && message.hasOwnProperty("categoricalMapping"))
                        $root.CoreML.Specification.CategoricalMapping.encode(message.categoricalMapping, writer.uint32(/* id 606, wireType 2 =*/4850).fork()).ldelim();
                    if (message.normalizer != null && message.hasOwnProperty("normalizer"))
                        $root.CoreML.Specification.Normalizer.encode(message.normalizer, writer.uint32(/* id 607, wireType 2 =*/4858).fork()).ldelim();
                    if (message.arrayFeatureExtractor != null && message.hasOwnProperty("arrayFeatureExtractor"))
                        $root.CoreML.Specification.ArrayFeatureExtractor.encode(message.arrayFeatureExtractor, writer.uint32(/* id 609, wireType 2 =*/4874).fork()).ldelim();
                    if (message.identity != null && message.hasOwnProperty("identity"))
                        $root.CoreML.Specification.Identity.encode(message.identity, writer.uint32(/* id 900, wireType 2 =*/7202).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Model message, length delimited. Does not implicitly {@link CoreML.Specification.Model.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {CoreML.Specification.IModel} message Model message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Model.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Model message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Model} Model
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Model.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Model();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.specificationVersion = reader.int32();
                            break;
                        case 2:
                            message.description = $root.CoreML.Specification.ModelDescription.decode(reader, reader.uint32());
                            break;
                        case 200:
                            message.pipelineClassifier = $root.CoreML.Specification.PipelineClassifier.decode(reader, reader.uint32());
                            break;
                        case 201:
                            message.pipelineRegressor = $root.CoreML.Specification.PipelineRegressor.decode(reader, reader.uint32());
                            break;
                        case 202:
                            message.pipeline = $root.CoreML.Specification.Pipeline.decode(reader, reader.uint32());
                            break;
                        case 300:
                            message.glmRegressor = $root.CoreML.Specification.GLMRegressor.decode(reader, reader.uint32());
                            break;
                        case 301:
                            message.supportVectorRegressor = $root.CoreML.Specification.SupportVectorRegressor.decode(reader, reader.uint32());
                            break;
                        case 302:
                            message.treeEnsembleRegressor = $root.CoreML.Specification.TreeEnsembleRegressor.decode(reader, reader.uint32());
                            break;
                        case 303:
                            message.neuralNetworkRegressor = $root.CoreML.Specification.NeuralNetworkRegressor.decode(reader, reader.uint32());
                            break;
                        case 400:
                            message.glmClassifier = $root.CoreML.Specification.GLMClassifier.decode(reader, reader.uint32());
                            break;
                        case 401:
                            message.supportVectorClassifier = $root.CoreML.Specification.SupportVectorClassifier.decode(reader, reader.uint32());
                            break;
                        case 402:
                            message.treeEnsembleClassifier = $root.CoreML.Specification.TreeEnsembleClassifier.decode(reader, reader.uint32());
                            break;
                        case 403:
                            message.neuralNetworkClassifier = $root.CoreML.Specification.NeuralNetworkClassifier.decode(reader, reader.uint32());
                            break;
                        case 500:
                            message.neuralNetwork = $root.CoreML.Specification.NeuralNetwork.decode(reader, reader.uint32());
                            break;
                        case 600:
                            message.oneHotEncoder = $root.CoreML.Specification.OneHotEncoder.decode(reader, reader.uint32());
                            break;
                        case 601:
                            message.imputer = $root.CoreML.Specification.Imputer.decode(reader, reader.uint32());
                            break;
                        case 602:
                            message.featureVectorizer = $root.CoreML.Specification.FeatureVectorizer.decode(reader, reader.uint32());
                            break;
                        case 603:
                            message.dictVectorizer = $root.CoreML.Specification.DictVectorizer.decode(reader, reader.uint32());
                            break;
                        case 604:
                            message.scaler = $root.CoreML.Specification.Scaler.decode(reader, reader.uint32());
                            break;
                        case 606:
                            message.categoricalMapping = $root.CoreML.Specification.CategoricalMapping.decode(reader, reader.uint32());
                            break;
                        case 607:
                            message.normalizer = $root.CoreML.Specification.Normalizer.decode(reader, reader.uint32());
                            break;
                        case 609:
                            message.arrayFeatureExtractor = $root.CoreML.Specification.ArrayFeatureExtractor.decode(reader, reader.uint32());
                            break;
                        case 900:
                            message.identity = $root.CoreML.Specification.Identity.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Model message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Model} Model
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Model.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Model message.
                 * @function verify
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Model.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.specificationVersion != null && message.hasOwnProperty("specificationVersion"))
                        if (!$util.isInteger(message.specificationVersion))
                            return "specificationVersion: integer expected";
                    if (message.description != null && message.hasOwnProperty("description")) {
                        var error = $root.CoreML.Specification.ModelDescription.verify(message.description);
                        if (error)
                            return "description." + error;
                    }
                    if (message.pipelineClassifier != null && message.hasOwnProperty("pipelineClassifier")) {
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.PipelineClassifier.verify(message.pipelineClassifier);
                            if (error)
                                return "pipelineClassifier." + error;
                        }
                    }
                    if (message.pipelineRegressor != null && message.hasOwnProperty("pipelineRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.PipelineRegressor.verify(message.pipelineRegressor);
                            if (error)
                                return "pipelineRegressor." + error;
                        }
                    }
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Pipeline.verify(message.pipeline);
                            if (error)
                                return "pipeline." + error;
                        }
                    }
                    if (message.glmRegressor != null && message.hasOwnProperty("glmRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.GLMRegressor.verify(message.glmRegressor);
                            if (error)
                                return "glmRegressor." + error;
                        }
                    }
                    if (message.supportVectorRegressor != null && message.hasOwnProperty("supportVectorRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.SupportVectorRegressor.verify(message.supportVectorRegressor);
                            if (error)
                                return "supportVectorRegressor." + error;
                        }
                    }
                    if (message.treeEnsembleRegressor != null && message.hasOwnProperty("treeEnsembleRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.TreeEnsembleRegressor.verify(message.treeEnsembleRegressor);
                            if (error)
                                return "treeEnsembleRegressor." + error;
                        }
                    }
                    if (message.neuralNetworkRegressor != null && message.hasOwnProperty("neuralNetworkRegressor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkRegressor.verify(message.neuralNetworkRegressor);
                            if (error)
                                return "neuralNetworkRegressor." + error;
                        }
                    }
                    if (message.glmClassifier != null && message.hasOwnProperty("glmClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.GLMClassifier.verify(message.glmClassifier);
                            if (error)
                                return "glmClassifier." + error;
                        }
                    }
                    if (message.supportVectorClassifier != null && message.hasOwnProperty("supportVectorClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.SupportVectorClassifier.verify(message.supportVectorClassifier);
                            if (error)
                                return "supportVectorClassifier." + error;
                        }
                    }
                    if (message.treeEnsembleClassifier != null && message.hasOwnProperty("treeEnsembleClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.TreeEnsembleClassifier.verify(message.treeEnsembleClassifier);
                            if (error)
                                return "treeEnsembleClassifier." + error;
                        }
                    }
                    if (message.neuralNetworkClassifier != null && message.hasOwnProperty("neuralNetworkClassifier")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkClassifier.verify(message.neuralNetworkClassifier);
                            if (error)
                                return "neuralNetworkClassifier." + error;
                        }
                    }
                    if (message.neuralNetwork != null && message.hasOwnProperty("neuralNetwork")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetwork.verify(message.neuralNetwork);
                            if (error)
                                return "neuralNetwork." + error;
                        }
                    }
                    if (message.oneHotEncoder != null && message.hasOwnProperty("oneHotEncoder")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.OneHotEncoder.verify(message.oneHotEncoder);
                            if (error)
                                return "oneHotEncoder." + error;
                        }
                    }
                    if (message.imputer != null && message.hasOwnProperty("imputer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Imputer.verify(message.imputer);
                            if (error)
                                return "imputer." + error;
                        }
                    }
                    if (message.featureVectorizer != null && message.hasOwnProperty("featureVectorizer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.FeatureVectorizer.verify(message.featureVectorizer);
                            if (error)
                                return "featureVectorizer." + error;
                        }
                    }
                    if (message.dictVectorizer != null && message.hasOwnProperty("dictVectorizer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.DictVectorizer.verify(message.dictVectorizer);
                            if (error)
                                return "dictVectorizer." + error;
                        }
                    }
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Scaler.verify(message.scaler);
                            if (error)
                                return "scaler." + error;
                        }
                    }
                    if (message.categoricalMapping != null && message.hasOwnProperty("categoricalMapping")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.CategoricalMapping.verify(message.categoricalMapping);
                            if (error)
                                return "categoricalMapping." + error;
                        }
                    }
                    if (message.normalizer != null && message.hasOwnProperty("normalizer")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Normalizer.verify(message.normalizer);
                            if (error)
                                return "normalizer." + error;
                        }
                    }
                    if (message.arrayFeatureExtractor != null && message.hasOwnProperty("arrayFeatureExtractor")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.ArrayFeatureExtractor.verify(message.arrayFeatureExtractor);
                            if (error)
                                return "arrayFeatureExtractor." + error;
                        }
                    }
                    if (message.identity != null && message.hasOwnProperty("identity")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Identity.verify(message.identity);
                            if (error)
                                return "identity." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Model message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Model} Model
                 */
                Model.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Model)
                        return object;
                    var message = new $root.CoreML.Specification.Model();
                    if (object.specificationVersion != null)
                        message.specificationVersion = object.specificationVersion | 0;
                    if (object.description != null) {
                        if (typeof object.description !== "object")
                            throw TypeError(".CoreML.Specification.Model.description: object expected");
                        message.description = $root.CoreML.Specification.ModelDescription.fromObject(object.description);
                    }
                    if (object.pipelineClassifier != null) {
                        if (typeof object.pipelineClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.pipelineClassifier: object expected");
                        message.pipelineClassifier = $root.CoreML.Specification.PipelineClassifier.fromObject(object.pipelineClassifier);
                    }
                    if (object.pipelineRegressor != null) {
                        if (typeof object.pipelineRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.pipelineRegressor: object expected");
                        message.pipelineRegressor = $root.CoreML.Specification.PipelineRegressor.fromObject(object.pipelineRegressor);
                    }
                    if (object.pipeline != null) {
                        if (typeof object.pipeline !== "object")
                            throw TypeError(".CoreML.Specification.Model.pipeline: object expected");
                        message.pipeline = $root.CoreML.Specification.Pipeline.fromObject(object.pipeline);
                    }
                    if (object.glmRegressor != null) {
                        if (typeof object.glmRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.glmRegressor: object expected");
                        message.glmRegressor = $root.CoreML.Specification.GLMRegressor.fromObject(object.glmRegressor);
                    }
                    if (object.supportVectorRegressor != null) {
                        if (typeof object.supportVectorRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.supportVectorRegressor: object expected");
                        message.supportVectorRegressor = $root.CoreML.Specification.SupportVectorRegressor.fromObject(object.supportVectorRegressor);
                    }
                    if (object.treeEnsembleRegressor != null) {
                        if (typeof object.treeEnsembleRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.treeEnsembleRegressor: object expected");
                        message.treeEnsembleRegressor = $root.CoreML.Specification.TreeEnsembleRegressor.fromObject(object.treeEnsembleRegressor);
                    }
                    if (object.neuralNetworkRegressor != null) {
                        if (typeof object.neuralNetworkRegressor !== "object")
                            throw TypeError(".CoreML.Specification.Model.neuralNetworkRegressor: object expected");
                        message.neuralNetworkRegressor = $root.CoreML.Specification.NeuralNetworkRegressor.fromObject(object.neuralNetworkRegressor);
                    }
                    if (object.glmClassifier != null) {
                        if (typeof object.glmClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.glmClassifier: object expected");
                        message.glmClassifier = $root.CoreML.Specification.GLMClassifier.fromObject(object.glmClassifier);
                    }
                    if (object.supportVectorClassifier != null) {
                        if (typeof object.supportVectorClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.supportVectorClassifier: object expected");
                        message.supportVectorClassifier = $root.CoreML.Specification.SupportVectorClassifier.fromObject(object.supportVectorClassifier);
                    }
                    if (object.treeEnsembleClassifier != null) {
                        if (typeof object.treeEnsembleClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.treeEnsembleClassifier: object expected");
                        message.treeEnsembleClassifier = $root.CoreML.Specification.TreeEnsembleClassifier.fromObject(object.treeEnsembleClassifier);
                    }
                    if (object.neuralNetworkClassifier != null) {
                        if (typeof object.neuralNetworkClassifier !== "object")
                            throw TypeError(".CoreML.Specification.Model.neuralNetworkClassifier: object expected");
                        message.neuralNetworkClassifier = $root.CoreML.Specification.NeuralNetworkClassifier.fromObject(object.neuralNetworkClassifier);
                    }
                    if (object.neuralNetwork != null) {
                        if (typeof object.neuralNetwork !== "object")
                            throw TypeError(".CoreML.Specification.Model.neuralNetwork: object expected");
                        message.neuralNetwork = $root.CoreML.Specification.NeuralNetwork.fromObject(object.neuralNetwork);
                    }
                    if (object.oneHotEncoder != null) {
                        if (typeof object.oneHotEncoder !== "object")
                            throw TypeError(".CoreML.Specification.Model.oneHotEncoder: object expected");
                        message.oneHotEncoder = $root.CoreML.Specification.OneHotEncoder.fromObject(object.oneHotEncoder);
                    }
                    if (object.imputer != null) {
                        if (typeof object.imputer !== "object")
                            throw TypeError(".CoreML.Specification.Model.imputer: object expected");
                        message.imputer = $root.CoreML.Specification.Imputer.fromObject(object.imputer);
                    }
                    if (object.featureVectorizer != null) {
                        if (typeof object.featureVectorizer !== "object")
                            throw TypeError(".CoreML.Specification.Model.featureVectorizer: object expected");
                        message.featureVectorizer = $root.CoreML.Specification.FeatureVectorizer.fromObject(object.featureVectorizer);
                    }
                    if (object.dictVectorizer != null) {
                        if (typeof object.dictVectorizer !== "object")
                            throw TypeError(".CoreML.Specification.Model.dictVectorizer: object expected");
                        message.dictVectorizer = $root.CoreML.Specification.DictVectorizer.fromObject(object.dictVectorizer);
                    }
                    if (object.scaler != null) {
                        if (typeof object.scaler !== "object")
                            throw TypeError(".CoreML.Specification.Model.scaler: object expected");
                        message.scaler = $root.CoreML.Specification.Scaler.fromObject(object.scaler);
                    }
                    if (object.categoricalMapping != null) {
                        if (typeof object.categoricalMapping !== "object")
                            throw TypeError(".CoreML.Specification.Model.categoricalMapping: object expected");
                        message.categoricalMapping = $root.CoreML.Specification.CategoricalMapping.fromObject(object.categoricalMapping);
                    }
                    if (object.normalizer != null) {
                        if (typeof object.normalizer !== "object")
                            throw TypeError(".CoreML.Specification.Model.normalizer: object expected");
                        message.normalizer = $root.CoreML.Specification.Normalizer.fromObject(object.normalizer);
                    }
                    if (object.arrayFeatureExtractor != null) {
                        if (typeof object.arrayFeatureExtractor !== "object")
                            throw TypeError(".CoreML.Specification.Model.arrayFeatureExtractor: object expected");
                        message.arrayFeatureExtractor = $root.CoreML.Specification.ArrayFeatureExtractor.fromObject(object.arrayFeatureExtractor);
                    }
                    if (object.identity != null) {
                        if (typeof object.identity !== "object")
                            throw TypeError(".CoreML.Specification.Model.identity: object expected");
                        message.identity = $root.CoreML.Specification.Identity.fromObject(object.identity);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Model message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Model
                 * @static
                 * @param {CoreML.Specification.Model} message Model
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Model.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.specificationVersion = 0;
                        object.description = null;
                    }
                    if (message.specificationVersion != null && message.hasOwnProperty("specificationVersion"))
                        object.specificationVersion = message.specificationVersion;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = $root.CoreML.Specification.ModelDescription.toObject(message.description, options);
                    if (message.pipelineClassifier != null && message.hasOwnProperty("pipelineClassifier")) {
                        object.pipelineClassifier = $root.CoreML.Specification.PipelineClassifier.toObject(message.pipelineClassifier, options);
                        if (options.oneofs)
                            object.Type = "pipelineClassifier";
                    }
                    if (message.pipelineRegressor != null && message.hasOwnProperty("pipelineRegressor")) {
                        object.pipelineRegressor = $root.CoreML.Specification.PipelineRegressor.toObject(message.pipelineRegressor, options);
                        if (options.oneofs)
                            object.Type = "pipelineRegressor";
                    }
                    if (message.pipeline != null && message.hasOwnProperty("pipeline")) {
                        object.pipeline = $root.CoreML.Specification.Pipeline.toObject(message.pipeline, options);
                        if (options.oneofs)
                            object.Type = "pipeline";
                    }
                    if (message.glmRegressor != null && message.hasOwnProperty("glmRegressor")) {
                        object.glmRegressor = $root.CoreML.Specification.GLMRegressor.toObject(message.glmRegressor, options);
                        if (options.oneofs)
                            object.Type = "glmRegressor";
                    }
                    if (message.supportVectorRegressor != null && message.hasOwnProperty("supportVectorRegressor")) {
                        object.supportVectorRegressor = $root.CoreML.Specification.SupportVectorRegressor.toObject(message.supportVectorRegressor, options);
                        if (options.oneofs)
                            object.Type = "supportVectorRegressor";
                    }
                    if (message.treeEnsembleRegressor != null && message.hasOwnProperty("treeEnsembleRegressor")) {
                        object.treeEnsembleRegressor = $root.CoreML.Specification.TreeEnsembleRegressor.toObject(message.treeEnsembleRegressor, options);
                        if (options.oneofs)
                            object.Type = "treeEnsembleRegressor";
                    }
                    if (message.neuralNetworkRegressor != null && message.hasOwnProperty("neuralNetworkRegressor")) {
                        object.neuralNetworkRegressor = $root.CoreML.Specification.NeuralNetworkRegressor.toObject(message.neuralNetworkRegressor, options);
                        if (options.oneofs)
                            object.Type = "neuralNetworkRegressor";
                    }
                    if (message.glmClassifier != null && message.hasOwnProperty("glmClassifier")) {
                        object.glmClassifier = $root.CoreML.Specification.GLMClassifier.toObject(message.glmClassifier, options);
                        if (options.oneofs)
                            object.Type = "glmClassifier";
                    }
                    if (message.supportVectorClassifier != null && message.hasOwnProperty("supportVectorClassifier")) {
                        object.supportVectorClassifier = $root.CoreML.Specification.SupportVectorClassifier.toObject(message.supportVectorClassifier, options);
                        if (options.oneofs)
                            object.Type = "supportVectorClassifier";
                    }
                    if (message.treeEnsembleClassifier != null && message.hasOwnProperty("treeEnsembleClassifier")) {
                        object.treeEnsembleClassifier = $root.CoreML.Specification.TreeEnsembleClassifier.toObject(message.treeEnsembleClassifier, options);
                        if (options.oneofs)
                            object.Type = "treeEnsembleClassifier";
                    }
                    if (message.neuralNetworkClassifier != null && message.hasOwnProperty("neuralNetworkClassifier")) {
                        object.neuralNetworkClassifier = $root.CoreML.Specification.NeuralNetworkClassifier.toObject(message.neuralNetworkClassifier, options);
                        if (options.oneofs)
                            object.Type = "neuralNetworkClassifier";
                    }
                    if (message.neuralNetwork != null && message.hasOwnProperty("neuralNetwork")) {
                        object.neuralNetwork = $root.CoreML.Specification.NeuralNetwork.toObject(message.neuralNetwork, options);
                        if (options.oneofs)
                            object.Type = "neuralNetwork";
                    }
                    if (message.oneHotEncoder != null && message.hasOwnProperty("oneHotEncoder")) {
                        object.oneHotEncoder = $root.CoreML.Specification.OneHotEncoder.toObject(message.oneHotEncoder, options);
                        if (options.oneofs)
                            object.Type = "oneHotEncoder";
                    }
                    if (message.imputer != null && message.hasOwnProperty("imputer")) {
                        object.imputer = $root.CoreML.Specification.Imputer.toObject(message.imputer, options);
                        if (options.oneofs)
                            object.Type = "imputer";
                    }
                    if (message.featureVectorizer != null && message.hasOwnProperty("featureVectorizer")) {
                        object.featureVectorizer = $root.CoreML.Specification.FeatureVectorizer.toObject(message.featureVectorizer, options);
                        if (options.oneofs)
                            object.Type = "featureVectorizer";
                    }
                    if (message.dictVectorizer != null && message.hasOwnProperty("dictVectorizer")) {
                        object.dictVectorizer = $root.CoreML.Specification.DictVectorizer.toObject(message.dictVectorizer, options);
                        if (options.oneofs)
                            object.Type = "dictVectorizer";
                    }
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        object.scaler = $root.CoreML.Specification.Scaler.toObject(message.scaler, options);
                        if (options.oneofs)
                            object.Type = "scaler";
                    }
                    if (message.categoricalMapping != null && message.hasOwnProperty("categoricalMapping")) {
                        object.categoricalMapping = $root.CoreML.Specification.CategoricalMapping.toObject(message.categoricalMapping, options);
                        if (options.oneofs)
                            object.Type = "categoricalMapping";
                    }
                    if (message.normalizer != null && message.hasOwnProperty("normalizer")) {
                        object.normalizer = $root.CoreML.Specification.Normalizer.toObject(message.normalizer, options);
                        if (options.oneofs)
                            object.Type = "normalizer";
                    }
                    if (message.arrayFeatureExtractor != null && message.hasOwnProperty("arrayFeatureExtractor")) {
                        object.arrayFeatureExtractor = $root.CoreML.Specification.ArrayFeatureExtractor.toObject(message.arrayFeatureExtractor, options);
                        if (options.oneofs)
                            object.Type = "arrayFeatureExtractor";
                    }
                    if (message.identity != null && message.hasOwnProperty("identity")) {
                        object.identity = $root.CoreML.Specification.Identity.toObject(message.identity, options);
                        if (options.oneofs)
                            object.Type = "identity";
                    }
                    return object;
                };
    
                /**
                 * Converts this Model to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Model
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Model.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Model;
            })();
    
            Specification.ArrayFeatureExtractor = (function() {
    
                /**
                 * Properties of an ArrayFeatureExtractor.
                 * @memberof CoreML.Specification
                 * @interface IArrayFeatureExtractor
                 * @property {Array.<number|Long>|null} [extractIndex] ArrayFeatureExtractor extractIndex
                 */
    
                /**
                 * Constructs a new ArrayFeatureExtractor.
                 * @memberof CoreML.Specification
                 * @classdesc An array feature extractor.
                 * 
                 * Given an index, extracts the value at that index from its array input.
                 * Indexes are zero-based.
                 * @implements IArrayFeatureExtractor
                 * @constructor
                 * @param {CoreML.Specification.IArrayFeatureExtractor=} [properties] Properties to set
                 */
                function ArrayFeatureExtractor(properties) {
                    this.extractIndex = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ArrayFeatureExtractor extractIndex.
                 * @member {Array.<number|Long>} extractIndex
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @instance
                 */
                ArrayFeatureExtractor.prototype.extractIndex = $util.emptyArray;
    
                /**
                 * Creates a new ArrayFeatureExtractor instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {CoreML.Specification.IArrayFeatureExtractor=} [properties] Properties to set
                 * @returns {CoreML.Specification.ArrayFeatureExtractor} ArrayFeatureExtractor instance
                 */
                ArrayFeatureExtractor.create = function create(properties) {
                    return new ArrayFeatureExtractor(properties);
                };
    
                /**
                 * Encodes the specified ArrayFeatureExtractor message. Does not implicitly {@link CoreML.Specification.ArrayFeatureExtractor.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {CoreML.Specification.IArrayFeatureExtractor} message ArrayFeatureExtractor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayFeatureExtractor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.extractIndex != null && message.extractIndex.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.extractIndex.length; ++i)
                            writer.uint64(message.extractIndex[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified ArrayFeatureExtractor message, length delimited. Does not implicitly {@link CoreML.Specification.ArrayFeatureExtractor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {CoreML.Specification.IArrayFeatureExtractor} message ArrayFeatureExtractor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayFeatureExtractor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ArrayFeatureExtractor message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ArrayFeatureExtractor} ArrayFeatureExtractor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayFeatureExtractor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureExtractor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.extractIndex && message.extractIndex.length))
                                message.extractIndex = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.extractIndex.push(reader.uint64());
                            } else
                                message.extractIndex.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ArrayFeatureExtractor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ArrayFeatureExtractor} ArrayFeatureExtractor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayFeatureExtractor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ArrayFeatureExtractor message.
                 * @function verify
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArrayFeatureExtractor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.extractIndex != null && message.hasOwnProperty("extractIndex")) {
                        if (!Array.isArray(message.extractIndex))
                            return "extractIndex: array expected";
                        for (var i = 0; i < message.extractIndex.length; ++i)
                            if (!$util.isInteger(message.extractIndex[i]) && !(message.extractIndex[i] && $util.isInteger(message.extractIndex[i].low) && $util.isInteger(message.extractIndex[i].high)))
                                return "extractIndex: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an ArrayFeatureExtractor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ArrayFeatureExtractor} ArrayFeatureExtractor
                 */
                ArrayFeatureExtractor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ArrayFeatureExtractor)
                        return object;
                    var message = new $root.CoreML.Specification.ArrayFeatureExtractor();
                    if (object.extractIndex) {
                        if (!Array.isArray(object.extractIndex))
                            throw TypeError(".CoreML.Specification.ArrayFeatureExtractor.extractIndex: array expected");
                        message.extractIndex = [];
                        for (var i = 0; i < object.extractIndex.length; ++i)
                            if ($util.Long)
                                (message.extractIndex[i] = $util.Long.fromValue(object.extractIndex[i])).unsigned = true;
                            else if (typeof object.extractIndex[i] === "string")
                                message.extractIndex[i] = parseInt(object.extractIndex[i], 10);
                            else if (typeof object.extractIndex[i] === "number")
                                message.extractIndex[i] = object.extractIndex[i];
                            else if (typeof object.extractIndex[i] === "object")
                                message.extractIndex[i] = new $util.LongBits(object.extractIndex[i].low >>> 0, object.extractIndex[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ArrayFeatureExtractor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @static
                 * @param {CoreML.Specification.ArrayFeatureExtractor} message ArrayFeatureExtractor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArrayFeatureExtractor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.extractIndex = [];
                    if (message.extractIndex && message.extractIndex.length) {
                        object.extractIndex = [];
                        for (var j = 0; j < message.extractIndex.length; ++j)
                            if (typeof message.extractIndex[j] === "number")
                                object.extractIndex[j] = options.longs === String ? String(message.extractIndex[j]) : message.extractIndex[j];
                            else
                                object.extractIndex[j] = options.longs === String ? $util.Long.prototype.toString.call(message.extractIndex[j]) : options.longs === Number ? new $util.LongBits(message.extractIndex[j].low >>> 0, message.extractIndex[j].high >>> 0).toNumber(true) : message.extractIndex[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this ArrayFeatureExtractor to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ArrayFeatureExtractor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArrayFeatureExtractor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ArrayFeatureExtractor;
            })();
    
            Specification.CategoricalMapping = (function() {
    
                /**
                 * Properties of a CategoricalMapping.
                 * @memberof CoreML.Specification
                 * @interface ICategoricalMapping
                 * @property {CoreML.Specification.IStringToInt64Map|null} [stringToInt64Map] CategoricalMapping stringToInt64Map
                 * @property {CoreML.Specification.IInt64ToStringMap|null} [int64ToStringMap] CategoricalMapping int64ToStringMap
                 * @property {string|null} [strValue] CategoricalMapping strValue
                 * @property {number|Long|null} [int64Value] CategoricalMapping int64Value
                 */
    
                /**
                 * Constructs a new CategoricalMapping.
                 * @memberof CoreML.Specification
                 * @classdesc A categorical mapping.
                 * 
                 * This allows conversion from integers to strings, or from strings to integers.
                 * @implements ICategoricalMapping
                 * @constructor
                 * @param {CoreML.Specification.ICategoricalMapping=} [properties] Properties to set
                 */
                function CategoricalMapping(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CategoricalMapping stringToInt64Map.
                 * @member {CoreML.Specification.IStringToInt64Map|null|undefined} stringToInt64Map
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 */
                CategoricalMapping.prototype.stringToInt64Map = null;
    
                /**
                 * CategoricalMapping int64ToStringMap.
                 * @member {CoreML.Specification.IInt64ToStringMap|null|undefined} int64ToStringMap
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 */
                CategoricalMapping.prototype.int64ToStringMap = null;
    
                /**
                 * CategoricalMapping strValue.
                 * @member {string} strValue
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 */
                CategoricalMapping.prototype.strValue = "";
    
                /**
                 * CategoricalMapping int64Value.
                 * @member {number|Long} int64Value
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 */
                CategoricalMapping.prototype.int64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * CategoricalMapping MappingType.
                 * @member {"stringToInt64Map"|"int64ToStringMap"|undefined} MappingType
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 */
                Object.defineProperty(CategoricalMapping.prototype, "MappingType", {
                    get: $util.oneOfGetter($oneOfFields = ["stringToInt64Map", "int64ToStringMap"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * The value returned if an input is not contained in the map above.
                 * If one of these is not set, then an error is raised on an unknown input.
                 * @member {"strValue"|"int64Value"|undefined} ValueOnUnknown
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 */
                Object.defineProperty(CategoricalMapping.prototype, "ValueOnUnknown", {
                    get: $util.oneOfGetter($oneOfFields = ["strValue", "int64Value"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new CategoricalMapping instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {CoreML.Specification.ICategoricalMapping=} [properties] Properties to set
                 * @returns {CoreML.Specification.CategoricalMapping} CategoricalMapping instance
                 */
                CategoricalMapping.create = function create(properties) {
                    return new CategoricalMapping(properties);
                };
    
                /**
                 * Encodes the specified CategoricalMapping message. Does not implicitly {@link CoreML.Specification.CategoricalMapping.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {CoreML.Specification.ICategoricalMapping} message CategoricalMapping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CategoricalMapping.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stringToInt64Map != null && message.hasOwnProperty("stringToInt64Map"))
                        $root.CoreML.Specification.StringToInt64Map.encode(message.stringToInt64Map, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.int64ToStringMap != null && message.hasOwnProperty("int64ToStringMap"))
                        $root.CoreML.Specification.Int64ToStringMap.encode(message.int64ToStringMap, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.strValue != null && message.hasOwnProperty("strValue"))
                        writer.uint32(/* id 101, wireType 2 =*/810).string(message.strValue);
                    if (message.int64Value != null && message.hasOwnProperty("int64Value"))
                        writer.uint32(/* id 102, wireType 0 =*/816).int64(message.int64Value);
                    return writer;
                };
    
                /**
                 * Encodes the specified CategoricalMapping message, length delimited. Does not implicitly {@link CoreML.Specification.CategoricalMapping.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {CoreML.Specification.ICategoricalMapping} message CategoricalMapping message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CategoricalMapping.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CategoricalMapping message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.CategoricalMapping} CategoricalMapping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CategoricalMapping.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CategoricalMapping();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringToInt64Map = $root.CoreML.Specification.StringToInt64Map.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.int64ToStringMap = $root.CoreML.Specification.Int64ToStringMap.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.strValue = reader.string();
                            break;
                        case 102:
                            message.int64Value = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CategoricalMapping message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.CategoricalMapping} CategoricalMapping
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CategoricalMapping.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CategoricalMapping message.
                 * @function verify
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CategoricalMapping.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringToInt64Map != null && message.hasOwnProperty("stringToInt64Map")) {
                        properties.MappingType = 1;
                        {
                            var error = $root.CoreML.Specification.StringToInt64Map.verify(message.stringToInt64Map);
                            if (error)
                                return "stringToInt64Map." + error;
                        }
                    }
                    if (message.int64ToStringMap != null && message.hasOwnProperty("int64ToStringMap")) {
                        if (properties.MappingType === 1)
                            return "MappingType: multiple values";
                        properties.MappingType = 1;
                        {
                            var error = $root.CoreML.Specification.Int64ToStringMap.verify(message.int64ToStringMap);
                            if (error)
                                return "int64ToStringMap." + error;
                        }
                    }
                    if (message.strValue != null && message.hasOwnProperty("strValue")) {
                        properties.ValueOnUnknown = 1;
                        if (!$util.isString(message.strValue))
                            return "strValue: string expected";
                    }
                    if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                        if (properties.ValueOnUnknown === 1)
                            return "ValueOnUnknown: multiple values";
                        properties.ValueOnUnknown = 1;
                        if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                            return "int64Value: integer|Long expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a CategoricalMapping message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.CategoricalMapping} CategoricalMapping
                 */
                CategoricalMapping.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CategoricalMapping)
                        return object;
                    var message = new $root.CoreML.Specification.CategoricalMapping();
                    if (object.stringToInt64Map != null) {
                        if (typeof object.stringToInt64Map !== "object")
                            throw TypeError(".CoreML.Specification.CategoricalMapping.stringToInt64Map: object expected");
                        message.stringToInt64Map = $root.CoreML.Specification.StringToInt64Map.fromObject(object.stringToInt64Map);
                    }
                    if (object.int64ToStringMap != null) {
                        if (typeof object.int64ToStringMap !== "object")
                            throw TypeError(".CoreML.Specification.CategoricalMapping.int64ToStringMap: object expected");
                        message.int64ToStringMap = $root.CoreML.Specification.Int64ToStringMap.fromObject(object.int64ToStringMap);
                    }
                    if (object.strValue != null)
                        message.strValue = String(object.strValue);
                    if (object.int64Value != null)
                        if ($util.Long)
                            (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                        else if (typeof object.int64Value === "string")
                            message.int64Value = parseInt(object.int64Value, 10);
                        else if (typeof object.int64Value === "number")
                            message.int64Value = object.int64Value;
                        else if (typeof object.int64Value === "object")
                            message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
                    return message;
                };
    
                /**
                 * Creates a plain object from a CategoricalMapping message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @static
                 * @param {CoreML.Specification.CategoricalMapping} message CategoricalMapping
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CategoricalMapping.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.stringToInt64Map != null && message.hasOwnProperty("stringToInt64Map")) {
                        object.stringToInt64Map = $root.CoreML.Specification.StringToInt64Map.toObject(message.stringToInt64Map, options);
                        if (options.oneofs)
                            object.MappingType = "stringToInt64Map";
                    }
                    if (message.int64ToStringMap != null && message.hasOwnProperty("int64ToStringMap")) {
                        object.int64ToStringMap = $root.CoreML.Specification.Int64ToStringMap.toObject(message.int64ToStringMap, options);
                        if (options.oneofs)
                            object.MappingType = "int64ToStringMap";
                    }
                    if (message.strValue != null && message.hasOwnProperty("strValue")) {
                        object.strValue = message.strValue;
                        if (options.oneofs)
                            object.ValueOnUnknown = "strValue";
                    }
                    if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                        if (typeof message.int64Value === "number")
                            object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                        else
                            object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
                        if (options.oneofs)
                            object.ValueOnUnknown = "int64Value";
                    }
                    return object;
                };
    
                /**
                 * Converts this CategoricalMapping to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.CategoricalMapping
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CategoricalMapping.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CategoricalMapping;
            })();
    
            Specification.StringToInt64Map = (function() {
    
                /**
                 * Properties of a StringToInt64Map.
                 * @memberof CoreML.Specification
                 * @interface IStringToInt64Map
                 * @property {Object.<string,number|Long>|null} [map] StringToInt64Map map
                 */
    
                /**
                 * Constructs a new StringToInt64Map.
                 * @memberof CoreML.Specification
                 * @classdesc A mapping from a string
                 * to a 64-bit integer.
                 * @implements IStringToInt64Map
                 * @constructor
                 * @param {CoreML.Specification.IStringToInt64Map=} [properties] Properties to set
                 */
                function StringToInt64Map(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StringToInt64Map map.
                 * @member {Object.<string,number|Long>} map
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @instance
                 */
                StringToInt64Map.prototype.map = $util.emptyObject;
    
                /**
                 * Creates a new StringToInt64Map instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {CoreML.Specification.IStringToInt64Map=} [properties] Properties to set
                 * @returns {CoreML.Specification.StringToInt64Map} StringToInt64Map instance
                 */
                StringToInt64Map.create = function create(properties) {
                    return new StringToInt64Map(properties);
                };
    
                /**
                 * Encodes the specified StringToInt64Map message. Does not implicitly {@link CoreML.Specification.StringToInt64Map.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {CoreML.Specification.IStringToInt64Map} message StringToInt64Map message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringToInt64Map.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.map != null && message.hasOwnProperty("map"))
                        for (var keys = Object.keys(message.map), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 0 =*/16).int64(message.map[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified StringToInt64Map message, length delimited. Does not implicitly {@link CoreML.Specification.StringToInt64Map.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {CoreML.Specification.IStringToInt64Map} message StringToInt64Map message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringToInt64Map.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a StringToInt64Map message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.StringToInt64Map} StringToInt64Map
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringToInt64Map.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringToInt64Map(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.string();
                            reader.pos++;
                            message.map[key] = reader.int64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a StringToInt64Map message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.StringToInt64Map} StringToInt64Map
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringToInt64Map.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a StringToInt64Map message.
                 * @function verify
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringToInt64Map.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i)
                            if (!$util.isInteger(message.map[key[i]]) && !(message.map[key[i]] && $util.isInteger(message.map[key[i]].low) && $util.isInteger(message.map[key[i]].high)))
                                return "map: integer|Long{k:string} expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a StringToInt64Map message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.StringToInt64Map} StringToInt64Map
                 */
                StringToInt64Map.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringToInt64Map)
                        return object;
                    var message = new $root.CoreML.Specification.StringToInt64Map();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.StringToInt64Map.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            if ($util.Long)
                                (message.map[keys[i]] = $util.Long.fromValue(object.map[keys[i]])).unsigned = false;
                            else if (typeof object.map[keys[i]] === "string")
                                message.map[keys[i]] = parseInt(object.map[keys[i]], 10);
                            else if (typeof object.map[keys[i]] === "number")
                                message.map[keys[i]] = object.map[keys[i]];
                            else if (typeof object.map[keys[i]] === "object")
                                message.map[keys[i]] = new $util.LongBits(object.map[keys[i]].low >>> 0, object.map[keys[i]].high >>> 0).toNumber();
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a StringToInt64Map message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @static
                 * @param {CoreML.Specification.StringToInt64Map} message StringToInt64Map
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringToInt64Map.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            if (typeof message.map[keys2[j]] === "number")
                                object.map[keys2[j]] = options.longs === String ? String(message.map[keys2[j]]) : message.map[keys2[j]];
                            else
                                object.map[keys2[j]] = options.longs === String ? $util.Long.prototype.toString.call(message.map[keys2[j]]) : options.longs === Number ? new $util.LongBits(message.map[keys2[j]].low >>> 0, message.map[keys2[j]].high >>> 0).toNumber() : message.map[keys2[j]];
                    }
                    return object;
                };
    
                /**
                 * Converts this StringToInt64Map to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.StringToInt64Map
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringToInt64Map.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringToInt64Map;
            })();
    
            Specification.Int64ToStringMap = (function() {
    
                /**
                 * Properties of an Int64ToStringMap.
                 * @memberof CoreML.Specification
                 * @interface IInt64ToStringMap
                 * @property {Object.<string,string>|null} [map] Int64ToStringMap map
                 */
    
                /**
                 * Constructs a new Int64ToStringMap.
                 * @memberof CoreML.Specification
                 * @classdesc A mapping from a 64-bit integer
                 * to a string.
                 * @implements IInt64ToStringMap
                 * @constructor
                 * @param {CoreML.Specification.IInt64ToStringMap=} [properties] Properties to set
                 */
                function Int64ToStringMap(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int64ToStringMap map.
                 * @member {Object.<string,string>} map
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @instance
                 */
                Int64ToStringMap.prototype.map = $util.emptyObject;
    
                /**
                 * Creates a new Int64ToStringMap instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {CoreML.Specification.IInt64ToStringMap=} [properties] Properties to set
                 * @returns {CoreML.Specification.Int64ToStringMap} Int64ToStringMap instance
                 */
                Int64ToStringMap.create = function create(properties) {
                    return new Int64ToStringMap(properties);
                };
    
                /**
                 * Encodes the specified Int64ToStringMap message. Does not implicitly {@link CoreML.Specification.Int64ToStringMap.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {CoreML.Specification.IInt64ToStringMap} message Int64ToStringMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64ToStringMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.map != null && message.hasOwnProperty("map"))
                        for (var keys = Object.keys(message.map), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 2 =*/18).string(message.map[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Int64ToStringMap message, length delimited. Does not implicitly {@link CoreML.Specification.Int64ToStringMap.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {CoreML.Specification.IInt64ToStringMap} message Int64ToStringMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64ToStringMap.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Int64ToStringMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Int64ToStringMap} Int64ToStringMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64ToStringMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64ToStringMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.int64();
                            reader.pos++;
                            message.map[typeof key === "object" ? $util.longToHash(key) : key] = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Int64ToStringMap message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Int64ToStringMap} Int64ToStringMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64ToStringMap.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Int64ToStringMap message.
                 * @function verify
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int64ToStringMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "map: integer|Long key{k:int64} expected";
                            if (!$util.isString(message.map[key[i]]))
                                return "map: string{k:int64} expected";
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Int64ToStringMap message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Int64ToStringMap} Int64ToStringMap
                 */
                Int64ToStringMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64ToStringMap)
                        return object;
                    var message = new $root.CoreML.Specification.Int64ToStringMap();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.Int64ToStringMap.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            message.map[keys[i]] = String(object.map[keys[i]]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Int64ToStringMap message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @static
                 * @param {CoreML.Specification.Int64ToStringMap} message Int64ToStringMap
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Int64ToStringMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.map[keys2[j]] = message.map[keys2[j]];
                    }
                    return object;
                };
    
                /**
                 * Converts this Int64ToStringMap to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Int64ToStringMap
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Int64ToStringMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64ToStringMap;
            })();
    
            Specification.StringToDoubleMap = (function() {
    
                /**
                 * Properties of a StringToDoubleMap.
                 * @memberof CoreML.Specification
                 * @interface IStringToDoubleMap
                 * @property {Object.<string,number>|null} [map] StringToDoubleMap map
                 */
    
                /**
                 * Constructs a new StringToDoubleMap.
                 * @memberof CoreML.Specification
                 * @classdesc A mapping from a string
                 * to a double-precision floating point number.
                 * @implements IStringToDoubleMap
                 * @constructor
                 * @param {CoreML.Specification.IStringToDoubleMap=} [properties] Properties to set
                 */
                function StringToDoubleMap(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StringToDoubleMap map.
                 * @member {Object.<string,number>} map
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @instance
                 */
                StringToDoubleMap.prototype.map = $util.emptyObject;
    
                /**
                 * Creates a new StringToDoubleMap instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {CoreML.Specification.IStringToDoubleMap=} [properties] Properties to set
                 * @returns {CoreML.Specification.StringToDoubleMap} StringToDoubleMap instance
                 */
                StringToDoubleMap.create = function create(properties) {
                    return new StringToDoubleMap(properties);
                };
    
                /**
                 * Encodes the specified StringToDoubleMap message. Does not implicitly {@link CoreML.Specification.StringToDoubleMap.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {CoreML.Specification.IStringToDoubleMap} message StringToDoubleMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringToDoubleMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.map != null && message.hasOwnProperty("map"))
                        for (var keys = Object.keys(message.map), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.map[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified StringToDoubleMap message, length delimited. Does not implicitly {@link CoreML.Specification.StringToDoubleMap.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {CoreML.Specification.IStringToDoubleMap} message StringToDoubleMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringToDoubleMap.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a StringToDoubleMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.StringToDoubleMap} StringToDoubleMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringToDoubleMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringToDoubleMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.string();
                            reader.pos++;
                            message.map[key] = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a StringToDoubleMap message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.StringToDoubleMap} StringToDoubleMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringToDoubleMap.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a StringToDoubleMap message.
                 * @function verify
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringToDoubleMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i)
                            if (typeof message.map[key[i]] !== "number")
                                return "map: number{k:string} expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a StringToDoubleMap message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.StringToDoubleMap} StringToDoubleMap
                 */
                StringToDoubleMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringToDoubleMap)
                        return object;
                    var message = new $root.CoreML.Specification.StringToDoubleMap();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.StringToDoubleMap.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            message.map[keys[i]] = Number(object.map[keys[i]]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a StringToDoubleMap message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @static
                 * @param {CoreML.Specification.StringToDoubleMap} message StringToDoubleMap
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringToDoubleMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.map[keys2[j]] = options.json && !isFinite(message.map[keys2[j]]) ? String(message.map[keys2[j]]) : message.map[keys2[j]];
                    }
                    return object;
                };
    
                /**
                 * Converts this StringToDoubleMap to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.StringToDoubleMap
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringToDoubleMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringToDoubleMap;
            })();
    
            Specification.Int64ToDoubleMap = (function() {
    
                /**
                 * Properties of an Int64ToDoubleMap.
                 * @memberof CoreML.Specification
                 * @interface IInt64ToDoubleMap
                 * @property {Object.<string,number>|null} [map] Int64ToDoubleMap map
                 */
    
                /**
                 * Constructs a new Int64ToDoubleMap.
                 * @memberof CoreML.Specification
                 * @classdesc A mapping from a 64-bit integer
                 * to a double-precision floating point number.
                 * @implements IInt64ToDoubleMap
                 * @constructor
                 * @param {CoreML.Specification.IInt64ToDoubleMap=} [properties] Properties to set
                 */
                function Int64ToDoubleMap(properties) {
                    this.map = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int64ToDoubleMap map.
                 * @member {Object.<string,number>} map
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @instance
                 */
                Int64ToDoubleMap.prototype.map = $util.emptyObject;
    
                /**
                 * Creates a new Int64ToDoubleMap instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {CoreML.Specification.IInt64ToDoubleMap=} [properties] Properties to set
                 * @returns {CoreML.Specification.Int64ToDoubleMap} Int64ToDoubleMap instance
                 */
                Int64ToDoubleMap.create = function create(properties) {
                    return new Int64ToDoubleMap(properties);
                };
    
                /**
                 * Encodes the specified Int64ToDoubleMap message. Does not implicitly {@link CoreML.Specification.Int64ToDoubleMap.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {CoreML.Specification.IInt64ToDoubleMap} message Int64ToDoubleMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64ToDoubleMap.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.map != null && message.hasOwnProperty("map"))
                        for (var keys = Object.keys(message.map), i = 0; i < keys.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).fork().uint32(/* id 1, wireType 0 =*/8).int64(keys[i]).uint32(/* id 2, wireType 1 =*/17).double(message.map[keys[i]]).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Int64ToDoubleMap message, length delimited. Does not implicitly {@link CoreML.Specification.Int64ToDoubleMap.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {CoreML.Specification.IInt64ToDoubleMap} message Int64ToDoubleMap message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64ToDoubleMap.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Int64ToDoubleMap message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Int64ToDoubleMap} Int64ToDoubleMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64ToDoubleMap.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64ToDoubleMap(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            reader.skip().pos++;
                            if (message.map === $util.emptyObject)
                                message.map = {};
                            key = reader.int64();
                            reader.pos++;
                            message.map[typeof key === "object" ? $util.longToHash(key) : key] = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Int64ToDoubleMap message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Int64ToDoubleMap} Int64ToDoubleMap
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64ToDoubleMap.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Int64ToDoubleMap message.
                 * @function verify
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int64ToDoubleMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.map != null && message.hasOwnProperty("map")) {
                        if (!$util.isObject(message.map))
                            return "map: object expected";
                        var key = Object.keys(message.map);
                        for (var i = 0; i < key.length; ++i) {
                            if (!$util.key64Re.test(key[i]))
                                return "map: integer|Long key{k:int64} expected";
                            if (typeof message.map[key[i]] !== "number")
                                return "map: number{k:int64} expected";
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an Int64ToDoubleMap message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Int64ToDoubleMap} Int64ToDoubleMap
                 */
                Int64ToDoubleMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64ToDoubleMap)
                        return object;
                    var message = new $root.CoreML.Specification.Int64ToDoubleMap();
                    if (object.map) {
                        if (typeof object.map !== "object")
                            throw TypeError(".CoreML.Specification.Int64ToDoubleMap.map: object expected");
                        message.map = {};
                        for (var keys = Object.keys(object.map), i = 0; i < keys.length; ++i)
                            message.map[keys[i]] = Number(object.map[keys[i]]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Int64ToDoubleMap message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @static
                 * @param {CoreML.Specification.Int64ToDoubleMap} message Int64ToDoubleMap
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Int64ToDoubleMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.objects || options.defaults)
                        object.map = {};
                    var keys2;
                    if (message.map && (keys2 = Object.keys(message.map)).length) {
                        object.map = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.map[keys2[j]] = options.json && !isFinite(message.map[keys2[j]]) ? String(message.map[keys2[j]]) : message.map[keys2[j]];
                    }
                    return object;
                };
    
                /**
                 * Converts this Int64ToDoubleMap to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Int64ToDoubleMap
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Int64ToDoubleMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64ToDoubleMap;
            })();
    
            Specification.StringVector = (function() {
    
                /**
                 * Properties of a StringVector.
                 * @memberof CoreML.Specification
                 * @interface IStringVector
                 * @property {Array.<string>|null} [vector] StringVector vector
                 */
    
                /**
                 * Constructs a new StringVector.
                 * @memberof CoreML.Specification
                 * @classdesc A vector of strings.
                 * @implements IStringVector
                 * @constructor
                 * @param {CoreML.Specification.IStringVector=} [properties] Properties to set
                 */
                function StringVector(properties) {
                    this.vector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * StringVector vector.
                 * @member {Array.<string>} vector
                 * @memberof CoreML.Specification.StringVector
                 * @instance
                 */
                StringVector.prototype.vector = $util.emptyArray;
    
                /**
                 * Creates a new StringVector instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {CoreML.Specification.IStringVector=} [properties] Properties to set
                 * @returns {CoreML.Specification.StringVector} StringVector instance
                 */
                StringVector.create = function create(properties) {
                    return new StringVector(properties);
                };
    
                /**
                 * Encodes the specified StringVector message. Does not implicitly {@link CoreML.Specification.StringVector.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {CoreML.Specification.IStringVector} message StringVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringVector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vector != null && message.vector.length)
                        for (var i = 0; i < message.vector.length; ++i)
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.vector[i]);
                    return writer;
                };
    
                /**
                 * Encodes the specified StringVector message, length delimited. Does not implicitly {@link CoreML.Specification.StringVector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {CoreML.Specification.IStringVector} message StringVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringVector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a StringVector message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.StringVector} StringVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vector && message.vector.length))
                                message.vector = [];
                            message.vector.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a StringVector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.StringVector} StringVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringVector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a StringVector message.
                 * @function verify
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vector != null && message.hasOwnProperty("vector")) {
                        if (!Array.isArray(message.vector))
                            return "vector: array expected";
                        for (var i = 0; i < message.vector.length; ++i)
                            if (!$util.isString(message.vector[i]))
                                return "vector: string[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a StringVector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.StringVector} StringVector
                 */
                StringVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringVector)
                        return object;
                    var message = new $root.CoreML.Specification.StringVector();
                    if (object.vector) {
                        if (!Array.isArray(object.vector))
                            throw TypeError(".CoreML.Specification.StringVector.vector: array expected");
                        message.vector = [];
                        for (var i = 0; i < object.vector.length; ++i)
                            message.vector[i] = String(object.vector[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a StringVector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.StringVector
                 * @static
                 * @param {CoreML.Specification.StringVector} message StringVector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vector = [];
                    if (message.vector && message.vector.length) {
                        object.vector = [];
                        for (var j = 0; j < message.vector.length; ++j)
                            object.vector[j] = message.vector[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this StringVector to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.StringVector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringVector;
            })();
    
            Specification.Int64Vector = (function() {
    
                /**
                 * Properties of an Int64Vector.
                 * @memberof CoreML.Specification
                 * @interface IInt64Vector
                 * @property {Array.<number|Long>|null} [vector] Int64Vector vector
                 */
    
                /**
                 * Constructs a new Int64Vector.
                 * @memberof CoreML.Specification
                 * @classdesc A vector of 64-bit integers.
                 * @implements IInt64Vector
                 * @constructor
                 * @param {CoreML.Specification.IInt64Vector=} [properties] Properties to set
                 */
                function Int64Vector(properties) {
                    this.vector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Int64Vector vector.
                 * @member {Array.<number|Long>} vector
                 * @memberof CoreML.Specification.Int64Vector
                 * @instance
                 */
                Int64Vector.prototype.vector = $util.emptyArray;
    
                /**
                 * Creates a new Int64Vector instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {CoreML.Specification.IInt64Vector=} [properties] Properties to set
                 * @returns {CoreML.Specification.Int64Vector} Int64Vector instance
                 */
                Int64Vector.create = function create(properties) {
                    return new Int64Vector(properties);
                };
    
                /**
                 * Encodes the specified Int64Vector message. Does not implicitly {@link CoreML.Specification.Int64Vector.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {CoreML.Specification.IInt64Vector} message Int64Vector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64Vector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vector != null && message.vector.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.vector.length; ++i)
                            writer.int64(message.vector[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified Int64Vector message, length delimited. Does not implicitly {@link CoreML.Specification.Int64Vector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {CoreML.Specification.IInt64Vector} message Int64Vector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64Vector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Int64Vector message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Int64Vector} Int64Vector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64Vector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64Vector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vector && message.vector.length))
                                message.vector = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.vector.push(reader.int64());
                            } else
                                message.vector.push(reader.int64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Int64Vector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Int64Vector} Int64Vector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64Vector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Int64Vector message.
                 * @function verify
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int64Vector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vector != null && message.hasOwnProperty("vector")) {
                        if (!Array.isArray(message.vector))
                            return "vector: array expected";
                        for (var i = 0; i < message.vector.length; ++i)
                            if (!$util.isInteger(message.vector[i]) && !(message.vector[i] && $util.isInteger(message.vector[i].low) && $util.isInteger(message.vector[i].high)))
                                return "vector: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an Int64Vector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Int64Vector} Int64Vector
                 */
                Int64Vector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64Vector)
                        return object;
                    var message = new $root.CoreML.Specification.Int64Vector();
                    if (object.vector) {
                        if (!Array.isArray(object.vector))
                            throw TypeError(".CoreML.Specification.Int64Vector.vector: array expected");
                        message.vector = [];
                        for (var i = 0; i < object.vector.length; ++i)
                            if ($util.Long)
                                (message.vector[i] = $util.Long.fromValue(object.vector[i])).unsigned = false;
                            else if (typeof object.vector[i] === "string")
                                message.vector[i] = parseInt(object.vector[i], 10);
                            else if (typeof object.vector[i] === "number")
                                message.vector[i] = object.vector[i];
                            else if (typeof object.vector[i] === "object")
                                message.vector[i] = new $util.LongBits(object.vector[i].low >>> 0, object.vector[i].high >>> 0).toNumber();
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an Int64Vector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Int64Vector
                 * @static
                 * @param {CoreML.Specification.Int64Vector} message Int64Vector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Int64Vector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vector = [];
                    if (message.vector && message.vector.length) {
                        object.vector = [];
                        for (var j = 0; j < message.vector.length; ++j)
                            if (typeof message.vector[j] === "number")
                                object.vector[j] = options.longs === String ? String(message.vector[j]) : message.vector[j];
                            else
                                object.vector[j] = options.longs === String ? $util.Long.prototype.toString.call(message.vector[j]) : options.longs === Number ? new $util.LongBits(message.vector[j].low >>> 0, message.vector[j].high >>> 0).toNumber() : message.vector[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this Int64Vector to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Int64Vector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Int64Vector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64Vector;
            })();
    
            Specification.DoubleVector = (function() {
    
                /**
                 * Properties of a DoubleVector.
                 * @memberof CoreML.Specification
                 * @interface IDoubleVector
                 * @property {Array.<number>|null} [vector] DoubleVector vector
                 */
    
                /**
                 * Constructs a new DoubleVector.
                 * @memberof CoreML.Specification
                 * @classdesc A vector of double-precision floating point numbers.
                 * @implements IDoubleVector
                 * @constructor
                 * @param {CoreML.Specification.IDoubleVector=} [properties] Properties to set
                 */
                function DoubleVector(properties) {
                    this.vector = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DoubleVector vector.
                 * @member {Array.<number>} vector
                 * @memberof CoreML.Specification.DoubleVector
                 * @instance
                 */
                DoubleVector.prototype.vector = $util.emptyArray;
    
                /**
                 * Creates a new DoubleVector instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {CoreML.Specification.IDoubleVector=} [properties] Properties to set
                 * @returns {CoreML.Specification.DoubleVector} DoubleVector instance
                 */
                DoubleVector.create = function create(properties) {
                    return new DoubleVector(properties);
                };
    
                /**
                 * Encodes the specified DoubleVector message. Does not implicitly {@link CoreML.Specification.DoubleVector.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {CoreML.Specification.IDoubleVector} message DoubleVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleVector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vector != null && message.vector.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.vector.length; ++i)
                            writer.double(message.vector[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified DoubleVector message, length delimited. Does not implicitly {@link CoreML.Specification.DoubleVector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {CoreML.Specification.IDoubleVector} message DoubleVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleVector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DoubleVector message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DoubleVector} DoubleVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DoubleVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vector && message.vector.length))
                                message.vector = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.vector.push(reader.double());
                            } else
                                message.vector.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DoubleVector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DoubleVector} DoubleVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleVector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DoubleVector message.
                 * @function verify
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DoubleVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vector != null && message.hasOwnProperty("vector")) {
                        if (!Array.isArray(message.vector))
                            return "vector: array expected";
                        for (var i = 0; i < message.vector.length; ++i)
                            if (typeof message.vector[i] !== "number")
                                return "vector: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DoubleVector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DoubleVector} DoubleVector
                 */
                DoubleVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DoubleVector)
                        return object;
                    var message = new $root.CoreML.Specification.DoubleVector();
                    if (object.vector) {
                        if (!Array.isArray(object.vector))
                            throw TypeError(".CoreML.Specification.DoubleVector.vector: array expected");
                        message.vector = [];
                        for (var i = 0; i < object.vector.length; ++i)
                            message.vector[i] = Number(object.vector[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DoubleVector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DoubleVector
                 * @static
                 * @param {CoreML.Specification.DoubleVector} message DoubleVector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DoubleVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vector = [];
                    if (message.vector && message.vector.length) {
                        object.vector = [];
                        for (var j = 0; j < message.vector.length; ++j)
                            object.vector[j] = options.json && !isFinite(message.vector[j]) ? String(message.vector[j]) : message.vector[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DoubleVector to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DoubleVector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DoubleVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DoubleVector;
            })();
    
            Specification.Int64FeatureType = (function() {
    
                /**
                 * Properties of an Int64FeatureType.
                 * @memberof CoreML.Specification
                 * @interface IInt64FeatureType
                 */
    
                /**
                 * Constructs a new Int64FeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc The 64-bit integer feature type.
                 * @implements IInt64FeatureType
                 * @constructor
                 * @param {CoreML.Specification.IInt64FeatureType=} [properties] Properties to set
                 */
                function Int64FeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Int64FeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {CoreML.Specification.IInt64FeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.Int64FeatureType} Int64FeatureType instance
                 */
                Int64FeatureType.create = function create(properties) {
                    return new Int64FeatureType(properties);
                };
    
                /**
                 * Encodes the specified Int64FeatureType message. Does not implicitly {@link CoreML.Specification.Int64FeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {CoreML.Specification.IInt64FeatureType} message Int64FeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64FeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Int64FeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.Int64FeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {CoreML.Specification.IInt64FeatureType} message Int64FeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Int64FeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Int64FeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Int64FeatureType} Int64FeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64FeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Int64FeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Int64FeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Int64FeatureType} Int64FeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Int64FeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Int64FeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Int64FeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Int64FeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Int64FeatureType} Int64FeatureType
                 */
                Int64FeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Int64FeatureType)
                        return object;
                    return new $root.CoreML.Specification.Int64FeatureType();
                };
    
                /**
                 * Creates a plain object from an Int64FeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @static
                 * @param {CoreML.Specification.Int64FeatureType} message Int64FeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Int64FeatureType.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Int64FeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Int64FeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Int64FeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Int64FeatureType;
            })();
    
            Specification.DoubleFeatureType = (function() {
    
                /**
                 * Properties of a DoubleFeatureType.
                 * @memberof CoreML.Specification
                 * @interface IDoubleFeatureType
                 */
    
                /**
                 * Constructs a new DoubleFeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc The double-precision floating point number feature type.
                 * @implements IDoubleFeatureType
                 * @constructor
                 * @param {CoreML.Specification.IDoubleFeatureType=} [properties] Properties to set
                 */
                function DoubleFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new DoubleFeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {CoreML.Specification.IDoubleFeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.DoubleFeatureType} DoubleFeatureType instance
                 */
                DoubleFeatureType.create = function create(properties) {
                    return new DoubleFeatureType(properties);
                };
    
                /**
                 * Encodes the specified DoubleFeatureType message. Does not implicitly {@link CoreML.Specification.DoubleFeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {CoreML.Specification.IDoubleFeatureType} message DoubleFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleFeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified DoubleFeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.DoubleFeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {CoreML.Specification.IDoubleFeatureType} message DoubleFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DoubleFeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DoubleFeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DoubleFeatureType} DoubleFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DoubleFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DoubleFeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DoubleFeatureType} DoubleFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DoubleFeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DoubleFeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DoubleFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a DoubleFeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DoubleFeatureType} DoubleFeatureType
                 */
                DoubleFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DoubleFeatureType)
                        return object;
                    return new $root.CoreML.Specification.DoubleFeatureType();
                };
    
                /**
                 * Creates a plain object from a DoubleFeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @static
                 * @param {CoreML.Specification.DoubleFeatureType} message DoubleFeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DoubleFeatureType.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this DoubleFeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DoubleFeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DoubleFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DoubleFeatureType;
            })();
    
            Specification.StringFeatureType = (function() {
    
                /**
                 * Properties of a StringFeatureType.
                 * @memberof CoreML.Specification
                 * @interface IStringFeatureType
                 */
    
                /**
                 * Constructs a new StringFeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc The string feature type.
                 * @implements IStringFeatureType
                 * @constructor
                 * @param {CoreML.Specification.IStringFeatureType=} [properties] Properties to set
                 */
                function StringFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new StringFeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {CoreML.Specification.IStringFeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.StringFeatureType} StringFeatureType instance
                 */
                StringFeatureType.create = function create(properties) {
                    return new StringFeatureType(properties);
                };
    
                /**
                 * Encodes the specified StringFeatureType message. Does not implicitly {@link CoreML.Specification.StringFeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {CoreML.Specification.IStringFeatureType} message StringFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringFeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified StringFeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.StringFeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {CoreML.Specification.IStringFeatureType} message StringFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                StringFeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a StringFeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.StringFeatureType} StringFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.StringFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a StringFeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.StringFeatureType} StringFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                StringFeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a StringFeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a StringFeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.StringFeatureType} StringFeatureType
                 */
                StringFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.StringFeatureType)
                        return object;
                    return new $root.CoreML.Specification.StringFeatureType();
                };
    
                /**
                 * Creates a plain object from a StringFeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.StringFeatureType
                 * @static
                 * @param {CoreML.Specification.StringFeatureType} message StringFeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringFeatureType.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this StringFeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.StringFeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return StringFeatureType;
            })();
    
            Specification.ImageFeatureType = (function() {
    
                /**
                 * Properties of an ImageFeatureType.
                 * @memberof CoreML.Specification
                 * @interface IImageFeatureType
                 * @property {number|Long|null} [width] ImageFeatureType width
                 * @property {number|Long|null} [height] ImageFeatureType height
                 * @property {CoreML.Specification.ImageFeatureType.ColorSpace|null} [colorSpace] ImageFeatureType colorSpace
                 */
    
                /**
                 * Constructs a new ImageFeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc The image feature type.
                 * @implements IImageFeatureType
                 * @constructor
                 * @param {CoreML.Specification.IImageFeatureType=} [properties] Properties to set
                 */
                function ImageFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ImageFeatureType width.
                 * @member {number|Long} width
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @instance
                 */
                ImageFeatureType.prototype.width = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * ImageFeatureType height.
                 * @member {number|Long} height
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @instance
                 */
                ImageFeatureType.prototype.height = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * ImageFeatureType colorSpace.
                 * @member {CoreML.Specification.ImageFeatureType.ColorSpace} colorSpace
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @instance
                 */
                ImageFeatureType.prototype.colorSpace = 0;
    
                /**
                 * Creates a new ImageFeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {CoreML.Specification.IImageFeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.ImageFeatureType} ImageFeatureType instance
                 */
                ImageFeatureType.create = function create(properties) {
                    return new ImageFeatureType(properties);
                };
    
                /**
                 * Encodes the specified ImageFeatureType message. Does not implicitly {@link CoreML.Specification.ImageFeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {CoreML.Specification.IImageFeatureType} message ImageFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageFeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.width != null && message.hasOwnProperty("width"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.width);
                    if (message.height != null && message.hasOwnProperty("height"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.height);
                    if (message.colorSpace != null && message.hasOwnProperty("colorSpace"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.colorSpace);
                    return writer;
                };
    
                /**
                 * Encodes the specified ImageFeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.ImageFeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {CoreML.Specification.IImageFeatureType} message ImageFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageFeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ImageFeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ImageFeatureType} ImageFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ImageFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.width = reader.int64();
                            break;
                        case 2:
                            message.height = reader.int64();
                            break;
                        case 3:
                            message.colorSpace = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ImageFeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ImageFeatureType} ImageFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageFeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ImageFeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (!$util.isInteger(message.width) && !(message.width && $util.isInteger(message.width.low) && $util.isInteger(message.width.high)))
                            return "width: integer|Long expected";
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (!$util.isInteger(message.height) && !(message.height && $util.isInteger(message.height.low) && $util.isInteger(message.height.high)))
                            return "height: integer|Long expected";
                    if (message.colorSpace != null && message.hasOwnProperty("colorSpace"))
                        switch (message.colorSpace) {
                        default:
                            return "colorSpace: enum value expected";
                        case 0:
                        case 10:
                        case 20:
                        case 30:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates an ImageFeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ImageFeatureType} ImageFeatureType
                 */
                ImageFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ImageFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.ImageFeatureType();
                    if (object.width != null)
                        if ($util.Long)
                            (message.width = $util.Long.fromValue(object.width)).unsigned = false;
                        else if (typeof object.width === "string")
                            message.width = parseInt(object.width, 10);
                        else if (typeof object.width === "number")
                            message.width = object.width;
                        else if (typeof object.width === "object")
                            message.width = new $util.LongBits(object.width.low >>> 0, object.width.high >>> 0).toNumber();
                    if (object.height != null)
                        if ($util.Long)
                            (message.height = $util.Long.fromValue(object.height)).unsigned = false;
                        else if (typeof object.height === "string")
                            message.height = parseInt(object.height, 10);
                        else if (typeof object.height === "number")
                            message.height = object.height;
                        else if (typeof object.height === "object")
                            message.height = new $util.LongBits(object.height.low >>> 0, object.height.high >>> 0).toNumber();
                    switch (object.colorSpace) {
                    case "INVALID_COLOR_SPACE":
                    case 0:
                        message.colorSpace = 0;
                        break;
                    case "GRAYSCALE":
                    case 10:
                        message.colorSpace = 10;
                        break;
                    case "RGB":
                    case 20:
                        message.colorSpace = 20;
                        break;
                    case "BGR":
                    case 30:
                        message.colorSpace = 30;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ImageFeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @static
                 * @param {CoreML.Specification.ImageFeatureType} message ImageFeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.width = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.width = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.height = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.height = options.longs === String ? "0" : 0;
                        object.colorSpace = options.enums === String ? "INVALID_COLOR_SPACE" : 0;
                    }
                    if (message.width != null && message.hasOwnProperty("width"))
                        if (typeof message.width === "number")
                            object.width = options.longs === String ? String(message.width) : message.width;
                        else
                            object.width = options.longs === String ? $util.Long.prototype.toString.call(message.width) : options.longs === Number ? new $util.LongBits(message.width.low >>> 0, message.width.high >>> 0).toNumber() : message.width;
                    if (message.height != null && message.hasOwnProperty("height"))
                        if (typeof message.height === "number")
                            object.height = options.longs === String ? String(message.height) : message.height;
                        else
                            object.height = options.longs === String ? $util.Long.prototype.toString.call(message.height) : options.longs === Number ? new $util.LongBits(message.height.low >>> 0, message.height.high >>> 0).toNumber() : message.height;
                    if (message.colorSpace != null && message.hasOwnProperty("colorSpace"))
                        object.colorSpace = options.enums === String ? $root.CoreML.Specification.ImageFeatureType.ColorSpace[message.colorSpace] : message.colorSpace;
                    return object;
                };
    
                /**
                 * Converts this ImageFeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ImageFeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * ColorSpace enum.
                 * @name CoreML.Specification.ImageFeatureType.ColorSpace
                 * @enum {string}
                 * @property {number} INVALID_COLOR_SPACE=0 INVALID_COLOR_SPACE value
                 * @property {number} GRAYSCALE=10 GRAYSCALE value
                 * @property {number} RGB=20 RGB value
                 * @property {number} BGR=30 BGR value
                 */
                ImageFeatureType.ColorSpace = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_COLOR_SPACE"] = 0;
                    values[valuesById[10] = "GRAYSCALE"] = 10;
                    values[valuesById[20] = "RGB"] = 20;
                    values[valuesById[30] = "BGR"] = 30;
                    return values;
                })();
    
                return ImageFeatureType;
            })();
    
            Specification.ArrayFeatureType = (function() {
    
                /**
                 * Properties of an ArrayFeatureType.
                 * @memberof CoreML.Specification
                 * @interface IArrayFeatureType
                 * @property {Array.<number|Long>|null} [shape] For neural networks, must be of length 1 or 3, representing input shape [C] or [C,H,W], respectively.
                 * @property {CoreML.Specification.ArrayFeatureType.ArrayDataType|null} [dataType] ArrayFeatureType dataType
                 */
    
                /**
                 * Constructs a new ArrayFeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc The array feature type.
                 * @implements IArrayFeatureType
                 * @constructor
                 * @param {CoreML.Specification.IArrayFeatureType=} [properties] Properties to set
                 */
                function ArrayFeatureType(properties) {
                    this.shape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * For neural networks, must be of length 1 or 3, representing input shape [C] or [C,H,W], respectively.
                 * @member {Array.<number|Long>} shape
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @instance
                 */
                ArrayFeatureType.prototype.shape = $util.emptyArray;
    
                /**
                 * ArrayFeatureType dataType.
                 * @member {CoreML.Specification.ArrayFeatureType.ArrayDataType} dataType
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @instance
                 */
                ArrayFeatureType.prototype.dataType = 0;
    
                /**
                 * Creates a new ArrayFeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {CoreML.Specification.IArrayFeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.ArrayFeatureType} ArrayFeatureType instance
                 */
                ArrayFeatureType.create = function create(properties) {
                    return new ArrayFeatureType(properties);
                };
    
                /**
                 * Encodes the specified ArrayFeatureType message. Does not implicitly {@link CoreML.Specification.ArrayFeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {CoreML.Specification.IArrayFeatureType} message ArrayFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayFeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shape != null && message.shape.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.shape.length; ++i)
                            writer.int64(message.shape[i]);
                        writer.ldelim();
                    }
                    if (message.dataType != null && message.hasOwnProperty("dataType"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.dataType);
                    return writer;
                };
    
                /**
                 * Encodes the specified ArrayFeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.ArrayFeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {CoreML.Specification.IArrayFeatureType} message ArrayFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ArrayFeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ArrayFeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ArrayFeatureType} ArrayFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ArrayFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shape && message.shape.length))
                                message.shape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shape.push(reader.int64());
                            } else
                                message.shape.push(reader.int64());
                            break;
                        case 2:
                            message.dataType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ArrayFeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ArrayFeatureType} ArrayFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ArrayFeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ArrayFeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ArrayFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        if (!Array.isArray(message.shape))
                            return "shape: array expected";
                        for (var i = 0; i < message.shape.length; ++i)
                            if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                return "shape: integer|Long[] expected";
                    }
                    if (message.dataType != null && message.hasOwnProperty("dataType"))
                        switch (message.dataType) {
                        default:
                            return "dataType: enum value expected";
                        case 0:
                        case 65568:
                        case 65600:
                        case 131104:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates an ArrayFeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ArrayFeatureType} ArrayFeatureType
                 */
                ArrayFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ArrayFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.ArrayFeatureType();
                    if (object.shape) {
                        if (!Array.isArray(object.shape))
                            throw TypeError(".CoreML.Specification.ArrayFeatureType.shape: array expected");
                        message.shape = [];
                        for (var i = 0; i < object.shape.length; ++i)
                            if ($util.Long)
                                (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = false;
                            else if (typeof object.shape[i] === "string")
                                message.shape[i] = parseInt(object.shape[i], 10);
                            else if (typeof object.shape[i] === "number")
                                message.shape[i] = object.shape[i];
                            else if (typeof object.shape[i] === "object")
                                message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber();
                    }
                    switch (object.dataType) {
                    case "INVALID_ARRAY_DATA_TYPE":
                    case 0:
                        message.dataType = 0;
                        break;
                    case "FLOAT32":
                    case 65568:
                        message.dataType = 65568;
                        break;
                    case "DOUBLE":
                    case 65600:
                        message.dataType = 65600;
                        break;
                    case "INT32":
                    case 131104:
                        message.dataType = 131104;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ArrayFeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @static
                 * @param {CoreML.Specification.ArrayFeatureType} message ArrayFeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ArrayFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.shape = [];
                    if (options.defaults)
                        object.dataType = options.enums === String ? "INVALID_ARRAY_DATA_TYPE" : 0;
                    if (message.shape && message.shape.length) {
                        object.shape = [];
                        for (var j = 0; j < message.shape.length; ++j)
                            if (typeof message.shape[j] === "number")
                                object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                            else
                                object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber() : message.shape[j];
                    }
                    if (message.dataType != null && message.hasOwnProperty("dataType"))
                        object.dataType = options.enums === String ? $root.CoreML.Specification.ArrayFeatureType.ArrayDataType[message.dataType] : message.dataType;
                    return object;
                };
    
                /**
                 * Converts this ArrayFeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ArrayFeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ArrayFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * ArrayDataType enum.
                 * @name CoreML.Specification.ArrayFeatureType.ArrayDataType
                 * @enum {string}
                 * @property {number} INVALID_ARRAY_DATA_TYPE=0 INVALID_ARRAY_DATA_TYPE value
                 * @property {number} FLOAT32=65568 FLOAT32 value
                 * @property {number} DOUBLE=65600 DOUBLE value
                 * @property {number} INT32=131104 INT32 value
                 */
                ArrayFeatureType.ArrayDataType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "INVALID_ARRAY_DATA_TYPE"] = 0;
                    values[valuesById[65568] = "FLOAT32"] = 65568;
                    values[valuesById[65600] = "DOUBLE"] = 65600;
                    values[valuesById[131104] = "INT32"] = 131104;
                    return values;
                })();
    
                return ArrayFeatureType;
            })();
    
            Specification.DictionaryFeatureType = (function() {
    
                /**
                 * Properties of a DictionaryFeatureType.
                 * @memberof CoreML.Specification
                 * @interface IDictionaryFeatureType
                 * @property {CoreML.Specification.IInt64FeatureType|null} [int64KeyType] DictionaryFeatureType int64KeyType
                 * @property {CoreML.Specification.IStringFeatureType|null} [stringKeyType] DictionaryFeatureType stringKeyType
                 */
    
                /**
                 * Constructs a new DictionaryFeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc The dictionary feature type.
                 * @implements IDictionaryFeatureType
                 * @constructor
                 * @param {CoreML.Specification.IDictionaryFeatureType=} [properties] Properties to set
                 */
                function DictionaryFeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DictionaryFeatureType int64KeyType.
                 * @member {CoreML.Specification.IInt64FeatureType|null|undefined} int64KeyType
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @instance
                 */
                DictionaryFeatureType.prototype.int64KeyType = null;
    
                /**
                 * DictionaryFeatureType stringKeyType.
                 * @member {CoreML.Specification.IStringFeatureType|null|undefined} stringKeyType
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @instance
                 */
                DictionaryFeatureType.prototype.stringKeyType = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Key/value type tags, with the following restrictions:
                 * - ``keyType`` must be a hashable type
                 * - ``valueType`` is assumed to be a ``double``
                 * @member {"int64KeyType"|"stringKeyType"|undefined} KeyType
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @instance
                 */
                Object.defineProperty(DictionaryFeatureType.prototype, "KeyType", {
                    get: $util.oneOfGetter($oneOfFields = ["int64KeyType", "stringKeyType"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new DictionaryFeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {CoreML.Specification.IDictionaryFeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.DictionaryFeatureType} DictionaryFeatureType instance
                 */
                DictionaryFeatureType.create = function create(properties) {
                    return new DictionaryFeatureType(properties);
                };
    
                /**
                 * Encodes the specified DictionaryFeatureType message. Does not implicitly {@link CoreML.Specification.DictionaryFeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {CoreML.Specification.IDictionaryFeatureType} message DictionaryFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryFeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.int64KeyType != null && message.hasOwnProperty("int64KeyType"))
                        $root.CoreML.Specification.Int64FeatureType.encode(message.int64KeyType, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.stringKeyType != null && message.hasOwnProperty("stringKeyType"))
                        $root.CoreML.Specification.StringFeatureType.encode(message.stringKeyType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DictionaryFeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.DictionaryFeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {CoreML.Specification.IDictionaryFeatureType} message DictionaryFeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictionaryFeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DictionaryFeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DictionaryFeatureType} DictionaryFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryFeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DictionaryFeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.int64KeyType = $root.CoreML.Specification.Int64FeatureType.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.stringKeyType = $root.CoreML.Specification.StringFeatureType.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DictionaryFeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DictionaryFeatureType} DictionaryFeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictionaryFeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DictionaryFeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DictionaryFeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.int64KeyType != null && message.hasOwnProperty("int64KeyType")) {
                        properties.KeyType = 1;
                        {
                            var error = $root.CoreML.Specification.Int64FeatureType.verify(message.int64KeyType);
                            if (error)
                                return "int64KeyType." + error;
                        }
                    }
                    if (message.stringKeyType != null && message.hasOwnProperty("stringKeyType")) {
                        if (properties.KeyType === 1)
                            return "KeyType: multiple values";
                        properties.KeyType = 1;
                        {
                            var error = $root.CoreML.Specification.StringFeatureType.verify(message.stringKeyType);
                            if (error)
                                return "stringKeyType." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DictionaryFeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DictionaryFeatureType} DictionaryFeatureType
                 */
                DictionaryFeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DictionaryFeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.DictionaryFeatureType();
                    if (object.int64KeyType != null) {
                        if (typeof object.int64KeyType !== "object")
                            throw TypeError(".CoreML.Specification.DictionaryFeatureType.int64KeyType: object expected");
                        message.int64KeyType = $root.CoreML.Specification.Int64FeatureType.fromObject(object.int64KeyType);
                    }
                    if (object.stringKeyType != null) {
                        if (typeof object.stringKeyType !== "object")
                            throw TypeError(".CoreML.Specification.DictionaryFeatureType.stringKeyType: object expected");
                        message.stringKeyType = $root.CoreML.Specification.StringFeatureType.fromObject(object.stringKeyType);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DictionaryFeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @static
                 * @param {CoreML.Specification.DictionaryFeatureType} message DictionaryFeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DictionaryFeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.int64KeyType != null && message.hasOwnProperty("int64KeyType")) {
                        object.int64KeyType = $root.CoreML.Specification.Int64FeatureType.toObject(message.int64KeyType, options);
                        if (options.oneofs)
                            object.KeyType = "int64KeyType";
                    }
                    if (message.stringKeyType != null && message.hasOwnProperty("stringKeyType")) {
                        object.stringKeyType = $root.CoreML.Specification.StringFeatureType.toObject(message.stringKeyType, options);
                        if (options.oneofs)
                            object.KeyType = "stringKeyType";
                    }
                    return object;
                };
    
                /**
                 * Converts this DictionaryFeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DictionaryFeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DictionaryFeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictionaryFeatureType;
            })();
    
            Specification.FeatureType = (function() {
    
                /**
                 * Properties of a FeatureType.
                 * @memberof CoreML.Specification
                 * @interface IFeatureType
                 * @property {CoreML.Specification.IInt64FeatureType|null} [int64Type] FeatureType int64Type
                 * @property {CoreML.Specification.IDoubleFeatureType|null} [doubleType] FeatureType doubleType
                 * @property {CoreML.Specification.IStringFeatureType|null} [stringType] FeatureType stringType
                 * @property {CoreML.Specification.IImageFeatureType|null} [imageType] FeatureType imageType
                 * @property {CoreML.Specification.IArrayFeatureType|null} [multiArrayType] FeatureType multiArrayType
                 * @property {CoreML.Specification.IDictionaryFeatureType|null} [dictionaryType] FeatureType dictionaryType
                 * @property {boolean|null} [isOptional] FeatureType isOptional
                 */
    
                /**
                 * Constructs a new FeatureType.
                 * @memberof CoreML.Specification
                 * @classdesc A feature, which may be optional.
                 * @implements IFeatureType
                 * @constructor
                 * @param {CoreML.Specification.IFeatureType=} [properties] Properties to set
                 */
                function FeatureType(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FeatureType int64Type.
                 * @member {CoreML.Specification.IInt64FeatureType|null|undefined} int64Type
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.int64Type = null;
    
                /**
                 * FeatureType doubleType.
                 * @member {CoreML.Specification.IDoubleFeatureType|null|undefined} doubleType
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.doubleType = null;
    
                /**
                 * FeatureType stringType.
                 * @member {CoreML.Specification.IStringFeatureType|null|undefined} stringType
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.stringType = null;
    
                /**
                 * FeatureType imageType.
                 * @member {CoreML.Specification.IImageFeatureType|null|undefined} imageType
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.imageType = null;
    
                /**
                 * FeatureType multiArrayType.
                 * @member {CoreML.Specification.IArrayFeatureType|null|undefined} multiArrayType
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.multiArrayType = null;
    
                /**
                 * FeatureType dictionaryType.
                 * @member {CoreML.Specification.IDictionaryFeatureType|null|undefined} dictionaryType
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.dictionaryType = null;
    
                /**
                 * FeatureType isOptional.
                 * @member {boolean} isOptional
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                FeatureType.prototype.isOptional = false;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * FeatureType Type.
                 * @member {"int64Type"|"doubleType"|"stringType"|"imageType"|"multiArrayType"|"dictionaryType"|undefined} Type
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 */
                Object.defineProperty(FeatureType.prototype, "Type", {
                    get: $util.oneOfGetter($oneOfFields = ["int64Type", "doubleType", "stringType", "imageType", "multiArrayType", "dictionaryType"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new FeatureType instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {CoreML.Specification.IFeatureType=} [properties] Properties to set
                 * @returns {CoreML.Specification.FeatureType} FeatureType instance
                 */
                FeatureType.create = function create(properties) {
                    return new FeatureType(properties);
                };
    
                /**
                 * Encodes the specified FeatureType message. Does not implicitly {@link CoreML.Specification.FeatureType.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {CoreML.Specification.IFeatureType} message FeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureType.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.int64Type != null && message.hasOwnProperty("int64Type"))
                        $root.CoreML.Specification.Int64FeatureType.encode(message.int64Type, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.doubleType != null && message.hasOwnProperty("doubleType"))
                        $root.CoreML.Specification.DoubleFeatureType.encode(message.doubleType, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.stringType != null && message.hasOwnProperty("stringType"))
                        $root.CoreML.Specification.StringFeatureType.encode(message.stringType, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.imageType != null && message.hasOwnProperty("imageType"))
                        $root.CoreML.Specification.ImageFeatureType.encode(message.imageType, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.multiArrayType != null && message.hasOwnProperty("multiArrayType"))
                        $root.CoreML.Specification.ArrayFeatureType.encode(message.multiArrayType, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.dictionaryType != null && message.hasOwnProperty("dictionaryType"))
                        $root.CoreML.Specification.DictionaryFeatureType.encode(message.dictionaryType, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.isOptional != null && message.hasOwnProperty("isOptional"))
                        writer.uint32(/* id 1000, wireType 0 =*/8000).bool(message.isOptional);
                    return writer;
                };
    
                /**
                 * Encodes the specified FeatureType message, length delimited. Does not implicitly {@link CoreML.Specification.FeatureType.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {CoreML.Specification.IFeatureType} message FeatureType message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureType.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FeatureType message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.FeatureType} FeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureType.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureType();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.int64Type = $root.CoreML.Specification.Int64FeatureType.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.doubleType = $root.CoreML.Specification.DoubleFeatureType.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.stringType = $root.CoreML.Specification.StringFeatureType.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.imageType = $root.CoreML.Specification.ImageFeatureType.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.multiArrayType = $root.CoreML.Specification.ArrayFeatureType.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.dictionaryType = $root.CoreML.Specification.DictionaryFeatureType.decode(reader, reader.uint32());
                            break;
                        case 1000:
                            message.isOptional = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FeatureType message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.FeatureType} FeatureType
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureType.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FeatureType message.
                 * @function verify
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureType.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.int64Type != null && message.hasOwnProperty("int64Type")) {
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.Int64FeatureType.verify(message.int64Type);
                            if (error)
                                return "int64Type." + error;
                        }
                    }
                    if (message.doubleType != null && message.hasOwnProperty("doubleType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.DoubleFeatureType.verify(message.doubleType);
                            if (error)
                                return "doubleType." + error;
                        }
                    }
                    if (message.stringType != null && message.hasOwnProperty("stringType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.StringFeatureType.verify(message.stringType);
                            if (error)
                                return "stringType." + error;
                        }
                    }
                    if (message.imageType != null && message.hasOwnProperty("imageType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.ImageFeatureType.verify(message.imageType);
                            if (error)
                                return "imageType." + error;
                        }
                    }
                    if (message.multiArrayType != null && message.hasOwnProperty("multiArrayType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.ArrayFeatureType.verify(message.multiArrayType);
                            if (error)
                                return "multiArrayType." + error;
                        }
                    }
                    if (message.dictionaryType != null && message.hasOwnProperty("dictionaryType")) {
                        if (properties.Type === 1)
                            return "Type: multiple values";
                        properties.Type = 1;
                        {
                            var error = $root.CoreML.Specification.DictionaryFeatureType.verify(message.dictionaryType);
                            if (error)
                                return "dictionaryType." + error;
                        }
                    }
                    if (message.isOptional != null && message.hasOwnProperty("isOptional"))
                        if (typeof message.isOptional !== "boolean")
                            return "isOptional: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a FeatureType message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.FeatureType} FeatureType
                 */
                FeatureType.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FeatureType)
                        return object;
                    var message = new $root.CoreML.Specification.FeatureType();
                    if (object.int64Type != null) {
                        if (typeof object.int64Type !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.int64Type: object expected");
                        message.int64Type = $root.CoreML.Specification.Int64FeatureType.fromObject(object.int64Type);
                    }
                    if (object.doubleType != null) {
                        if (typeof object.doubleType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.doubleType: object expected");
                        message.doubleType = $root.CoreML.Specification.DoubleFeatureType.fromObject(object.doubleType);
                    }
                    if (object.stringType != null) {
                        if (typeof object.stringType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.stringType: object expected");
                        message.stringType = $root.CoreML.Specification.StringFeatureType.fromObject(object.stringType);
                    }
                    if (object.imageType != null) {
                        if (typeof object.imageType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.imageType: object expected");
                        message.imageType = $root.CoreML.Specification.ImageFeatureType.fromObject(object.imageType);
                    }
                    if (object.multiArrayType != null) {
                        if (typeof object.multiArrayType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.multiArrayType: object expected");
                        message.multiArrayType = $root.CoreML.Specification.ArrayFeatureType.fromObject(object.multiArrayType);
                    }
                    if (object.dictionaryType != null) {
                        if (typeof object.dictionaryType !== "object")
                            throw TypeError(".CoreML.Specification.FeatureType.dictionaryType: object expected");
                        message.dictionaryType = $root.CoreML.Specification.DictionaryFeatureType.fromObject(object.dictionaryType);
                    }
                    if (object.isOptional != null)
                        message.isOptional = Boolean(object.isOptional);
                    return message;
                };
    
                /**
                 * Creates a plain object from a FeatureType message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.FeatureType
                 * @static
                 * @param {CoreML.Specification.FeatureType} message FeatureType
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureType.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.isOptional = false;
                    if (message.int64Type != null && message.hasOwnProperty("int64Type")) {
                        object.int64Type = $root.CoreML.Specification.Int64FeatureType.toObject(message.int64Type, options);
                        if (options.oneofs)
                            object.Type = "int64Type";
                    }
                    if (message.doubleType != null && message.hasOwnProperty("doubleType")) {
                        object.doubleType = $root.CoreML.Specification.DoubleFeatureType.toObject(message.doubleType, options);
                        if (options.oneofs)
                            object.Type = "doubleType";
                    }
                    if (message.stringType != null && message.hasOwnProperty("stringType")) {
                        object.stringType = $root.CoreML.Specification.StringFeatureType.toObject(message.stringType, options);
                        if (options.oneofs)
                            object.Type = "stringType";
                    }
                    if (message.imageType != null && message.hasOwnProperty("imageType")) {
                        object.imageType = $root.CoreML.Specification.ImageFeatureType.toObject(message.imageType, options);
                        if (options.oneofs)
                            object.Type = "imageType";
                    }
                    if (message.multiArrayType != null && message.hasOwnProperty("multiArrayType")) {
                        object.multiArrayType = $root.CoreML.Specification.ArrayFeatureType.toObject(message.multiArrayType, options);
                        if (options.oneofs)
                            object.Type = "multiArrayType";
                    }
                    if (message.dictionaryType != null && message.hasOwnProperty("dictionaryType")) {
                        object.dictionaryType = $root.CoreML.Specification.DictionaryFeatureType.toObject(message.dictionaryType, options);
                        if (options.oneofs)
                            object.Type = "dictionaryType";
                    }
                    if (message.isOptional != null && message.hasOwnProperty("isOptional"))
                        object.isOptional = message.isOptional;
                    return object;
                };
    
                /**
                 * Converts this FeatureType to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.FeatureType
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureType.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return FeatureType;
            })();
    
            Specification.DictVectorizer = (function() {
    
                /**
                 * Properties of a DictVectorizer.
                 * @memberof CoreML.Specification
                 * @interface IDictVectorizer
                 * @property {CoreML.Specification.IStringVector|null} [stringToIndex] String keys to indexes
                 * @property {CoreML.Specification.IInt64Vector|null} [int64ToIndex] Int keys to indexes
                 */
    
                /**
                 * Constructs a new DictVectorizer.
                 * @memberof CoreML.Specification
                 * @classdesc Uses an index mapping to convert a dictionary to an array.
                 * 
                 * The output array will be equal in length to the index mapping vector parameter.
                 * All keys in the input dictionary must be present in the index mapping vector.
                 * 
                 * For each item in the input dictionary, insert its value in the output array.
                 * The position of the insertion is determined by the position of the item's key
                 * in the index mapping. Any keys not present in the input dictionary, will be
                 * zero in the output array.
                 * 
                 * For example: if the ``stringToIndex`` parameter is set to ``["a", "c", "b", "z"]``,
                 * then an input of ``{"a": 4, "c": 8}`` will produce an output of ``[4, 8, 0, 0]``.
                 * @implements IDictVectorizer
                 * @constructor
                 * @param {CoreML.Specification.IDictVectorizer=} [properties] Properties to set
                 */
                function DictVectorizer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * String keys to indexes
                 * @member {CoreML.Specification.IStringVector|null|undefined} stringToIndex
                 * @memberof CoreML.Specification.DictVectorizer
                 * @instance
                 */
                DictVectorizer.prototype.stringToIndex = null;
    
                /**
                 * Int keys to indexes
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} int64ToIndex
                 * @memberof CoreML.Specification.DictVectorizer
                 * @instance
                 */
                DictVectorizer.prototype.int64ToIndex = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * DictVectorizer Map.
                 * @member {"stringToIndex"|"int64ToIndex"|undefined} Map
                 * @memberof CoreML.Specification.DictVectorizer
                 * @instance
                 */
                Object.defineProperty(DictVectorizer.prototype, "Map", {
                    get: $util.oneOfGetter($oneOfFields = ["stringToIndex", "int64ToIndex"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new DictVectorizer instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {CoreML.Specification.IDictVectorizer=} [properties] Properties to set
                 * @returns {CoreML.Specification.DictVectorizer} DictVectorizer instance
                 */
                DictVectorizer.create = function create(properties) {
                    return new DictVectorizer(properties);
                };
    
                /**
                 * Encodes the specified DictVectorizer message. Does not implicitly {@link CoreML.Specification.DictVectorizer.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {CoreML.Specification.IDictVectorizer} message DictVectorizer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictVectorizer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stringToIndex != null && message.hasOwnProperty("stringToIndex"))
                        $root.CoreML.Specification.StringVector.encode(message.stringToIndex, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.int64ToIndex != null && message.hasOwnProperty("int64ToIndex"))
                        $root.CoreML.Specification.Int64Vector.encode(message.int64ToIndex, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DictVectorizer message, length delimited. Does not implicitly {@link CoreML.Specification.DictVectorizer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {CoreML.Specification.IDictVectorizer} message DictVectorizer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DictVectorizer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DictVectorizer message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DictVectorizer} DictVectorizer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictVectorizer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DictVectorizer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringToIndex = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.int64ToIndex = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DictVectorizer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DictVectorizer} DictVectorizer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DictVectorizer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DictVectorizer message.
                 * @function verify
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DictVectorizer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringToIndex != null && message.hasOwnProperty("stringToIndex")) {
                        properties.Map = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringToIndex);
                            if (error)
                                return "stringToIndex." + error;
                        }
                    }
                    if (message.int64ToIndex != null && message.hasOwnProperty("int64ToIndex")) {
                        if (properties.Map === 1)
                            return "Map: multiple values";
                        properties.Map = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ToIndex);
                            if (error)
                                return "int64ToIndex." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DictVectorizer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DictVectorizer} DictVectorizer
                 */
                DictVectorizer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DictVectorizer)
                        return object;
                    var message = new $root.CoreML.Specification.DictVectorizer();
                    if (object.stringToIndex != null) {
                        if (typeof object.stringToIndex !== "object")
                            throw TypeError(".CoreML.Specification.DictVectorizer.stringToIndex: object expected");
                        message.stringToIndex = $root.CoreML.Specification.StringVector.fromObject(object.stringToIndex);
                    }
                    if (object.int64ToIndex != null) {
                        if (typeof object.int64ToIndex !== "object")
                            throw TypeError(".CoreML.Specification.DictVectorizer.int64ToIndex: object expected");
                        message.int64ToIndex = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ToIndex);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DictVectorizer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DictVectorizer
                 * @static
                 * @param {CoreML.Specification.DictVectorizer} message DictVectorizer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DictVectorizer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.stringToIndex != null && message.hasOwnProperty("stringToIndex")) {
                        object.stringToIndex = $root.CoreML.Specification.StringVector.toObject(message.stringToIndex, options);
                        if (options.oneofs)
                            object.Map = "stringToIndex";
                    }
                    if (message.int64ToIndex != null && message.hasOwnProperty("int64ToIndex")) {
                        object.int64ToIndex = $root.CoreML.Specification.Int64Vector.toObject(message.int64ToIndex, options);
                        if (options.oneofs)
                            object.Map = "int64ToIndex";
                    }
                    return object;
                };
    
                /**
                 * Converts this DictVectorizer to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DictVectorizer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DictVectorizer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DictVectorizer;
            })();
    
            Specification.FeatureVectorizer = (function() {
    
                /**
                 * Properties of a FeatureVectorizer.
                 * @memberof CoreML.Specification
                 * @interface IFeatureVectorizer
                 * @property {Array.<CoreML.Specification.FeatureVectorizer.IInputColumn>|null} [inputList] FeatureVectorizer inputList
                 */
    
                /**
                 * Constructs a new FeatureVectorizer.
                 * @memberof CoreML.Specification
                 * @classdesc A FeatureVectorizer puts one or more features into a single array.
                 * 
                 * The ordering of features in the output array is determined by
                 * ``inputList``.
                 * 
                 * ``inputDimensions`` is a zero based index.
                 * @implements IFeatureVectorizer
                 * @constructor
                 * @param {CoreML.Specification.IFeatureVectorizer=} [properties] Properties to set
                 */
                function FeatureVectorizer(properties) {
                    this.inputList = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FeatureVectorizer inputList.
                 * @member {Array.<CoreML.Specification.FeatureVectorizer.IInputColumn>} inputList
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @instance
                 */
                FeatureVectorizer.prototype.inputList = $util.emptyArray;
    
                /**
                 * Creates a new FeatureVectorizer instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {CoreML.Specification.IFeatureVectorizer=} [properties] Properties to set
                 * @returns {CoreML.Specification.FeatureVectorizer} FeatureVectorizer instance
                 */
                FeatureVectorizer.create = function create(properties) {
                    return new FeatureVectorizer(properties);
                };
    
                /**
                 * Encodes the specified FeatureVectorizer message. Does not implicitly {@link CoreML.Specification.FeatureVectorizer.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {CoreML.Specification.IFeatureVectorizer} message FeatureVectorizer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureVectorizer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputList != null && message.inputList.length)
                        for (var i = 0; i < message.inputList.length; ++i)
                            $root.CoreML.Specification.FeatureVectorizer.InputColumn.encode(message.inputList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified FeatureVectorizer message, length delimited. Does not implicitly {@link CoreML.Specification.FeatureVectorizer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {CoreML.Specification.IFeatureVectorizer} message FeatureVectorizer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FeatureVectorizer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FeatureVectorizer message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.FeatureVectorizer} FeatureVectorizer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureVectorizer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureVectorizer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.inputList && message.inputList.length))
                                message.inputList = [];
                            message.inputList.push($root.CoreML.Specification.FeatureVectorizer.InputColumn.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FeatureVectorizer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.FeatureVectorizer} FeatureVectorizer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FeatureVectorizer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FeatureVectorizer message.
                 * @function verify
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureVectorizer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputList != null && message.hasOwnProperty("inputList")) {
                        if (!Array.isArray(message.inputList))
                            return "inputList: array expected";
                        for (var i = 0; i < message.inputList.length; ++i) {
                            var error = $root.CoreML.Specification.FeatureVectorizer.InputColumn.verify(message.inputList[i]);
                            if (error)
                                return "inputList." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a FeatureVectorizer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.FeatureVectorizer} FeatureVectorizer
                 */
                FeatureVectorizer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FeatureVectorizer)
                        return object;
                    var message = new $root.CoreML.Specification.FeatureVectorizer();
                    if (object.inputList) {
                        if (!Array.isArray(object.inputList))
                            throw TypeError(".CoreML.Specification.FeatureVectorizer.inputList: array expected");
                        message.inputList = [];
                        for (var i = 0; i < object.inputList.length; ++i) {
                            if (typeof object.inputList[i] !== "object")
                                throw TypeError(".CoreML.Specification.FeatureVectorizer.inputList: object expected");
                            message.inputList[i] = $root.CoreML.Specification.FeatureVectorizer.InputColumn.fromObject(object.inputList[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FeatureVectorizer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @static
                 * @param {CoreML.Specification.FeatureVectorizer} message FeatureVectorizer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureVectorizer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.inputList = [];
                    if (message.inputList && message.inputList.length) {
                        object.inputList = [];
                        for (var j = 0; j < message.inputList.length; ++j)
                            object.inputList[j] = $root.CoreML.Specification.FeatureVectorizer.InputColumn.toObject(message.inputList[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this FeatureVectorizer to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.FeatureVectorizer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureVectorizer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                FeatureVectorizer.InputColumn = (function() {
    
                    /**
                     * Properties of an InputColumn.
                     * @memberof CoreML.Specification.FeatureVectorizer
                     * @interface IInputColumn
                     * @property {string|null} [inputColumn] InputColumn inputColumn
                     * @property {number|Long|null} [inputDimensions] InputColumn inputDimensions
                     */
    
                    /**
                     * Constructs a new InputColumn.
                     * @memberof CoreML.Specification.FeatureVectorizer
                     * @classdesc Represents an InputColumn.
                     * @implements IInputColumn
                     * @constructor
                     * @param {CoreML.Specification.FeatureVectorizer.IInputColumn=} [properties] Properties to set
                     */
                    function InputColumn(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * InputColumn inputColumn.
                     * @member {string} inputColumn
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @instance
                     */
                    InputColumn.prototype.inputColumn = "";
    
                    /**
                     * InputColumn inputDimensions.
                     * @member {number|Long} inputDimensions
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @instance
                     */
                    InputColumn.prototype.inputDimensions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new InputColumn instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {CoreML.Specification.FeatureVectorizer.IInputColumn=} [properties] Properties to set
                     * @returns {CoreML.Specification.FeatureVectorizer.InputColumn} InputColumn instance
                     */
                    InputColumn.create = function create(properties) {
                        return new InputColumn(properties);
                    };
    
                    /**
                     * Encodes the specified InputColumn message. Does not implicitly {@link CoreML.Specification.FeatureVectorizer.InputColumn.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {CoreML.Specification.FeatureVectorizer.IInputColumn} message InputColumn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    InputColumn.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.inputColumn != null && message.hasOwnProperty("inputColumn"))
                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.inputColumn);
                        if (message.inputDimensions != null && message.hasOwnProperty("inputDimensions"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.inputDimensions);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified InputColumn message, length delimited. Does not implicitly {@link CoreML.Specification.FeatureVectorizer.InputColumn.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {CoreML.Specification.FeatureVectorizer.IInputColumn} message InputColumn message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    InputColumn.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an InputColumn message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.FeatureVectorizer.InputColumn} InputColumn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    InputColumn.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FeatureVectorizer.InputColumn();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.inputColumn = reader.string();
                                break;
                            case 2:
                                message.inputDimensions = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an InputColumn message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.FeatureVectorizer.InputColumn} InputColumn
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    InputColumn.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an InputColumn message.
                     * @function verify
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    InputColumn.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.inputColumn != null && message.hasOwnProperty("inputColumn"))
                            if (!$util.isString(message.inputColumn))
                                return "inputColumn: string expected";
                        if (message.inputDimensions != null && message.hasOwnProperty("inputDimensions"))
                            if (!$util.isInteger(message.inputDimensions) && !(message.inputDimensions && $util.isInteger(message.inputDimensions.low) && $util.isInteger(message.inputDimensions.high)))
                                return "inputDimensions: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an InputColumn message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.FeatureVectorizer.InputColumn} InputColumn
                     */
                    InputColumn.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.FeatureVectorizer.InputColumn)
                            return object;
                        var message = new $root.CoreML.Specification.FeatureVectorizer.InputColumn();
                        if (object.inputColumn != null)
                            message.inputColumn = String(object.inputColumn);
                        if (object.inputDimensions != null)
                            if ($util.Long)
                                (message.inputDimensions = $util.Long.fromValue(object.inputDimensions)).unsigned = true;
                            else if (typeof object.inputDimensions === "string")
                                message.inputDimensions = parseInt(object.inputDimensions, 10);
                            else if (typeof object.inputDimensions === "number")
                                message.inputDimensions = object.inputDimensions;
                            else if (typeof object.inputDimensions === "object")
                                message.inputDimensions = new $util.LongBits(object.inputDimensions.low >>> 0, object.inputDimensions.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an InputColumn message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @static
                     * @param {CoreML.Specification.FeatureVectorizer.InputColumn} message InputColumn
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    InputColumn.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            object.inputColumn = "";
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.inputDimensions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.inputDimensions = options.longs === String ? "0" : 0;
                        }
                        if (message.inputColumn != null && message.hasOwnProperty("inputColumn"))
                            object.inputColumn = message.inputColumn;
                        if (message.inputDimensions != null && message.hasOwnProperty("inputDimensions"))
                            if (typeof message.inputDimensions === "number")
                                object.inputDimensions = options.longs === String ? String(message.inputDimensions) : message.inputDimensions;
                            else
                                object.inputDimensions = options.longs === String ? $util.Long.prototype.toString.call(message.inputDimensions) : options.longs === Number ? new $util.LongBits(message.inputDimensions.low >>> 0, message.inputDimensions.high >>> 0).toNumber(true) : message.inputDimensions;
                        return object;
                    };
    
                    /**
                     * Converts this InputColumn to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.FeatureVectorizer.InputColumn
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    InputColumn.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return InputColumn;
                })();
    
                return FeatureVectorizer;
            })();
    
            Specification.GLMRegressor = (function() {
    
                /**
                 * Properties of a GLMRegressor.
                 * @memberof CoreML.Specification
                 * @interface IGLMRegressor
                 * @property {Array.<CoreML.Specification.GLMRegressor.IDoubleArray>|null} [weights] GLMRegressor weights
                 * @property {Array.<number>|null} [offset] GLMRegressor offset
                 * @property {CoreML.Specification.GLMRegressor.PostEvaluationTransform|null} [postEvaluationTransform] GLMRegressor postEvaluationTransform
                 */
    
                /**
                 * Constructs a new GLMRegressor.
                 * @memberof CoreML.Specification
                 * @classdesc A generalized linear model regressor.
                 * @implements IGLMRegressor
                 * @constructor
                 * @param {CoreML.Specification.IGLMRegressor=} [properties] Properties to set
                 */
                function GLMRegressor(properties) {
                    this.weights = [];
                    this.offset = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GLMRegressor weights.
                 * @member {Array.<CoreML.Specification.GLMRegressor.IDoubleArray>} weights
                 * @memberof CoreML.Specification.GLMRegressor
                 * @instance
                 */
                GLMRegressor.prototype.weights = $util.emptyArray;
    
                /**
                 * GLMRegressor offset.
                 * @member {Array.<number>} offset
                 * @memberof CoreML.Specification.GLMRegressor
                 * @instance
                 */
                GLMRegressor.prototype.offset = $util.emptyArray;
    
                /**
                 * GLMRegressor postEvaluationTransform.
                 * @member {CoreML.Specification.GLMRegressor.PostEvaluationTransform} postEvaluationTransform
                 * @memberof CoreML.Specification.GLMRegressor
                 * @instance
                 */
                GLMRegressor.prototype.postEvaluationTransform = 0;
    
                /**
                 * Creates a new GLMRegressor instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {CoreML.Specification.IGLMRegressor=} [properties] Properties to set
                 * @returns {CoreML.Specification.GLMRegressor} GLMRegressor instance
                 */
                GLMRegressor.create = function create(properties) {
                    return new GLMRegressor(properties);
                };
    
                /**
                 * Encodes the specified GLMRegressor message. Does not implicitly {@link CoreML.Specification.GLMRegressor.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {CoreML.Specification.IGLMRegressor} message GLMRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GLMRegressor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.weights != null && message.weights.length)
                        for (var i = 0; i < message.weights.length; ++i)
                            $root.CoreML.Specification.GLMRegressor.DoubleArray.encode(message.weights[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.offset != null && message.offset.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.offset.length; ++i)
                            writer.double(message.offset[i]);
                        writer.ldelim();
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.postEvaluationTransform);
                    return writer;
                };
    
                /**
                 * Encodes the specified GLMRegressor message, length delimited. Does not implicitly {@link CoreML.Specification.GLMRegressor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {CoreML.Specification.IGLMRegressor} message GLMRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GLMRegressor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GLMRegressor message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.GLMRegressor} GLMRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GLMRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.weights && message.weights.length))
                                message.weights = [];
                            message.weights.push($root.CoreML.Specification.GLMRegressor.DoubleArray.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.offset && message.offset.length))
                                message.offset = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.offset.push(reader.double());
                            } else
                                message.offset.push(reader.double());
                            break;
                        case 3:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GLMRegressor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.GLMRegressor} GLMRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GLMRegressor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GLMRegressor message.
                 * @function verify
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GLMRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        if (!Array.isArray(message.weights))
                            return "weights: array expected";
                        for (var i = 0; i < message.weights.length; ++i) {
                            var error = $root.CoreML.Specification.GLMRegressor.DoubleArray.verify(message.weights[i]);
                            if (error)
                                return "weights." + error;
                        }
                    }
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        if (!Array.isArray(message.offset))
                            return "offset: array expected";
                        for (var i = 0; i < message.offset.length; ++i)
                            if (typeof message.offset[i] !== "number")
                                return "offset: number[] expected";
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a GLMRegressor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.GLMRegressor} GLMRegressor
                 */
                GLMRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.GLMRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.GLMRegressor();
                    if (object.weights) {
                        if (!Array.isArray(object.weights))
                            throw TypeError(".CoreML.Specification.GLMRegressor.weights: array expected");
                        message.weights = [];
                        for (var i = 0; i < object.weights.length; ++i) {
                            if (typeof object.weights[i] !== "object")
                                throw TypeError(".CoreML.Specification.GLMRegressor.weights: object expected");
                            message.weights[i] = $root.CoreML.Specification.GLMRegressor.DoubleArray.fromObject(object.weights[i]);
                        }
                    }
                    if (object.offset) {
                        if (!Array.isArray(object.offset))
                            throw TypeError(".CoreML.Specification.GLMRegressor.offset: array expected");
                        message.offset = [];
                        for (var i = 0; i < object.offset.length; ++i)
                            message.offset[i] = Number(object.offset[i]);
                    }
                    switch (object.postEvaluationTransform) {
                    case "NoTransform":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Logit":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    case "Probit":
                    case 2:
                        message.postEvaluationTransform = 2;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GLMRegressor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.GLMRegressor
                 * @static
                 * @param {CoreML.Specification.GLMRegressor} message GLMRegressor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GLMRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.weights = [];
                        object.offset = [];
                    }
                    if (options.defaults)
                        object.postEvaluationTransform = options.enums === String ? "NoTransform" : 0;
                    if (message.weights && message.weights.length) {
                        object.weights = [];
                        for (var j = 0; j < message.weights.length; ++j)
                            object.weights[j] = $root.CoreML.Specification.GLMRegressor.DoubleArray.toObject(message.weights[j], options);
                    }
                    if (message.offset && message.offset.length) {
                        object.offset = [];
                        for (var j = 0; j < message.offset.length; ++j)
                            object.offset[j] = options.json && !isFinite(message.offset[j]) ? String(message.offset[j]) : message.offset[j];
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.GLMRegressor.PostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    return object;
                };
    
                /**
                 * Converts this GLMRegressor to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.GLMRegressor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GLMRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GLMRegressor.DoubleArray = (function() {
    
                    /**
                     * Properties of a DoubleArray.
                     * @memberof CoreML.Specification.GLMRegressor
                     * @interface IDoubleArray
                     * @property {Array.<number>|null} [value] DoubleArray value
                     */
    
                    /**
                     * Constructs a new DoubleArray.
                     * @memberof CoreML.Specification.GLMRegressor
                     * @classdesc Represents a DoubleArray.
                     * @implements IDoubleArray
                     * @constructor
                     * @param {CoreML.Specification.GLMRegressor.IDoubleArray=} [properties] Properties to set
                     */
                    function DoubleArray(properties) {
                        this.value = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DoubleArray value.
                     * @member {Array.<number>} value
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @instance
                     */
                    DoubleArray.prototype.value = $util.emptyArray;
    
                    /**
                     * Creates a new DoubleArray instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMRegressor.IDoubleArray=} [properties] Properties to set
                     * @returns {CoreML.Specification.GLMRegressor.DoubleArray} DoubleArray instance
                     */
                    DoubleArray.create = function create(properties) {
                        return new DoubleArray(properties);
                    };
    
                    /**
                     * Encodes the specified DoubleArray message. Does not implicitly {@link CoreML.Specification.GLMRegressor.DoubleArray.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMRegressor.IDoubleArray} message DoubleArray message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DoubleArray.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.value.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.value.length; ++i)
                                writer.double(message.value[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified DoubleArray message, length delimited. Does not implicitly {@link CoreML.Specification.GLMRegressor.DoubleArray.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMRegressor.IDoubleArray} message DoubleArray message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DoubleArray.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a DoubleArray message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.GLMRegressor.DoubleArray} DoubleArray
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DoubleArray.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMRegressor.DoubleArray();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.value.push(reader.double());
                                } else
                                    message.value.push(reader.double());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a DoubleArray message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.GLMRegressor.DoubleArray} DoubleArray
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DoubleArray.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a DoubleArray message.
                     * @function verify
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DoubleArray.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            if (!Array.isArray(message.value))
                                return "value: array expected";
                            for (var i = 0; i < message.value.length; ++i)
                                if (typeof message.value[i] !== "number")
                                    return "value: number[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a DoubleArray message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.GLMRegressor.DoubleArray} DoubleArray
                     */
                    DoubleArray.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.GLMRegressor.DoubleArray)
                            return object;
                        var message = new $root.CoreML.Specification.GLMRegressor.DoubleArray();
                        if (object.value) {
                            if (!Array.isArray(object.value))
                                throw TypeError(".CoreML.Specification.GLMRegressor.DoubleArray.value: array expected");
                            message.value = [];
                            for (var i = 0; i < object.value.length; ++i)
                                message.value[i] = Number(object.value[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DoubleArray message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMRegressor.DoubleArray} message DoubleArray
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DoubleArray.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.value = [];
                        if (message.value && message.value.length) {
                            object.value = [];
                            for (var j = 0; j < message.value.length; ++j)
                                object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this DoubleArray to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.GLMRegressor.DoubleArray
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DoubleArray.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DoubleArray;
                })();
    
                /**
                 * PostEvaluationTransform enum.
                 * @name CoreML.Specification.GLMRegressor.PostEvaluationTransform
                 * @enum {string}
                 * @property {number} NoTransform=0 NoTransform value
                 * @property {number} Logit=1 Logit value
                 * @property {number} Probit=2 Probit value
                 */
                GLMRegressor.PostEvaluationTransform = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NoTransform"] = 0;
                    values[valuesById[1] = "Logit"] = 1;
                    values[valuesById[2] = "Probit"] = 2;
                    return values;
                })();
    
                return GLMRegressor;
            })();
    
            Specification.GLMClassifier = (function() {
    
                /**
                 * Properties of a GLMClassifier.
                 * @memberof CoreML.Specification
                 * @interface IGLMClassifier
                 * @property {Array.<CoreML.Specification.GLMClassifier.IDoubleArray>|null} [weights] GLMClassifier weights
                 * @property {Array.<number>|null} [offset] GLMClassifier offset
                 * @property {CoreML.Specification.GLMClassifier.PostEvaluationTransform|null} [postEvaluationTransform] GLMClassifier postEvaluationTransform
                 * @property {CoreML.Specification.GLMClassifier.ClassEncoding|null} [classEncoding] GLMClassifier classEncoding
                 * @property {CoreML.Specification.IStringVector|null} [stringClassLabels] GLMClassifier stringClassLabels
                 * @property {CoreML.Specification.IInt64Vector|null} [int64ClassLabels] GLMClassifier int64ClassLabels
                 */
    
                /**
                 * Constructs a new GLMClassifier.
                 * @memberof CoreML.Specification
                 * @classdesc A generalized linear model classifier.
                 * @implements IGLMClassifier
                 * @constructor
                 * @param {CoreML.Specification.IGLMClassifier=} [properties] Properties to set
                 */
                function GLMClassifier(properties) {
                    this.weights = [];
                    this.offset = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * GLMClassifier weights.
                 * @member {Array.<CoreML.Specification.GLMClassifier.IDoubleArray>} weights
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                GLMClassifier.prototype.weights = $util.emptyArray;
    
                /**
                 * GLMClassifier offset.
                 * @member {Array.<number>} offset
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                GLMClassifier.prototype.offset = $util.emptyArray;
    
                /**
                 * GLMClassifier postEvaluationTransform.
                 * @member {CoreML.Specification.GLMClassifier.PostEvaluationTransform} postEvaluationTransform
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                GLMClassifier.prototype.postEvaluationTransform = 0;
    
                /**
                 * GLMClassifier classEncoding.
                 * @member {CoreML.Specification.GLMClassifier.ClassEncoding} classEncoding
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                GLMClassifier.prototype.classEncoding = 0;
    
                /**
                 * GLMClassifier stringClassLabels.
                 * @member {CoreML.Specification.IStringVector|null|undefined} stringClassLabels
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                GLMClassifier.prototype.stringClassLabels = null;
    
                /**
                 * GLMClassifier int64ClassLabels.
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} int64ClassLabels
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                GLMClassifier.prototype.int64ClassLabels = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Required class label mapping.
                 * @member {"stringClassLabels"|"int64ClassLabels"|undefined} ClassLabels
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 */
                Object.defineProperty(GLMClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new GLMClassifier instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {CoreML.Specification.IGLMClassifier=} [properties] Properties to set
                 * @returns {CoreML.Specification.GLMClassifier} GLMClassifier instance
                 */
                GLMClassifier.create = function create(properties) {
                    return new GLMClassifier(properties);
                };
    
                /**
                 * Encodes the specified GLMClassifier message. Does not implicitly {@link CoreML.Specification.GLMClassifier.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {CoreML.Specification.IGLMClassifier} message GLMClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GLMClassifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.weights != null && message.weights.length)
                        for (var i = 0; i < message.weights.length; ++i)
                            $root.CoreML.Specification.GLMClassifier.DoubleArray.encode(message.weights[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.offset != null && message.offset.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.offset.length; ++i)
                            writer.double(message.offset[i]);
                        writer.ldelim();
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.postEvaluationTransform);
                    if (message.classEncoding != null && message.hasOwnProperty("classEncoding"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.classEncoding);
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels"))
                        $root.CoreML.Specification.StringVector.encode(message.stringClassLabels, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels"))
                        $root.CoreML.Specification.Int64Vector.encode(message.int64ClassLabels, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified GLMClassifier message, length delimited. Does not implicitly {@link CoreML.Specification.GLMClassifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {CoreML.Specification.IGLMClassifier} message GLMClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GLMClassifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GLMClassifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.GLMClassifier} GLMClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GLMClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.weights && message.weights.length))
                                message.weights = [];
                            message.weights.push($root.CoreML.Specification.GLMClassifier.DoubleArray.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.offset && message.offset.length))
                                message.offset = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.offset.push(reader.double());
                            } else
                                message.offset.push(reader.double());
                            break;
                        case 3:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        case 4:
                            message.classEncoding = reader.int32();
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GLMClassifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.GLMClassifier} GLMClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GLMClassifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GLMClassifier message.
                 * @function verify
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GLMClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        if (!Array.isArray(message.weights))
                            return "weights: array expected";
                        for (var i = 0; i < message.weights.length; ++i) {
                            var error = $root.CoreML.Specification.GLMClassifier.DoubleArray.verify(message.weights[i]);
                            if (error)
                                return "weights." + error;
                        }
                    }
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        if (!Array.isArray(message.offset))
                            return "offset: array expected";
                        for (var i = 0; i < message.offset.length; ++i)
                            if (typeof message.offset[i] !== "number")
                                return "offset: number[] expected";
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.classEncoding != null && message.hasOwnProperty("classEncoding"))
                        switch (message.classEncoding) {
                        default:
                            return "classEncoding: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a GLMClassifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.GLMClassifier} GLMClassifier
                 */
                GLMClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.GLMClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.GLMClassifier();
                    if (object.weights) {
                        if (!Array.isArray(object.weights))
                            throw TypeError(".CoreML.Specification.GLMClassifier.weights: array expected");
                        message.weights = [];
                        for (var i = 0; i < object.weights.length; ++i) {
                            if (typeof object.weights[i] !== "object")
                                throw TypeError(".CoreML.Specification.GLMClassifier.weights: object expected");
                            message.weights[i] = $root.CoreML.Specification.GLMClassifier.DoubleArray.fromObject(object.weights[i]);
                        }
                    }
                    if (object.offset) {
                        if (!Array.isArray(object.offset))
                            throw TypeError(".CoreML.Specification.GLMClassifier.offset: array expected");
                        message.offset = [];
                        for (var i = 0; i < object.offset.length; ++i)
                            message.offset[i] = Number(object.offset[i]);
                    }
                    switch (object.postEvaluationTransform) {
                    case "Logit":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Probit":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    }
                    switch (object.classEncoding) {
                    case "ReferenceClass":
                    case 0:
                        message.classEncoding = 0;
                        break;
                    case "OneVsRest":
                    case 1:
                        message.classEncoding = 1;
                        break;
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.GLMClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.GLMClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a GLMClassifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.GLMClassifier
                 * @static
                 * @param {CoreML.Specification.GLMClassifier} message GLMClassifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GLMClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.weights = [];
                        object.offset = [];
                    }
                    if (options.defaults) {
                        object.postEvaluationTransform = options.enums === String ? "Logit" : 0;
                        object.classEncoding = options.enums === String ? "ReferenceClass" : 0;
                    }
                    if (message.weights && message.weights.length) {
                        object.weights = [];
                        for (var j = 0; j < message.weights.length; ++j)
                            object.weights[j] = $root.CoreML.Specification.GLMClassifier.DoubleArray.toObject(message.weights[j], options);
                    }
                    if (message.offset && message.offset.length) {
                        object.offset = [];
                        for (var j = 0; j < message.offset.length; ++j)
                            object.offset[j] = options.json && !isFinite(message.offset[j]) ? String(message.offset[j]) : message.offset[j];
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.GLMClassifier.PostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    if (message.classEncoding != null && message.hasOwnProperty("classEncoding"))
                        object.classEncoding = options.enums === String ? $root.CoreML.Specification.GLMClassifier.ClassEncoding[message.classEncoding] : message.classEncoding;
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    return object;
                };
    
                /**
                 * Converts this GLMClassifier to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.GLMClassifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GLMClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                GLMClassifier.DoubleArray = (function() {
    
                    /**
                     * Properties of a DoubleArray.
                     * @memberof CoreML.Specification.GLMClassifier
                     * @interface IDoubleArray
                     * @property {Array.<number>|null} [value] DoubleArray value
                     */
    
                    /**
                     * Constructs a new DoubleArray.
                     * @memberof CoreML.Specification.GLMClassifier
                     * @classdesc Represents a DoubleArray.
                     * @implements IDoubleArray
                     * @constructor
                     * @param {CoreML.Specification.GLMClassifier.IDoubleArray=} [properties] Properties to set
                     */
                    function DoubleArray(properties) {
                        this.value = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * DoubleArray value.
                     * @member {Array.<number>} value
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @instance
                     */
                    DoubleArray.prototype.value = $util.emptyArray;
    
                    /**
                     * Creates a new DoubleArray instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMClassifier.IDoubleArray=} [properties] Properties to set
                     * @returns {CoreML.Specification.GLMClassifier.DoubleArray} DoubleArray instance
                     */
                    DoubleArray.create = function create(properties) {
                        return new DoubleArray(properties);
                    };
    
                    /**
                     * Encodes the specified DoubleArray message. Does not implicitly {@link CoreML.Specification.GLMClassifier.DoubleArray.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMClassifier.IDoubleArray} message DoubleArray message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DoubleArray.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.value.length) {
                            writer.uint32(/* id 1, wireType 2 =*/10).fork();
                            for (var i = 0; i < message.value.length; ++i)
                                writer.double(message.value[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified DoubleArray message, length delimited. Does not implicitly {@link CoreML.Specification.GLMClassifier.DoubleArray.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMClassifier.IDoubleArray} message DoubleArray message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    DoubleArray.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a DoubleArray message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.GLMClassifier.DoubleArray} DoubleArray
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DoubleArray.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GLMClassifier.DoubleArray();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                if (!(message.value && message.value.length))
                                    message.value = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.value.push(reader.double());
                                } else
                                    message.value.push(reader.double());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a DoubleArray message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.GLMClassifier.DoubleArray} DoubleArray
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    DoubleArray.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a DoubleArray message.
                     * @function verify
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DoubleArray.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            if (!Array.isArray(message.value))
                                return "value: array expected";
                            for (var i = 0; i < message.value.length; ++i)
                                if (typeof message.value[i] !== "number")
                                    return "value: number[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a DoubleArray message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.GLMClassifier.DoubleArray} DoubleArray
                     */
                    DoubleArray.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.GLMClassifier.DoubleArray)
                            return object;
                        var message = new $root.CoreML.Specification.GLMClassifier.DoubleArray();
                        if (object.value) {
                            if (!Array.isArray(object.value))
                                throw TypeError(".CoreML.Specification.GLMClassifier.DoubleArray.value: array expected");
                            message.value = [];
                            for (var i = 0; i < object.value.length; ++i)
                                message.value[i] = Number(object.value[i]);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a DoubleArray message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @static
                     * @param {CoreML.Specification.GLMClassifier.DoubleArray} message DoubleArray
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DoubleArray.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.value = [];
                        if (message.value && message.value.length) {
                            object.value = [];
                            for (var j = 0; j < message.value.length; ++j)
                                object.value[j] = options.json && !isFinite(message.value[j]) ? String(message.value[j]) : message.value[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this DoubleArray to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.GLMClassifier.DoubleArray
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DoubleArray.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return DoubleArray;
                })();
    
                /**
                 * PostEvaluationTransform enum.
                 * @name CoreML.Specification.GLMClassifier.PostEvaluationTransform
                 * @enum {string}
                 * @property {number} Logit=0 Logit value
                 * @property {number} Probit=1 Only binary classification is supported for probit
                 */
                GLMClassifier.PostEvaluationTransform = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "Logit"] = 0;
                    values[valuesById[1] = "Probit"] = 1;
                    return values;
                })();
    
                /**
                 * ClassEncoding enum.
                 * @name CoreML.Specification.GLMClassifier.ClassEncoding
                 * @enum {string}
                 * @property {number} ReferenceClass=0 First class is the reference class
                 * @property {number} OneVsRest=1 Also called One vs All
                 */
                GLMClassifier.ClassEncoding = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ReferenceClass"] = 0;
                    values[valuesById[1] = "OneVsRest"] = 1;
                    return values;
                })();
    
                return GLMClassifier;
            })();
    
            Specification.Identity = (function() {
    
                /**
                 * Properties of an Identity.
                 * @memberof CoreML.Specification
                 * @interface IIdentity
                 */
    
                /**
                 * Constructs a new Identity.
                 * @memberof CoreML.Specification
                 * @classdesc An identity model.
                 * 
                 * This model returns given inputs as outputs, unchanged.
                 * Intended to be used for testing purposes.
                 * @implements IIdentity
                 * @constructor
                 * @param {CoreML.Specification.IIdentity=} [properties] Properties to set
                 */
                function Identity(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new Identity instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {CoreML.Specification.IIdentity=} [properties] Properties to set
                 * @returns {CoreML.Specification.Identity} Identity instance
                 */
                Identity.create = function create(properties) {
                    return new Identity(properties);
                };
    
                /**
                 * Encodes the specified Identity message. Does not implicitly {@link CoreML.Specification.Identity.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {CoreML.Specification.IIdentity} message Identity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Identity.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified Identity message, length delimited. Does not implicitly {@link CoreML.Specification.Identity.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {CoreML.Specification.IIdentity} message Identity message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Identity.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Identity message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Identity} Identity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Identity.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Identity();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Identity message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Identity} Identity
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Identity.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Identity message.
                 * @function verify
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Identity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an Identity message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Identity} Identity
                 */
                Identity.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Identity)
                        return object;
                    return new $root.CoreML.Specification.Identity();
                };
    
                /**
                 * Creates a plain object from an Identity message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Identity
                 * @static
                 * @param {CoreML.Specification.Identity} message Identity
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Identity.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this Identity to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Identity
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Identity.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Identity;
            })();
    
            Specification.Imputer = (function() {
    
                /**
                 * Properties of an Imputer.
                 * @memberof CoreML.Specification
                 * @interface IImputer
                 * @property {number|null} [imputedDoubleValue] Imputer imputedDoubleValue
                 * @property {number|Long|null} [imputedInt64Value] Imputer imputedInt64Value
                 * @property {string|null} [imputedStringValue] Imputer imputedStringValue
                 * @property {CoreML.Specification.IDoubleVector|null} [imputedDoubleArray] Imputer imputedDoubleArray
                 * @property {CoreML.Specification.IInt64Vector|null} [imputedInt64Array] Imputer imputedInt64Array
                 * @property {CoreML.Specification.IStringToDoubleMap|null} [imputedStringDictionary] Imputer imputedStringDictionary
                 * @property {CoreML.Specification.IInt64ToDoubleMap|null} [imputedInt64Dictionary] Imputer imputedInt64Dictionary
                 * @property {number|null} [replaceDoubleValue] Imputer replaceDoubleValue
                 * @property {number|Long|null} [replaceInt64Value] Imputer replaceInt64Value
                 * @property {string|null} [replaceStringValue] Imputer replaceStringValue
                 */
    
                /**
                 * Constructs a new Imputer.
                 * @memberof CoreML.Specification
                 * @classdesc A transformer that replaces missing values with a default value,
                 * such as a statistically-derived value.
                 * 
                 * If ``ReplaceValue`` is set, then missing values of that type are
                 * replaced with the corresponding value.
                 * 
                 * For example: if ``replaceDoubleValue`` is set to ``NaN``
                 * and a single ``NaN`` double value is provided as input,
                 * then it is replaced by ``imputedDoubleValue``. However
                 * if the input is an array of doubles, then any instances
                 * of ``NaN`` in the array is replaced with the corresponding
                 * value in ``imputedDoubleArray``.
                 * @implements IImputer
                 * @constructor
                 * @param {CoreML.Specification.IImputer=} [properties] Properties to set
                 */
                function Imputer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Imputer imputedDoubleValue.
                 * @member {number} imputedDoubleValue
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedDoubleValue = 0;
    
                /**
                 * Imputer imputedInt64Value.
                 * @member {number|Long} imputedInt64Value
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedInt64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Imputer imputedStringValue.
                 * @member {string} imputedStringValue
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedStringValue = "";
    
                /**
                 * Imputer imputedDoubleArray.
                 * @member {CoreML.Specification.IDoubleVector|null|undefined} imputedDoubleArray
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedDoubleArray = null;
    
                /**
                 * Imputer imputedInt64Array.
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} imputedInt64Array
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedInt64Array = null;
    
                /**
                 * Imputer imputedStringDictionary.
                 * @member {CoreML.Specification.IStringToDoubleMap|null|undefined} imputedStringDictionary
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedStringDictionary = null;
    
                /**
                 * Imputer imputedInt64Dictionary.
                 * @member {CoreML.Specification.IInt64ToDoubleMap|null|undefined} imputedInt64Dictionary
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.imputedInt64Dictionary = null;
    
                /**
                 * Imputer replaceDoubleValue.
                 * @member {number} replaceDoubleValue
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.replaceDoubleValue = 0;
    
                /**
                 * Imputer replaceInt64Value.
                 * @member {number|Long} replaceInt64Value
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.replaceInt64Value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * Imputer replaceStringValue.
                 * @member {string} replaceStringValue
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Imputer.prototype.replaceStringValue = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Imputer ImputedValue.
                 * @member {"imputedDoubleValue"|"imputedInt64Value"|"imputedStringValue"|"imputedDoubleArray"|"imputedInt64Array"|"imputedStringDictionary"|"imputedInt64Dictionary"|undefined} ImputedValue
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Object.defineProperty(Imputer.prototype, "ImputedValue", {
                    get: $util.oneOfGetter($oneOfFields = ["imputedDoubleValue", "imputedInt64Value", "imputedStringValue", "imputedDoubleArray", "imputedInt64Array", "imputedStringDictionary", "imputedInt64Dictionary"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Imputer ReplaceValue.
                 * @member {"replaceDoubleValue"|"replaceInt64Value"|"replaceStringValue"|undefined} ReplaceValue
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 */
                Object.defineProperty(Imputer.prototype, "ReplaceValue", {
                    get: $util.oneOfGetter($oneOfFields = ["replaceDoubleValue", "replaceInt64Value", "replaceStringValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Imputer instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {CoreML.Specification.IImputer=} [properties] Properties to set
                 * @returns {CoreML.Specification.Imputer} Imputer instance
                 */
                Imputer.create = function create(properties) {
                    return new Imputer(properties);
                };
    
                /**
                 * Encodes the specified Imputer message. Does not implicitly {@link CoreML.Specification.Imputer.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {CoreML.Specification.IImputer} message Imputer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Imputer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.imputedDoubleValue != null && message.hasOwnProperty("imputedDoubleValue"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.imputedDoubleValue);
                    if (message.imputedInt64Value != null && message.hasOwnProperty("imputedInt64Value"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.imputedInt64Value);
                    if (message.imputedStringValue != null && message.hasOwnProperty("imputedStringValue"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.imputedStringValue);
                    if (message.imputedDoubleArray != null && message.hasOwnProperty("imputedDoubleArray"))
                        $root.CoreML.Specification.DoubleVector.encode(message.imputedDoubleArray, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.imputedInt64Array != null && message.hasOwnProperty("imputedInt64Array"))
                        $root.CoreML.Specification.Int64Vector.encode(message.imputedInt64Array, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.imputedStringDictionary != null && message.hasOwnProperty("imputedStringDictionary"))
                        $root.CoreML.Specification.StringToDoubleMap.encode(message.imputedStringDictionary, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    if (message.imputedInt64Dictionary != null && message.hasOwnProperty("imputedInt64Dictionary"))
                        $root.CoreML.Specification.Int64ToDoubleMap.encode(message.imputedInt64Dictionary, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    if (message.replaceDoubleValue != null && message.hasOwnProperty("replaceDoubleValue"))
                        writer.uint32(/* id 11, wireType 1 =*/89).double(message.replaceDoubleValue);
                    if (message.replaceInt64Value != null && message.hasOwnProperty("replaceInt64Value"))
                        writer.uint32(/* id 12, wireType 0 =*/96).int64(message.replaceInt64Value);
                    if (message.replaceStringValue != null && message.hasOwnProperty("replaceStringValue"))
                        writer.uint32(/* id 13, wireType 2 =*/106).string(message.replaceStringValue);
                    return writer;
                };
    
                /**
                 * Encodes the specified Imputer message, length delimited. Does not implicitly {@link CoreML.Specification.Imputer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {CoreML.Specification.IImputer} message Imputer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Imputer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an Imputer message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Imputer} Imputer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Imputer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Imputer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.imputedDoubleValue = reader.double();
                            break;
                        case 2:
                            message.imputedInt64Value = reader.int64();
                            break;
                        case 3:
                            message.imputedStringValue = reader.string();
                            break;
                        case 4:
                            message.imputedDoubleArray = $root.CoreML.Specification.DoubleVector.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.imputedInt64Array = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.imputedStringDictionary = $root.CoreML.Specification.StringToDoubleMap.decode(reader, reader.uint32());
                            break;
                        case 7:
                            message.imputedInt64Dictionary = $root.CoreML.Specification.Int64ToDoubleMap.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.replaceDoubleValue = reader.double();
                            break;
                        case 12:
                            message.replaceInt64Value = reader.int64();
                            break;
                        case 13:
                            message.replaceStringValue = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an Imputer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Imputer} Imputer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Imputer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an Imputer message.
                 * @function verify
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Imputer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.imputedDoubleValue != null && message.hasOwnProperty("imputedDoubleValue")) {
                        properties.ImputedValue = 1;
                        if (typeof message.imputedDoubleValue !== "number")
                            return "imputedDoubleValue: number expected";
                    }
                    if (message.imputedInt64Value != null && message.hasOwnProperty("imputedInt64Value")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        if (!$util.isInteger(message.imputedInt64Value) && !(message.imputedInt64Value && $util.isInteger(message.imputedInt64Value.low) && $util.isInteger(message.imputedInt64Value.high)))
                            return "imputedInt64Value: integer|Long expected";
                    }
                    if (message.imputedStringValue != null && message.hasOwnProperty("imputedStringValue")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        if (!$util.isString(message.imputedStringValue))
                            return "imputedStringValue: string expected";
                    }
                    if (message.imputedDoubleArray != null && message.hasOwnProperty("imputedDoubleArray")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.DoubleVector.verify(message.imputedDoubleArray);
                            if (error)
                                return "imputedDoubleArray." + error;
                        }
                    }
                    if (message.imputedInt64Array != null && message.hasOwnProperty("imputedInt64Array")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.imputedInt64Array);
                            if (error)
                                return "imputedInt64Array." + error;
                        }
                    }
                    if (message.imputedStringDictionary != null && message.hasOwnProperty("imputedStringDictionary")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.StringToDoubleMap.verify(message.imputedStringDictionary);
                            if (error)
                                return "imputedStringDictionary." + error;
                        }
                    }
                    if (message.imputedInt64Dictionary != null && message.hasOwnProperty("imputedInt64Dictionary")) {
                        if (properties.ImputedValue === 1)
                            return "ImputedValue: multiple values";
                        properties.ImputedValue = 1;
                        {
                            var error = $root.CoreML.Specification.Int64ToDoubleMap.verify(message.imputedInt64Dictionary);
                            if (error)
                                return "imputedInt64Dictionary." + error;
                        }
                    }
                    if (message.replaceDoubleValue != null && message.hasOwnProperty("replaceDoubleValue")) {
                        properties.ReplaceValue = 1;
                        if (typeof message.replaceDoubleValue !== "number")
                            return "replaceDoubleValue: number expected";
                    }
                    if (message.replaceInt64Value != null && message.hasOwnProperty("replaceInt64Value")) {
                        if (properties.ReplaceValue === 1)
                            return "ReplaceValue: multiple values";
                        properties.ReplaceValue = 1;
                        if (!$util.isInteger(message.replaceInt64Value) && !(message.replaceInt64Value && $util.isInteger(message.replaceInt64Value.low) && $util.isInteger(message.replaceInt64Value.high)))
                            return "replaceInt64Value: integer|Long expected";
                    }
                    if (message.replaceStringValue != null && message.hasOwnProperty("replaceStringValue")) {
                        if (properties.ReplaceValue === 1)
                            return "ReplaceValue: multiple values";
                        properties.ReplaceValue = 1;
                        if (!$util.isString(message.replaceStringValue))
                            return "replaceStringValue: string expected";
                    }
                    return null;
                };
    
                /**
                 * Creates an Imputer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Imputer} Imputer
                 */
                Imputer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Imputer)
                        return object;
                    var message = new $root.CoreML.Specification.Imputer();
                    if (object.imputedDoubleValue != null)
                        message.imputedDoubleValue = Number(object.imputedDoubleValue);
                    if (object.imputedInt64Value != null)
                        if ($util.Long)
                            (message.imputedInt64Value = $util.Long.fromValue(object.imputedInt64Value)).unsigned = false;
                        else if (typeof object.imputedInt64Value === "string")
                            message.imputedInt64Value = parseInt(object.imputedInt64Value, 10);
                        else if (typeof object.imputedInt64Value === "number")
                            message.imputedInt64Value = object.imputedInt64Value;
                        else if (typeof object.imputedInt64Value === "object")
                            message.imputedInt64Value = new $util.LongBits(object.imputedInt64Value.low >>> 0, object.imputedInt64Value.high >>> 0).toNumber();
                    if (object.imputedStringValue != null)
                        message.imputedStringValue = String(object.imputedStringValue);
                    if (object.imputedDoubleArray != null) {
                        if (typeof object.imputedDoubleArray !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedDoubleArray: object expected");
                        message.imputedDoubleArray = $root.CoreML.Specification.DoubleVector.fromObject(object.imputedDoubleArray);
                    }
                    if (object.imputedInt64Array != null) {
                        if (typeof object.imputedInt64Array !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedInt64Array: object expected");
                        message.imputedInt64Array = $root.CoreML.Specification.Int64Vector.fromObject(object.imputedInt64Array);
                    }
                    if (object.imputedStringDictionary != null) {
                        if (typeof object.imputedStringDictionary !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedStringDictionary: object expected");
                        message.imputedStringDictionary = $root.CoreML.Specification.StringToDoubleMap.fromObject(object.imputedStringDictionary);
                    }
                    if (object.imputedInt64Dictionary != null) {
                        if (typeof object.imputedInt64Dictionary !== "object")
                            throw TypeError(".CoreML.Specification.Imputer.imputedInt64Dictionary: object expected");
                        message.imputedInt64Dictionary = $root.CoreML.Specification.Int64ToDoubleMap.fromObject(object.imputedInt64Dictionary);
                    }
                    if (object.replaceDoubleValue != null)
                        message.replaceDoubleValue = Number(object.replaceDoubleValue);
                    if (object.replaceInt64Value != null)
                        if ($util.Long)
                            (message.replaceInt64Value = $util.Long.fromValue(object.replaceInt64Value)).unsigned = false;
                        else if (typeof object.replaceInt64Value === "string")
                            message.replaceInt64Value = parseInt(object.replaceInt64Value, 10);
                        else if (typeof object.replaceInt64Value === "number")
                            message.replaceInt64Value = object.replaceInt64Value;
                        else if (typeof object.replaceInt64Value === "object")
                            message.replaceInt64Value = new $util.LongBits(object.replaceInt64Value.low >>> 0, object.replaceInt64Value.high >>> 0).toNumber();
                    if (object.replaceStringValue != null)
                        message.replaceStringValue = String(object.replaceStringValue);
                    return message;
                };
    
                /**
                 * Creates a plain object from an Imputer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Imputer
                 * @static
                 * @param {CoreML.Specification.Imputer} message Imputer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Imputer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.imputedDoubleValue != null && message.hasOwnProperty("imputedDoubleValue")) {
                        object.imputedDoubleValue = options.json && !isFinite(message.imputedDoubleValue) ? String(message.imputedDoubleValue) : message.imputedDoubleValue;
                        if (options.oneofs)
                            object.ImputedValue = "imputedDoubleValue";
                    }
                    if (message.imputedInt64Value != null && message.hasOwnProperty("imputedInt64Value")) {
                        if (typeof message.imputedInt64Value === "number")
                            object.imputedInt64Value = options.longs === String ? String(message.imputedInt64Value) : message.imputedInt64Value;
                        else
                            object.imputedInt64Value = options.longs === String ? $util.Long.prototype.toString.call(message.imputedInt64Value) : options.longs === Number ? new $util.LongBits(message.imputedInt64Value.low >>> 0, message.imputedInt64Value.high >>> 0).toNumber() : message.imputedInt64Value;
                        if (options.oneofs)
                            object.ImputedValue = "imputedInt64Value";
                    }
                    if (message.imputedStringValue != null && message.hasOwnProperty("imputedStringValue")) {
                        object.imputedStringValue = message.imputedStringValue;
                        if (options.oneofs)
                            object.ImputedValue = "imputedStringValue";
                    }
                    if (message.imputedDoubleArray != null && message.hasOwnProperty("imputedDoubleArray")) {
                        object.imputedDoubleArray = $root.CoreML.Specification.DoubleVector.toObject(message.imputedDoubleArray, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedDoubleArray";
                    }
                    if (message.imputedInt64Array != null && message.hasOwnProperty("imputedInt64Array")) {
                        object.imputedInt64Array = $root.CoreML.Specification.Int64Vector.toObject(message.imputedInt64Array, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedInt64Array";
                    }
                    if (message.imputedStringDictionary != null && message.hasOwnProperty("imputedStringDictionary")) {
                        object.imputedStringDictionary = $root.CoreML.Specification.StringToDoubleMap.toObject(message.imputedStringDictionary, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedStringDictionary";
                    }
                    if (message.imputedInt64Dictionary != null && message.hasOwnProperty("imputedInt64Dictionary")) {
                        object.imputedInt64Dictionary = $root.CoreML.Specification.Int64ToDoubleMap.toObject(message.imputedInt64Dictionary, options);
                        if (options.oneofs)
                            object.ImputedValue = "imputedInt64Dictionary";
                    }
                    if (message.replaceDoubleValue != null && message.hasOwnProperty("replaceDoubleValue")) {
                        object.replaceDoubleValue = options.json && !isFinite(message.replaceDoubleValue) ? String(message.replaceDoubleValue) : message.replaceDoubleValue;
                        if (options.oneofs)
                            object.ReplaceValue = "replaceDoubleValue";
                    }
                    if (message.replaceInt64Value != null && message.hasOwnProperty("replaceInt64Value")) {
                        if (typeof message.replaceInt64Value === "number")
                            object.replaceInt64Value = options.longs === String ? String(message.replaceInt64Value) : message.replaceInt64Value;
                        else
                            object.replaceInt64Value = options.longs === String ? $util.Long.prototype.toString.call(message.replaceInt64Value) : options.longs === Number ? new $util.LongBits(message.replaceInt64Value.low >>> 0, message.replaceInt64Value.high >>> 0).toNumber() : message.replaceInt64Value;
                        if (options.oneofs)
                            object.ReplaceValue = "replaceInt64Value";
                    }
                    if (message.replaceStringValue != null && message.hasOwnProperty("replaceStringValue")) {
                        object.replaceStringValue = message.replaceStringValue;
                        if (options.oneofs)
                            object.ReplaceValue = "replaceStringValue";
                    }
                    return object;
                };
    
                /**
                 * Converts this Imputer to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Imputer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Imputer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Imputer;
            })();
    
            Specification.NeuralNetwork = (function() {
    
                /**
                 * Properties of a NeuralNetwork.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetwork
                 * @property {Array.<CoreML.Specification.INeuralNetworkLayer>|null} [layers] NeuralNetwork layers
                 * @property {Array.<CoreML.Specification.INeuralNetworkPreprocessing>|null} [preprocessing] NeuralNetwork preprocessing
                 */
    
                /**
                 * Constructs a new NeuralNetwork.
                 * @memberof CoreML.Specification
                 * @classdesc A neural network.
                 * @implements INeuralNetwork
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetwork=} [properties] Properties to set
                 */
                function NeuralNetwork(properties) {
                    this.layers = [];
                    this.preprocessing = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NeuralNetwork layers.
                 * @member {Array.<CoreML.Specification.INeuralNetworkLayer>} layers
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @instance
                 */
                NeuralNetwork.prototype.layers = $util.emptyArray;
    
                /**
                 * NeuralNetwork preprocessing.
                 * @member {Array.<CoreML.Specification.INeuralNetworkPreprocessing>} preprocessing
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @instance
                 */
                NeuralNetwork.prototype.preprocessing = $util.emptyArray;
    
                /**
                 * Creates a new NeuralNetwork instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {CoreML.Specification.INeuralNetwork=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetwork} NeuralNetwork instance
                 */
                NeuralNetwork.create = function create(properties) {
                    return new NeuralNetwork(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetwork message. Does not implicitly {@link CoreML.Specification.NeuralNetwork.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {CoreML.Specification.INeuralNetwork} message NeuralNetwork message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetwork.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.layers != null && message.layers.length)
                        for (var i = 0; i < message.layers.length; ++i)
                            $root.CoreML.Specification.NeuralNetworkLayer.encode(message.layers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.preprocessing != null && message.preprocessing.length)
                        for (var i = 0; i < message.preprocessing.length; ++i)
                            $root.CoreML.Specification.NeuralNetworkPreprocessing.encode(message.preprocessing[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetwork message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetwork.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {CoreML.Specification.INeuralNetwork} message NeuralNetwork message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetwork.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetwork message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetwork} NeuralNetwork
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetwork.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetwork();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.layers && message.layers.length))
                                message.layers = [];
                            message.layers.push($root.CoreML.Specification.NeuralNetworkLayer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.preprocessing && message.preprocessing.length))
                                message.preprocessing = [];
                            message.preprocessing.push($root.CoreML.Specification.NeuralNetworkPreprocessing.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetwork message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetwork} NeuralNetwork
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetwork.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetwork message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetwork.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.layers != null && message.hasOwnProperty("layers")) {
                        if (!Array.isArray(message.layers))
                            return "layers: array expected";
                        for (var i = 0; i < message.layers.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkLayer.verify(message.layers[i]);
                            if (error)
                                return "layers." + error;
                        }
                    }
                    if (message.preprocessing != null && message.hasOwnProperty("preprocessing")) {
                        if (!Array.isArray(message.preprocessing))
                            return "preprocessing: array expected";
                        for (var i = 0; i < message.preprocessing.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkPreprocessing.verify(message.preprocessing[i]);
                            if (error)
                                return "preprocessing." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NeuralNetwork message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetwork} NeuralNetwork
                 */
                NeuralNetwork.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetwork)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetwork();
                    if (object.layers) {
                        if (!Array.isArray(object.layers))
                            throw TypeError(".CoreML.Specification.NeuralNetwork.layers: array expected");
                        message.layers = [];
                        for (var i = 0; i < object.layers.length; ++i) {
                            if (typeof object.layers[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetwork.layers: object expected");
                            message.layers[i] = $root.CoreML.Specification.NeuralNetworkLayer.fromObject(object.layers[i]);
                        }
                    }
                    if (object.preprocessing) {
                        if (!Array.isArray(object.preprocessing))
                            throw TypeError(".CoreML.Specification.NeuralNetwork.preprocessing: array expected");
                        message.preprocessing = [];
                        for (var i = 0; i < object.preprocessing.length; ++i) {
                            if (typeof object.preprocessing[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetwork.preprocessing: object expected");
                            message.preprocessing[i] = $root.CoreML.Specification.NeuralNetworkPreprocessing.fromObject(object.preprocessing[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetwork message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @static
                 * @param {CoreML.Specification.NeuralNetwork} message NeuralNetwork
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetwork.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.layers = [];
                        object.preprocessing = [];
                    }
                    if (message.layers && message.layers.length) {
                        object.layers = [];
                        for (var j = 0; j < message.layers.length; ++j)
                            object.layers[j] = $root.CoreML.Specification.NeuralNetworkLayer.toObject(message.layers[j], options);
                    }
                    if (message.preprocessing && message.preprocessing.length) {
                        object.preprocessing = [];
                        for (var j = 0; j < message.preprocessing.length; ++j)
                            object.preprocessing[j] = $root.CoreML.Specification.NeuralNetworkPreprocessing.toObject(message.preprocessing[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NeuralNetwork to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetwork
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetwork.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetwork;
            })();
    
            Specification.NeuralNetworkImageScaler = (function() {
    
                /**
                 * Properties of a NeuralNetworkImageScaler.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetworkImageScaler
                 * @property {number|null} [channelScale] Scalar to be multiplied.
                 * @property {number|null} [blueBias] Scalar blue bias to be added.
                 * @property {number|null} [greenBias] Scalar green bias to be added.
                 * @property {number|null} [redBias] Scalar red bias to be added.
                 * @property {number|null} [grayBias] Scalar bias to be added for grayscale images.
                 */
    
                /**
                 * Constructs a new NeuralNetworkImageScaler.
                 * @memberof CoreML.Specification
                 * @classdesc A neural network preprocessor that
                 * performs a scalar multiplication of an image
                 * followed by addition of scalar biases to the channels.
                 * 
                 * Input: X
                 * An image in BGR or RGB format with shape ``[3, H, W]``
                 * or in grayscale format with shape ``[1, H, W]``.
                 * Output: Y
                 * An image with format and shape corresponding to the input.
                 * 
                 * If the input image is in BGR format:
                 * 
                 * .. code::
                 * 
                 * Y[0, :, :] = channelScale * X[0, :, :] + blueBias
                 * Y[1, :, :] = channelScale * X[1, :, :] + greenBias
                 * Y[2, :, :] = channelScale * X[2, :, :] + redBias
                 * 
                 * If the input image is in RGB format:
                 * 
                 * .. code::
                 * 
                 * Y[0, :, :] = channelScale * X[0, :, :] + redBias
                 * Y[1, :, :] = channelScale * X[1, :, :] + greenBias
                 * Y[2, :, :] = channelScale * X[2, :, :] + blueBias
                 * 
                 * If the input image is in grayscale format:
                 * 
                 * .. code::
                 * 
                 * Y[0, :, :] = channelScale * X[0, :, :] + grayBias
                 * @implements INeuralNetworkImageScaler
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetworkImageScaler=} [properties] Properties to set
                 */
                function NeuralNetworkImageScaler(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scalar to be multiplied.
                 * @member {number} channelScale
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @instance
                 */
                NeuralNetworkImageScaler.prototype.channelScale = 0;
    
                /**
                 * Scalar blue bias to be added.
                 * @member {number} blueBias
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @instance
                 */
                NeuralNetworkImageScaler.prototype.blueBias = 0;
    
                /**
                 * Scalar green bias to be added.
                 * @member {number} greenBias
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @instance
                 */
                NeuralNetworkImageScaler.prototype.greenBias = 0;
    
                /**
                 * Scalar red bias to be added.
                 * @member {number} redBias
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @instance
                 */
                NeuralNetworkImageScaler.prototype.redBias = 0;
    
                /**
                 * Scalar bias to be added for grayscale images.
                 * @member {number} grayBias
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @instance
                 */
                NeuralNetworkImageScaler.prototype.grayBias = 0;
    
                /**
                 * Creates a new NeuralNetworkImageScaler instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkImageScaler=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetworkImageScaler} NeuralNetworkImageScaler instance
                 */
                NeuralNetworkImageScaler.create = function create(properties) {
                    return new NeuralNetworkImageScaler(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetworkImageScaler message. Does not implicitly {@link CoreML.Specification.NeuralNetworkImageScaler.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkImageScaler} message NeuralNetworkImageScaler message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkImageScaler.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.channelScale != null && message.hasOwnProperty("channelScale"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.channelScale);
                    if (message.blueBias != null && message.hasOwnProperty("blueBias"))
                        writer.uint32(/* id 20, wireType 5 =*/165).float(message.blueBias);
                    if (message.greenBias != null && message.hasOwnProperty("greenBias"))
                        writer.uint32(/* id 21, wireType 5 =*/173).float(message.greenBias);
                    if (message.redBias != null && message.hasOwnProperty("redBias"))
                        writer.uint32(/* id 22, wireType 5 =*/181).float(message.redBias);
                    if (message.grayBias != null && message.hasOwnProperty("grayBias"))
                        writer.uint32(/* id 30, wireType 5 =*/245).float(message.grayBias);
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetworkImageScaler message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetworkImageScaler.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkImageScaler} message NeuralNetworkImageScaler message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkImageScaler.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetworkImageScaler message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetworkImageScaler} NeuralNetworkImageScaler
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkImageScaler.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkImageScaler();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.channelScale = reader.float();
                            break;
                        case 20:
                            message.blueBias = reader.float();
                            break;
                        case 21:
                            message.greenBias = reader.float();
                            break;
                        case 22:
                            message.redBias = reader.float();
                            break;
                        case 30:
                            message.grayBias = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetworkImageScaler message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetworkImageScaler} NeuralNetworkImageScaler
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkImageScaler.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetworkImageScaler message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetworkImageScaler.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.channelScale != null && message.hasOwnProperty("channelScale"))
                        if (typeof message.channelScale !== "number")
                            return "channelScale: number expected";
                    if (message.blueBias != null && message.hasOwnProperty("blueBias"))
                        if (typeof message.blueBias !== "number")
                            return "blueBias: number expected";
                    if (message.greenBias != null && message.hasOwnProperty("greenBias"))
                        if (typeof message.greenBias !== "number")
                            return "greenBias: number expected";
                    if (message.redBias != null && message.hasOwnProperty("redBias"))
                        if (typeof message.redBias !== "number")
                            return "redBias: number expected";
                    if (message.grayBias != null && message.hasOwnProperty("grayBias"))
                        if (typeof message.grayBias !== "number")
                            return "grayBias: number expected";
                    return null;
                };
    
                /**
                 * Creates a NeuralNetworkImageScaler message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetworkImageScaler} NeuralNetworkImageScaler
                 */
                NeuralNetworkImageScaler.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkImageScaler)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkImageScaler();
                    if (object.channelScale != null)
                        message.channelScale = Number(object.channelScale);
                    if (object.blueBias != null)
                        message.blueBias = Number(object.blueBias);
                    if (object.greenBias != null)
                        message.greenBias = Number(object.greenBias);
                    if (object.redBias != null)
                        message.redBias = Number(object.redBias);
                    if (object.grayBias != null)
                        message.grayBias = Number(object.grayBias);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetworkImageScaler message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @static
                 * @param {CoreML.Specification.NeuralNetworkImageScaler} message NeuralNetworkImageScaler
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetworkImageScaler.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.channelScale = 0;
                        object.blueBias = 0;
                        object.greenBias = 0;
                        object.redBias = 0;
                        object.grayBias = 0;
                    }
                    if (message.channelScale != null && message.hasOwnProperty("channelScale"))
                        object.channelScale = options.json && !isFinite(message.channelScale) ? String(message.channelScale) : message.channelScale;
                    if (message.blueBias != null && message.hasOwnProperty("blueBias"))
                        object.blueBias = options.json && !isFinite(message.blueBias) ? String(message.blueBias) : message.blueBias;
                    if (message.greenBias != null && message.hasOwnProperty("greenBias"))
                        object.greenBias = options.json && !isFinite(message.greenBias) ? String(message.greenBias) : message.greenBias;
                    if (message.redBias != null && message.hasOwnProperty("redBias"))
                        object.redBias = options.json && !isFinite(message.redBias) ? String(message.redBias) : message.redBias;
                    if (message.grayBias != null && message.hasOwnProperty("grayBias"))
                        object.grayBias = options.json && !isFinite(message.grayBias) ? String(message.grayBias) : message.grayBias;
                    return object;
                };
    
                /**
                 * Converts this NeuralNetworkImageScaler to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetworkImageScaler
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetworkImageScaler.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkImageScaler;
            })();
    
            Specification.NeuralNetworkMeanImage = (function() {
    
                /**
                 * Properties of a NeuralNetworkMeanImage.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetworkMeanImage
                 * @property {Array.<number>|null} [meanImage] Mean image stored as a flattened array of floats,
                 * representing shape [Channel,Height,Width].
                 */
    
                /**
                 * Constructs a new NeuralNetworkMeanImage.
                 * @memberof CoreML.Specification
                 * @classdesc A neural network preprocessor that
                 * subtracts the provided mean image from the input image.
                 * The mean image is subtracted from the input named
                 * ``NeuralNetworkPreprocessing.featureName``.
                 * @implements INeuralNetworkMeanImage
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetworkMeanImage=} [properties] Properties to set
                 */
                function NeuralNetworkMeanImage(properties) {
                    this.meanImage = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Mean image stored as a flattened array of floats,
                 * representing shape [Channel,Height,Width].
                 * @member {Array.<number>} meanImage
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @instance
                 */
                NeuralNetworkMeanImage.prototype.meanImage = $util.emptyArray;
    
                /**
                 * Creates a new NeuralNetworkMeanImage instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkMeanImage=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetworkMeanImage} NeuralNetworkMeanImage instance
                 */
                NeuralNetworkMeanImage.create = function create(properties) {
                    return new NeuralNetworkMeanImage(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetworkMeanImage message. Does not implicitly {@link CoreML.Specification.NeuralNetworkMeanImage.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkMeanImage} message NeuralNetworkMeanImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkMeanImage.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.meanImage != null && message.meanImage.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.meanImage.length; ++i)
                            writer.float(message.meanImage[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetworkMeanImage message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetworkMeanImage.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkMeanImage} message NeuralNetworkMeanImage message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkMeanImage.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetworkMeanImage message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetworkMeanImage} NeuralNetworkMeanImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkMeanImage.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkMeanImage();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.meanImage && message.meanImage.length))
                                message.meanImage = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.meanImage.push(reader.float());
                            } else
                                message.meanImage.push(reader.float());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetworkMeanImage message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetworkMeanImage} NeuralNetworkMeanImage
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkMeanImage.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetworkMeanImage message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetworkMeanImage.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.meanImage != null && message.hasOwnProperty("meanImage")) {
                        if (!Array.isArray(message.meanImage))
                            return "meanImage: array expected";
                        for (var i = 0; i < message.meanImage.length; ++i)
                            if (typeof message.meanImage[i] !== "number")
                                return "meanImage: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a NeuralNetworkMeanImage message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetworkMeanImage} NeuralNetworkMeanImage
                 */
                NeuralNetworkMeanImage.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkMeanImage)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkMeanImage();
                    if (object.meanImage) {
                        if (!Array.isArray(object.meanImage))
                            throw TypeError(".CoreML.Specification.NeuralNetworkMeanImage.meanImage: array expected");
                        message.meanImage = [];
                        for (var i = 0; i < object.meanImage.length; ++i)
                            message.meanImage[i] = Number(object.meanImage[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetworkMeanImage message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @static
                 * @param {CoreML.Specification.NeuralNetworkMeanImage} message NeuralNetworkMeanImage
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetworkMeanImage.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.meanImage = [];
                    if (message.meanImage && message.meanImage.length) {
                        object.meanImage = [];
                        for (var j = 0; j < message.meanImage.length; ++j)
                            object.meanImage[j] = options.json && !isFinite(message.meanImage[j]) ? String(message.meanImage[j]) : message.meanImage[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this NeuralNetworkMeanImage to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetworkMeanImage
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetworkMeanImage.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkMeanImage;
            })();
    
            Specification.NeuralNetworkPreprocessing = (function() {
    
                /**
                 * Properties of a NeuralNetworkPreprocessing.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetworkPreprocessing
                 * @property {string|null} [featureName] must be equal to the input name to which the preprocessing is applied
                 * @property {CoreML.Specification.INeuralNetworkImageScaler|null} [scaler] NeuralNetworkPreprocessing scaler
                 * @property {CoreML.Specification.INeuralNetworkMeanImage|null} [meanImage] NeuralNetworkPreprocessing meanImage
                 */
    
                /**
                 * Constructs a new NeuralNetworkPreprocessing.
                 * @memberof CoreML.Specification
                 * @classdesc Preprocessing parameters for image inputs.
                 * @implements INeuralNetworkPreprocessing
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetworkPreprocessing=} [properties] Properties to set
                 */
                function NeuralNetworkPreprocessing(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * must be equal to the input name to which the preprocessing is applied
                 * @member {string} featureName
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @instance
                 */
                NeuralNetworkPreprocessing.prototype.featureName = "";
    
                /**
                 * NeuralNetworkPreprocessing scaler.
                 * @member {CoreML.Specification.INeuralNetworkImageScaler|null|undefined} scaler
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @instance
                 */
                NeuralNetworkPreprocessing.prototype.scaler = null;
    
                /**
                 * NeuralNetworkPreprocessing meanImage.
                 * @member {CoreML.Specification.INeuralNetworkMeanImage|null|undefined} meanImage
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @instance
                 */
                NeuralNetworkPreprocessing.prototype.meanImage = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * NeuralNetworkPreprocessing preprocessor.
                 * @member {"scaler"|"meanImage"|undefined} preprocessor
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @instance
                 */
                Object.defineProperty(NeuralNetworkPreprocessing.prototype, "preprocessor", {
                    get: $util.oneOfGetter($oneOfFields = ["scaler", "meanImage"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NeuralNetworkPreprocessing instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkPreprocessing=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetworkPreprocessing} NeuralNetworkPreprocessing instance
                 */
                NeuralNetworkPreprocessing.create = function create(properties) {
                    return new NeuralNetworkPreprocessing(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetworkPreprocessing message. Does not implicitly {@link CoreML.Specification.NeuralNetworkPreprocessing.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkPreprocessing} message NeuralNetworkPreprocessing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkPreprocessing.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.featureName != null && message.hasOwnProperty("featureName"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.featureName);
                    if (message.scaler != null && message.hasOwnProperty("scaler"))
                        $root.CoreML.Specification.NeuralNetworkImageScaler.encode(message.scaler, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.meanImage != null && message.hasOwnProperty("meanImage"))
                        $root.CoreML.Specification.NeuralNetworkMeanImage.encode(message.meanImage, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetworkPreprocessing message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetworkPreprocessing.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkPreprocessing} message NeuralNetworkPreprocessing message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkPreprocessing.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetworkPreprocessing message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetworkPreprocessing} NeuralNetworkPreprocessing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkPreprocessing.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkPreprocessing();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.featureName = reader.string();
                            break;
                        case 10:
                            message.scaler = $root.CoreML.Specification.NeuralNetworkImageScaler.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.meanImage = $root.CoreML.Specification.NeuralNetworkMeanImage.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetworkPreprocessing message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetworkPreprocessing} NeuralNetworkPreprocessing
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkPreprocessing.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetworkPreprocessing message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetworkPreprocessing.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.featureName != null && message.hasOwnProperty("featureName"))
                        if (!$util.isString(message.featureName))
                            return "featureName: string expected";
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        properties.preprocessor = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkImageScaler.verify(message.scaler);
                            if (error)
                                return "scaler." + error;
                        }
                    }
                    if (message.meanImage != null && message.hasOwnProperty("meanImage")) {
                        if (properties.preprocessor === 1)
                            return "preprocessor: multiple values";
                        properties.preprocessor = 1;
                        {
                            var error = $root.CoreML.Specification.NeuralNetworkMeanImage.verify(message.meanImage);
                            if (error)
                                return "meanImage." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NeuralNetworkPreprocessing message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetworkPreprocessing} NeuralNetworkPreprocessing
                 */
                NeuralNetworkPreprocessing.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkPreprocessing)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkPreprocessing();
                    if (object.featureName != null)
                        message.featureName = String(object.featureName);
                    if (object.scaler != null) {
                        if (typeof object.scaler !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkPreprocessing.scaler: object expected");
                        message.scaler = $root.CoreML.Specification.NeuralNetworkImageScaler.fromObject(object.scaler);
                    }
                    if (object.meanImage != null) {
                        if (typeof object.meanImage !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkPreprocessing.meanImage: object expected");
                        message.meanImage = $root.CoreML.Specification.NeuralNetworkMeanImage.fromObject(object.meanImage);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetworkPreprocessing message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @static
                 * @param {CoreML.Specification.NeuralNetworkPreprocessing} message NeuralNetworkPreprocessing
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetworkPreprocessing.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.featureName = "";
                    if (message.featureName != null && message.hasOwnProperty("featureName"))
                        object.featureName = message.featureName;
                    if (message.scaler != null && message.hasOwnProperty("scaler")) {
                        object.scaler = $root.CoreML.Specification.NeuralNetworkImageScaler.toObject(message.scaler, options);
                        if (options.oneofs)
                            object.preprocessor = "scaler";
                    }
                    if (message.meanImage != null && message.hasOwnProperty("meanImage")) {
                        object.meanImage = $root.CoreML.Specification.NeuralNetworkMeanImage.toObject(message.meanImage, options);
                        if (options.oneofs)
                            object.preprocessor = "meanImage";
                    }
                    return object;
                };
    
                /**
                 * Converts this NeuralNetworkPreprocessing to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetworkPreprocessing
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetworkPreprocessing.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkPreprocessing;
            })();
    
            Specification.ActivationReLU = (function() {
    
                /**
                 * Properties of an ActivationReLU.
                 * @memberof CoreML.Specification
                 * @interface IActivationReLU
                 */
    
                /**
                 * Constructs a new ActivationReLU.
                 * @memberof CoreML.Specification
                 * @classdesc A rectified linear unit (ReLU) activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \text{max}(0, x)
                 * @implements IActivationReLU
                 * @constructor
                 * @param {CoreML.Specification.IActivationReLU=} [properties] Properties to set
                 */
                function ActivationReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ActivationReLU instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {CoreML.Specification.IActivationReLU=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationReLU} ActivationReLU instance
                 */
                ActivationReLU.create = function create(properties) {
                    return new ActivationReLU(properties);
                };
    
                /**
                 * Encodes the specified ActivationReLU message. Does not implicitly {@link CoreML.Specification.ActivationReLU.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {CoreML.Specification.IActivationReLU} message ActivationReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationReLU.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationReLU message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationReLU.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {CoreML.Specification.IActivationReLU} message ActivationReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationReLU.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationReLU message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationReLU} ActivationReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationReLU message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationReLU} ActivationReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationReLU.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationReLU message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationReLU message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationReLU} ActivationReLU
                 */
                ActivationReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationReLU)
                        return object;
                    return new $root.CoreML.Specification.ActivationReLU();
                };
    
                /**
                 * Creates a plain object from an ActivationReLU message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationReLU
                 * @static
                 * @param {CoreML.Specification.ActivationReLU} message ActivationReLU
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationReLU.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this ActivationReLU to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationReLU
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationReLU;
            })();
    
            Specification.ActivationLeakyReLU = (function() {
    
                /**
                 * Properties of an ActivationLeakyReLU.
                 * @memberof CoreML.Specification
                 * @interface IActivationLeakyReLU
                 * @property {number|null} [alpha] ActivationLeakyReLU alpha
                 */
    
                /**
                 * Constructs a new ActivationLeakyReLU.
                 * @memberof CoreML.Specification
                 * @classdesc A leaky rectified linear unit (ReLU) activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \begin{cases}
                 * x      & \text{if } x \geq 0 \\
                 * \alpha x & \text{if } x < 0
                 * \end{cases}
                 * @implements IActivationLeakyReLU
                 * @constructor
                 * @param {CoreML.Specification.IActivationLeakyReLU=} [properties] Properties to set
                 */
                function ActivationLeakyReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationLeakyReLU alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @instance
                 */
                ActivationLeakyReLU.prototype.alpha = 0;
    
                /**
                 * Creates a new ActivationLeakyReLU instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {CoreML.Specification.IActivationLeakyReLU=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationLeakyReLU} ActivationLeakyReLU instance
                 */
                ActivationLeakyReLU.create = function create(properties) {
                    return new ActivationLeakyReLU(properties);
                };
    
                /**
                 * Encodes the specified ActivationLeakyReLU message. Does not implicitly {@link CoreML.Specification.ActivationLeakyReLU.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {CoreML.Specification.IActivationLeakyReLU} message ActivationLeakyReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationLeakyReLU.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationLeakyReLU message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationLeakyReLU.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {CoreML.Specification.IActivationLeakyReLU} message ActivationLeakyReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationLeakyReLU.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationLeakyReLU message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationLeakyReLU} ActivationLeakyReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationLeakyReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationLeakyReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationLeakyReLU message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationLeakyReLU} ActivationLeakyReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationLeakyReLU.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationLeakyReLU message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationLeakyReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationLeakyReLU message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationLeakyReLU} ActivationLeakyReLU
                 */
                ActivationLeakyReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationLeakyReLU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationLeakyReLU();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationLeakyReLU message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @static
                 * @param {CoreML.Specification.ActivationLeakyReLU} message ActivationLeakyReLU
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationLeakyReLU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                /**
                 * Converts this ActivationLeakyReLU to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationLeakyReLU
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationLeakyReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationLeakyReLU;
            })();
    
            Specification.ActivationTanh = (function() {
    
                /**
                 * Properties of an ActivationTanh.
                 * @memberof CoreML.Specification
                 * @interface IActivationTanh
                 */
    
                /**
                 * Constructs a new ActivationTanh.
                 * @memberof CoreML.Specification
                 * @classdesc A hyperbolic tangent activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \dfrac{1 - e^{-2x}}{1 + e^{-2x}}
                 * @implements IActivationTanh
                 * @constructor
                 * @param {CoreML.Specification.IActivationTanh=} [properties] Properties to set
                 */
                function ActivationTanh(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ActivationTanh instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {CoreML.Specification.IActivationTanh=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationTanh} ActivationTanh instance
                 */
                ActivationTanh.create = function create(properties) {
                    return new ActivationTanh(properties);
                };
    
                /**
                 * Encodes the specified ActivationTanh message. Does not implicitly {@link CoreML.Specification.ActivationTanh.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {CoreML.Specification.IActivationTanh} message ActivationTanh message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationTanh.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationTanh message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationTanh.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {CoreML.Specification.IActivationTanh} message ActivationTanh message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationTanh.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationTanh message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationTanh} ActivationTanh
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationTanh.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationTanh();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationTanh message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationTanh} ActivationTanh
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationTanh.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationTanh message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationTanh.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationTanh message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationTanh} ActivationTanh
                 */
                ActivationTanh.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationTanh)
                        return object;
                    return new $root.CoreML.Specification.ActivationTanh();
                };
    
                /**
                 * Creates a plain object from an ActivationTanh message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationTanh
                 * @static
                 * @param {CoreML.Specification.ActivationTanh} message ActivationTanh
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationTanh.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this ActivationTanh to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationTanh
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationTanh.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationTanh;
            })();
    
            Specification.ActivationScaledTanh = (function() {
    
                /**
                 * Properties of an ActivationScaledTanh.
                 * @memberof CoreML.Specification
                 * @interface IActivationScaledTanh
                 * @property {number|null} [alpha] ActivationScaledTanh alpha
                 * @property {number|null} [beta] ActivationScaledTanh beta
                 */
    
                /**
                 * Constructs a new ActivationScaledTanh.
                 * @memberof CoreML.Specification
                 * @classdesc A scaled hyperbolic tangent activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \alpha \tanh(\beta x)
                 * @implements IActivationScaledTanh
                 * @constructor
                 * @param {CoreML.Specification.IActivationScaledTanh=} [properties] Properties to set
                 */
                function ActivationScaledTanh(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationScaledTanh alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @instance
                 */
                ActivationScaledTanh.prototype.alpha = 0;
    
                /**
                 * ActivationScaledTanh beta.
                 * @member {number} beta
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @instance
                 */
                ActivationScaledTanh.prototype.beta = 0;
    
                /**
                 * Creates a new ActivationScaledTanh instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {CoreML.Specification.IActivationScaledTanh=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationScaledTanh} ActivationScaledTanh instance
                 */
                ActivationScaledTanh.create = function create(properties) {
                    return new ActivationScaledTanh(properties);
                };
    
                /**
                 * Encodes the specified ActivationScaledTanh message. Does not implicitly {@link CoreML.Specification.ActivationScaledTanh.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {CoreML.Specification.IActivationScaledTanh} message ActivationScaledTanh message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationScaledTanh.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.beta);
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationScaledTanh message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationScaledTanh.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {CoreML.Specification.IActivationScaledTanh} message ActivationScaledTanh message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationScaledTanh.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationScaledTanh message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationScaledTanh} ActivationScaledTanh
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationScaledTanh.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationScaledTanh();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationScaledTanh message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationScaledTanh} ActivationScaledTanh
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationScaledTanh.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationScaledTanh message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationScaledTanh.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationScaledTanh message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationScaledTanh} ActivationScaledTanh
                 */
                ActivationScaledTanh.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationScaledTanh)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationScaledTanh();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationScaledTanh message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @static
                 * @param {CoreML.Specification.ActivationScaledTanh} message ActivationScaledTanh
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationScaledTanh.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    return object;
                };
    
                /**
                 * Converts this ActivationScaledTanh to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationScaledTanh
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationScaledTanh.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationScaledTanh;
            })();
    
            Specification.ActivationSigmoid = (function() {
    
                /**
                 * Properties of an ActivationSigmoid.
                 * @memberof CoreML.Specification
                 * @interface IActivationSigmoid
                 */
    
                /**
                 * Constructs a new ActivationSigmoid.
                 * @memberof CoreML.Specification
                 * @classdesc A sigmoid activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \dfrac{1}{1 + e^{-x}}
                 * @implements IActivationSigmoid
                 * @constructor
                 * @param {CoreML.Specification.IActivationSigmoid=} [properties] Properties to set
                 */
                function ActivationSigmoid(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ActivationSigmoid instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {CoreML.Specification.IActivationSigmoid=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationSigmoid} ActivationSigmoid instance
                 */
                ActivationSigmoid.create = function create(properties) {
                    return new ActivationSigmoid(properties);
                };
    
                /**
                 * Encodes the specified ActivationSigmoid message. Does not implicitly {@link CoreML.Specification.ActivationSigmoid.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {CoreML.Specification.IActivationSigmoid} message ActivationSigmoid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSigmoid.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationSigmoid message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationSigmoid.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {CoreML.Specification.IActivationSigmoid} message ActivationSigmoid message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSigmoid.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationSigmoid message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationSigmoid} ActivationSigmoid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSigmoid.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSigmoid();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationSigmoid message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationSigmoid} ActivationSigmoid
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSigmoid.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationSigmoid message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationSigmoid.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationSigmoid message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationSigmoid} ActivationSigmoid
                 */
                ActivationSigmoid.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSigmoid)
                        return object;
                    return new $root.CoreML.Specification.ActivationSigmoid();
                };
    
                /**
                 * Creates a plain object from an ActivationSigmoid message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @static
                 * @param {CoreML.Specification.ActivationSigmoid} message ActivationSigmoid
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationSigmoid.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this ActivationSigmoid to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationSigmoid
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationSigmoid.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSigmoid;
            })();
    
            Specification.ActivationLinear = (function() {
    
                /**
                 * Properties of an ActivationLinear.
                 * @memberof CoreML.Specification
                 * @interface IActivationLinear
                 * @property {number|null} [alpha] ActivationLinear alpha
                 * @property {number|null} [beta] ActivationLinear beta
                 */
    
                /**
                 * Constructs a new ActivationLinear.
                 * @memberof CoreML.Specification
                 * @classdesc A linear activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \alpha x + \beta
                 * @implements IActivationLinear
                 * @constructor
                 * @param {CoreML.Specification.IActivationLinear=} [properties] Properties to set
                 */
                function ActivationLinear(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationLinear alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.ActivationLinear
                 * @instance
                 */
                ActivationLinear.prototype.alpha = 0;
    
                /**
                 * ActivationLinear beta.
                 * @member {number} beta
                 * @memberof CoreML.Specification.ActivationLinear
                 * @instance
                 */
                ActivationLinear.prototype.beta = 0;
    
                /**
                 * Creates a new ActivationLinear instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {CoreML.Specification.IActivationLinear=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationLinear} ActivationLinear instance
                 */
                ActivationLinear.create = function create(properties) {
                    return new ActivationLinear(properties);
                };
    
                /**
                 * Encodes the specified ActivationLinear message. Does not implicitly {@link CoreML.Specification.ActivationLinear.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {CoreML.Specification.IActivationLinear} message ActivationLinear message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationLinear.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.beta);
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationLinear message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationLinear.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {CoreML.Specification.IActivationLinear} message ActivationLinear message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationLinear.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationLinear message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationLinear} ActivationLinear
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationLinear.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationLinear();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationLinear message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationLinear} ActivationLinear
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationLinear.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationLinear message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationLinear.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationLinear message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationLinear} ActivationLinear
                 */
                ActivationLinear.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationLinear)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationLinear();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationLinear message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationLinear
                 * @static
                 * @param {CoreML.Specification.ActivationLinear} message ActivationLinear
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationLinear.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    return object;
                };
    
                /**
                 * Converts this ActivationLinear to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationLinear
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationLinear.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationLinear;
            })();
    
            Specification.ActivationSigmoidHard = (function() {
    
                /**
                 * Properties of an ActivationSigmoidHard.
                 * @memberof CoreML.Specification
                 * @interface IActivationSigmoidHard
                 * @property {number|null} [alpha] ActivationSigmoidHard alpha
                 * @property {number|null} [beta] ActivationSigmoidHard beta
                 */
    
                /**
                 * Constructs a new ActivationSigmoidHard.
                 * @memberof CoreML.Specification
                 * @classdesc A hard sigmoid activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \text{min}(\text{max}(\alpha x + \beta, 0), 1)
                 * @implements IActivationSigmoidHard
                 * @constructor
                 * @param {CoreML.Specification.IActivationSigmoidHard=} [properties] Properties to set
                 */
                function ActivationSigmoidHard(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationSigmoidHard alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @instance
                 */
                ActivationSigmoidHard.prototype.alpha = 0;
    
                /**
                 * ActivationSigmoidHard beta.
                 * @member {number} beta
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @instance
                 */
                ActivationSigmoidHard.prototype.beta = 0;
    
                /**
                 * Creates a new ActivationSigmoidHard instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {CoreML.Specification.IActivationSigmoidHard=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationSigmoidHard} ActivationSigmoidHard instance
                 */
                ActivationSigmoidHard.create = function create(properties) {
                    return new ActivationSigmoidHard(properties);
                };
    
                /**
                 * Encodes the specified ActivationSigmoidHard message. Does not implicitly {@link CoreML.Specification.ActivationSigmoidHard.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {CoreML.Specification.IActivationSigmoidHard} message ActivationSigmoidHard message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSigmoidHard.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.beta);
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationSigmoidHard message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationSigmoidHard.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {CoreML.Specification.IActivationSigmoidHard} message ActivationSigmoidHard message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSigmoidHard.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationSigmoidHard message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationSigmoidHard} ActivationSigmoidHard
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSigmoidHard.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSigmoidHard();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationSigmoidHard message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationSigmoidHard} ActivationSigmoidHard
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSigmoidHard.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationSigmoidHard message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationSigmoidHard.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationSigmoidHard message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationSigmoidHard} ActivationSigmoidHard
                 */
                ActivationSigmoidHard.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSigmoidHard)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationSigmoidHard();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationSigmoidHard message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @static
                 * @param {CoreML.Specification.ActivationSigmoidHard} message ActivationSigmoidHard
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationSigmoidHard.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    return object;
                };
    
                /**
                 * Converts this ActivationSigmoidHard to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationSigmoidHard
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationSigmoidHard.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSigmoidHard;
            })();
    
            Specification.ActivationPReLU = (function() {
    
                /**
                 * Properties of an ActivationPReLU.
                 * @memberof CoreML.Specification
                 * @interface IActivationPReLU
                 * @property {CoreML.Specification.IWeightParams|null} [alpha] ActivationPReLU alpha
                 */
    
                /**
                 * Constructs a new ActivationPReLU.
                 * @memberof CoreML.Specification
                 * @classdesc A parameterized rectified linear unit (PReLU) activation function,
                 * which takes ``[C]`` or ``[C,H,W]`` as an input and
                 * applies different parameters in each channel dimension
                 * (shared across the ``H`` and ``W`` components).
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x_i) = \begin{cases}
                 * x_i          & \text{if } x_i \geq 0 \\
                 * \alpha_i x_i & \text{if } x_i < 0
                 * \end{cases} \;,\;i=1,...,C
                 * @implements IActivationPReLU
                 * @constructor
                 * @param {CoreML.Specification.IActivationPReLU=} [properties] Properties to set
                 */
                function ActivationPReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationPReLU alpha.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} alpha
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @instance
                 */
                ActivationPReLU.prototype.alpha = null;
    
                /**
                 * Creates a new ActivationPReLU instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {CoreML.Specification.IActivationPReLU=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationPReLU} ActivationPReLU instance
                 */
                ActivationPReLU.create = function create(properties) {
                    return new ActivationPReLU(properties);
                };
    
                /**
                 * Encodes the specified ActivationPReLU message. Does not implicitly {@link CoreML.Specification.ActivationPReLU.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {CoreML.Specification.IActivationPReLU} message ActivationPReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationPReLU.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        $root.CoreML.Specification.WeightParams.encode(message.alpha, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationPReLU message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationPReLU.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {CoreML.Specification.IActivationPReLU} message ActivationPReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationPReLU.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationPReLU message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationPReLU} ActivationPReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationPReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationPReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationPReLU message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationPReLU} ActivationPReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationPReLU.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationPReLU message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationPReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.alpha);
                        if (error)
                            return "alpha." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an ActivationPReLU message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationPReLU} ActivationPReLU
                 */
                ActivationPReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationPReLU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationPReLU();
                    if (object.alpha != null) {
                        if (typeof object.alpha !== "object")
                            throw TypeError(".CoreML.Specification.ActivationPReLU.alpha: object expected");
                        message.alpha = $root.CoreML.Specification.WeightParams.fromObject(object.alpha);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationPReLU message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @static
                 * @param {CoreML.Specification.ActivationPReLU} message ActivationPReLU
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationPReLU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = null;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = $root.CoreML.Specification.WeightParams.toObject(message.alpha, options);
                    return object;
                };
    
                /**
                 * Converts this ActivationPReLU to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationPReLU
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationPReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationPReLU;
            })();
    
            Specification.ActivationELU = (function() {
    
                /**
                 * Properties of an ActivationELU.
                 * @memberof CoreML.Specification
                 * @interface IActivationELU
                 * @property {number|null} [alpha] ActivationELU alpha
                 */
    
                /**
                 * Constructs a new ActivationELU.
                 * @memberof CoreML.Specification
                 * @classdesc An exponential linear unit (ELU) activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \begin{cases}
                 * x              & \text{if } x \geq 0 \\
                 * \alpha (e^x - 1) & \text{if } x < 0
                 * \end{cases}
                 * @implements IActivationELU
                 * @constructor
                 * @param {CoreML.Specification.IActivationELU=} [properties] Properties to set
                 */
                function ActivationELU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationELU alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.ActivationELU
                 * @instance
                 */
                ActivationELU.prototype.alpha = 0;
    
                /**
                 * Creates a new ActivationELU instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {CoreML.Specification.IActivationELU=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationELU} ActivationELU instance
                 */
                ActivationELU.create = function create(properties) {
                    return new ActivationELU(properties);
                };
    
                /**
                 * Encodes the specified ActivationELU message. Does not implicitly {@link CoreML.Specification.ActivationELU.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {CoreML.Specification.IActivationELU} message ActivationELU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationELU.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationELU message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationELU.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {CoreML.Specification.IActivationELU} message ActivationELU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationELU.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationELU message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationELU} ActivationELU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationELU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationELU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationELU message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationELU} ActivationELU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationELU.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationELU message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationELU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationELU message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationELU} ActivationELU
                 */
                ActivationELU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationELU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationELU();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationELU message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationELU
                 * @static
                 * @param {CoreML.Specification.ActivationELU} message ActivationELU
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationELU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                /**
                 * Converts this ActivationELU to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationELU
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationELU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationELU;
            })();
    
            Specification.ActivationThresholdedReLU = (function() {
    
                /**
                 * Properties of an ActivationThresholdedReLU.
                 * @memberof CoreML.Specification
                 * @interface IActivationThresholdedReLU
                 * @property {number|null} [alpha] ActivationThresholdedReLU alpha
                 */
    
                /**
                 * Constructs a new ActivationThresholdedReLU.
                 * @memberof CoreML.Specification
                 * @classdesc A thresholded rectified linear unit (ReLU) activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \begin{cases}
                 * x & \text{if } x \geq \alpha \\
                 * 0 & \text{if } x < \alpha
                 * \end{cases}
                 * @implements IActivationThresholdedReLU
                 * @constructor
                 * @param {CoreML.Specification.IActivationThresholdedReLU=} [properties] Properties to set
                 */
                function ActivationThresholdedReLU(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationThresholdedReLU alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @instance
                 */
                ActivationThresholdedReLU.prototype.alpha = 0;
    
                /**
                 * Creates a new ActivationThresholdedReLU instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {CoreML.Specification.IActivationThresholdedReLU=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationThresholdedReLU} ActivationThresholdedReLU instance
                 */
                ActivationThresholdedReLU.create = function create(properties) {
                    return new ActivationThresholdedReLU(properties);
                };
    
                /**
                 * Encodes the specified ActivationThresholdedReLU message. Does not implicitly {@link CoreML.Specification.ActivationThresholdedReLU.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {CoreML.Specification.IActivationThresholdedReLU} message ActivationThresholdedReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationThresholdedReLU.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationThresholdedReLU message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationThresholdedReLU.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {CoreML.Specification.IActivationThresholdedReLU} message ActivationThresholdedReLU message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationThresholdedReLU.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationThresholdedReLU message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationThresholdedReLU} ActivationThresholdedReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationThresholdedReLU.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationThresholdedReLU();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationThresholdedReLU message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationThresholdedReLU} ActivationThresholdedReLU
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationThresholdedReLU.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationThresholdedReLU message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationThresholdedReLU.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationThresholdedReLU message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationThresholdedReLU} ActivationThresholdedReLU
                 */
                ActivationThresholdedReLU.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationThresholdedReLU)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationThresholdedReLU();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationThresholdedReLU message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @static
                 * @param {CoreML.Specification.ActivationThresholdedReLU} message ActivationThresholdedReLU
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationThresholdedReLU.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                /**
                 * Converts this ActivationThresholdedReLU to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationThresholdedReLU
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationThresholdedReLU.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationThresholdedReLU;
            })();
    
            Specification.ActivationSoftsign = (function() {
    
                /**
                 * Properties of an ActivationSoftsign.
                 * @memberof CoreML.Specification
                 * @interface IActivationSoftsign
                 */
    
                /**
                 * Constructs a new ActivationSoftsign.
                 * @memberof CoreML.Specification
                 * @classdesc A softsign activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \dfrac{x}{1 + |x|}
                 * @implements IActivationSoftsign
                 * @constructor
                 * @param {CoreML.Specification.IActivationSoftsign=} [properties] Properties to set
                 */
                function ActivationSoftsign(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ActivationSoftsign instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {CoreML.Specification.IActivationSoftsign=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationSoftsign} ActivationSoftsign instance
                 */
                ActivationSoftsign.create = function create(properties) {
                    return new ActivationSoftsign(properties);
                };
    
                /**
                 * Encodes the specified ActivationSoftsign message. Does not implicitly {@link CoreML.Specification.ActivationSoftsign.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {CoreML.Specification.IActivationSoftsign} message ActivationSoftsign message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSoftsign.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationSoftsign message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationSoftsign.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {CoreML.Specification.IActivationSoftsign} message ActivationSoftsign message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSoftsign.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationSoftsign message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationSoftsign} ActivationSoftsign
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSoftsign.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSoftsign();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationSoftsign message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationSoftsign} ActivationSoftsign
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSoftsign.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationSoftsign message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationSoftsign.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationSoftsign message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationSoftsign} ActivationSoftsign
                 */
                ActivationSoftsign.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSoftsign)
                        return object;
                    return new $root.CoreML.Specification.ActivationSoftsign();
                };
    
                /**
                 * Creates a plain object from an ActivationSoftsign message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @static
                 * @param {CoreML.Specification.ActivationSoftsign} message ActivationSoftsign
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationSoftsign.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this ActivationSoftsign to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationSoftsign
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationSoftsign.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSoftsign;
            })();
    
            Specification.ActivationSoftplus = (function() {
    
                /**
                 * Properties of an ActivationSoftplus.
                 * @memberof CoreML.Specification
                 * @interface IActivationSoftplus
                 */
    
                /**
                 * Constructs a new ActivationSoftplus.
                 * @memberof CoreML.Specification
                 * @classdesc A softplus activation function.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = \text{log}(1 + e^x)
                 * @implements IActivationSoftplus
                 * @constructor
                 * @param {CoreML.Specification.IActivationSoftplus=} [properties] Properties to set
                 */
                function ActivationSoftplus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new ActivationSoftplus instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {CoreML.Specification.IActivationSoftplus=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationSoftplus} ActivationSoftplus instance
                 */
                ActivationSoftplus.create = function create(properties) {
                    return new ActivationSoftplus(properties);
                };
    
                /**
                 * Encodes the specified ActivationSoftplus message. Does not implicitly {@link CoreML.Specification.ActivationSoftplus.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {CoreML.Specification.IActivationSoftplus} message ActivationSoftplus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSoftplus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationSoftplus message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationSoftplus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {CoreML.Specification.IActivationSoftplus} message ActivationSoftplus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationSoftplus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationSoftplus message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationSoftplus} ActivationSoftplus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSoftplus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationSoftplus();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationSoftplus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationSoftplus} ActivationSoftplus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationSoftplus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationSoftplus message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationSoftplus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an ActivationSoftplus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationSoftplus} ActivationSoftplus
                 */
                ActivationSoftplus.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationSoftplus)
                        return object;
                    return new $root.CoreML.Specification.ActivationSoftplus();
                };
    
                /**
                 * Creates a plain object from an ActivationSoftplus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @static
                 * @param {CoreML.Specification.ActivationSoftplus} message ActivationSoftplus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationSoftplus.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this ActivationSoftplus to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationSoftplus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationSoftplus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationSoftplus;
            })();
    
            Specification.ActivationParametricSoftplus = (function() {
    
                /**
                 * Properties of an ActivationParametricSoftplus.
                 * @memberof CoreML.Specification
                 * @interface IActivationParametricSoftplus
                 * @property {CoreML.Specification.IWeightParams|null} [alpha] ActivationParametricSoftplus alpha
                 * @property {CoreML.Specification.IWeightParams|null} [beta] ActivationParametricSoftplus beta
                 */
    
                /**
                 * Constructs a new ActivationParametricSoftplus.
                 * @memberof CoreML.Specification
                 * @classdesc A parametric softplus activation function,
                 * which takes ``[C]`` or ``[C,H,W]`` as an input and
                 * applies different parameters in each channel dimension
                 * (shared across the ``H`` and ``W`` components).
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x_i) = \alpha_i \text{log}(1 + e^{\beta_i x_i}) \;,\;i=1,...,C
                 * @implements IActivationParametricSoftplus
                 * @constructor
                 * @param {CoreML.Specification.IActivationParametricSoftplus=} [properties] Properties to set
                 */
                function ActivationParametricSoftplus(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationParametricSoftplus alpha.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} alpha
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @instance
                 */
                ActivationParametricSoftplus.prototype.alpha = null;
    
                /**
                 * ActivationParametricSoftplus beta.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} beta
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @instance
                 */
                ActivationParametricSoftplus.prototype.beta = null;
    
                /**
                 * Creates a new ActivationParametricSoftplus instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {CoreML.Specification.IActivationParametricSoftplus=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationParametricSoftplus} ActivationParametricSoftplus instance
                 */
                ActivationParametricSoftplus.create = function create(properties) {
                    return new ActivationParametricSoftplus(properties);
                };
    
                /**
                 * Encodes the specified ActivationParametricSoftplus message. Does not implicitly {@link CoreML.Specification.ActivationParametricSoftplus.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {CoreML.Specification.IActivationParametricSoftplus} message ActivationParametricSoftplus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationParametricSoftplus.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        $root.CoreML.Specification.WeightParams.encode(message.alpha, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        $root.CoreML.Specification.WeightParams.encode(message.beta, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationParametricSoftplus message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationParametricSoftplus.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {CoreML.Specification.IActivationParametricSoftplus} message ActivationParametricSoftplus message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationParametricSoftplus.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationParametricSoftplus message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationParametricSoftplus} ActivationParametricSoftplus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationParametricSoftplus.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationParametricSoftplus();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.beta = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationParametricSoftplus message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationParametricSoftplus} ActivationParametricSoftplus
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationParametricSoftplus.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationParametricSoftplus message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationParametricSoftplus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.alpha);
                        if (error)
                            return "alpha." + error;
                    }
                    if (message.beta != null && message.hasOwnProperty("beta")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.beta);
                        if (error)
                            return "beta." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an ActivationParametricSoftplus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationParametricSoftplus} ActivationParametricSoftplus
                 */
                ActivationParametricSoftplus.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationParametricSoftplus)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationParametricSoftplus();
                    if (object.alpha != null) {
                        if (typeof object.alpha !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParametricSoftplus.alpha: object expected");
                        message.alpha = $root.CoreML.Specification.WeightParams.fromObject(object.alpha);
                    }
                    if (object.beta != null) {
                        if (typeof object.beta !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParametricSoftplus.beta: object expected");
                        message.beta = $root.CoreML.Specification.WeightParams.fromObject(object.beta);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationParametricSoftplus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @static
                 * @param {CoreML.Specification.ActivationParametricSoftplus} message ActivationParametricSoftplus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationParametricSoftplus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = null;
                        object.beta = null;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = $root.CoreML.Specification.WeightParams.toObject(message.alpha, options);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = $root.CoreML.Specification.WeightParams.toObject(message.beta, options);
                    return object;
                };
    
                /**
                 * Converts this ActivationParametricSoftplus to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationParametricSoftplus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationParametricSoftplus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationParametricSoftplus;
            })();
    
            Specification.ActivationParams = (function() {
    
                /**
                 * Properties of an ActivationParams.
                 * @memberof CoreML.Specification
                 * @interface IActivationParams
                 * @property {CoreML.Specification.IActivationLinear|null} [linear] ActivationParams linear
                 * @property {CoreML.Specification.IActivationReLU|null} [ReLU] ActivationParams ReLU
                 * @property {CoreML.Specification.IActivationLeakyReLU|null} [leakyReLU] ActivationParams leakyReLU
                 * @property {CoreML.Specification.IActivationThresholdedReLU|null} [thresholdedReLU] ActivationParams thresholdedReLU
                 * @property {CoreML.Specification.IActivationPReLU|null} [PReLU] ActivationParams PReLU
                 * @property {CoreML.Specification.IActivationTanh|null} [tanh] ActivationParams tanh
                 * @property {CoreML.Specification.IActivationScaledTanh|null} [scaledTanh] ActivationParams scaledTanh
                 * @property {CoreML.Specification.IActivationSigmoid|null} [sigmoid] ActivationParams sigmoid
                 * @property {CoreML.Specification.IActivationSigmoidHard|null} [sigmoidHard] ActivationParams sigmoidHard
                 * @property {CoreML.Specification.IActivationELU|null} [ELU] ActivationParams ELU
                 * @property {CoreML.Specification.IActivationSoftsign|null} [softsign] ActivationParams softsign
                 * @property {CoreML.Specification.IActivationSoftplus|null} [softplus] ActivationParams softplus
                 * @property {CoreML.Specification.IActivationParametricSoftplus|null} [parametricSoftplus] ActivationParams parametricSoftplus
                 */
    
                /**
                 * Constructs a new ActivationParams.
                 * @memberof CoreML.Specification
                 * @classdesc Represents an ActivationParams.
                 * @implements IActivationParams
                 * @constructor
                 * @param {CoreML.Specification.IActivationParams=} [properties] Properties to set
                 */
                function ActivationParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ActivationParams linear.
                 * @member {CoreML.Specification.IActivationLinear|null|undefined} linear
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.linear = null;
    
                /**
                 * ActivationParams ReLU.
                 * @member {CoreML.Specification.IActivationReLU|null|undefined} ReLU
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.ReLU = null;
    
                /**
                 * ActivationParams leakyReLU.
                 * @member {CoreML.Specification.IActivationLeakyReLU|null|undefined} leakyReLU
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.leakyReLU = null;
    
                /**
                 * ActivationParams thresholdedReLU.
                 * @member {CoreML.Specification.IActivationThresholdedReLU|null|undefined} thresholdedReLU
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.thresholdedReLU = null;
    
                /**
                 * ActivationParams PReLU.
                 * @member {CoreML.Specification.IActivationPReLU|null|undefined} PReLU
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.PReLU = null;
    
                /**
                 * ActivationParams tanh.
                 * @member {CoreML.Specification.IActivationTanh|null|undefined} tanh
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.tanh = null;
    
                /**
                 * ActivationParams scaledTanh.
                 * @member {CoreML.Specification.IActivationScaledTanh|null|undefined} scaledTanh
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.scaledTanh = null;
    
                /**
                 * ActivationParams sigmoid.
                 * @member {CoreML.Specification.IActivationSigmoid|null|undefined} sigmoid
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.sigmoid = null;
    
                /**
                 * ActivationParams sigmoidHard.
                 * @member {CoreML.Specification.IActivationSigmoidHard|null|undefined} sigmoidHard
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.sigmoidHard = null;
    
                /**
                 * ActivationParams ELU.
                 * @member {CoreML.Specification.IActivationELU|null|undefined} ELU
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.ELU = null;
    
                /**
                 * ActivationParams softsign.
                 * @member {CoreML.Specification.IActivationSoftsign|null|undefined} softsign
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.softsign = null;
    
                /**
                 * ActivationParams softplus.
                 * @member {CoreML.Specification.IActivationSoftplus|null|undefined} softplus
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.softplus = null;
    
                /**
                 * ActivationParams parametricSoftplus.
                 * @member {CoreML.Specification.IActivationParametricSoftplus|null|undefined} parametricSoftplus
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                ActivationParams.prototype.parametricSoftplus = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * ActivationParams NonlinearityType.
                 * @member {"linear"|"ReLU"|"leakyReLU"|"thresholdedReLU"|"PReLU"|"tanh"|"scaledTanh"|"sigmoid"|"sigmoidHard"|"ELU"|"softsign"|"softplus"|"parametricSoftplus"|undefined} NonlinearityType
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 */
                Object.defineProperty(ActivationParams.prototype, "NonlinearityType", {
                    get: $util.oneOfGetter($oneOfFields = ["linear", "ReLU", "leakyReLU", "thresholdedReLU", "PReLU", "tanh", "scaledTanh", "sigmoid", "sigmoidHard", "ELU", "softsign", "softplus", "parametricSoftplus"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new ActivationParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {CoreML.Specification.IActivationParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ActivationParams} ActivationParams instance
                 */
                ActivationParams.create = function create(properties) {
                    return new ActivationParams(properties);
                };
    
                /**
                 * Encodes the specified ActivationParams message. Does not implicitly {@link CoreML.Specification.ActivationParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {CoreML.Specification.IActivationParams} message ActivationParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.linear != null && message.hasOwnProperty("linear"))
                        $root.CoreML.Specification.ActivationLinear.encode(message.linear, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.ReLU != null && message.hasOwnProperty("ReLU"))
                        $root.CoreML.Specification.ActivationReLU.encode(message.ReLU, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.leakyReLU != null && message.hasOwnProperty("leakyReLU"))
                        $root.CoreML.Specification.ActivationLeakyReLU.encode(message.leakyReLU, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.thresholdedReLU != null && message.hasOwnProperty("thresholdedReLU"))
                        $root.CoreML.Specification.ActivationThresholdedReLU.encode(message.thresholdedReLU, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.PReLU != null && message.hasOwnProperty("PReLU"))
                        $root.CoreML.Specification.ActivationPReLU.encode(message.PReLU, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
                    if (message.tanh != null && message.hasOwnProperty("tanh"))
                        $root.CoreML.Specification.ActivationTanh.encode(message.tanh, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                    if (message.scaledTanh != null && message.hasOwnProperty("scaledTanh"))
                        $root.CoreML.Specification.ActivationScaledTanh.encode(message.scaledTanh, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                    if (message.sigmoid != null && message.hasOwnProperty("sigmoid"))
                        $root.CoreML.Specification.ActivationSigmoid.encode(message.sigmoid, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                    if (message.sigmoidHard != null && message.hasOwnProperty("sigmoidHard"))
                        $root.CoreML.Specification.ActivationSigmoidHard.encode(message.sigmoidHard, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                    if (message.ELU != null && message.hasOwnProperty("ELU"))
                        $root.CoreML.Specification.ActivationELU.encode(message.ELU, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                    if (message.softsign != null && message.hasOwnProperty("softsign"))
                        $root.CoreML.Specification.ActivationSoftsign.encode(message.softsign, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
                    if (message.softplus != null && message.hasOwnProperty("softplus"))
                        $root.CoreML.Specification.ActivationSoftplus.encode(message.softplus, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
                    if (message.parametricSoftplus != null && message.hasOwnProperty("parametricSoftplus"))
                        $root.CoreML.Specification.ActivationParametricSoftplus.encode(message.parametricSoftplus, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ActivationParams message, length delimited. Does not implicitly {@link CoreML.Specification.ActivationParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {CoreML.Specification.IActivationParams} message ActivationParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ActivationParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an ActivationParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ActivationParams} ActivationParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ActivationParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 5:
                            message.linear = $root.CoreML.Specification.ActivationLinear.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.ReLU = $root.CoreML.Specification.ActivationReLU.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.leakyReLU = $root.CoreML.Specification.ActivationLeakyReLU.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.thresholdedReLU = $root.CoreML.Specification.ActivationThresholdedReLU.decode(reader, reader.uint32());
                            break;
                        case 25:
                            message.PReLU = $root.CoreML.Specification.ActivationPReLU.decode(reader, reader.uint32());
                            break;
                        case 30:
                            message.tanh = $root.CoreML.Specification.ActivationTanh.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.scaledTanh = $root.CoreML.Specification.ActivationScaledTanh.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.sigmoid = $root.CoreML.Specification.ActivationSigmoid.decode(reader, reader.uint32());
                            break;
                        case 41:
                            message.sigmoidHard = $root.CoreML.Specification.ActivationSigmoidHard.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.ELU = $root.CoreML.Specification.ActivationELU.decode(reader, reader.uint32());
                            break;
                        case 60:
                            message.softsign = $root.CoreML.Specification.ActivationSoftsign.decode(reader, reader.uint32());
                            break;
                        case 70:
                            message.softplus = $root.CoreML.Specification.ActivationSoftplus.decode(reader, reader.uint32());
                            break;
                        case 71:
                            message.parametricSoftplus = $root.CoreML.Specification.ActivationParametricSoftplus.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an ActivationParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ActivationParams} ActivationParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ActivationParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an ActivationParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ActivationParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.linear != null && message.hasOwnProperty("linear")) {
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationLinear.verify(message.linear);
                            if (error)
                                return "linear." + error;
                        }
                    }
                    if (message.ReLU != null && message.hasOwnProperty("ReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationReLU.verify(message.ReLU);
                            if (error)
                                return "ReLU." + error;
                        }
                    }
                    if (message.leakyReLU != null && message.hasOwnProperty("leakyReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationLeakyReLU.verify(message.leakyReLU);
                            if (error)
                                return "leakyReLU." + error;
                        }
                    }
                    if (message.thresholdedReLU != null && message.hasOwnProperty("thresholdedReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationThresholdedReLU.verify(message.thresholdedReLU);
                            if (error)
                                return "thresholdedReLU." + error;
                        }
                    }
                    if (message.PReLU != null && message.hasOwnProperty("PReLU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationPReLU.verify(message.PReLU);
                            if (error)
                                return "PReLU." + error;
                        }
                    }
                    if (message.tanh != null && message.hasOwnProperty("tanh")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationTanh.verify(message.tanh);
                            if (error)
                                return "tanh." + error;
                        }
                    }
                    if (message.scaledTanh != null && message.hasOwnProperty("scaledTanh")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationScaledTanh.verify(message.scaledTanh);
                            if (error)
                                return "scaledTanh." + error;
                        }
                    }
                    if (message.sigmoid != null && message.hasOwnProperty("sigmoid")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSigmoid.verify(message.sigmoid);
                            if (error)
                                return "sigmoid." + error;
                        }
                    }
                    if (message.sigmoidHard != null && message.hasOwnProperty("sigmoidHard")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSigmoidHard.verify(message.sigmoidHard);
                            if (error)
                                return "sigmoidHard." + error;
                        }
                    }
                    if (message.ELU != null && message.hasOwnProperty("ELU")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationELU.verify(message.ELU);
                            if (error)
                                return "ELU." + error;
                        }
                    }
                    if (message.softsign != null && message.hasOwnProperty("softsign")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSoftsign.verify(message.softsign);
                            if (error)
                                return "softsign." + error;
                        }
                    }
                    if (message.softplus != null && message.hasOwnProperty("softplus")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationSoftplus.verify(message.softplus);
                            if (error)
                                return "softplus." + error;
                        }
                    }
                    if (message.parametricSoftplus != null && message.hasOwnProperty("parametricSoftplus")) {
                        if (properties.NonlinearityType === 1)
                            return "NonlinearityType: multiple values";
                        properties.NonlinearityType = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationParametricSoftplus.verify(message.parametricSoftplus);
                            if (error)
                                return "parametricSoftplus." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates an ActivationParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ActivationParams} ActivationParams
                 */
                ActivationParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ActivationParams)
                        return object;
                    var message = new $root.CoreML.Specification.ActivationParams();
                    if (object.linear != null) {
                        if (typeof object.linear !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.linear: object expected");
                        message.linear = $root.CoreML.Specification.ActivationLinear.fromObject(object.linear);
                    }
                    if (object.ReLU != null) {
                        if (typeof object.ReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.ReLU: object expected");
                        message.ReLU = $root.CoreML.Specification.ActivationReLU.fromObject(object.ReLU);
                    }
                    if (object.leakyReLU != null) {
                        if (typeof object.leakyReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.leakyReLU: object expected");
                        message.leakyReLU = $root.CoreML.Specification.ActivationLeakyReLU.fromObject(object.leakyReLU);
                    }
                    if (object.thresholdedReLU != null) {
                        if (typeof object.thresholdedReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.thresholdedReLU: object expected");
                        message.thresholdedReLU = $root.CoreML.Specification.ActivationThresholdedReLU.fromObject(object.thresholdedReLU);
                    }
                    if (object.PReLU != null) {
                        if (typeof object.PReLU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.PReLU: object expected");
                        message.PReLU = $root.CoreML.Specification.ActivationPReLU.fromObject(object.PReLU);
                    }
                    if (object.tanh != null) {
                        if (typeof object.tanh !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.tanh: object expected");
                        message.tanh = $root.CoreML.Specification.ActivationTanh.fromObject(object.tanh);
                    }
                    if (object.scaledTanh != null) {
                        if (typeof object.scaledTanh !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.scaledTanh: object expected");
                        message.scaledTanh = $root.CoreML.Specification.ActivationScaledTanh.fromObject(object.scaledTanh);
                    }
                    if (object.sigmoid != null) {
                        if (typeof object.sigmoid !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.sigmoid: object expected");
                        message.sigmoid = $root.CoreML.Specification.ActivationSigmoid.fromObject(object.sigmoid);
                    }
                    if (object.sigmoidHard != null) {
                        if (typeof object.sigmoidHard !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.sigmoidHard: object expected");
                        message.sigmoidHard = $root.CoreML.Specification.ActivationSigmoidHard.fromObject(object.sigmoidHard);
                    }
                    if (object.ELU != null) {
                        if (typeof object.ELU !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.ELU: object expected");
                        message.ELU = $root.CoreML.Specification.ActivationELU.fromObject(object.ELU);
                    }
                    if (object.softsign != null) {
                        if (typeof object.softsign !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.softsign: object expected");
                        message.softsign = $root.CoreML.Specification.ActivationSoftsign.fromObject(object.softsign);
                    }
                    if (object.softplus != null) {
                        if (typeof object.softplus !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.softplus: object expected");
                        message.softplus = $root.CoreML.Specification.ActivationSoftplus.fromObject(object.softplus);
                    }
                    if (object.parametricSoftplus != null) {
                        if (typeof object.parametricSoftplus !== "object")
                            throw TypeError(".CoreML.Specification.ActivationParams.parametricSoftplus: object expected");
                        message.parametricSoftplus = $root.CoreML.Specification.ActivationParametricSoftplus.fromObject(object.parametricSoftplus);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an ActivationParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ActivationParams
                 * @static
                 * @param {CoreML.Specification.ActivationParams} message ActivationParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ActivationParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.linear != null && message.hasOwnProperty("linear")) {
                        object.linear = $root.CoreML.Specification.ActivationLinear.toObject(message.linear, options);
                        if (options.oneofs)
                            object.NonlinearityType = "linear";
                    }
                    if (message.ReLU != null && message.hasOwnProperty("ReLU")) {
                        object.ReLU = $root.CoreML.Specification.ActivationReLU.toObject(message.ReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "ReLU";
                    }
                    if (message.leakyReLU != null && message.hasOwnProperty("leakyReLU")) {
                        object.leakyReLU = $root.CoreML.Specification.ActivationLeakyReLU.toObject(message.leakyReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "leakyReLU";
                    }
                    if (message.thresholdedReLU != null && message.hasOwnProperty("thresholdedReLU")) {
                        object.thresholdedReLU = $root.CoreML.Specification.ActivationThresholdedReLU.toObject(message.thresholdedReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "thresholdedReLU";
                    }
                    if (message.PReLU != null && message.hasOwnProperty("PReLU")) {
                        object.PReLU = $root.CoreML.Specification.ActivationPReLU.toObject(message.PReLU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "PReLU";
                    }
                    if (message.tanh != null && message.hasOwnProperty("tanh")) {
                        object.tanh = $root.CoreML.Specification.ActivationTanh.toObject(message.tanh, options);
                        if (options.oneofs)
                            object.NonlinearityType = "tanh";
                    }
                    if (message.scaledTanh != null && message.hasOwnProperty("scaledTanh")) {
                        object.scaledTanh = $root.CoreML.Specification.ActivationScaledTanh.toObject(message.scaledTanh, options);
                        if (options.oneofs)
                            object.NonlinearityType = "scaledTanh";
                    }
                    if (message.sigmoid != null && message.hasOwnProperty("sigmoid")) {
                        object.sigmoid = $root.CoreML.Specification.ActivationSigmoid.toObject(message.sigmoid, options);
                        if (options.oneofs)
                            object.NonlinearityType = "sigmoid";
                    }
                    if (message.sigmoidHard != null && message.hasOwnProperty("sigmoidHard")) {
                        object.sigmoidHard = $root.CoreML.Specification.ActivationSigmoidHard.toObject(message.sigmoidHard, options);
                        if (options.oneofs)
                            object.NonlinearityType = "sigmoidHard";
                    }
                    if (message.ELU != null && message.hasOwnProperty("ELU")) {
                        object.ELU = $root.CoreML.Specification.ActivationELU.toObject(message.ELU, options);
                        if (options.oneofs)
                            object.NonlinearityType = "ELU";
                    }
                    if (message.softsign != null && message.hasOwnProperty("softsign")) {
                        object.softsign = $root.CoreML.Specification.ActivationSoftsign.toObject(message.softsign, options);
                        if (options.oneofs)
                            object.NonlinearityType = "softsign";
                    }
                    if (message.softplus != null && message.hasOwnProperty("softplus")) {
                        object.softplus = $root.CoreML.Specification.ActivationSoftplus.toObject(message.softplus, options);
                        if (options.oneofs)
                            object.NonlinearityType = "softplus";
                    }
                    if (message.parametricSoftplus != null && message.hasOwnProperty("parametricSoftplus")) {
                        object.parametricSoftplus = $root.CoreML.Specification.ActivationParametricSoftplus.toObject(message.parametricSoftplus, options);
                        if (options.oneofs)
                            object.NonlinearityType = "parametricSoftplus";
                    }
                    return object;
                };
    
                /**
                 * Converts this ActivationParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ActivationParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ActivationParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ActivationParams;
            })();
    
            Specification.NeuralNetworkLayer = (function() {
    
                /**
                 * Properties of a NeuralNetworkLayer.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetworkLayer
                 * @property {string|null} [name] NeuralNetworkLayer name
                 * @property {Array.<string>|null} [input] NeuralNetworkLayer input
                 * @property {Array.<string>|null} [output] NeuralNetworkLayer output
                 * @property {CoreML.Specification.IConvolutionLayerParams|null} [convolution] NeuralNetworkLayer convolution
                 * @property {CoreML.Specification.IPoolingLayerParams|null} [pooling] NeuralNetworkLayer pooling
                 * @property {CoreML.Specification.IActivationParams|null} [activation] NeuralNetworkLayer activation
                 * @property {CoreML.Specification.IInnerProductLayerParams|null} [innerProduct] NeuralNetworkLayer innerProduct
                 * @property {CoreML.Specification.IEmbeddingLayerParams|null} [embedding] NeuralNetworkLayer embedding
                 * @property {CoreML.Specification.IBatchnormLayerParams|null} [batchnorm] NeuralNetworkLayer batchnorm
                 * @property {CoreML.Specification.IMeanVarianceNormalizeLayerParams|null} [mvn] NeuralNetworkLayer mvn
                 * @property {CoreML.Specification.IL2NormalizeLayerParams|null} [l2normalize] NeuralNetworkLayer l2normalize
                 * @property {CoreML.Specification.ISoftmaxLayerParams|null} [softmax] NeuralNetworkLayer softmax
                 * @property {CoreML.Specification.ILRNLayerParams|null} [lrn] NeuralNetworkLayer lrn
                 * @property {CoreML.Specification.ICropLayerParams|null} [crop] NeuralNetworkLayer crop
                 * @property {CoreML.Specification.IPaddingLayerParams|null} [padding] NeuralNetworkLayer padding
                 * @property {CoreML.Specification.IUpsampleLayerParams|null} [upsample] NeuralNetworkLayer upsample
                 * @property {CoreML.Specification.IUnaryFunctionLayerParams|null} [unary] NeuralNetworkLayer unary
                 * @property {CoreML.Specification.IAddLayerParams|null} [add] NeuralNetworkLayer add
                 * @property {CoreML.Specification.IMultiplyLayerParams|null} [multiply] NeuralNetworkLayer multiply
                 * @property {CoreML.Specification.IAverageLayerParams|null} [average] NeuralNetworkLayer average
                 * @property {CoreML.Specification.IScaleLayerParams|null} [scale] NeuralNetworkLayer scale
                 * @property {CoreML.Specification.IBiasLayerParams|null} [bias] NeuralNetworkLayer bias
                 * @property {CoreML.Specification.IMaxLayerParams|null} [max] NeuralNetworkLayer max
                 * @property {CoreML.Specification.IMinLayerParams|null} [min] NeuralNetworkLayer min
                 * @property {CoreML.Specification.IDotProductLayerParams|null} [dot] NeuralNetworkLayer dot
                 * @property {CoreML.Specification.IReduceLayerParams|null} [reduce] NeuralNetworkLayer reduce
                 * @property {CoreML.Specification.ILoadConstantLayerParams|null} [loadConstant] NeuralNetworkLayer loadConstant
                 * @property {CoreML.Specification.IReshapeLayerParams|null} [reshape] NeuralNetworkLayer reshape
                 * @property {CoreML.Specification.IFlattenLayerParams|null} [flatten] NeuralNetworkLayer flatten
                 * @property {CoreML.Specification.IPermuteLayerParams|null} [permute] NeuralNetworkLayer permute
                 * @property {CoreML.Specification.IConcatLayerParams|null} [concat] NeuralNetworkLayer concat
                 * @property {CoreML.Specification.ISplitLayerParams|null} [split] NeuralNetworkLayer split
                 * @property {CoreML.Specification.ISequenceRepeatLayerParams|null} [sequenceRepeat] NeuralNetworkLayer sequenceRepeat
                 * @property {CoreML.Specification.IReorganizeDataLayerParams|null} [reorganizeData] NeuralNetworkLayer reorganizeData
                 * @property {CoreML.Specification.ISliceLayerParams|null} [slice] NeuralNetworkLayer slice
                 * @property {CoreML.Specification.ISimpleRecurrentLayerParams|null} [simpleRecurrent] NeuralNetworkLayer simpleRecurrent
                 * @property {CoreML.Specification.IGRULayerParams|null} [gru] NeuralNetworkLayer gru
                 * @property {CoreML.Specification.IUniDirectionalLSTMLayerParams|null} [uniDirectionalLSTM] NeuralNetworkLayer uniDirectionalLSTM
                 * @property {CoreML.Specification.IBiDirectionalLSTMLayerParams|null} [biDirectionalLSTM] NeuralNetworkLayer biDirectionalLSTM
                 * @property {CoreML.Specification.ICustomLayerParams|null} [custom] NeuralNetworkLayer custom
                 */
    
                /**
                 * Constructs a new NeuralNetworkLayer.
                 * @memberof CoreML.Specification
                 * @classdesc A single neural network layer.
                 * @implements INeuralNetworkLayer
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetworkLayer=} [properties] Properties to set
                 */
                function NeuralNetworkLayer(properties) {
                    this.input = [];
                    this.output = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NeuralNetworkLayer name.
                 * @member {string} name
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.name = "";
    
                /**
                 * NeuralNetworkLayer input.
                 * @member {Array.<string>} input
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.input = $util.emptyArray;
    
                /**
                 * NeuralNetworkLayer output.
                 * @member {Array.<string>} output
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.output = $util.emptyArray;
    
                /**
                 * NeuralNetworkLayer convolution.
                 * @member {CoreML.Specification.IConvolutionLayerParams|null|undefined} convolution
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.convolution = null;
    
                /**
                 * NeuralNetworkLayer pooling.
                 * @member {CoreML.Specification.IPoolingLayerParams|null|undefined} pooling
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.pooling = null;
    
                /**
                 * NeuralNetworkLayer activation.
                 * @member {CoreML.Specification.IActivationParams|null|undefined} activation
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.activation = null;
    
                /**
                 * NeuralNetworkLayer innerProduct.
                 * @member {CoreML.Specification.IInnerProductLayerParams|null|undefined} innerProduct
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.innerProduct = null;
    
                /**
                 * NeuralNetworkLayer embedding.
                 * @member {CoreML.Specification.IEmbeddingLayerParams|null|undefined} embedding
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.embedding = null;
    
                /**
                 * NeuralNetworkLayer batchnorm.
                 * @member {CoreML.Specification.IBatchnormLayerParams|null|undefined} batchnorm
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.batchnorm = null;
    
                /**
                 * NeuralNetworkLayer mvn.
                 * @member {CoreML.Specification.IMeanVarianceNormalizeLayerParams|null|undefined} mvn
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.mvn = null;
    
                /**
                 * NeuralNetworkLayer l2normalize.
                 * @member {CoreML.Specification.IL2NormalizeLayerParams|null|undefined} l2normalize
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.l2normalize = null;
    
                /**
                 * NeuralNetworkLayer softmax.
                 * @member {CoreML.Specification.ISoftmaxLayerParams|null|undefined} softmax
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.softmax = null;
    
                /**
                 * NeuralNetworkLayer lrn.
                 * @member {CoreML.Specification.ILRNLayerParams|null|undefined} lrn
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.lrn = null;
    
                /**
                 * NeuralNetworkLayer crop.
                 * @member {CoreML.Specification.ICropLayerParams|null|undefined} crop
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.crop = null;
    
                /**
                 * NeuralNetworkLayer padding.
                 * @member {CoreML.Specification.IPaddingLayerParams|null|undefined} padding
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.padding = null;
    
                /**
                 * NeuralNetworkLayer upsample.
                 * @member {CoreML.Specification.IUpsampleLayerParams|null|undefined} upsample
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.upsample = null;
    
                /**
                 * NeuralNetworkLayer unary.
                 * @member {CoreML.Specification.IUnaryFunctionLayerParams|null|undefined} unary
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.unary = null;
    
                /**
                 * NeuralNetworkLayer add.
                 * @member {CoreML.Specification.IAddLayerParams|null|undefined} add
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.add = null;
    
                /**
                 * NeuralNetworkLayer multiply.
                 * @member {CoreML.Specification.IMultiplyLayerParams|null|undefined} multiply
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.multiply = null;
    
                /**
                 * NeuralNetworkLayer average.
                 * @member {CoreML.Specification.IAverageLayerParams|null|undefined} average
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.average = null;
    
                /**
                 * NeuralNetworkLayer scale.
                 * @member {CoreML.Specification.IScaleLayerParams|null|undefined} scale
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.scale = null;
    
                /**
                 * NeuralNetworkLayer bias.
                 * @member {CoreML.Specification.IBiasLayerParams|null|undefined} bias
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.bias = null;
    
                /**
                 * NeuralNetworkLayer max.
                 * @member {CoreML.Specification.IMaxLayerParams|null|undefined} max
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.max = null;
    
                /**
                 * NeuralNetworkLayer min.
                 * @member {CoreML.Specification.IMinLayerParams|null|undefined} min
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.min = null;
    
                /**
                 * NeuralNetworkLayer dot.
                 * @member {CoreML.Specification.IDotProductLayerParams|null|undefined} dot
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.dot = null;
    
                /**
                 * NeuralNetworkLayer reduce.
                 * @member {CoreML.Specification.IReduceLayerParams|null|undefined} reduce
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.reduce = null;
    
                /**
                 * NeuralNetworkLayer loadConstant.
                 * @member {CoreML.Specification.ILoadConstantLayerParams|null|undefined} loadConstant
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.loadConstant = null;
    
                /**
                 * NeuralNetworkLayer reshape.
                 * @member {CoreML.Specification.IReshapeLayerParams|null|undefined} reshape
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.reshape = null;
    
                /**
                 * NeuralNetworkLayer flatten.
                 * @member {CoreML.Specification.IFlattenLayerParams|null|undefined} flatten
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.flatten = null;
    
                /**
                 * NeuralNetworkLayer permute.
                 * @member {CoreML.Specification.IPermuteLayerParams|null|undefined} permute
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.permute = null;
    
                /**
                 * NeuralNetworkLayer concat.
                 * @member {CoreML.Specification.IConcatLayerParams|null|undefined} concat
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.concat = null;
    
                /**
                 * NeuralNetworkLayer split.
                 * @member {CoreML.Specification.ISplitLayerParams|null|undefined} split
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.split = null;
    
                /**
                 * NeuralNetworkLayer sequenceRepeat.
                 * @member {CoreML.Specification.ISequenceRepeatLayerParams|null|undefined} sequenceRepeat
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.sequenceRepeat = null;
    
                /**
                 * NeuralNetworkLayer reorganizeData.
                 * @member {CoreML.Specification.IReorganizeDataLayerParams|null|undefined} reorganizeData
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.reorganizeData = null;
    
                /**
                 * NeuralNetworkLayer slice.
                 * @member {CoreML.Specification.ISliceLayerParams|null|undefined} slice
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.slice = null;
    
                /**
                 * NeuralNetworkLayer simpleRecurrent.
                 * @member {CoreML.Specification.ISimpleRecurrentLayerParams|null|undefined} simpleRecurrent
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.simpleRecurrent = null;
    
                /**
                 * NeuralNetworkLayer gru.
                 * @member {CoreML.Specification.IGRULayerParams|null|undefined} gru
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.gru = null;
    
                /**
                 * NeuralNetworkLayer uniDirectionalLSTM.
                 * @member {CoreML.Specification.IUniDirectionalLSTMLayerParams|null|undefined} uniDirectionalLSTM
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.uniDirectionalLSTM = null;
    
                /**
                 * NeuralNetworkLayer biDirectionalLSTM.
                 * @member {CoreML.Specification.IBiDirectionalLSTMLayerParams|null|undefined} biDirectionalLSTM
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.biDirectionalLSTM = null;
    
                /**
                 * NeuralNetworkLayer custom.
                 * @member {CoreML.Specification.ICustomLayerParams|null|undefined} custom
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                NeuralNetworkLayer.prototype.custom = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * NeuralNetworkLayer layer.
                 * @member {"convolution"|"pooling"|"activation"|"innerProduct"|"embedding"|"batchnorm"|"mvn"|"l2normalize"|"softmax"|"lrn"|"crop"|"padding"|"upsample"|"unary"|"add"|"multiply"|"average"|"scale"|"bias"|"max"|"min"|"dot"|"reduce"|"loadConstant"|"reshape"|"flatten"|"permute"|"concat"|"split"|"sequenceRepeat"|"reorganizeData"|"slice"|"simpleRecurrent"|"gru"|"uniDirectionalLSTM"|"biDirectionalLSTM"|"custom"|undefined} layer
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 */
                Object.defineProperty(NeuralNetworkLayer.prototype, "layer", {
                    get: $util.oneOfGetter($oneOfFields = ["convolution", "pooling", "activation", "innerProduct", "embedding", "batchnorm", "mvn", "l2normalize", "softmax", "lrn", "crop", "padding", "upsample", "unary", "add", "multiply", "average", "scale", "bias", "max", "min", "dot", "reduce", "loadConstant", "reshape", "flatten", "permute", "concat", "split", "sequenceRepeat", "reorganizeData", "slice", "simpleRecurrent", "gru", "uniDirectionalLSTM", "biDirectionalLSTM", "custom"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NeuralNetworkLayer instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkLayer=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetworkLayer} NeuralNetworkLayer instance
                 */
                NeuralNetworkLayer.create = function create(properties) {
                    return new NeuralNetworkLayer(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetworkLayer message. Does not implicitly {@link CoreML.Specification.NeuralNetworkLayer.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkLayer} message NeuralNetworkLayer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkLayer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && message.hasOwnProperty("name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.input != null && message.input.length)
                        for (var i = 0; i < message.input.length; ++i)
                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.input[i]);
                    if (message.output != null && message.output.length)
                        for (var i = 0; i < message.output.length; ++i)
                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.output[i]);
                    if (message.convolution != null && message.hasOwnProperty("convolution"))
                        $root.CoreML.Specification.ConvolutionLayerParams.encode(message.convolution, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    if (message.pooling != null && message.hasOwnProperty("pooling"))
                        $root.CoreML.Specification.PoolingLayerParams.encode(message.pooling, writer.uint32(/* id 120, wireType 2 =*/962).fork()).ldelim();
                    if (message.activation != null && message.hasOwnProperty("activation"))
                        $root.CoreML.Specification.ActivationParams.encode(message.activation, writer.uint32(/* id 130, wireType 2 =*/1042).fork()).ldelim();
                    if (message.innerProduct != null && message.hasOwnProperty("innerProduct"))
                        $root.CoreML.Specification.InnerProductLayerParams.encode(message.innerProduct, writer.uint32(/* id 140, wireType 2 =*/1122).fork()).ldelim();
                    if (message.embedding != null && message.hasOwnProperty("embedding"))
                        $root.CoreML.Specification.EmbeddingLayerParams.encode(message.embedding, writer.uint32(/* id 150, wireType 2 =*/1202).fork()).ldelim();
                    if (message.batchnorm != null && message.hasOwnProperty("batchnorm"))
                        $root.CoreML.Specification.BatchnormLayerParams.encode(message.batchnorm, writer.uint32(/* id 160, wireType 2 =*/1282).fork()).ldelim();
                    if (message.mvn != null && message.hasOwnProperty("mvn"))
                        $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.encode(message.mvn, writer.uint32(/* id 165, wireType 2 =*/1322).fork()).ldelim();
                    if (message.l2normalize != null && message.hasOwnProperty("l2normalize"))
                        $root.CoreML.Specification.L2NormalizeLayerParams.encode(message.l2normalize, writer.uint32(/* id 170, wireType 2 =*/1362).fork()).ldelim();
                    if (message.softmax != null && message.hasOwnProperty("softmax"))
                        $root.CoreML.Specification.SoftmaxLayerParams.encode(message.softmax, writer.uint32(/* id 175, wireType 2 =*/1402).fork()).ldelim();
                    if (message.lrn != null && message.hasOwnProperty("lrn"))
                        $root.CoreML.Specification.LRNLayerParams.encode(message.lrn, writer.uint32(/* id 180, wireType 2 =*/1442).fork()).ldelim();
                    if (message.crop != null && message.hasOwnProperty("crop"))
                        $root.CoreML.Specification.CropLayerParams.encode(message.crop, writer.uint32(/* id 190, wireType 2 =*/1522).fork()).ldelim();
                    if (message.padding != null && message.hasOwnProperty("padding"))
                        $root.CoreML.Specification.PaddingLayerParams.encode(message.padding, writer.uint32(/* id 200, wireType 2 =*/1602).fork()).ldelim();
                    if (message.upsample != null && message.hasOwnProperty("upsample"))
                        $root.CoreML.Specification.UpsampleLayerParams.encode(message.upsample, writer.uint32(/* id 210, wireType 2 =*/1682).fork()).ldelim();
                    if (message.unary != null && message.hasOwnProperty("unary"))
                        $root.CoreML.Specification.UnaryFunctionLayerParams.encode(message.unary, writer.uint32(/* id 220, wireType 2 =*/1762).fork()).ldelim();
                    if (message.add != null && message.hasOwnProperty("add"))
                        $root.CoreML.Specification.AddLayerParams.encode(message.add, writer.uint32(/* id 230, wireType 2 =*/1842).fork()).ldelim();
                    if (message.multiply != null && message.hasOwnProperty("multiply"))
                        $root.CoreML.Specification.MultiplyLayerParams.encode(message.multiply, writer.uint32(/* id 231, wireType 2 =*/1850).fork()).ldelim();
                    if (message.average != null && message.hasOwnProperty("average"))
                        $root.CoreML.Specification.AverageLayerParams.encode(message.average, writer.uint32(/* id 240, wireType 2 =*/1922).fork()).ldelim();
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        $root.CoreML.Specification.ScaleLayerParams.encode(message.scale, writer.uint32(/* id 245, wireType 2 =*/1962).fork()).ldelim();
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        $root.CoreML.Specification.BiasLayerParams.encode(message.bias, writer.uint32(/* id 250, wireType 2 =*/2002).fork()).ldelim();
                    if (message.max != null && message.hasOwnProperty("max"))
                        $root.CoreML.Specification.MaxLayerParams.encode(message.max, writer.uint32(/* id 260, wireType 2 =*/2082).fork()).ldelim();
                    if (message.min != null && message.hasOwnProperty("min"))
                        $root.CoreML.Specification.MinLayerParams.encode(message.min, writer.uint32(/* id 261, wireType 2 =*/2090).fork()).ldelim();
                    if (message.dot != null && message.hasOwnProperty("dot"))
                        $root.CoreML.Specification.DotProductLayerParams.encode(message.dot, writer.uint32(/* id 270, wireType 2 =*/2162).fork()).ldelim();
                    if (message.reduce != null && message.hasOwnProperty("reduce"))
                        $root.CoreML.Specification.ReduceLayerParams.encode(message.reduce, writer.uint32(/* id 280, wireType 2 =*/2242).fork()).ldelim();
                    if (message.loadConstant != null && message.hasOwnProperty("loadConstant"))
                        $root.CoreML.Specification.LoadConstantLayerParams.encode(message.loadConstant, writer.uint32(/* id 290, wireType 2 =*/2322).fork()).ldelim();
                    if (message.reshape != null && message.hasOwnProperty("reshape"))
                        $root.CoreML.Specification.ReshapeLayerParams.encode(message.reshape, writer.uint32(/* id 300, wireType 2 =*/2402).fork()).ldelim();
                    if (message.flatten != null && message.hasOwnProperty("flatten"))
                        $root.CoreML.Specification.FlattenLayerParams.encode(message.flatten, writer.uint32(/* id 301, wireType 2 =*/2410).fork()).ldelim();
                    if (message.permute != null && message.hasOwnProperty("permute"))
                        $root.CoreML.Specification.PermuteLayerParams.encode(message.permute, writer.uint32(/* id 310, wireType 2 =*/2482).fork()).ldelim();
                    if (message.concat != null && message.hasOwnProperty("concat"))
                        $root.CoreML.Specification.ConcatLayerParams.encode(message.concat, writer.uint32(/* id 320, wireType 2 =*/2562).fork()).ldelim();
                    if (message.split != null && message.hasOwnProperty("split"))
                        $root.CoreML.Specification.SplitLayerParams.encode(message.split, writer.uint32(/* id 330, wireType 2 =*/2642).fork()).ldelim();
                    if (message.sequenceRepeat != null && message.hasOwnProperty("sequenceRepeat"))
                        $root.CoreML.Specification.SequenceRepeatLayerParams.encode(message.sequenceRepeat, writer.uint32(/* id 340, wireType 2 =*/2722).fork()).ldelim();
                    if (message.reorganizeData != null && message.hasOwnProperty("reorganizeData"))
                        $root.CoreML.Specification.ReorganizeDataLayerParams.encode(message.reorganizeData, writer.uint32(/* id 345, wireType 2 =*/2762).fork()).ldelim();
                    if (message.slice != null && message.hasOwnProperty("slice"))
                        $root.CoreML.Specification.SliceLayerParams.encode(message.slice, writer.uint32(/* id 350, wireType 2 =*/2802).fork()).ldelim();
                    if (message.simpleRecurrent != null && message.hasOwnProperty("simpleRecurrent"))
                        $root.CoreML.Specification.SimpleRecurrentLayerParams.encode(message.simpleRecurrent, writer.uint32(/* id 400, wireType 2 =*/3202).fork()).ldelim();
                    if (message.gru != null && message.hasOwnProperty("gru"))
                        $root.CoreML.Specification.GRULayerParams.encode(message.gru, writer.uint32(/* id 410, wireType 2 =*/3282).fork()).ldelim();
                    if (message.uniDirectionalLSTM != null && message.hasOwnProperty("uniDirectionalLSTM"))
                        $root.CoreML.Specification.UniDirectionalLSTMLayerParams.encode(message.uniDirectionalLSTM, writer.uint32(/* id 420, wireType 2 =*/3362).fork()).ldelim();
                    if (message.biDirectionalLSTM != null && message.hasOwnProperty("biDirectionalLSTM"))
                        $root.CoreML.Specification.BiDirectionalLSTMLayerParams.encode(message.biDirectionalLSTM, writer.uint32(/* id 430, wireType 2 =*/3442).fork()).ldelim();
                    if (message.custom != null && message.hasOwnProperty("custom"))
                        $root.CoreML.Specification.CustomLayerParams.encode(message.custom, writer.uint32(/* id 500, wireType 2 =*/4002).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetworkLayer message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetworkLayer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkLayer} message NeuralNetworkLayer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkLayer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetworkLayer message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetworkLayer} NeuralNetworkLayer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkLayer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkLayer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            if (!(message.input && message.input.length))
                                message.input = [];
                            message.input.push(reader.string());
                            break;
                        case 3:
                            if (!(message.output && message.output.length))
                                message.output = [];
                            message.output.push(reader.string());
                            break;
                        case 100:
                            message.convolution = $root.CoreML.Specification.ConvolutionLayerParams.decode(reader, reader.uint32());
                            break;
                        case 120:
                            message.pooling = $root.CoreML.Specification.PoolingLayerParams.decode(reader, reader.uint32());
                            break;
                        case 130:
                            message.activation = $root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32());
                            break;
                        case 140:
                            message.innerProduct = $root.CoreML.Specification.InnerProductLayerParams.decode(reader, reader.uint32());
                            break;
                        case 150:
                            message.embedding = $root.CoreML.Specification.EmbeddingLayerParams.decode(reader, reader.uint32());
                            break;
                        case 160:
                            message.batchnorm = $root.CoreML.Specification.BatchnormLayerParams.decode(reader, reader.uint32());
                            break;
                        case 165:
                            message.mvn = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 170:
                            message.l2normalize = $root.CoreML.Specification.L2NormalizeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 175:
                            message.softmax = $root.CoreML.Specification.SoftmaxLayerParams.decode(reader, reader.uint32());
                            break;
                        case 180:
                            message.lrn = $root.CoreML.Specification.LRNLayerParams.decode(reader, reader.uint32());
                            break;
                        case 190:
                            message.crop = $root.CoreML.Specification.CropLayerParams.decode(reader, reader.uint32());
                            break;
                        case 200:
                            message.padding = $root.CoreML.Specification.PaddingLayerParams.decode(reader, reader.uint32());
                            break;
                        case 210:
                            message.upsample = $root.CoreML.Specification.UpsampleLayerParams.decode(reader, reader.uint32());
                            break;
                        case 220:
                            message.unary = $root.CoreML.Specification.UnaryFunctionLayerParams.decode(reader, reader.uint32());
                            break;
                        case 230:
                            message.add = $root.CoreML.Specification.AddLayerParams.decode(reader, reader.uint32());
                            break;
                        case 231:
                            message.multiply = $root.CoreML.Specification.MultiplyLayerParams.decode(reader, reader.uint32());
                            break;
                        case 240:
                            message.average = $root.CoreML.Specification.AverageLayerParams.decode(reader, reader.uint32());
                            break;
                        case 245:
                            message.scale = $root.CoreML.Specification.ScaleLayerParams.decode(reader, reader.uint32());
                            break;
                        case 250:
                            message.bias = $root.CoreML.Specification.BiasLayerParams.decode(reader, reader.uint32());
                            break;
                        case 260:
                            message.max = $root.CoreML.Specification.MaxLayerParams.decode(reader, reader.uint32());
                            break;
                        case 261:
                            message.min = $root.CoreML.Specification.MinLayerParams.decode(reader, reader.uint32());
                            break;
                        case 270:
                            message.dot = $root.CoreML.Specification.DotProductLayerParams.decode(reader, reader.uint32());
                            break;
                        case 280:
                            message.reduce = $root.CoreML.Specification.ReduceLayerParams.decode(reader, reader.uint32());
                            break;
                        case 290:
                            message.loadConstant = $root.CoreML.Specification.LoadConstantLayerParams.decode(reader, reader.uint32());
                            break;
                        case 300:
                            message.reshape = $root.CoreML.Specification.ReshapeLayerParams.decode(reader, reader.uint32());
                            break;
                        case 301:
                            message.flatten = $root.CoreML.Specification.FlattenLayerParams.decode(reader, reader.uint32());
                            break;
                        case 310:
                            message.permute = $root.CoreML.Specification.PermuteLayerParams.decode(reader, reader.uint32());
                            break;
                        case 320:
                            message.concat = $root.CoreML.Specification.ConcatLayerParams.decode(reader, reader.uint32());
                            break;
                        case 330:
                            message.split = $root.CoreML.Specification.SplitLayerParams.decode(reader, reader.uint32());
                            break;
                        case 340:
                            message.sequenceRepeat = $root.CoreML.Specification.SequenceRepeatLayerParams.decode(reader, reader.uint32());
                            break;
                        case 345:
                            message.reorganizeData = $root.CoreML.Specification.ReorganizeDataLayerParams.decode(reader, reader.uint32());
                            break;
                        case 350:
                            message.slice = $root.CoreML.Specification.SliceLayerParams.decode(reader, reader.uint32());
                            break;
                        case 400:
                            message.simpleRecurrent = $root.CoreML.Specification.SimpleRecurrentLayerParams.decode(reader, reader.uint32());
                            break;
                        case 410:
                            message.gru = $root.CoreML.Specification.GRULayerParams.decode(reader, reader.uint32());
                            break;
                        case 420:
                            message.uniDirectionalLSTM = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.decode(reader, reader.uint32());
                            break;
                        case 430:
                            message.biDirectionalLSTM = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.decode(reader, reader.uint32());
                            break;
                        case 500:
                            message.custom = $root.CoreML.Specification.CustomLayerParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetworkLayer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetworkLayer} NeuralNetworkLayer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkLayer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetworkLayer message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetworkLayer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.input != null && message.hasOwnProperty("input")) {
                        if (!Array.isArray(message.input))
                            return "input: array expected";
                        for (var i = 0; i < message.input.length; ++i)
                            if (!$util.isString(message.input[i]))
                                return "input: string[] expected";
                    }
                    if (message.output != null && message.hasOwnProperty("output")) {
                        if (!Array.isArray(message.output))
                            return "output: array expected";
                        for (var i = 0; i < message.output.length; ++i)
                            if (!$util.isString(message.output[i]))
                                return "output: string[] expected";
                    }
                    if (message.convolution != null && message.hasOwnProperty("convolution")) {
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ConvolutionLayerParams.verify(message.convolution);
                            if (error)
                                return "convolution." + error;
                        }
                    }
                    if (message.pooling != null && message.hasOwnProperty("pooling")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.PoolingLayerParams.verify(message.pooling);
                            if (error)
                                return "pooling." + error;
                        }
                    }
                    if (message.activation != null && message.hasOwnProperty("activation")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activation);
                            if (error)
                                return "activation." + error;
                        }
                    }
                    if (message.innerProduct != null && message.hasOwnProperty("innerProduct")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.InnerProductLayerParams.verify(message.innerProduct);
                            if (error)
                                return "innerProduct." + error;
                        }
                    }
                    if (message.embedding != null && message.hasOwnProperty("embedding")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.EmbeddingLayerParams.verify(message.embedding);
                            if (error)
                                return "embedding." + error;
                        }
                    }
                    if (message.batchnorm != null && message.hasOwnProperty("batchnorm")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.BatchnormLayerParams.verify(message.batchnorm);
                            if (error)
                                return "batchnorm." + error;
                        }
                    }
                    if (message.mvn != null && message.hasOwnProperty("mvn")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.verify(message.mvn);
                            if (error)
                                return "mvn." + error;
                        }
                    }
                    if (message.l2normalize != null && message.hasOwnProperty("l2normalize")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.L2NormalizeLayerParams.verify(message.l2normalize);
                            if (error)
                                return "l2normalize." + error;
                        }
                    }
                    if (message.softmax != null && message.hasOwnProperty("softmax")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SoftmaxLayerParams.verify(message.softmax);
                            if (error)
                                return "softmax." + error;
                        }
                    }
                    if (message.lrn != null && message.hasOwnProperty("lrn")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.LRNLayerParams.verify(message.lrn);
                            if (error)
                                return "lrn." + error;
                        }
                    }
                    if (message.crop != null && message.hasOwnProperty("crop")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.CropLayerParams.verify(message.crop);
                            if (error)
                                return "crop." + error;
                        }
                    }
                    if (message.padding != null && message.hasOwnProperty("padding")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.verify(message.padding);
                            if (error)
                                return "padding." + error;
                        }
                    }
                    if (message.upsample != null && message.hasOwnProperty("upsample")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.UpsampleLayerParams.verify(message.upsample);
                            if (error)
                                return "upsample." + error;
                        }
                    }
                    if (message.unary != null && message.hasOwnProperty("unary")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.UnaryFunctionLayerParams.verify(message.unary);
                            if (error)
                                return "unary." + error;
                        }
                    }
                    if (message.add != null && message.hasOwnProperty("add")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.AddLayerParams.verify(message.add);
                            if (error)
                                return "add." + error;
                        }
                    }
                    if (message.multiply != null && message.hasOwnProperty("multiply")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MultiplyLayerParams.verify(message.multiply);
                            if (error)
                                return "multiply." + error;
                        }
                    }
                    if (message.average != null && message.hasOwnProperty("average")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.AverageLayerParams.verify(message.average);
                            if (error)
                                return "average." + error;
                        }
                    }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ScaleLayerParams.verify(message.scale);
                            if (error)
                                return "scale." + error;
                        }
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.BiasLayerParams.verify(message.bias);
                            if (error)
                                return "bias." + error;
                        }
                    }
                    if (message.max != null && message.hasOwnProperty("max")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MaxLayerParams.verify(message.max);
                            if (error)
                                return "max." + error;
                        }
                    }
                    if (message.min != null && message.hasOwnProperty("min")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.MinLayerParams.verify(message.min);
                            if (error)
                                return "min." + error;
                        }
                    }
                    if (message.dot != null && message.hasOwnProperty("dot")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.DotProductLayerParams.verify(message.dot);
                            if (error)
                                return "dot." + error;
                        }
                    }
                    if (message.reduce != null && message.hasOwnProperty("reduce")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ReduceLayerParams.verify(message.reduce);
                            if (error)
                                return "reduce." + error;
                        }
                    }
                    if (message.loadConstant != null && message.hasOwnProperty("loadConstant")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.LoadConstantLayerParams.verify(message.loadConstant);
                            if (error)
                                return "loadConstant." + error;
                        }
                    }
                    if (message.reshape != null && message.hasOwnProperty("reshape")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ReshapeLayerParams.verify(message.reshape);
                            if (error)
                                return "reshape." + error;
                        }
                    }
                    if (message.flatten != null && message.hasOwnProperty("flatten")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.FlattenLayerParams.verify(message.flatten);
                            if (error)
                                return "flatten." + error;
                        }
                    }
                    if (message.permute != null && message.hasOwnProperty("permute")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.PermuteLayerParams.verify(message.permute);
                            if (error)
                                return "permute." + error;
                        }
                    }
                    if (message.concat != null && message.hasOwnProperty("concat")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ConcatLayerParams.verify(message.concat);
                            if (error)
                                return "concat." + error;
                        }
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SplitLayerParams.verify(message.split);
                            if (error)
                                return "split." + error;
                        }
                    }
                    if (message.sequenceRepeat != null && message.hasOwnProperty("sequenceRepeat")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SequenceRepeatLayerParams.verify(message.sequenceRepeat);
                            if (error)
                                return "sequenceRepeat." + error;
                        }
                    }
                    if (message.reorganizeData != null && message.hasOwnProperty("reorganizeData")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.ReorganizeDataLayerParams.verify(message.reorganizeData);
                            if (error)
                                return "reorganizeData." + error;
                        }
                    }
                    if (message.slice != null && message.hasOwnProperty("slice")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SliceLayerParams.verify(message.slice);
                            if (error)
                                return "slice." + error;
                        }
                    }
                    if (message.simpleRecurrent != null && message.hasOwnProperty("simpleRecurrent")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.SimpleRecurrentLayerParams.verify(message.simpleRecurrent);
                            if (error)
                                return "simpleRecurrent." + error;
                        }
                    }
                    if (message.gru != null && message.hasOwnProperty("gru")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.GRULayerParams.verify(message.gru);
                            if (error)
                                return "gru." + error;
                        }
                    }
                    if (message.uniDirectionalLSTM != null && message.hasOwnProperty("uniDirectionalLSTM")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.verify(message.uniDirectionalLSTM);
                            if (error)
                                return "uniDirectionalLSTM." + error;
                        }
                    }
                    if (message.biDirectionalLSTM != null && message.hasOwnProperty("biDirectionalLSTM")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.verify(message.biDirectionalLSTM);
                            if (error)
                                return "biDirectionalLSTM." + error;
                        }
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        if (properties.layer === 1)
                            return "layer: multiple values";
                        properties.layer = 1;
                        {
                            var error = $root.CoreML.Specification.CustomLayerParams.verify(message.custom);
                            if (error)
                                return "custom." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NeuralNetworkLayer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetworkLayer} NeuralNetworkLayer
                 */
                NeuralNetworkLayer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkLayer)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkLayer();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.input) {
                        if (!Array.isArray(object.input))
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.input: array expected");
                        message.input = [];
                        for (var i = 0; i < object.input.length; ++i)
                            message.input[i] = String(object.input[i]);
                    }
                    if (object.output) {
                        if (!Array.isArray(object.output))
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.output: array expected");
                        message.output = [];
                        for (var i = 0; i < object.output.length; ++i)
                            message.output[i] = String(object.output[i]);
                    }
                    if (object.convolution != null) {
                        if (typeof object.convolution !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.convolution: object expected");
                        message.convolution = $root.CoreML.Specification.ConvolutionLayerParams.fromObject(object.convolution);
                    }
                    if (object.pooling != null) {
                        if (typeof object.pooling !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.pooling: object expected");
                        message.pooling = $root.CoreML.Specification.PoolingLayerParams.fromObject(object.pooling);
                    }
                    if (object.activation != null) {
                        if (typeof object.activation !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.activation: object expected");
                        message.activation = $root.CoreML.Specification.ActivationParams.fromObject(object.activation);
                    }
                    if (object.innerProduct != null) {
                        if (typeof object.innerProduct !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.innerProduct: object expected");
                        message.innerProduct = $root.CoreML.Specification.InnerProductLayerParams.fromObject(object.innerProduct);
                    }
                    if (object.embedding != null) {
                        if (typeof object.embedding !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.embedding: object expected");
                        message.embedding = $root.CoreML.Specification.EmbeddingLayerParams.fromObject(object.embedding);
                    }
                    if (object.batchnorm != null) {
                        if (typeof object.batchnorm !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.batchnorm: object expected");
                        message.batchnorm = $root.CoreML.Specification.BatchnormLayerParams.fromObject(object.batchnorm);
                    }
                    if (object.mvn != null) {
                        if (typeof object.mvn !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.mvn: object expected");
                        message.mvn = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.fromObject(object.mvn);
                    }
                    if (object.l2normalize != null) {
                        if (typeof object.l2normalize !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.l2normalize: object expected");
                        message.l2normalize = $root.CoreML.Specification.L2NormalizeLayerParams.fromObject(object.l2normalize);
                    }
                    if (object.softmax != null) {
                        if (typeof object.softmax !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.softmax: object expected");
                        message.softmax = $root.CoreML.Specification.SoftmaxLayerParams.fromObject(object.softmax);
                    }
                    if (object.lrn != null) {
                        if (typeof object.lrn !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.lrn: object expected");
                        message.lrn = $root.CoreML.Specification.LRNLayerParams.fromObject(object.lrn);
                    }
                    if (object.crop != null) {
                        if (typeof object.crop !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.crop: object expected");
                        message.crop = $root.CoreML.Specification.CropLayerParams.fromObject(object.crop);
                    }
                    if (object.padding != null) {
                        if (typeof object.padding !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.padding: object expected");
                        message.padding = $root.CoreML.Specification.PaddingLayerParams.fromObject(object.padding);
                    }
                    if (object.upsample != null) {
                        if (typeof object.upsample !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.upsample: object expected");
                        message.upsample = $root.CoreML.Specification.UpsampleLayerParams.fromObject(object.upsample);
                    }
                    if (object.unary != null) {
                        if (typeof object.unary !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.unary: object expected");
                        message.unary = $root.CoreML.Specification.UnaryFunctionLayerParams.fromObject(object.unary);
                    }
                    if (object.add != null) {
                        if (typeof object.add !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.add: object expected");
                        message.add = $root.CoreML.Specification.AddLayerParams.fromObject(object.add);
                    }
                    if (object.multiply != null) {
                        if (typeof object.multiply !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.multiply: object expected");
                        message.multiply = $root.CoreML.Specification.MultiplyLayerParams.fromObject(object.multiply);
                    }
                    if (object.average != null) {
                        if (typeof object.average !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.average: object expected");
                        message.average = $root.CoreML.Specification.AverageLayerParams.fromObject(object.average);
                    }
                    if (object.scale != null) {
                        if (typeof object.scale !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.scale: object expected");
                        message.scale = $root.CoreML.Specification.ScaleLayerParams.fromObject(object.scale);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.bias: object expected");
                        message.bias = $root.CoreML.Specification.BiasLayerParams.fromObject(object.bias);
                    }
                    if (object.max != null) {
                        if (typeof object.max !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.max: object expected");
                        message.max = $root.CoreML.Specification.MaxLayerParams.fromObject(object.max);
                    }
                    if (object.min != null) {
                        if (typeof object.min !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.min: object expected");
                        message.min = $root.CoreML.Specification.MinLayerParams.fromObject(object.min);
                    }
                    if (object.dot != null) {
                        if (typeof object.dot !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.dot: object expected");
                        message.dot = $root.CoreML.Specification.DotProductLayerParams.fromObject(object.dot);
                    }
                    if (object.reduce != null) {
                        if (typeof object.reduce !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.reduce: object expected");
                        message.reduce = $root.CoreML.Specification.ReduceLayerParams.fromObject(object.reduce);
                    }
                    if (object.loadConstant != null) {
                        if (typeof object.loadConstant !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.loadConstant: object expected");
                        message.loadConstant = $root.CoreML.Specification.LoadConstantLayerParams.fromObject(object.loadConstant);
                    }
                    if (object.reshape != null) {
                        if (typeof object.reshape !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.reshape: object expected");
                        message.reshape = $root.CoreML.Specification.ReshapeLayerParams.fromObject(object.reshape);
                    }
                    if (object.flatten != null) {
                        if (typeof object.flatten !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.flatten: object expected");
                        message.flatten = $root.CoreML.Specification.FlattenLayerParams.fromObject(object.flatten);
                    }
                    if (object.permute != null) {
                        if (typeof object.permute !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.permute: object expected");
                        message.permute = $root.CoreML.Specification.PermuteLayerParams.fromObject(object.permute);
                    }
                    if (object.concat != null) {
                        if (typeof object.concat !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.concat: object expected");
                        message.concat = $root.CoreML.Specification.ConcatLayerParams.fromObject(object.concat);
                    }
                    if (object.split != null) {
                        if (typeof object.split !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.split: object expected");
                        message.split = $root.CoreML.Specification.SplitLayerParams.fromObject(object.split);
                    }
                    if (object.sequenceRepeat != null) {
                        if (typeof object.sequenceRepeat !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.sequenceRepeat: object expected");
                        message.sequenceRepeat = $root.CoreML.Specification.SequenceRepeatLayerParams.fromObject(object.sequenceRepeat);
                    }
                    if (object.reorganizeData != null) {
                        if (typeof object.reorganizeData !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.reorganizeData: object expected");
                        message.reorganizeData = $root.CoreML.Specification.ReorganizeDataLayerParams.fromObject(object.reorganizeData);
                    }
                    if (object.slice != null) {
                        if (typeof object.slice !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.slice: object expected");
                        message.slice = $root.CoreML.Specification.SliceLayerParams.fromObject(object.slice);
                    }
                    if (object.simpleRecurrent != null) {
                        if (typeof object.simpleRecurrent !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.simpleRecurrent: object expected");
                        message.simpleRecurrent = $root.CoreML.Specification.SimpleRecurrentLayerParams.fromObject(object.simpleRecurrent);
                    }
                    if (object.gru != null) {
                        if (typeof object.gru !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.gru: object expected");
                        message.gru = $root.CoreML.Specification.GRULayerParams.fromObject(object.gru);
                    }
                    if (object.uniDirectionalLSTM != null) {
                        if (typeof object.uniDirectionalLSTM !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.uniDirectionalLSTM: object expected");
                        message.uniDirectionalLSTM = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.fromObject(object.uniDirectionalLSTM);
                    }
                    if (object.biDirectionalLSTM != null) {
                        if (typeof object.biDirectionalLSTM !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.biDirectionalLSTM: object expected");
                        message.biDirectionalLSTM = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.fromObject(object.biDirectionalLSTM);
                    }
                    if (object.custom != null) {
                        if (typeof object.custom !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkLayer.custom: object expected");
                        message.custom = $root.CoreML.Specification.CustomLayerParams.fromObject(object.custom);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetworkLayer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @static
                 * @param {CoreML.Specification.NeuralNetworkLayer} message NeuralNetworkLayer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetworkLayer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.input = [];
                        object.output = [];
                    }
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.input && message.input.length) {
                        object.input = [];
                        for (var j = 0; j < message.input.length; ++j)
                            object.input[j] = message.input[j];
                    }
                    if (message.output && message.output.length) {
                        object.output = [];
                        for (var j = 0; j < message.output.length; ++j)
                            object.output[j] = message.output[j];
                    }
                    if (message.convolution != null && message.hasOwnProperty("convolution")) {
                        object.convolution = $root.CoreML.Specification.ConvolutionLayerParams.toObject(message.convolution, options);
                        if (options.oneofs)
                            object.layer = "convolution";
                    }
                    if (message.pooling != null && message.hasOwnProperty("pooling")) {
                        object.pooling = $root.CoreML.Specification.PoolingLayerParams.toObject(message.pooling, options);
                        if (options.oneofs)
                            object.layer = "pooling";
                    }
                    if (message.activation != null && message.hasOwnProperty("activation")) {
                        object.activation = $root.CoreML.Specification.ActivationParams.toObject(message.activation, options);
                        if (options.oneofs)
                            object.layer = "activation";
                    }
                    if (message.innerProduct != null && message.hasOwnProperty("innerProduct")) {
                        object.innerProduct = $root.CoreML.Specification.InnerProductLayerParams.toObject(message.innerProduct, options);
                        if (options.oneofs)
                            object.layer = "innerProduct";
                    }
                    if (message.embedding != null && message.hasOwnProperty("embedding")) {
                        object.embedding = $root.CoreML.Specification.EmbeddingLayerParams.toObject(message.embedding, options);
                        if (options.oneofs)
                            object.layer = "embedding";
                    }
                    if (message.batchnorm != null && message.hasOwnProperty("batchnorm")) {
                        object.batchnorm = $root.CoreML.Specification.BatchnormLayerParams.toObject(message.batchnorm, options);
                        if (options.oneofs)
                            object.layer = "batchnorm";
                    }
                    if (message.mvn != null && message.hasOwnProperty("mvn")) {
                        object.mvn = $root.CoreML.Specification.MeanVarianceNormalizeLayerParams.toObject(message.mvn, options);
                        if (options.oneofs)
                            object.layer = "mvn";
                    }
                    if (message.l2normalize != null && message.hasOwnProperty("l2normalize")) {
                        object.l2normalize = $root.CoreML.Specification.L2NormalizeLayerParams.toObject(message.l2normalize, options);
                        if (options.oneofs)
                            object.layer = "l2normalize";
                    }
                    if (message.softmax != null && message.hasOwnProperty("softmax")) {
                        object.softmax = $root.CoreML.Specification.SoftmaxLayerParams.toObject(message.softmax, options);
                        if (options.oneofs)
                            object.layer = "softmax";
                    }
                    if (message.lrn != null && message.hasOwnProperty("lrn")) {
                        object.lrn = $root.CoreML.Specification.LRNLayerParams.toObject(message.lrn, options);
                        if (options.oneofs)
                            object.layer = "lrn";
                    }
                    if (message.crop != null && message.hasOwnProperty("crop")) {
                        object.crop = $root.CoreML.Specification.CropLayerParams.toObject(message.crop, options);
                        if (options.oneofs)
                            object.layer = "crop";
                    }
                    if (message.padding != null && message.hasOwnProperty("padding")) {
                        object.padding = $root.CoreML.Specification.PaddingLayerParams.toObject(message.padding, options);
                        if (options.oneofs)
                            object.layer = "padding";
                    }
                    if (message.upsample != null && message.hasOwnProperty("upsample")) {
                        object.upsample = $root.CoreML.Specification.UpsampleLayerParams.toObject(message.upsample, options);
                        if (options.oneofs)
                            object.layer = "upsample";
                    }
                    if (message.unary != null && message.hasOwnProperty("unary")) {
                        object.unary = $root.CoreML.Specification.UnaryFunctionLayerParams.toObject(message.unary, options);
                        if (options.oneofs)
                            object.layer = "unary";
                    }
                    if (message.add != null && message.hasOwnProperty("add")) {
                        object.add = $root.CoreML.Specification.AddLayerParams.toObject(message.add, options);
                        if (options.oneofs)
                            object.layer = "add";
                    }
                    if (message.multiply != null && message.hasOwnProperty("multiply")) {
                        object.multiply = $root.CoreML.Specification.MultiplyLayerParams.toObject(message.multiply, options);
                        if (options.oneofs)
                            object.layer = "multiply";
                    }
                    if (message.average != null && message.hasOwnProperty("average")) {
                        object.average = $root.CoreML.Specification.AverageLayerParams.toObject(message.average, options);
                        if (options.oneofs)
                            object.layer = "average";
                    }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        object.scale = $root.CoreML.Specification.ScaleLayerParams.toObject(message.scale, options);
                        if (options.oneofs)
                            object.layer = "scale";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        object.bias = $root.CoreML.Specification.BiasLayerParams.toObject(message.bias, options);
                        if (options.oneofs)
                            object.layer = "bias";
                    }
                    if (message.max != null && message.hasOwnProperty("max")) {
                        object.max = $root.CoreML.Specification.MaxLayerParams.toObject(message.max, options);
                        if (options.oneofs)
                            object.layer = "max";
                    }
                    if (message.min != null && message.hasOwnProperty("min")) {
                        object.min = $root.CoreML.Specification.MinLayerParams.toObject(message.min, options);
                        if (options.oneofs)
                            object.layer = "min";
                    }
                    if (message.dot != null && message.hasOwnProperty("dot")) {
                        object.dot = $root.CoreML.Specification.DotProductLayerParams.toObject(message.dot, options);
                        if (options.oneofs)
                            object.layer = "dot";
                    }
                    if (message.reduce != null && message.hasOwnProperty("reduce")) {
                        object.reduce = $root.CoreML.Specification.ReduceLayerParams.toObject(message.reduce, options);
                        if (options.oneofs)
                            object.layer = "reduce";
                    }
                    if (message.loadConstant != null && message.hasOwnProperty("loadConstant")) {
                        object.loadConstant = $root.CoreML.Specification.LoadConstantLayerParams.toObject(message.loadConstant, options);
                        if (options.oneofs)
                            object.layer = "loadConstant";
                    }
                    if (message.reshape != null && message.hasOwnProperty("reshape")) {
                        object.reshape = $root.CoreML.Specification.ReshapeLayerParams.toObject(message.reshape, options);
                        if (options.oneofs)
                            object.layer = "reshape";
                    }
                    if (message.flatten != null && message.hasOwnProperty("flatten")) {
                        object.flatten = $root.CoreML.Specification.FlattenLayerParams.toObject(message.flatten, options);
                        if (options.oneofs)
                            object.layer = "flatten";
                    }
                    if (message.permute != null && message.hasOwnProperty("permute")) {
                        object.permute = $root.CoreML.Specification.PermuteLayerParams.toObject(message.permute, options);
                        if (options.oneofs)
                            object.layer = "permute";
                    }
                    if (message.concat != null && message.hasOwnProperty("concat")) {
                        object.concat = $root.CoreML.Specification.ConcatLayerParams.toObject(message.concat, options);
                        if (options.oneofs)
                            object.layer = "concat";
                    }
                    if (message.split != null && message.hasOwnProperty("split")) {
                        object.split = $root.CoreML.Specification.SplitLayerParams.toObject(message.split, options);
                        if (options.oneofs)
                            object.layer = "split";
                    }
                    if (message.sequenceRepeat != null && message.hasOwnProperty("sequenceRepeat")) {
                        object.sequenceRepeat = $root.CoreML.Specification.SequenceRepeatLayerParams.toObject(message.sequenceRepeat, options);
                        if (options.oneofs)
                            object.layer = "sequenceRepeat";
                    }
                    if (message.reorganizeData != null && message.hasOwnProperty("reorganizeData")) {
                        object.reorganizeData = $root.CoreML.Specification.ReorganizeDataLayerParams.toObject(message.reorganizeData, options);
                        if (options.oneofs)
                            object.layer = "reorganizeData";
                    }
                    if (message.slice != null && message.hasOwnProperty("slice")) {
                        object.slice = $root.CoreML.Specification.SliceLayerParams.toObject(message.slice, options);
                        if (options.oneofs)
                            object.layer = "slice";
                    }
                    if (message.simpleRecurrent != null && message.hasOwnProperty("simpleRecurrent")) {
                        object.simpleRecurrent = $root.CoreML.Specification.SimpleRecurrentLayerParams.toObject(message.simpleRecurrent, options);
                        if (options.oneofs)
                            object.layer = "simpleRecurrent";
                    }
                    if (message.gru != null && message.hasOwnProperty("gru")) {
                        object.gru = $root.CoreML.Specification.GRULayerParams.toObject(message.gru, options);
                        if (options.oneofs)
                            object.layer = "gru";
                    }
                    if (message.uniDirectionalLSTM != null && message.hasOwnProperty("uniDirectionalLSTM")) {
                        object.uniDirectionalLSTM = $root.CoreML.Specification.UniDirectionalLSTMLayerParams.toObject(message.uniDirectionalLSTM, options);
                        if (options.oneofs)
                            object.layer = "uniDirectionalLSTM";
                    }
                    if (message.biDirectionalLSTM != null && message.hasOwnProperty("biDirectionalLSTM")) {
                        object.biDirectionalLSTM = $root.CoreML.Specification.BiDirectionalLSTMLayerParams.toObject(message.biDirectionalLSTM, options);
                        if (options.oneofs)
                            object.layer = "biDirectionalLSTM";
                    }
                    if (message.custom != null && message.hasOwnProperty("custom")) {
                        object.custom = $root.CoreML.Specification.CustomLayerParams.toObject(message.custom, options);
                        if (options.oneofs)
                            object.layer = "custom";
                    }
                    return object;
                };
    
                /**
                 * Converts this NeuralNetworkLayer to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetworkLayer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetworkLayer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkLayer;
            })();
    
            Specification.BorderAmounts = (function() {
    
                /**
                 * Properties of a BorderAmounts.
                 * @memberof CoreML.Specification
                 * @interface IBorderAmounts
                 * @property {Array.<CoreML.Specification.BorderAmounts.IEdgeSizes>|null} [borderAmounts] The border amounts.
                 * This must be length 2 in the order ``[H, W]``.
                 */
    
                /**
                 * Constructs a new BorderAmounts.
                 * @memberof CoreML.Specification
                 * @classdesc Specifies the amount of spatial border to be either padded or cropped.
                 * 
                 * For padding:
                 * 
                 * .. code::
                 * 
                 * H_out = borderAmounts[0].startEdgeSize + H_in + borderAmounts[0].endEdgeSize
                 * W_out = borderAmounts[1].startEdgeSize + W_in + borderAmounts[1].endEdgeSize
                 * 
                 * topPaddingAmount == Height startEdgeSize
                 * bottomPaddingAmount == Height endEdgeSize
                 * leftPaddingAmount == Width startEdgeSize
                 * rightPaddingAmount == Width endEdgeSize
                 * 
                 * For cropping:
                 * 
                 * .. code::
                 * 
                 * H_out = (-borderAmounts[0].startEdgeSize) + H_in + (-borderAmounts[0].endEdgeSize)
                 * W_out = (-borderAmounts[1].startEdgeSize) + W_in + (-borderAmounts[1].endEdgeSize)
                 * 
                 * topCropAmount == Height startEdgeSize
                 * bottomCropAmount == Height endEdgeSize
                 * leftCropAmount == Width startEdgeSize
                 * rightCropAmount == Width endEdgeSize
                 * @implements IBorderAmounts
                 * @constructor
                 * @param {CoreML.Specification.IBorderAmounts=} [properties] Properties to set
                 */
                function BorderAmounts(properties) {
                    this.borderAmounts = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The border amounts.
                 * This must be length 2 in the order ``[H, W]``.
                 * @member {Array.<CoreML.Specification.BorderAmounts.IEdgeSizes>} borderAmounts
                 * @memberof CoreML.Specification.BorderAmounts
                 * @instance
                 */
                BorderAmounts.prototype.borderAmounts = $util.emptyArray;
    
                /**
                 * Creates a new BorderAmounts instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {CoreML.Specification.IBorderAmounts=} [properties] Properties to set
                 * @returns {CoreML.Specification.BorderAmounts} BorderAmounts instance
                 */
                BorderAmounts.create = function create(properties) {
                    return new BorderAmounts(properties);
                };
    
                /**
                 * Encodes the specified BorderAmounts message. Does not implicitly {@link CoreML.Specification.BorderAmounts.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {CoreML.Specification.IBorderAmounts} message BorderAmounts message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BorderAmounts.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.borderAmounts != null && message.borderAmounts.length)
                        for (var i = 0; i < message.borderAmounts.length; ++i)
                            $root.CoreML.Specification.BorderAmounts.EdgeSizes.encode(message.borderAmounts[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified BorderAmounts message, length delimited. Does not implicitly {@link CoreML.Specification.BorderAmounts.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {CoreML.Specification.IBorderAmounts} message BorderAmounts message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BorderAmounts.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BorderAmounts message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.BorderAmounts} BorderAmounts
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BorderAmounts.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BorderAmounts();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            if (!(message.borderAmounts && message.borderAmounts.length))
                                message.borderAmounts = [];
                            message.borderAmounts.push($root.CoreML.Specification.BorderAmounts.EdgeSizes.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BorderAmounts message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.BorderAmounts} BorderAmounts
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BorderAmounts.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BorderAmounts message.
                 * @function verify
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BorderAmounts.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.borderAmounts != null && message.hasOwnProperty("borderAmounts")) {
                        if (!Array.isArray(message.borderAmounts))
                            return "borderAmounts: array expected";
                        for (var i = 0; i < message.borderAmounts.length; ++i) {
                            var error = $root.CoreML.Specification.BorderAmounts.EdgeSizes.verify(message.borderAmounts[i]);
                            if (error)
                                return "borderAmounts." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a BorderAmounts message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.BorderAmounts} BorderAmounts
                 */
                BorderAmounts.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BorderAmounts)
                        return object;
                    var message = new $root.CoreML.Specification.BorderAmounts();
                    if (object.borderAmounts) {
                        if (!Array.isArray(object.borderAmounts))
                            throw TypeError(".CoreML.Specification.BorderAmounts.borderAmounts: array expected");
                        message.borderAmounts = [];
                        for (var i = 0; i < object.borderAmounts.length; ++i) {
                            if (typeof object.borderAmounts[i] !== "object")
                                throw TypeError(".CoreML.Specification.BorderAmounts.borderAmounts: object expected");
                            message.borderAmounts[i] = $root.CoreML.Specification.BorderAmounts.EdgeSizes.fromObject(object.borderAmounts[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BorderAmounts message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.BorderAmounts
                 * @static
                 * @param {CoreML.Specification.BorderAmounts} message BorderAmounts
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BorderAmounts.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.borderAmounts = [];
                    if (message.borderAmounts && message.borderAmounts.length) {
                        object.borderAmounts = [];
                        for (var j = 0; j < message.borderAmounts.length; ++j)
                            object.borderAmounts[j] = $root.CoreML.Specification.BorderAmounts.EdgeSizes.toObject(message.borderAmounts[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this BorderAmounts to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.BorderAmounts
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BorderAmounts.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                BorderAmounts.EdgeSizes = (function() {
    
                    /**
                     * Properties of an EdgeSizes.
                     * @memberof CoreML.Specification.BorderAmounts
                     * @interface IEdgeSizes
                     * @property {number|Long|null} [startEdgeSize] The amount to be padded or cropped from the beginning.
                     * @property {number|Long|null} [endEdgeSize] The amount to be padded or cropped from the end.
                     */
    
                    /**
                     * Constructs a new EdgeSizes.
                     * @memberof CoreML.Specification.BorderAmounts
                     * @classdesc Represents an EdgeSizes.
                     * @implements IEdgeSizes
                     * @constructor
                     * @param {CoreML.Specification.BorderAmounts.IEdgeSizes=} [properties] Properties to set
                     */
                    function EdgeSizes(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * The amount to be padded or cropped from the beginning.
                     * @member {number|Long} startEdgeSize
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @instance
                     */
                    EdgeSizes.prototype.startEdgeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * The amount to be padded or cropped from the end.
                     * @member {number|Long} endEdgeSize
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @instance
                     */
                    EdgeSizes.prototype.endEdgeSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * Creates a new EdgeSizes instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {CoreML.Specification.BorderAmounts.IEdgeSizes=} [properties] Properties to set
                     * @returns {CoreML.Specification.BorderAmounts.EdgeSizes} EdgeSizes instance
                     */
                    EdgeSizes.create = function create(properties) {
                        return new EdgeSizes(properties);
                    };
    
                    /**
                     * Encodes the specified EdgeSizes message. Does not implicitly {@link CoreML.Specification.BorderAmounts.EdgeSizes.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {CoreML.Specification.BorderAmounts.IEdgeSizes} message EdgeSizes message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EdgeSizes.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.startEdgeSize != null && message.hasOwnProperty("startEdgeSize"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startEdgeSize);
                        if (message.endEdgeSize != null && message.hasOwnProperty("endEdgeSize"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.endEdgeSize);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified EdgeSizes message, length delimited. Does not implicitly {@link CoreML.Specification.BorderAmounts.EdgeSizes.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {CoreML.Specification.BorderAmounts.IEdgeSizes} message EdgeSizes message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    EdgeSizes.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes an EdgeSizes message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.BorderAmounts.EdgeSizes} EdgeSizes
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EdgeSizes.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BorderAmounts.EdgeSizes();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.startEdgeSize = reader.uint64();
                                break;
                            case 2:
                                message.endEdgeSize = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes an EdgeSizes message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.BorderAmounts.EdgeSizes} EdgeSizes
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    EdgeSizes.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies an EdgeSizes message.
                     * @function verify
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EdgeSizes.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.startEdgeSize != null && message.hasOwnProperty("startEdgeSize"))
                            if (!$util.isInteger(message.startEdgeSize) && !(message.startEdgeSize && $util.isInteger(message.startEdgeSize.low) && $util.isInteger(message.startEdgeSize.high)))
                                return "startEdgeSize: integer|Long expected";
                        if (message.endEdgeSize != null && message.hasOwnProperty("endEdgeSize"))
                            if (!$util.isInteger(message.endEdgeSize) && !(message.endEdgeSize && $util.isInteger(message.endEdgeSize.low) && $util.isInteger(message.endEdgeSize.high)))
                                return "endEdgeSize: integer|Long expected";
                        return null;
                    };
    
                    /**
                     * Creates an EdgeSizes message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.BorderAmounts.EdgeSizes} EdgeSizes
                     */
                    EdgeSizes.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.BorderAmounts.EdgeSizes)
                            return object;
                        var message = new $root.CoreML.Specification.BorderAmounts.EdgeSizes();
                        if (object.startEdgeSize != null)
                            if ($util.Long)
                                (message.startEdgeSize = $util.Long.fromValue(object.startEdgeSize)).unsigned = true;
                            else if (typeof object.startEdgeSize === "string")
                                message.startEdgeSize = parseInt(object.startEdgeSize, 10);
                            else if (typeof object.startEdgeSize === "number")
                                message.startEdgeSize = object.startEdgeSize;
                            else if (typeof object.startEdgeSize === "object")
                                message.startEdgeSize = new $util.LongBits(object.startEdgeSize.low >>> 0, object.startEdgeSize.high >>> 0).toNumber(true);
                        if (object.endEdgeSize != null)
                            if ($util.Long)
                                (message.endEdgeSize = $util.Long.fromValue(object.endEdgeSize)).unsigned = true;
                            else if (typeof object.endEdgeSize === "string")
                                message.endEdgeSize = parseInt(object.endEdgeSize, 10);
                            else if (typeof object.endEdgeSize === "number")
                                message.endEdgeSize = object.endEdgeSize;
                            else if (typeof object.endEdgeSize === "object")
                                message.endEdgeSize = new $util.LongBits(object.endEdgeSize.low >>> 0, object.endEdgeSize.high >>> 0).toNumber(true);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from an EdgeSizes message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @static
                     * @param {CoreML.Specification.BorderAmounts.EdgeSizes} message EdgeSizes
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EdgeSizes.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.startEdgeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.startEdgeSize = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.endEdgeSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.endEdgeSize = options.longs === String ? "0" : 0;
                        }
                        if (message.startEdgeSize != null && message.hasOwnProperty("startEdgeSize"))
                            if (typeof message.startEdgeSize === "number")
                                object.startEdgeSize = options.longs === String ? String(message.startEdgeSize) : message.startEdgeSize;
                            else
                                object.startEdgeSize = options.longs === String ? $util.Long.prototype.toString.call(message.startEdgeSize) : options.longs === Number ? new $util.LongBits(message.startEdgeSize.low >>> 0, message.startEdgeSize.high >>> 0).toNumber(true) : message.startEdgeSize;
                        if (message.endEdgeSize != null && message.hasOwnProperty("endEdgeSize"))
                            if (typeof message.endEdgeSize === "number")
                                object.endEdgeSize = options.longs === String ? String(message.endEdgeSize) : message.endEdgeSize;
                            else
                                object.endEdgeSize = options.longs === String ? $util.Long.prototype.toString.call(message.endEdgeSize) : options.longs === Number ? new $util.LongBits(message.endEdgeSize.low >>> 0, message.endEdgeSize.high >>> 0).toNumber(true) : message.endEdgeSize;
                        return object;
                    };
    
                    /**
                     * Converts this EdgeSizes to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.BorderAmounts.EdgeSizes
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EdgeSizes.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return EdgeSizes;
                })();
    
                return BorderAmounts;
            })();
    
            Specification.ValidPadding = (function() {
    
                /**
                 * Properties of a ValidPadding.
                 * @memberof CoreML.Specification
                 * @interface IValidPadding
                 * @property {CoreML.Specification.IBorderAmounts|null} [paddingAmounts] ValidPadding paddingAmounts
                 */
    
                /**
                 * Constructs a new ValidPadding.
                 * @memberof CoreML.Specification
                 * @classdesc Specifies the type of padding to be used with Convolution/Deconvolution and Pooling layers.
                 * After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
                 * output spatial shape ``[H_out, W_out]``.
                 * 
                 * .. code::
                 * 
                 * topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
                 * bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
                 * leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
                 * rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
                 * 
                 * With Convolution or Pooling:
                 * 
                 * .. code::
                 * 
                 * H_out = int_division_round_down((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0]),stride[0]) + 1
                 * 
                 * which is same as:
                 * 
                 * .. code::
                 * 
                 * H_out = int_division_round_up((H_in + topPaddingAmount + bottomPaddingAmount - KernelSize[0] + 1),stride[0])
                 * 
                 * With Deconvolution:
                 * 
                 * .. code::
                 * 
                 * H_out = (H_in-1) * stride[0] + kernelSize[0] - (topPaddingAmount + bottomPaddingAmount)
                 * 
                 * 
                 * The equivalent expressions hold true for ``W_out`` as well.
                 * 
                 * 
                 * By default, the values of ``paddingAmounts`` are set to ``0``,
                 * which results in a "true" valid padding.
                 * If non-zero values are provided for ``paddingAmounts``,
                 * "valid" convolution/pooling is performed within the spatially expanded input.
                 * @implements IValidPadding
                 * @constructor
                 * @param {CoreML.Specification.IValidPadding=} [properties] Properties to set
                 */
                function ValidPadding(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ValidPadding paddingAmounts.
                 * @member {CoreML.Specification.IBorderAmounts|null|undefined} paddingAmounts
                 * @memberof CoreML.Specification.ValidPadding
                 * @instance
                 */
                ValidPadding.prototype.paddingAmounts = null;
    
                /**
                 * Creates a new ValidPadding instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {CoreML.Specification.IValidPadding=} [properties] Properties to set
                 * @returns {CoreML.Specification.ValidPadding} ValidPadding instance
                 */
                ValidPadding.create = function create(properties) {
                    return new ValidPadding(properties);
                };
    
                /**
                 * Encodes the specified ValidPadding message. Does not implicitly {@link CoreML.Specification.ValidPadding.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {CoreML.Specification.IValidPadding} message ValidPadding message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ValidPadding.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts"))
                        $root.CoreML.Specification.BorderAmounts.encode(message.paddingAmounts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ValidPadding message, length delimited. Does not implicitly {@link CoreML.Specification.ValidPadding.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {CoreML.Specification.IValidPadding} message ValidPadding message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ValidPadding.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ValidPadding message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ValidPadding} ValidPadding
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ValidPadding.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ValidPadding();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ValidPadding message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ValidPadding} ValidPadding
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ValidPadding.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ValidPadding message.
                 * @function verify
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ValidPadding.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts")) {
                        var error = $root.CoreML.Specification.BorderAmounts.verify(message.paddingAmounts);
                        if (error)
                            return "paddingAmounts." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ValidPadding message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ValidPadding} ValidPadding
                 */
                ValidPadding.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ValidPadding)
                        return object;
                    var message = new $root.CoreML.Specification.ValidPadding();
                    if (object.paddingAmounts != null) {
                        if (typeof object.paddingAmounts !== "object")
                            throw TypeError(".CoreML.Specification.ValidPadding.paddingAmounts: object expected");
                        message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.fromObject(object.paddingAmounts);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ValidPadding message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ValidPadding
                 * @static
                 * @param {CoreML.Specification.ValidPadding} message ValidPadding
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ValidPadding.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.paddingAmounts = null;
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts"))
                        object.paddingAmounts = $root.CoreML.Specification.BorderAmounts.toObject(message.paddingAmounts, options);
                    return object;
                };
    
                /**
                 * Converts this ValidPadding to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ValidPadding
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ValidPadding.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ValidPadding;
            })();
    
            Specification.SamePadding = (function() {
    
                /**
                 * Properties of a SamePadding.
                 * @memberof CoreML.Specification
                 * @interface ISamePadding
                 * @property {CoreML.Specification.SamePadding.SamePaddingMode|null} [asymmetryMode] SamePadding asymmetryMode
                 */
    
                /**
                 * Constructs a new SamePadding.
                 * @memberof CoreML.Specification
                 * @classdesc Specifies the type of padding to be used with Convolution/Deconvolution and pooling layers.
                 * After padding, input spatial shape: ``[H_in, W_in]``, gets modified to the
                 * output spatial shape ``[H_out, W_out]``.
                 * With Convolution or pooling:
                 * 
                 * .. code::
                 * 
                 * H_out = int_division_round_up(H_in,stride[0])
                 * W_out = int_division_round_up(W_in,stride[1])
                 * 
                 * This is achieved by using the following padding amounts:
                 * 
                 * .. code::
                 * 
                 * totalPaddingHeight = max(0,(H_out-1) * stride[0] + KernelSize[0] - Hin)
                 * totalPaddingWidth = max(0,(W_out-1) * stride[1] + KernelSize[1] - Win)
                 * 
                 * There are two modes of asymmetry:
                 * ``BOTTOM_RIGHT_HEAVY``, and ``TOP_LEFT_HEAVY``.
                 * 
                 * If the mode is ``BOTTOM_RIGHT_HEAVY``:
                 * 
                 * .. code::
                 * 
                 * topPaddingAmount = floor(totalPaddingHeight / 2)
                 * bottomPaddingAmount = totalPaddingHeight - topPaddingAmount
                 * leftPaddingAmount = floor(totalPaddingWidth / 2)
                 * rightPaddingAmount = totalPaddingWidth - leftPaddingAmount
                 * 
                 * If the mode is ``TOP_LEFT_HEAVY``:
                 * 
                 * .. code::
                 * 
                 * bottomPaddingAmount = floor(totalPaddingHeight / 2)
                 * topPaddingAmount = totalPaddingHeight - bottomPaddingAmount
                 * rightPaddingAmount = floor(totalPaddingWidth / 2)
                 * leftPaddingAmount = totalPaddingWidth - rightPaddingAmount
                 * 
                 * 
                 * With Deconvolution:
                 * 
                 * .. code::
                 * 
                 * H_out = H_in * stride[0]
                 * W_out = W_in * stride[1]
                 * @implements ISamePadding
                 * @constructor
                 * @param {CoreML.Specification.ISamePadding=} [properties] Properties to set
                 */
                function SamePadding(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SamePadding asymmetryMode.
                 * @member {CoreML.Specification.SamePadding.SamePaddingMode} asymmetryMode
                 * @memberof CoreML.Specification.SamePadding
                 * @instance
                 */
                SamePadding.prototype.asymmetryMode = 0;
    
                /**
                 * Creates a new SamePadding instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {CoreML.Specification.ISamePadding=} [properties] Properties to set
                 * @returns {CoreML.Specification.SamePadding} SamePadding instance
                 */
                SamePadding.create = function create(properties) {
                    return new SamePadding(properties);
                };
    
                /**
                 * Encodes the specified SamePadding message. Does not implicitly {@link CoreML.Specification.SamePadding.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {CoreML.Specification.ISamePadding} message SamePadding message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SamePadding.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.asymmetryMode != null && message.hasOwnProperty("asymmetryMode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.asymmetryMode);
                    return writer;
                };
    
                /**
                 * Encodes the specified SamePadding message, length delimited. Does not implicitly {@link CoreML.Specification.SamePadding.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {CoreML.Specification.ISamePadding} message SamePadding message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SamePadding.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SamePadding message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SamePadding} SamePadding
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SamePadding.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SamePadding();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.asymmetryMode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SamePadding message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SamePadding} SamePadding
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SamePadding.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SamePadding message.
                 * @function verify
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SamePadding.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.asymmetryMode != null && message.hasOwnProperty("asymmetryMode"))
                        switch (message.asymmetryMode) {
                        default:
                            return "asymmetryMode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a SamePadding message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SamePadding} SamePadding
                 */
                SamePadding.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SamePadding)
                        return object;
                    var message = new $root.CoreML.Specification.SamePadding();
                    switch (object.asymmetryMode) {
                    case "BOTTOM_RIGHT_HEAVY":
                    case 0:
                        message.asymmetryMode = 0;
                        break;
                    case "TOP_LEFT_HEAVY":
                    case 1:
                        message.asymmetryMode = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SamePadding message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SamePadding
                 * @static
                 * @param {CoreML.Specification.SamePadding} message SamePadding
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SamePadding.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.asymmetryMode = options.enums === String ? "BOTTOM_RIGHT_HEAVY" : 0;
                    if (message.asymmetryMode != null && message.hasOwnProperty("asymmetryMode"))
                        object.asymmetryMode = options.enums === String ? $root.CoreML.Specification.SamePadding.SamePaddingMode[message.asymmetryMode] : message.asymmetryMode;
                    return object;
                };
    
                /**
                 * Converts this SamePadding to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SamePadding
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SamePadding.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * SamePaddingMode enum.
                 * @name CoreML.Specification.SamePadding.SamePaddingMode
                 * @enum {string}
                 * @property {number} BOTTOM_RIGHT_HEAVY=0 BOTTOM_RIGHT_HEAVY value
                 * @property {number} TOP_LEFT_HEAVY=1 TOP_LEFT_HEAVY value
                 */
                SamePadding.SamePaddingMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "BOTTOM_RIGHT_HEAVY"] = 0;
                    values[valuesById[1] = "TOP_LEFT_HEAVY"] = 1;
                    return values;
                })();
    
                return SamePadding;
            })();
    
            Specification.WeightParams = (function() {
    
                /**
                 * Properties of a WeightParams.
                 * @memberof CoreML.Specification
                 * @interface IWeightParams
                 * @property {Array.<number>|null} [floatValue] Values specified in single / float / FP32 precision.
                 * @property {Uint8Array|null} [float16Value] Values in 16-bit half precision floating point.
                 * @property {Uint8Array|null} [rawValue] Raw value specification for smaller types. Currently only supported by custom layer implementations.
                 */
    
                /**
                 * Constructs a new WeightParams.
                 * @memberof CoreML.Specification
                 * @classdesc Weights for layer parameters.
                 * Weights are stored as repeated floating point numbers
                 * using row-major ordering
                 * and can represent 1-, 2-, 3-, or 4-dimensional data.
                 * @implements IWeightParams
                 * @constructor
                 * @param {CoreML.Specification.IWeightParams=} [properties] Properties to set
                 */
                function WeightParams(properties) {
                    this.floatValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Values specified in single / float / FP32 precision.
                 * @member {Array.<number>} floatValue
                 * @memberof CoreML.Specification.WeightParams
                 * @instance
                 */
                WeightParams.prototype.floatValue = $util.emptyArray;
    
                /**
                 * Values in 16-bit half precision floating point.
                 * @member {Uint8Array} float16Value
                 * @memberof CoreML.Specification.WeightParams
                 * @instance
                 */
                WeightParams.prototype.float16Value = $util.newBuffer([]);
    
                /**
                 * Raw value specification for smaller types. Currently only supported by custom layer implementations.
                 * @member {Uint8Array} rawValue
                 * @memberof CoreML.Specification.WeightParams
                 * @instance
                 */
                WeightParams.prototype.rawValue = $util.newBuffer([]);
    
                /**
                 * Creates a new WeightParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {CoreML.Specification.IWeightParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.WeightParams} WeightParams instance
                 */
                WeightParams.create = function create(properties) {
                    return new WeightParams(properties);
                };
    
                /**
                 * Encodes the specified WeightParams message. Does not implicitly {@link CoreML.Specification.WeightParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {CoreML.Specification.IWeightParams} message WeightParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WeightParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.floatValue != null && message.floatValue.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.floatValue.length; ++i)
                            writer.float(message.floatValue[i]);
                        writer.ldelim();
                    }
                    if (message.float16Value != null && message.hasOwnProperty("float16Value"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.float16Value);
                    if (message.rawValue != null && message.hasOwnProperty("rawValue"))
                        writer.uint32(/* id 30, wireType 2 =*/242).bytes(message.rawValue);
                    return writer;
                };
    
                /**
                 * Encodes the specified WeightParams message, length delimited. Does not implicitly {@link CoreML.Specification.WeightParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {CoreML.Specification.IWeightParams} message WeightParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                WeightParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a WeightParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.WeightParams} WeightParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WeightParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.WeightParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.floatValue && message.floatValue.length))
                                message.floatValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.floatValue.push(reader.float());
                            } else
                                message.floatValue.push(reader.float());
                            break;
                        case 2:
                            message.float16Value = reader.bytes();
                            break;
                        case 30:
                            message.rawValue = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a WeightParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.WeightParams} WeightParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                WeightParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a WeightParams message.
                 * @function verify
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                WeightParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                        if (!Array.isArray(message.floatValue))
                            return "floatValue: array expected";
                        for (var i = 0; i < message.floatValue.length; ++i)
                            if (typeof message.floatValue[i] !== "number")
                                return "floatValue: number[] expected";
                    }
                    if (message.float16Value != null && message.hasOwnProperty("float16Value"))
                        if (!(message.float16Value && typeof message.float16Value.length === "number" || $util.isString(message.float16Value)))
                            return "float16Value: buffer expected";
                    if (message.rawValue != null && message.hasOwnProperty("rawValue"))
                        if (!(message.rawValue && typeof message.rawValue.length === "number" || $util.isString(message.rawValue)))
                            return "rawValue: buffer expected";
                    return null;
                };
    
                /**
                 * Creates a WeightParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.WeightParams} WeightParams
                 */
                WeightParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.WeightParams)
                        return object;
                    var message = new $root.CoreML.Specification.WeightParams();
                    if (object.floatValue) {
                        if (!Array.isArray(object.floatValue))
                            throw TypeError(".CoreML.Specification.WeightParams.floatValue: array expected");
                        message.floatValue = [];
                        for (var i = 0; i < object.floatValue.length; ++i)
                            message.floatValue[i] = Number(object.floatValue[i]);
                    }
                    if (object.float16Value != null)
                        if (typeof object.float16Value === "string")
                            $util.base64.decode(object.float16Value, message.float16Value = $util.newBuffer($util.base64.length(object.float16Value)), 0);
                        else if (object.float16Value.length)
                            message.float16Value = object.float16Value;
                    if (object.rawValue != null)
                        if (typeof object.rawValue === "string")
                            $util.base64.decode(object.rawValue, message.rawValue = $util.newBuffer($util.base64.length(object.rawValue)), 0);
                        else if (object.rawValue.length)
                            message.rawValue = object.rawValue;
                    return message;
                };
    
                /**
                 * Creates a plain object from a WeightParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.WeightParams
                 * @static
                 * @param {CoreML.Specification.WeightParams} message WeightParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                WeightParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.floatValue = [];
                    if (options.defaults) {
                        object.float16Value = options.bytes === String ? "" : [];
                        object.rawValue = options.bytes === String ? "" : [];
                    }
                    if (message.floatValue && message.floatValue.length) {
                        object.floatValue = [];
                        for (var j = 0; j < message.floatValue.length; ++j)
                            object.floatValue[j] = options.json && !isFinite(message.floatValue[j]) ? String(message.floatValue[j]) : message.floatValue[j];
                    }
                    if (message.float16Value != null && message.hasOwnProperty("float16Value"))
                        object.float16Value = options.bytes === String ? $util.base64.encode(message.float16Value, 0, message.float16Value.length) : options.bytes === Array ? Array.prototype.slice.call(message.float16Value) : message.float16Value;
                    if (message.rawValue != null && message.hasOwnProperty("rawValue"))
                        object.rawValue = options.bytes === String ? $util.base64.encode(message.rawValue, 0, message.rawValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.rawValue) : message.rawValue;
                    return object;
                };
    
                /**
                 * Converts this WeightParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.WeightParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                WeightParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return WeightParams;
            })();
    
            Specification.ConvolutionLayerParams = (function() {
    
                /**
                 * Properties of a ConvolutionLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IConvolutionLayerParams
                 * @property {number|Long|null} [outputChannels] The number of kernels.
                 * Same as ``C_out`` used in the layer description.
                 * @property {number|Long|null} [kernelChannels] Channel dimension of the kernels.
                 * Must be equal to ``inputChannels / nGroups``, if isDeconvolution == False
                 * Must be equal to ``inputChannels``, if isDeconvolution == True
                 * @property {number|Long|null} [nGroups] Group convolution, i.e. weight reuse along channel axis.
                 * Input and kernels are divided into g groups
                 * and convolution / deconvolution is applied within the groups independently.
                 * If not set or 0, it is set to the default value 1.
                 * @property {Array.<number|Long>|null} [kernelSize] Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[3, 3]`` is used.
                 * @property {Array.<number|Long>|null} [stride] Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * @property {Array.<number|Long>|null} [dilationFactor] Must be length 2 in order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * It is ignored if ``isDeconvolution == true``.
                 * @property {CoreML.Specification.IValidPadding|null} [valid] ConvolutionLayerParams valid
                 * @property {CoreML.Specification.ISamePadding|null} [same] ConvolutionLayerParams same
                 * @property {boolean|null} [isDeconvolution] Flag to specify whether it is a deconvolution layer.
                 * @property {boolean|null} [hasBias] Flag to specify whether a bias is to be added or not.
                 * @property {CoreML.Specification.IWeightParams|null} [weights] Weights associated with this layer.
                 * If convolution (``isDeconvolution == false``), weights have the shape
                 * ``[outputChannels, kernelChannels, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels / nGroups
                 * If deconvolution (``isDeconvolution == true``) weights have the shape
                 * ``[kernelChannels, outputChannels / nGroups, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels
                 * @property {CoreML.Specification.IWeightParams|null} [bias] ConvolutionLayerParams bias
                 * @property {Array.<number|Long>|null} [outputShape] The output shape, which has length 2 ``[H_out, W_out]``.
                 * This is used only for deconvolution (``isDeconvolution == true``).
                 * If not set, the deconvolution output shape is calculated
                 * based on ``ConvolutionPaddingType``.
                 */
    
                /**
                 * Constructs a new ConvolutionLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs spatial convolution or deconvolution.
                 * 
                 * .. code::
                 * 
                 * y = ConvolutionLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[inputChannels,inputHeight,inputWidth]`` or ``[C_in, H_in, W_in]``.
                 * 
                 * Output
                 * A blob with shape ``[outputChannels,outputHeight,outputWidth]`` or  ``[C_out, H_out, W_out]``.
                 * 
                 * 
                 * If ``dilationFactor`` is not 1, effective kernel size is
                 * modified as follows:
                 * 
                 * .. code::
                 * 
                 * KernelSize[0] <-- (kernelSize[0]-1) * dilationFactor[0] + 1
                 * KernelSize[1] <-- (kernelSize[1]-1) * dilationFactor[1] + 1
                 * 
                 * Type of padding can be ``valid`` or ``same``. Output spatial dimensions depend on the
                 * the type of padding. For details, refer to the descriptions of the messages "ValidPadding"
                 * and "SamePadding". Padded values are all zeros.
                 * 
                 * For Deconvolution, ``ConvolutionPaddingType`` (``valid`` or ``same``) is ignored when ``outputShape`` is set.
                 * @implements IConvolutionLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IConvolutionLayerParams=} [properties] Properties to set
                 */
                function ConvolutionLayerParams(properties) {
                    this.kernelSize = [];
                    this.stride = [];
                    this.dilationFactor = [];
                    this.outputShape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The number of kernels.
                 * Same as ``C_out`` used in the layer description.
                 * @member {number|Long} outputChannels
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.outputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Channel dimension of the kernels.
                 * Must be equal to ``inputChannels / nGroups``, if isDeconvolution == False
                 * Must be equal to ``inputChannels``, if isDeconvolution == True
                 * @member {number|Long} kernelChannels
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.kernelChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Group convolution, i.e. weight reuse along channel axis.
                 * Input and kernels are divided into g groups
                 * and convolution / deconvolution is applied within the groups independently.
                 * If not set or 0, it is set to the default value 1.
                 * @member {number|Long} nGroups
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.nGroups = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[3, 3]`` is used.
                 * @member {Array.<number|Long>} kernelSize
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.kernelSize = $util.emptyArray;
    
                /**
                 * Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * @member {Array.<number|Long>} stride
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.stride = $util.emptyArray;
    
                /**
                 * Must be length 2 in order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * It is ignored if ``isDeconvolution == true``.
                 * @member {Array.<number|Long>} dilationFactor
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.dilationFactor = $util.emptyArray;
    
                /**
                 * ConvolutionLayerParams valid.
                 * @member {CoreML.Specification.IValidPadding|null|undefined} valid
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.valid = null;
    
                /**
                 * ConvolutionLayerParams same.
                 * @member {CoreML.Specification.ISamePadding|null|undefined} same
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.same = null;
    
                /**
                 * Flag to specify whether it is a deconvolution layer.
                 * @member {boolean} isDeconvolution
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.isDeconvolution = false;
    
                /**
                 * Flag to specify whether a bias is to be added or not.
                 * @member {boolean} hasBias
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.hasBias = false;
    
                /**
                 * Weights associated with this layer.
                 * If convolution (``isDeconvolution == false``), weights have the shape
                 * ``[outputChannels, kernelChannels, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels / nGroups
                 * If deconvolution (``isDeconvolution == true``) weights have the shape
                 * ``[kernelChannels, outputChannels / nGroups, kernelHeight, kernelWidth]``, where kernelChannels == inputChannels
                 * @member {CoreML.Specification.IWeightParams|null|undefined} weights
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.weights = null;
    
                /**
                 * ConvolutionLayerParams bias.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} bias
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.bias = null;
    
                /**
                 * The output shape, which has length 2 ``[H_out, W_out]``.
                 * This is used only for deconvolution (``isDeconvolution == true``).
                 * If not set, the deconvolution output shape is calculated
                 * based on ``ConvolutionPaddingType``.
                 * @member {Array.<number|Long>} outputShape
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                ConvolutionLayerParams.prototype.outputShape = $util.emptyArray;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * The type of padding.
                 * @member {"valid"|"same"|undefined} ConvolutionPaddingType
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 */
                Object.defineProperty(ConvolutionLayerParams.prototype, "ConvolutionPaddingType", {
                    get: $util.oneOfGetter($oneOfFields = ["valid", "same"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new ConvolutionLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {CoreML.Specification.IConvolutionLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ConvolutionLayerParams} ConvolutionLayerParams instance
                 */
                ConvolutionLayerParams.create = function create(properties) {
                    return new ConvolutionLayerParams(properties);
                };
    
                /**
                 * Encodes the specified ConvolutionLayerParams message. Does not implicitly {@link CoreML.Specification.ConvolutionLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {CoreML.Specification.IConvolutionLayerParams} message ConvolutionLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConvolutionLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.outputChannels);
                    if (message.kernelChannels != null && message.hasOwnProperty("kernelChannels"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.kernelChannels);
                    if (message.nGroups != null && message.hasOwnProperty("nGroups"))
                        writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.nGroups);
                    if (message.kernelSize != null && message.kernelSize.length) {
                        writer.uint32(/* id 20, wireType 2 =*/162).fork();
                        for (var i = 0; i < message.kernelSize.length; ++i)
                            writer.uint64(message.kernelSize[i]);
                        writer.ldelim();
                    }
                    if (message.stride != null && message.stride.length) {
                        writer.uint32(/* id 30, wireType 2 =*/242).fork();
                        for (var i = 0; i < message.stride.length; ++i)
                            writer.uint64(message.stride[i]);
                        writer.ldelim();
                    }
                    if (message.dilationFactor != null && message.dilationFactor.length) {
                        writer.uint32(/* id 40, wireType 2 =*/322).fork();
                        for (var i = 0; i < message.dilationFactor.length; ++i)
                            writer.uint64(message.dilationFactor[i]);
                        writer.ldelim();
                    }
                    if (message.valid != null && message.hasOwnProperty("valid"))
                        $root.CoreML.Specification.ValidPadding.encode(message.valid, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                    if (message.same != null && message.hasOwnProperty("same"))
                        $root.CoreML.Specification.SamePadding.encode(message.same, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
                    if (message.isDeconvolution != null && message.hasOwnProperty("isDeconvolution"))
                        writer.uint32(/* id 60, wireType 0 =*/480).bool(message.isDeconvolution);
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        writer.uint32(/* id 70, wireType 0 =*/560).bool(message.hasBias);
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        $root.CoreML.Specification.WeightParams.encode(message.weights, writer.uint32(/* id 90, wireType 2 =*/722).fork()).ldelim();
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        $root.CoreML.Specification.WeightParams.encode(message.bias, writer.uint32(/* id 91, wireType 2 =*/730).fork()).ldelim();
                    if (message.outputShape != null && message.outputShape.length) {
                        writer.uint32(/* id 100, wireType 2 =*/802).fork();
                        for (var i = 0; i < message.outputShape.length; ++i)
                            writer.uint64(message.outputShape[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified ConvolutionLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.ConvolutionLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {CoreML.Specification.IConvolutionLayerParams} message ConvolutionLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConvolutionLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConvolutionLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ConvolutionLayerParams} ConvolutionLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConvolutionLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ConvolutionLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.outputChannels = reader.uint64();
                            break;
                        case 2:
                            message.kernelChannels = reader.uint64();
                            break;
                        case 10:
                            message.nGroups = reader.uint64();
                            break;
                        case 20:
                            if (!(message.kernelSize && message.kernelSize.length))
                                message.kernelSize = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.kernelSize.push(reader.uint64());
                            } else
                                message.kernelSize.push(reader.uint64());
                            break;
                        case 30:
                            if (!(message.stride && message.stride.length))
                                message.stride = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.stride.push(reader.uint64());
                            } else
                                message.stride.push(reader.uint64());
                            break;
                        case 40:
                            if (!(message.dilationFactor && message.dilationFactor.length))
                                message.dilationFactor = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.dilationFactor.push(reader.uint64());
                            } else
                                message.dilationFactor.push(reader.uint64());
                            break;
                        case 50:
                            message.valid = $root.CoreML.Specification.ValidPadding.decode(reader, reader.uint32());
                            break;
                        case 51:
                            message.same = $root.CoreML.Specification.SamePadding.decode(reader, reader.uint32());
                            break;
                        case 60:
                            message.isDeconvolution = reader.bool();
                            break;
                        case 70:
                            message.hasBias = reader.bool();
                            break;
                        case 90:
                            message.weights = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 91:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            if (!(message.outputShape && message.outputShape.length))
                                message.outputShape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.outputShape.push(reader.uint64());
                            } else
                                message.outputShape.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConvolutionLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ConvolutionLayerParams} ConvolutionLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConvolutionLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConvolutionLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConvolutionLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (!$util.isInteger(message.outputChannels) && !(message.outputChannels && $util.isInteger(message.outputChannels.low) && $util.isInteger(message.outputChannels.high)))
                            return "outputChannels: integer|Long expected";
                    if (message.kernelChannels != null && message.hasOwnProperty("kernelChannels"))
                        if (!$util.isInteger(message.kernelChannels) && !(message.kernelChannels && $util.isInteger(message.kernelChannels.low) && $util.isInteger(message.kernelChannels.high)))
                            return "kernelChannels: integer|Long expected";
                    if (message.nGroups != null && message.hasOwnProperty("nGroups"))
                        if (!$util.isInteger(message.nGroups) && !(message.nGroups && $util.isInteger(message.nGroups.low) && $util.isInteger(message.nGroups.high)))
                            return "nGroups: integer|Long expected";
                    if (message.kernelSize != null && message.hasOwnProperty("kernelSize")) {
                        if (!Array.isArray(message.kernelSize))
                            return "kernelSize: array expected";
                        for (var i = 0; i < message.kernelSize.length; ++i)
                            if (!$util.isInteger(message.kernelSize[i]) && !(message.kernelSize[i] && $util.isInteger(message.kernelSize[i].low) && $util.isInteger(message.kernelSize[i].high)))
                                return "kernelSize: integer|Long[] expected";
                    }
                    if (message.stride != null && message.hasOwnProperty("stride")) {
                        if (!Array.isArray(message.stride))
                            return "stride: array expected";
                        for (var i = 0; i < message.stride.length; ++i)
                            if (!$util.isInteger(message.stride[i]) && !(message.stride[i] && $util.isInteger(message.stride[i].low) && $util.isInteger(message.stride[i].high)))
                                return "stride: integer|Long[] expected";
                    }
                    if (message.dilationFactor != null && message.hasOwnProperty("dilationFactor")) {
                        if (!Array.isArray(message.dilationFactor))
                            return "dilationFactor: array expected";
                        for (var i = 0; i < message.dilationFactor.length; ++i)
                            if (!$util.isInteger(message.dilationFactor[i]) && !(message.dilationFactor[i] && $util.isInteger(message.dilationFactor[i].low) && $util.isInteger(message.dilationFactor[i].high)))
                                return "dilationFactor: integer|Long[] expected";
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        properties.ConvolutionPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.ValidPadding.verify(message.valid);
                            if (error)
                                return "valid." + error;
                        }
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        if (properties.ConvolutionPaddingType === 1)
                            return "ConvolutionPaddingType: multiple values";
                        properties.ConvolutionPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.SamePadding.verify(message.same);
                            if (error)
                                return "same." + error;
                        }
                    }
                    if (message.isDeconvolution != null && message.hasOwnProperty("isDeconvolution"))
                        if (typeof message.isDeconvolution !== "boolean")
                            return "isDeconvolution: boolean expected";
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weights);
                        if (error)
                            return "weights." + error;
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    if (message.outputShape != null && message.hasOwnProperty("outputShape")) {
                        if (!Array.isArray(message.outputShape))
                            return "outputShape: array expected";
                        for (var i = 0; i < message.outputShape.length; ++i)
                            if (!$util.isInteger(message.outputShape[i]) && !(message.outputShape[i] && $util.isInteger(message.outputShape[i].low) && $util.isInteger(message.outputShape[i].high)))
                                return "outputShape: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a ConvolutionLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ConvolutionLayerParams} ConvolutionLayerParams
                 */
                ConvolutionLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ConvolutionLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ConvolutionLayerParams();
                    if (object.outputChannels != null)
                        if ($util.Long)
                            (message.outputChannels = $util.Long.fromValue(object.outputChannels)).unsigned = true;
                        else if (typeof object.outputChannels === "string")
                            message.outputChannels = parseInt(object.outputChannels, 10);
                        else if (typeof object.outputChannels === "number")
                            message.outputChannels = object.outputChannels;
                        else if (typeof object.outputChannels === "object")
                            message.outputChannels = new $util.LongBits(object.outputChannels.low >>> 0, object.outputChannels.high >>> 0).toNumber(true);
                    if (object.kernelChannels != null)
                        if ($util.Long)
                            (message.kernelChannels = $util.Long.fromValue(object.kernelChannels)).unsigned = true;
                        else if (typeof object.kernelChannels === "string")
                            message.kernelChannels = parseInt(object.kernelChannels, 10);
                        else if (typeof object.kernelChannels === "number")
                            message.kernelChannels = object.kernelChannels;
                        else if (typeof object.kernelChannels === "object")
                            message.kernelChannels = new $util.LongBits(object.kernelChannels.low >>> 0, object.kernelChannels.high >>> 0).toNumber(true);
                    if (object.nGroups != null)
                        if ($util.Long)
                            (message.nGroups = $util.Long.fromValue(object.nGroups)).unsigned = true;
                        else if (typeof object.nGroups === "string")
                            message.nGroups = parseInt(object.nGroups, 10);
                        else if (typeof object.nGroups === "number")
                            message.nGroups = object.nGroups;
                        else if (typeof object.nGroups === "object")
                            message.nGroups = new $util.LongBits(object.nGroups.low >>> 0, object.nGroups.high >>> 0).toNumber(true);
                    if (object.kernelSize) {
                        if (!Array.isArray(object.kernelSize))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.kernelSize: array expected");
                        message.kernelSize = [];
                        for (var i = 0; i < object.kernelSize.length; ++i)
                            if ($util.Long)
                                (message.kernelSize[i] = $util.Long.fromValue(object.kernelSize[i])).unsigned = true;
                            else if (typeof object.kernelSize[i] === "string")
                                message.kernelSize[i] = parseInt(object.kernelSize[i], 10);
                            else if (typeof object.kernelSize[i] === "number")
                                message.kernelSize[i] = object.kernelSize[i];
                            else if (typeof object.kernelSize[i] === "object")
                                message.kernelSize[i] = new $util.LongBits(object.kernelSize[i].low >>> 0, object.kernelSize[i].high >>> 0).toNumber(true);
                    }
                    if (object.stride) {
                        if (!Array.isArray(object.stride))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.stride: array expected");
                        message.stride = [];
                        for (var i = 0; i < object.stride.length; ++i)
                            if ($util.Long)
                                (message.stride[i] = $util.Long.fromValue(object.stride[i])).unsigned = true;
                            else if (typeof object.stride[i] === "string")
                                message.stride[i] = parseInt(object.stride[i], 10);
                            else if (typeof object.stride[i] === "number")
                                message.stride[i] = object.stride[i];
                            else if (typeof object.stride[i] === "object")
                                message.stride[i] = new $util.LongBits(object.stride[i].low >>> 0, object.stride[i].high >>> 0).toNumber(true);
                    }
                    if (object.dilationFactor) {
                        if (!Array.isArray(object.dilationFactor))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.dilationFactor: array expected");
                        message.dilationFactor = [];
                        for (var i = 0; i < object.dilationFactor.length; ++i)
                            if ($util.Long)
                                (message.dilationFactor[i] = $util.Long.fromValue(object.dilationFactor[i])).unsigned = true;
                            else if (typeof object.dilationFactor[i] === "string")
                                message.dilationFactor[i] = parseInt(object.dilationFactor[i], 10);
                            else if (typeof object.dilationFactor[i] === "number")
                                message.dilationFactor[i] = object.dilationFactor[i];
                            else if (typeof object.dilationFactor[i] === "object")
                                message.dilationFactor[i] = new $util.LongBits(object.dilationFactor[i].low >>> 0, object.dilationFactor[i].high >>> 0).toNumber(true);
                    }
                    if (object.valid != null) {
                        if (typeof object.valid !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.valid: object expected");
                        message.valid = $root.CoreML.Specification.ValidPadding.fromObject(object.valid);
                    }
                    if (object.same != null) {
                        if (typeof object.same !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.same: object expected");
                        message.same = $root.CoreML.Specification.SamePadding.fromObject(object.same);
                    }
                    if (object.isDeconvolution != null)
                        message.isDeconvolution = Boolean(object.isDeconvolution);
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.weights != null) {
                        if (typeof object.weights !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.weights: object expected");
                        message.weights = $root.CoreML.Specification.WeightParams.fromObject(object.weights);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    if (object.outputShape) {
                        if (!Array.isArray(object.outputShape))
                            throw TypeError(".CoreML.Specification.ConvolutionLayerParams.outputShape: array expected");
                        message.outputShape = [];
                        for (var i = 0; i < object.outputShape.length; ++i)
                            if ($util.Long)
                                (message.outputShape[i] = $util.Long.fromValue(object.outputShape[i])).unsigned = true;
                            else if (typeof object.outputShape[i] === "string")
                                message.outputShape[i] = parseInt(object.outputShape[i], 10);
                            else if (typeof object.outputShape[i] === "number")
                                message.outputShape[i] = object.outputShape[i];
                            else if (typeof object.outputShape[i] === "object")
                                message.outputShape[i] = new $util.LongBits(object.outputShape[i].low >>> 0, object.outputShape[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConvolutionLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @static
                 * @param {CoreML.Specification.ConvolutionLayerParams} message ConvolutionLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConvolutionLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.kernelSize = [];
                        object.stride = [];
                        object.dilationFactor = [];
                        object.outputShape = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputChannels = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.kernelChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.kernelChannels = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nGroups = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nGroups = options.longs === String ? "0" : 0;
                        object.isDeconvolution = false;
                        object.hasBias = false;
                        object.weights = null;
                        object.bias = null;
                    }
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (typeof message.outputChannels === "number")
                            object.outputChannels = options.longs === String ? String(message.outputChannels) : message.outputChannels;
                        else
                            object.outputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.outputChannels) : options.longs === Number ? new $util.LongBits(message.outputChannels.low >>> 0, message.outputChannels.high >>> 0).toNumber(true) : message.outputChannels;
                    if (message.kernelChannels != null && message.hasOwnProperty("kernelChannels"))
                        if (typeof message.kernelChannels === "number")
                            object.kernelChannels = options.longs === String ? String(message.kernelChannels) : message.kernelChannels;
                        else
                            object.kernelChannels = options.longs === String ? $util.Long.prototype.toString.call(message.kernelChannels) : options.longs === Number ? new $util.LongBits(message.kernelChannels.low >>> 0, message.kernelChannels.high >>> 0).toNumber(true) : message.kernelChannels;
                    if (message.nGroups != null && message.hasOwnProperty("nGroups"))
                        if (typeof message.nGroups === "number")
                            object.nGroups = options.longs === String ? String(message.nGroups) : message.nGroups;
                        else
                            object.nGroups = options.longs === String ? $util.Long.prototype.toString.call(message.nGroups) : options.longs === Number ? new $util.LongBits(message.nGroups.low >>> 0, message.nGroups.high >>> 0).toNumber(true) : message.nGroups;
                    if (message.kernelSize && message.kernelSize.length) {
                        object.kernelSize = [];
                        for (var j = 0; j < message.kernelSize.length; ++j)
                            if (typeof message.kernelSize[j] === "number")
                                object.kernelSize[j] = options.longs === String ? String(message.kernelSize[j]) : message.kernelSize[j];
                            else
                                object.kernelSize[j] = options.longs === String ? $util.Long.prototype.toString.call(message.kernelSize[j]) : options.longs === Number ? new $util.LongBits(message.kernelSize[j].low >>> 0, message.kernelSize[j].high >>> 0).toNumber(true) : message.kernelSize[j];
                    }
                    if (message.stride && message.stride.length) {
                        object.stride = [];
                        for (var j = 0; j < message.stride.length; ++j)
                            if (typeof message.stride[j] === "number")
                                object.stride[j] = options.longs === String ? String(message.stride[j]) : message.stride[j];
                            else
                                object.stride[j] = options.longs === String ? $util.Long.prototype.toString.call(message.stride[j]) : options.longs === Number ? new $util.LongBits(message.stride[j].low >>> 0, message.stride[j].high >>> 0).toNumber(true) : message.stride[j];
                    }
                    if (message.dilationFactor && message.dilationFactor.length) {
                        object.dilationFactor = [];
                        for (var j = 0; j < message.dilationFactor.length; ++j)
                            if (typeof message.dilationFactor[j] === "number")
                                object.dilationFactor[j] = options.longs === String ? String(message.dilationFactor[j]) : message.dilationFactor[j];
                            else
                                object.dilationFactor[j] = options.longs === String ? $util.Long.prototype.toString.call(message.dilationFactor[j]) : options.longs === Number ? new $util.LongBits(message.dilationFactor[j].low >>> 0, message.dilationFactor[j].high >>> 0).toNumber(true) : message.dilationFactor[j];
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        object.valid = $root.CoreML.Specification.ValidPadding.toObject(message.valid, options);
                        if (options.oneofs)
                            object.ConvolutionPaddingType = "valid";
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        object.same = $root.CoreML.Specification.SamePadding.toObject(message.same, options);
                        if (options.oneofs)
                            object.ConvolutionPaddingType = "same";
                    }
                    if (message.isDeconvolution != null && message.hasOwnProperty("isDeconvolution"))
                        object.isDeconvolution = message.isDeconvolution;
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        object.weights = $root.CoreML.Specification.WeightParams.toObject(message.weights, options);
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    if (message.outputShape && message.outputShape.length) {
                        object.outputShape = [];
                        for (var j = 0; j < message.outputShape.length; ++j)
                            if (typeof message.outputShape[j] === "number")
                                object.outputShape[j] = options.longs === String ? String(message.outputShape[j]) : message.outputShape[j];
                            else
                                object.outputShape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.outputShape[j]) : options.longs === Number ? new $util.LongBits(message.outputShape[j].low >>> 0, message.outputShape[j].high >>> 0).toNumber(true) : message.outputShape[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this ConvolutionLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ConvolutionLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConvolutionLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConvolutionLayerParams;
            })();
    
            Specification.InnerProductLayerParams = (function() {
    
                /**
                 * Properties of an InnerProductLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IInnerProductLayerParams
                 * @property {number|Long|null} [inputChannels] Input size: C_in.
                 * @property {number|Long|null} [outputChannels] Output size: C_out.
                 * @property {boolean|null} [hasBias] Whether a bias is added or not.
                 * @property {CoreML.Specification.IWeightParams|null} [weights] Weight matrix [C_out, C_in].
                 * @property {CoreML.Specification.IWeightParams|null} [bias] Bias vector [C_out].
                 */
    
                /**
                 * Constructs a new InnerProductLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs a matrix vector product.
                 * This is equivalent to a fully-connected, or dense layer.
                 * 
                 * .. code::
                 * 
                 * y = InnerProductLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C_in]`` or ``[C_in, 1, 1]``, where ``C_in`` is equal to ``inputChannels``.
                 * 
                 * Output
                 * A blob with shape ``[C_out]``, where ``C_out`` is equal to ``outputChannels``.
                 * @implements IInnerProductLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IInnerProductLayerParams=} [properties] Properties to set
                 */
                function InnerProductLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Input size: C_in.
                 * @member {number|Long} inputChannels
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @instance
                 */
                InnerProductLayerParams.prototype.inputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Output size: C_out.
                 * @member {number|Long} outputChannels
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @instance
                 */
                InnerProductLayerParams.prototype.outputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Whether a bias is added or not.
                 * @member {boolean} hasBias
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @instance
                 */
                InnerProductLayerParams.prototype.hasBias = false;
    
                /**
                 * Weight matrix [C_out, C_in].
                 * @member {CoreML.Specification.IWeightParams|null|undefined} weights
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @instance
                 */
                InnerProductLayerParams.prototype.weights = null;
    
                /**
                 * Bias vector [C_out].
                 * @member {CoreML.Specification.IWeightParams|null|undefined} bias
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @instance
                 */
                InnerProductLayerParams.prototype.bias = null;
    
                /**
                 * Creates a new InnerProductLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {CoreML.Specification.IInnerProductLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.InnerProductLayerParams} InnerProductLayerParams instance
                 */
                InnerProductLayerParams.create = function create(properties) {
                    return new InnerProductLayerParams(properties);
                };
    
                /**
                 * Encodes the specified InnerProductLayerParams message. Does not implicitly {@link CoreML.Specification.InnerProductLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {CoreML.Specification.IInnerProductLayerParams} message InnerProductLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InnerProductLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputChannels != null && message.hasOwnProperty("inputChannels"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inputChannels);
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputChannels);
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasBias);
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        $root.CoreML.Specification.WeightParams.encode(message.weights, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        $root.CoreML.Specification.WeightParams.encode(message.bias, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified InnerProductLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.InnerProductLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {CoreML.Specification.IInnerProductLayerParams} message InnerProductLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InnerProductLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an InnerProductLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.InnerProductLayerParams} InnerProductLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InnerProductLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.InnerProductLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputChannels = reader.uint64();
                            break;
                        case 2:
                            message.outputChannels = reader.uint64();
                            break;
                        case 10:
                            message.hasBias = reader.bool();
                            break;
                        case 20:
                            message.weights = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an InnerProductLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.InnerProductLayerParams} InnerProductLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InnerProductLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an InnerProductLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InnerProductLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputChannels != null && message.hasOwnProperty("inputChannels"))
                        if (!$util.isInteger(message.inputChannels) && !(message.inputChannels && $util.isInteger(message.inputChannels.low) && $util.isInteger(message.inputChannels.high)))
                            return "inputChannels: integer|Long expected";
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (!$util.isInteger(message.outputChannels) && !(message.outputChannels && $util.isInteger(message.outputChannels.low) && $util.isInteger(message.outputChannels.high)))
                            return "outputChannels: integer|Long expected";
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weights);
                        if (error)
                            return "weights." + error;
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an InnerProductLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.InnerProductLayerParams} InnerProductLayerParams
                 */
                InnerProductLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.InnerProductLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.InnerProductLayerParams();
                    if (object.inputChannels != null)
                        if ($util.Long)
                            (message.inputChannels = $util.Long.fromValue(object.inputChannels)).unsigned = true;
                        else if (typeof object.inputChannels === "string")
                            message.inputChannels = parseInt(object.inputChannels, 10);
                        else if (typeof object.inputChannels === "number")
                            message.inputChannels = object.inputChannels;
                        else if (typeof object.inputChannels === "object")
                            message.inputChannels = new $util.LongBits(object.inputChannels.low >>> 0, object.inputChannels.high >>> 0).toNumber(true);
                    if (object.outputChannels != null)
                        if ($util.Long)
                            (message.outputChannels = $util.Long.fromValue(object.outputChannels)).unsigned = true;
                        else if (typeof object.outputChannels === "string")
                            message.outputChannels = parseInt(object.outputChannels, 10);
                        else if (typeof object.outputChannels === "number")
                            message.outputChannels = object.outputChannels;
                        else if (typeof object.outputChannels === "object")
                            message.outputChannels = new $util.LongBits(object.outputChannels.low >>> 0, object.outputChannels.high >>> 0).toNumber(true);
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.weights != null) {
                        if (typeof object.weights !== "object")
                            throw TypeError(".CoreML.Specification.InnerProductLayerParams.weights: object expected");
                        message.weights = $root.CoreML.Specification.WeightParams.fromObject(object.weights);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.InnerProductLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an InnerProductLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @static
                 * @param {CoreML.Specification.InnerProductLayerParams} message InnerProductLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InnerProductLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputChannels = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputChannels = options.longs === String ? "0" : 0;
                        object.hasBias = false;
                        object.weights = null;
                        object.bias = null;
                    }
                    if (message.inputChannels != null && message.hasOwnProperty("inputChannels"))
                        if (typeof message.inputChannels === "number")
                            object.inputChannels = options.longs === String ? String(message.inputChannels) : message.inputChannels;
                        else
                            object.inputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.inputChannels) : options.longs === Number ? new $util.LongBits(message.inputChannels.low >>> 0, message.inputChannels.high >>> 0).toNumber(true) : message.inputChannels;
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (typeof message.outputChannels === "number")
                            object.outputChannels = options.longs === String ? String(message.outputChannels) : message.outputChannels;
                        else
                            object.outputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.outputChannels) : options.longs === Number ? new $util.LongBits(message.outputChannels.low >>> 0, message.outputChannels.high >>> 0).toNumber(true) : message.outputChannels;
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        object.weights = $root.CoreML.Specification.WeightParams.toObject(message.weights, options);
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                /**
                 * Converts this InnerProductLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.InnerProductLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InnerProductLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return InnerProductLayerParams;
            })();
    
            Specification.EmbeddingLayerParams = (function() {
    
                /**
                 * Properties of an EmbeddingLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IEmbeddingLayerParams
                 * @property {number|Long|null} [inputDim] Size of the input dictionary.
                 * @property {number|Long|null} [outputChannels] Size of the output vectors.
                 * @property {boolean|null} [hasBias] Whether a bias is added or not.
                 * @property {CoreML.Specification.IWeightParams|null} [weights] 2-D weights of dimensions [outputChannels, inputDim].
                 * @property {CoreML.Specification.IWeightParams|null} [bias] Bias of size [outputChannels].
                 */
    
                /**
                 * Constructs a new EmbeddingLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs a matrix lookup and optionally adds a bias.
                 * 
                 * .. code::
                 * 
                 * y = EmbeddingLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A sequence of integers with shape ``[1]`` or ``[1, 1, 1]``, (equivalent to ``[Seq_length, 1, 1, 1]``).
                 * Input values must be in the range ``[0, inputDim - 1]``.
                 * 
                 * Output
                 * A sequence of 1-dimensional features of size ``outputChannels``
                 * (equivalent to ``[Seq_length, outputChannels, 1, 1]``).
                 * @implements IEmbeddingLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IEmbeddingLayerParams=} [properties] Properties to set
                 */
                function EmbeddingLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Size of the input dictionary.
                 * @member {number|Long} inputDim
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @instance
                 */
                EmbeddingLayerParams.prototype.inputDim = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Size of the output vectors.
                 * @member {number|Long} outputChannels
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @instance
                 */
                EmbeddingLayerParams.prototype.outputChannels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Whether a bias is added or not.
                 * @member {boolean} hasBias
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @instance
                 */
                EmbeddingLayerParams.prototype.hasBias = false;
    
                /**
                 * 2-D weights of dimensions [outputChannels, inputDim].
                 * @member {CoreML.Specification.IWeightParams|null|undefined} weights
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @instance
                 */
                EmbeddingLayerParams.prototype.weights = null;
    
                /**
                 * Bias of size [outputChannels].
                 * @member {CoreML.Specification.IWeightParams|null|undefined} bias
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @instance
                 */
                EmbeddingLayerParams.prototype.bias = null;
    
                /**
                 * Creates a new EmbeddingLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {CoreML.Specification.IEmbeddingLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.EmbeddingLayerParams} EmbeddingLayerParams instance
                 */
                EmbeddingLayerParams.create = function create(properties) {
                    return new EmbeddingLayerParams(properties);
                };
    
                /**
                 * Encodes the specified EmbeddingLayerParams message. Does not implicitly {@link CoreML.Specification.EmbeddingLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {CoreML.Specification.IEmbeddingLayerParams} message EmbeddingLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmbeddingLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputDim != null && message.hasOwnProperty("inputDim"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inputDim);
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputChannels);
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.hasBias);
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        $root.CoreML.Specification.WeightParams.encode(message.weights, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        $root.CoreML.Specification.WeightParams.encode(message.bias, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified EmbeddingLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.EmbeddingLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {CoreML.Specification.IEmbeddingLayerParams} message EmbeddingLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                EmbeddingLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an EmbeddingLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.EmbeddingLayerParams} EmbeddingLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmbeddingLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.EmbeddingLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputDim = reader.uint64();
                            break;
                        case 2:
                            message.outputChannels = reader.uint64();
                            break;
                        case 10:
                            message.hasBias = reader.bool();
                            break;
                        case 20:
                            message.weights = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an EmbeddingLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.EmbeddingLayerParams} EmbeddingLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                EmbeddingLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an EmbeddingLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EmbeddingLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputDim != null && message.hasOwnProperty("inputDim"))
                        if (!$util.isInteger(message.inputDim) && !(message.inputDim && $util.isInteger(message.inputDim.low) && $util.isInteger(message.inputDim.high)))
                            return "inputDim: integer|Long expected";
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (!$util.isInteger(message.outputChannels) && !(message.outputChannels && $util.isInteger(message.outputChannels.low) && $util.isInteger(message.outputChannels.high)))
                            return "outputChannels: integer|Long expected";
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weights);
                        if (error)
                            return "weights." + error;
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates an EmbeddingLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.EmbeddingLayerParams} EmbeddingLayerParams
                 */
                EmbeddingLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.EmbeddingLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.EmbeddingLayerParams();
                    if (object.inputDim != null)
                        if ($util.Long)
                            (message.inputDim = $util.Long.fromValue(object.inputDim)).unsigned = true;
                        else if (typeof object.inputDim === "string")
                            message.inputDim = parseInt(object.inputDim, 10);
                        else if (typeof object.inputDim === "number")
                            message.inputDim = object.inputDim;
                        else if (typeof object.inputDim === "object")
                            message.inputDim = new $util.LongBits(object.inputDim.low >>> 0, object.inputDim.high >>> 0).toNumber(true);
                    if (object.outputChannels != null)
                        if ($util.Long)
                            (message.outputChannels = $util.Long.fromValue(object.outputChannels)).unsigned = true;
                        else if (typeof object.outputChannels === "string")
                            message.outputChannels = parseInt(object.outputChannels, 10);
                        else if (typeof object.outputChannels === "number")
                            message.outputChannels = object.outputChannels;
                        else if (typeof object.outputChannels === "object")
                            message.outputChannels = new $util.LongBits(object.outputChannels.low >>> 0, object.outputChannels.high >>> 0).toNumber(true);
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.weights != null) {
                        if (typeof object.weights !== "object")
                            throw TypeError(".CoreML.Specification.EmbeddingLayerParams.weights: object expected");
                        message.weights = $root.CoreML.Specification.WeightParams.fromObject(object.weights);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.EmbeddingLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an EmbeddingLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @static
                 * @param {CoreML.Specification.EmbeddingLayerParams} message EmbeddingLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EmbeddingLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputDim = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputDim = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputChannels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputChannels = options.longs === String ? "0" : 0;
                        object.hasBias = false;
                        object.weights = null;
                        object.bias = null;
                    }
                    if (message.inputDim != null && message.hasOwnProperty("inputDim"))
                        if (typeof message.inputDim === "number")
                            object.inputDim = options.longs === String ? String(message.inputDim) : message.inputDim;
                        else
                            object.inputDim = options.longs === String ? $util.Long.prototype.toString.call(message.inputDim) : options.longs === Number ? new $util.LongBits(message.inputDim.low >>> 0, message.inputDim.high >>> 0).toNumber(true) : message.inputDim;
                    if (message.outputChannels != null && message.hasOwnProperty("outputChannels"))
                        if (typeof message.outputChannels === "number")
                            object.outputChannels = options.longs === String ? String(message.outputChannels) : message.outputChannels;
                        else
                            object.outputChannels = options.longs === String ? $util.Long.prototype.toString.call(message.outputChannels) : options.longs === Number ? new $util.LongBits(message.outputChannels.low >>> 0, message.outputChannels.high >>> 0).toNumber(true) : message.outputChannels;
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.weights != null && message.hasOwnProperty("weights"))
                        object.weights = $root.CoreML.Specification.WeightParams.toObject(message.weights, options);
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                /**
                 * Converts this EmbeddingLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.EmbeddingLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EmbeddingLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return EmbeddingLayerParams;
            })();
    
            Specification.BatchnormLayerParams = (function() {
    
                /**
                 * Properties of a BatchnormLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IBatchnormLayerParams
                 * @property {number|Long|null} [channels] BatchnormLayerParams channels
                 * @property {boolean|null} [computeMeanVar] If ``computeMeanVar == true``,
                 * the mean and variance are calculated from either
                 * the single input instance, if ``instanceNormalization == true``,
                 * or the whole batch, if ``instanceNormalization = false``.
                 * and the values provided in parameters "mean" and "variance" are ignored.
                 * @property {boolean|null} [instanceNormalization] BatchnormLayerParams instanceNormalization
                 * @property {number|null} [epsilon] A small constant to avoid division by 0 while normalizing by variance.
                 * Defaults to ``1e-5`` if not set or set to ``0``.
                 * @property {CoreML.Specification.IWeightParams|null} [gamma] Parameter of length [channels]
                 * @property {CoreML.Specification.IWeightParams|null} [beta] Parameter of length [channels]
                 * @property {CoreML.Specification.IWeightParams|null} [mean] Parameter of length [channels]
                 * @property {CoreML.Specification.IWeightParams|null} [variance] Parameter of length [channels]
                 */
    
                /**
                 * Constructs a new BatchnormLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs batch normalization,
                 * which is performed along the channel axis,
                 * and repeated along the other axes, if present.
                 * 
                 * .. code::
                 * 
                 * y = BatchnormLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * This operation is described by the following formula:
                 * 
                 * .. math::
                 * y_i = \gamma_i \dfrac{ (x_i - \mu_i)}{\sqrt{\sigma_i^2 + \epsilon}} + \beta_i \;,\;i=1,....,C
                 * 
                 * Input
                 * A blob with shape ``[C]`` or ``[C, H, W]``.
                 * 
                 * Output
                 * A blob with the same shape as the input.
                 * @implements IBatchnormLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IBatchnormLayerParams=} [properties] Properties to set
                 */
                function BatchnormLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * BatchnormLayerParams channels.
                 * @member {number|Long} channels
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.channels = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * If ``computeMeanVar == true``,
                 * the mean and variance are calculated from either
                 * the single input instance, if ``instanceNormalization == true``,
                 * or the whole batch, if ``instanceNormalization = false``.
                 * and the values provided in parameters "mean" and "variance" are ignored.
                 * @member {boolean} computeMeanVar
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.computeMeanVar = false;
    
                /**
                 * BatchnormLayerParams instanceNormalization.
                 * @member {boolean} instanceNormalization
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.instanceNormalization = false;
    
                /**
                 * A small constant to avoid division by 0 while normalizing by variance.
                 * Defaults to ``1e-5`` if not set or set to ``0``.
                 * @member {number} epsilon
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.epsilon = 0;
    
                /**
                 * Parameter of length [channels]
                 * @member {CoreML.Specification.IWeightParams|null|undefined} gamma
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.gamma = null;
    
                /**
                 * Parameter of length [channels]
                 * @member {CoreML.Specification.IWeightParams|null|undefined} beta
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.beta = null;
    
                /**
                 * Parameter of length [channels]
                 * @member {CoreML.Specification.IWeightParams|null|undefined} mean
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.mean = null;
    
                /**
                 * Parameter of length [channels]
                 * @member {CoreML.Specification.IWeightParams|null|undefined} variance
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 */
                BatchnormLayerParams.prototype.variance = null;
    
                /**
                 * Creates a new BatchnormLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {CoreML.Specification.IBatchnormLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.BatchnormLayerParams} BatchnormLayerParams instance
                 */
                BatchnormLayerParams.create = function create(properties) {
                    return new BatchnormLayerParams(properties);
                };
    
                /**
                 * Encodes the specified BatchnormLayerParams message. Does not implicitly {@link CoreML.Specification.BatchnormLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {CoreML.Specification.IBatchnormLayerParams} message BatchnormLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BatchnormLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.channels != null && message.hasOwnProperty("channels"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.channels);
                    if (message.computeMeanVar != null && message.hasOwnProperty("computeMeanVar"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.computeMeanVar);
                    if (message.instanceNormalization != null && message.hasOwnProperty("instanceNormalization"))
                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.instanceNormalization);
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        writer.uint32(/* id 10, wireType 5 =*/85).float(message.epsilon);
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        $root.CoreML.Specification.WeightParams.encode(message.gamma, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        $root.CoreML.Specification.WeightParams.encode(message.beta, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.mean != null && message.hasOwnProperty("mean"))
                        $root.CoreML.Specification.WeightParams.encode(message.mean, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
                    if (message.variance != null && message.hasOwnProperty("variance"))
                        $root.CoreML.Specification.WeightParams.encode(message.variance, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified BatchnormLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.BatchnormLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {CoreML.Specification.IBatchnormLayerParams} message BatchnormLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BatchnormLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BatchnormLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.BatchnormLayerParams} BatchnormLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BatchnormLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BatchnormLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.channels = reader.uint64();
                            break;
                        case 5:
                            message.computeMeanVar = reader.bool();
                            break;
                        case 6:
                            message.instanceNormalization = reader.bool();
                            break;
                        case 10:
                            message.epsilon = reader.float();
                            break;
                        case 15:
                            message.gamma = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.beta = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 17:
                            message.mean = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 18:
                            message.variance = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BatchnormLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.BatchnormLayerParams} BatchnormLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BatchnormLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BatchnormLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BatchnormLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.channels != null && message.hasOwnProperty("channels"))
                        if (!$util.isInteger(message.channels) && !(message.channels && $util.isInteger(message.channels.low) && $util.isInteger(message.channels.high)))
                            return "channels: integer|Long expected";
                    if (message.computeMeanVar != null && message.hasOwnProperty("computeMeanVar"))
                        if (typeof message.computeMeanVar !== "boolean")
                            return "computeMeanVar: boolean expected";
                    if (message.instanceNormalization != null && message.hasOwnProperty("instanceNormalization"))
                        if (typeof message.instanceNormalization !== "boolean")
                            return "instanceNormalization: boolean expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.gamma);
                        if (error)
                            return "gamma." + error;
                    }
                    if (message.beta != null && message.hasOwnProperty("beta")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.beta);
                        if (error)
                            return "beta." + error;
                    }
                    if (message.mean != null && message.hasOwnProperty("mean")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.mean);
                        if (error)
                            return "mean." + error;
                    }
                    if (message.variance != null && message.hasOwnProperty("variance")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.variance);
                        if (error)
                            return "variance." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a BatchnormLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.BatchnormLayerParams} BatchnormLayerParams
                 */
                BatchnormLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BatchnormLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.BatchnormLayerParams();
                    if (object.channels != null)
                        if ($util.Long)
                            (message.channels = $util.Long.fromValue(object.channels)).unsigned = true;
                        else if (typeof object.channels === "string")
                            message.channels = parseInt(object.channels, 10);
                        else if (typeof object.channels === "number")
                            message.channels = object.channels;
                        else if (typeof object.channels === "object")
                            message.channels = new $util.LongBits(object.channels.low >>> 0, object.channels.high >>> 0).toNumber(true);
                    if (object.computeMeanVar != null)
                        message.computeMeanVar = Boolean(object.computeMeanVar);
                    if (object.instanceNormalization != null)
                        message.instanceNormalization = Boolean(object.instanceNormalization);
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    if (object.gamma != null) {
                        if (typeof object.gamma !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.gamma: object expected");
                        message.gamma = $root.CoreML.Specification.WeightParams.fromObject(object.gamma);
                    }
                    if (object.beta != null) {
                        if (typeof object.beta !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.beta: object expected");
                        message.beta = $root.CoreML.Specification.WeightParams.fromObject(object.beta);
                    }
                    if (object.mean != null) {
                        if (typeof object.mean !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.mean: object expected");
                        message.mean = $root.CoreML.Specification.WeightParams.fromObject(object.mean);
                    }
                    if (object.variance != null) {
                        if (typeof object.variance !== "object")
                            throw TypeError(".CoreML.Specification.BatchnormLayerParams.variance: object expected");
                        message.variance = $root.CoreML.Specification.WeightParams.fromObject(object.variance);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BatchnormLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @static
                 * @param {CoreML.Specification.BatchnormLayerParams} message BatchnormLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BatchnormLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.channels = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.channels = options.longs === String ? "0" : 0;
                        object.computeMeanVar = false;
                        object.instanceNormalization = false;
                        object.epsilon = 0;
                        object.gamma = null;
                        object.beta = null;
                        object.mean = null;
                        object.variance = null;
                    }
                    if (message.channels != null && message.hasOwnProperty("channels"))
                        if (typeof message.channels === "number")
                            object.channels = options.longs === String ? String(message.channels) : message.channels;
                        else
                            object.channels = options.longs === String ? $util.Long.prototype.toString.call(message.channels) : options.longs === Number ? new $util.LongBits(message.channels.low >>> 0, message.channels.high >>> 0).toNumber(true) : message.channels;
                    if (message.computeMeanVar != null && message.hasOwnProperty("computeMeanVar"))
                        object.computeMeanVar = message.computeMeanVar;
                    if (message.instanceNormalization != null && message.hasOwnProperty("instanceNormalization"))
                        object.instanceNormalization = message.instanceNormalization;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = $root.CoreML.Specification.WeightParams.toObject(message.gamma, options);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = $root.CoreML.Specification.WeightParams.toObject(message.beta, options);
                    if (message.mean != null && message.hasOwnProperty("mean"))
                        object.mean = $root.CoreML.Specification.WeightParams.toObject(message.mean, options);
                    if (message.variance != null && message.hasOwnProperty("variance"))
                        object.variance = $root.CoreML.Specification.WeightParams.toObject(message.variance, options);
                    return object;
                };
    
                /**
                 * Converts this BatchnormLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.BatchnormLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BatchnormLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BatchnormLayerParams;
            })();
    
            Specification.PoolingLayerParams = (function() {
    
                /**
                 * Properties of a PoolingLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IPoolingLayerParams
                 * @property {CoreML.Specification.PoolingLayerParams.PoolingType|null} [type] PoolingLayerParams type
                 * @property {Array.<number|Long>|null} [kernelSize] Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[3, 3]`` is used.
                 * @property {Array.<number|Long>|null} [stride] Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * @property {CoreML.Specification.IValidPadding|null} [valid] PoolingLayerParams valid
                 * @property {CoreML.Specification.ISamePadding|null} [same] PoolingLayerParams same
                 * @property {CoreML.Specification.PoolingLayerParams.IValidCompletePadding|null} [includeLastPixel] PoolingLayerParams includeLastPixel
                 * @property {boolean|null} [avgPoolExcludePadding] If true, padded values are excluded from the count (denominator)
                 * when computing average pooling.
                 * @property {boolean|null} [globalPooling] If true, global pooling is performed.
                 * Kernel size is inferred from the input data spatial dimensions.
                 */
    
                /**
                 * Constructs a new PoolingLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A spatial pooling layer.
                 * 
                 * .. code::
                 * 
                 * y = PoolingLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H_in, W_in]``.
                 * Output
                 * A blob with shape ``[C, H_out, W_out]``.
                 * 
                 * Padding options are similar to ``ConvolutionLayerParams``
                 * with the additional option of ``ValidCompletePadding`` (``includeLastPixel``),
                 * which ensures that the last application of the kernel
                 * always includes the last pixel of the input image, if there is padding.
                 * 
                 * .. code::
                 * 
                 * H_out = int_division_round_up((H_in + 2 * paddingAmounts[0] - kernelSize[0]),Stride[0]) + 1)
                 * if (paddingAmounts[0] > 0 or paddingAmounts[1] > 0)
                 * if ((H_out - 1) * Stride >= H_in + paddingAmounts[0]) {
                 * H_out = H_out - 1
                 * }
                 * }
                 * 
                 * The equivalent expressions hold true for ``W_out`` as well.
                 * Only symmetric padding is supported with this option.
                 * @implements IPoolingLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IPoolingLayerParams=} [properties] Properties to set
                 */
                function PoolingLayerParams(properties) {
                    this.kernelSize = [];
                    this.stride = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PoolingLayerParams type.
                 * @member {CoreML.Specification.PoolingLayerParams.PoolingType} type
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.type = 0;
    
                /**
                 * Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[3, 3]`` is used.
                 * @member {Array.<number|Long>} kernelSize
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.kernelSize = $util.emptyArray;
    
                /**
                 * Must be length 2 in the order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * @member {Array.<number|Long>} stride
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.stride = $util.emptyArray;
    
                /**
                 * PoolingLayerParams valid.
                 * @member {CoreML.Specification.IValidPadding|null|undefined} valid
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.valid = null;
    
                /**
                 * PoolingLayerParams same.
                 * @member {CoreML.Specification.ISamePadding|null|undefined} same
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.same = null;
    
                /**
                 * PoolingLayerParams includeLastPixel.
                 * @member {CoreML.Specification.PoolingLayerParams.IValidCompletePadding|null|undefined} includeLastPixel
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.includeLastPixel = null;
    
                /**
                 * If true, padded values are excluded from the count (denominator)
                 * when computing average pooling.
                 * @member {boolean} avgPoolExcludePadding
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.avgPoolExcludePadding = false;
    
                /**
                 * If true, global pooling is performed.
                 * Kernel size is inferred from the input data spatial dimensions.
                 * @member {boolean} globalPooling
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                PoolingLayerParams.prototype.globalPooling = false;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * PoolingLayerParams PoolingPaddingType.
                 * @member {"valid"|"same"|"includeLastPixel"|undefined} PoolingPaddingType
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 */
                Object.defineProperty(PoolingLayerParams.prototype, "PoolingPaddingType", {
                    get: $util.oneOfGetter($oneOfFields = ["valid", "same", "includeLastPixel"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new PoolingLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {CoreML.Specification.IPoolingLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.PoolingLayerParams} PoolingLayerParams instance
                 */
                PoolingLayerParams.create = function create(properties) {
                    return new PoolingLayerParams(properties);
                };
    
                /**
                 * Encodes the specified PoolingLayerParams message. Does not implicitly {@link CoreML.Specification.PoolingLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {CoreML.Specification.IPoolingLayerParams} message PoolingLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolingLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.kernelSize != null && message.kernelSize.length) {
                        writer.uint32(/* id 10, wireType 2 =*/82).fork();
                        for (var i = 0; i < message.kernelSize.length; ++i)
                            writer.uint64(message.kernelSize[i]);
                        writer.ldelim();
                    }
                    if (message.stride != null && message.stride.length) {
                        writer.uint32(/* id 20, wireType 2 =*/162).fork();
                        for (var i = 0; i < message.stride.length; ++i)
                            writer.uint64(message.stride[i]);
                        writer.ldelim();
                    }
                    if (message.valid != null && message.hasOwnProperty("valid"))
                        $root.CoreML.Specification.ValidPadding.encode(message.valid, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                    if (message.same != null && message.hasOwnProperty("same"))
                        $root.CoreML.Specification.SamePadding.encode(message.same, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                    if (message.includeLastPixel != null && message.hasOwnProperty("includeLastPixel"))
                        $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.encode(message.includeLastPixel, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                    if (message.avgPoolExcludePadding != null && message.hasOwnProperty("avgPoolExcludePadding"))
                        writer.uint32(/* id 50, wireType 0 =*/400).bool(message.avgPoolExcludePadding);
                    if (message.globalPooling != null && message.hasOwnProperty("globalPooling"))
                        writer.uint32(/* id 60, wireType 0 =*/480).bool(message.globalPooling);
                    return writer;
                };
    
                /**
                 * Encodes the specified PoolingLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.PoolingLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {CoreML.Specification.IPoolingLayerParams} message PoolingLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PoolingLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PoolingLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.PoolingLayerParams} PoolingLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolingLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PoolingLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 10:
                            if (!(message.kernelSize && message.kernelSize.length))
                                message.kernelSize = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.kernelSize.push(reader.uint64());
                            } else
                                message.kernelSize.push(reader.uint64());
                            break;
                        case 20:
                            if (!(message.stride && message.stride.length))
                                message.stride = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.stride.push(reader.uint64());
                            } else
                                message.stride.push(reader.uint64());
                            break;
                        case 30:
                            message.valid = $root.CoreML.Specification.ValidPadding.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.same = $root.CoreML.Specification.SamePadding.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.includeLastPixel = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.avgPoolExcludePadding = reader.bool();
                            break;
                        case 60:
                            message.globalPooling = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PoolingLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.PoolingLayerParams} PoolingLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PoolingLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PoolingLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PoolingLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.kernelSize != null && message.hasOwnProperty("kernelSize")) {
                        if (!Array.isArray(message.kernelSize))
                            return "kernelSize: array expected";
                        for (var i = 0; i < message.kernelSize.length; ++i)
                            if (!$util.isInteger(message.kernelSize[i]) && !(message.kernelSize[i] && $util.isInteger(message.kernelSize[i].low) && $util.isInteger(message.kernelSize[i].high)))
                                return "kernelSize: integer|Long[] expected";
                    }
                    if (message.stride != null && message.hasOwnProperty("stride")) {
                        if (!Array.isArray(message.stride))
                            return "stride: array expected";
                        for (var i = 0; i < message.stride.length; ++i)
                            if (!$util.isInteger(message.stride[i]) && !(message.stride[i] && $util.isInteger(message.stride[i].low) && $util.isInteger(message.stride[i].high)))
                                return "stride: integer|Long[] expected";
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        properties.PoolingPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.ValidPadding.verify(message.valid);
                            if (error)
                                return "valid." + error;
                        }
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        if (properties.PoolingPaddingType === 1)
                            return "PoolingPaddingType: multiple values";
                        properties.PoolingPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.SamePadding.verify(message.same);
                            if (error)
                                return "same." + error;
                        }
                    }
                    if (message.includeLastPixel != null && message.hasOwnProperty("includeLastPixel")) {
                        if (properties.PoolingPaddingType === 1)
                            return "PoolingPaddingType: multiple values";
                        properties.PoolingPaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.verify(message.includeLastPixel);
                            if (error)
                                return "includeLastPixel." + error;
                        }
                    }
                    if (message.avgPoolExcludePadding != null && message.hasOwnProperty("avgPoolExcludePadding"))
                        if (typeof message.avgPoolExcludePadding !== "boolean")
                            return "avgPoolExcludePadding: boolean expected";
                    if (message.globalPooling != null && message.hasOwnProperty("globalPooling"))
                        if (typeof message.globalPooling !== "boolean")
                            return "globalPooling: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a PoolingLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.PoolingLayerParams} PoolingLayerParams
                 */
                PoolingLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PoolingLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.PoolingLayerParams();
                    switch (object.type) {
                    case "MAX":
                    case 0:
                        message.type = 0;
                        break;
                    case "AVERAGE":
                    case 1:
                        message.type = 1;
                        break;
                    case "L2":
                    case 2:
                        message.type = 2;
                        break;
                    }
                    if (object.kernelSize) {
                        if (!Array.isArray(object.kernelSize))
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.kernelSize: array expected");
                        message.kernelSize = [];
                        for (var i = 0; i < object.kernelSize.length; ++i)
                            if ($util.Long)
                                (message.kernelSize[i] = $util.Long.fromValue(object.kernelSize[i])).unsigned = true;
                            else if (typeof object.kernelSize[i] === "string")
                                message.kernelSize[i] = parseInt(object.kernelSize[i], 10);
                            else if (typeof object.kernelSize[i] === "number")
                                message.kernelSize[i] = object.kernelSize[i];
                            else if (typeof object.kernelSize[i] === "object")
                                message.kernelSize[i] = new $util.LongBits(object.kernelSize[i].low >>> 0, object.kernelSize[i].high >>> 0).toNumber(true);
                    }
                    if (object.stride) {
                        if (!Array.isArray(object.stride))
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.stride: array expected");
                        message.stride = [];
                        for (var i = 0; i < object.stride.length; ++i)
                            if ($util.Long)
                                (message.stride[i] = $util.Long.fromValue(object.stride[i])).unsigned = true;
                            else if (typeof object.stride[i] === "string")
                                message.stride[i] = parseInt(object.stride[i], 10);
                            else if (typeof object.stride[i] === "number")
                                message.stride[i] = object.stride[i];
                            else if (typeof object.stride[i] === "object")
                                message.stride[i] = new $util.LongBits(object.stride[i].low >>> 0, object.stride[i].high >>> 0).toNumber(true);
                    }
                    if (object.valid != null) {
                        if (typeof object.valid !== "object")
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.valid: object expected");
                        message.valid = $root.CoreML.Specification.ValidPadding.fromObject(object.valid);
                    }
                    if (object.same != null) {
                        if (typeof object.same !== "object")
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.same: object expected");
                        message.same = $root.CoreML.Specification.SamePadding.fromObject(object.same);
                    }
                    if (object.includeLastPixel != null) {
                        if (typeof object.includeLastPixel !== "object")
                            throw TypeError(".CoreML.Specification.PoolingLayerParams.includeLastPixel: object expected");
                        message.includeLastPixel = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.fromObject(object.includeLastPixel);
                    }
                    if (object.avgPoolExcludePadding != null)
                        message.avgPoolExcludePadding = Boolean(object.avgPoolExcludePadding);
                    if (object.globalPooling != null)
                        message.globalPooling = Boolean(object.globalPooling);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PoolingLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @static
                 * @param {CoreML.Specification.PoolingLayerParams} message PoolingLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PoolingLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.kernelSize = [];
                        object.stride = [];
                    }
                    if (options.defaults) {
                        object.type = options.enums === String ? "MAX" : 0;
                        object.avgPoolExcludePadding = false;
                        object.globalPooling = false;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CoreML.Specification.PoolingLayerParams.PoolingType[message.type] : message.type;
                    if (message.kernelSize && message.kernelSize.length) {
                        object.kernelSize = [];
                        for (var j = 0; j < message.kernelSize.length; ++j)
                            if (typeof message.kernelSize[j] === "number")
                                object.kernelSize[j] = options.longs === String ? String(message.kernelSize[j]) : message.kernelSize[j];
                            else
                                object.kernelSize[j] = options.longs === String ? $util.Long.prototype.toString.call(message.kernelSize[j]) : options.longs === Number ? new $util.LongBits(message.kernelSize[j].low >>> 0, message.kernelSize[j].high >>> 0).toNumber(true) : message.kernelSize[j];
                    }
                    if (message.stride && message.stride.length) {
                        object.stride = [];
                        for (var j = 0; j < message.stride.length; ++j)
                            if (typeof message.stride[j] === "number")
                                object.stride[j] = options.longs === String ? String(message.stride[j]) : message.stride[j];
                            else
                                object.stride[j] = options.longs === String ? $util.Long.prototype.toString.call(message.stride[j]) : options.longs === Number ? new $util.LongBits(message.stride[j].low >>> 0, message.stride[j].high >>> 0).toNumber(true) : message.stride[j];
                    }
                    if (message.valid != null && message.hasOwnProperty("valid")) {
                        object.valid = $root.CoreML.Specification.ValidPadding.toObject(message.valid, options);
                        if (options.oneofs)
                            object.PoolingPaddingType = "valid";
                    }
                    if (message.same != null && message.hasOwnProperty("same")) {
                        object.same = $root.CoreML.Specification.SamePadding.toObject(message.same, options);
                        if (options.oneofs)
                            object.PoolingPaddingType = "same";
                    }
                    if (message.includeLastPixel != null && message.hasOwnProperty("includeLastPixel")) {
                        object.includeLastPixel = $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding.toObject(message.includeLastPixel, options);
                        if (options.oneofs)
                            object.PoolingPaddingType = "includeLastPixel";
                    }
                    if (message.avgPoolExcludePadding != null && message.hasOwnProperty("avgPoolExcludePadding"))
                        object.avgPoolExcludePadding = message.avgPoolExcludePadding;
                    if (message.globalPooling != null && message.hasOwnProperty("globalPooling"))
                        object.globalPooling = message.globalPooling;
                    return object;
                };
    
                /**
                 * Converts this PoolingLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.PoolingLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PoolingLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * PoolingType enum.
                 * @name CoreML.Specification.PoolingLayerParams.PoolingType
                 * @enum {string}
                 * @property {number} MAX=0 MAX value
                 * @property {number} AVERAGE=1 AVERAGE value
                 * @property {number} L2=2 L2 value
                 */
                PoolingLayerParams.PoolingType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "MAX"] = 0;
                    values[valuesById[1] = "AVERAGE"] = 1;
                    values[valuesById[2] = "L2"] = 2;
                    return values;
                })();
    
                PoolingLayerParams.ValidCompletePadding = (function() {
    
                    /**
                     * Properties of a ValidCompletePadding.
                     * @memberof CoreML.Specification.PoolingLayerParams
                     * @interface IValidCompletePadding
                     * @property {Array.<number|Long>|null} [paddingAmounts] Must be length 2 in order ``[H, W]``.
                     * If not set, value ``[0, 0]`` is used.
                     */
    
                    /**
                     * Constructs a new ValidCompletePadding.
                     * @memberof CoreML.Specification.PoolingLayerParams
                     * @classdesc Represents a ValidCompletePadding.
                     * @implements IValidCompletePadding
                     * @constructor
                     * @param {CoreML.Specification.PoolingLayerParams.IValidCompletePadding=} [properties] Properties to set
                     */
                    function ValidCompletePadding(properties) {
                        this.paddingAmounts = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Must be length 2 in order ``[H, W]``.
                     * If not set, value ``[0, 0]`` is used.
                     * @member {Array.<number|Long>} paddingAmounts
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @instance
                     */
                    ValidCompletePadding.prototype.paddingAmounts = $util.emptyArray;
    
                    /**
                     * Creates a new ValidCompletePadding instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {CoreML.Specification.PoolingLayerParams.IValidCompletePadding=} [properties] Properties to set
                     * @returns {CoreML.Specification.PoolingLayerParams.ValidCompletePadding} ValidCompletePadding instance
                     */
                    ValidCompletePadding.create = function create(properties) {
                        return new ValidCompletePadding(properties);
                    };
    
                    /**
                     * Encodes the specified ValidCompletePadding message. Does not implicitly {@link CoreML.Specification.PoolingLayerParams.ValidCompletePadding.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {CoreML.Specification.PoolingLayerParams.IValidCompletePadding} message ValidCompletePadding message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ValidCompletePadding.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.paddingAmounts != null && message.paddingAmounts.length) {
                            writer.uint32(/* id 10, wireType 2 =*/82).fork();
                            for (var i = 0; i < message.paddingAmounts.length; ++i)
                                writer.uint64(message.paddingAmounts[i]);
                            writer.ldelim();
                        }
                        return writer;
                    };
    
                    /**
                     * Encodes the specified ValidCompletePadding message, length delimited. Does not implicitly {@link CoreML.Specification.PoolingLayerParams.ValidCompletePadding.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {CoreML.Specification.PoolingLayerParams.IValidCompletePadding} message ValidCompletePadding message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    ValidCompletePadding.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a ValidCompletePadding message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.PoolingLayerParams.ValidCompletePadding} ValidCompletePadding
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ValidCompletePadding.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 10:
                                if (!(message.paddingAmounts && message.paddingAmounts.length))
                                    message.paddingAmounts = [];
                                if ((tag & 7) === 2) {
                                    var end2 = reader.uint32() + reader.pos;
                                    while (reader.pos < end2)
                                        message.paddingAmounts.push(reader.uint64());
                                } else
                                    message.paddingAmounts.push(reader.uint64());
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a ValidCompletePadding message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.PoolingLayerParams.ValidCompletePadding} ValidCompletePadding
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    ValidCompletePadding.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a ValidCompletePadding message.
                     * @function verify
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ValidCompletePadding.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts")) {
                            if (!Array.isArray(message.paddingAmounts))
                                return "paddingAmounts: array expected";
                            for (var i = 0; i < message.paddingAmounts.length; ++i)
                                if (!$util.isInteger(message.paddingAmounts[i]) && !(message.paddingAmounts[i] && $util.isInteger(message.paddingAmounts[i].low) && $util.isInteger(message.paddingAmounts[i].high)))
                                    return "paddingAmounts: integer|Long[] expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a ValidCompletePadding message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.PoolingLayerParams.ValidCompletePadding} ValidCompletePadding
                     */
                    ValidCompletePadding.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding)
                            return object;
                        var message = new $root.CoreML.Specification.PoolingLayerParams.ValidCompletePadding();
                        if (object.paddingAmounts) {
                            if (!Array.isArray(object.paddingAmounts))
                                throw TypeError(".CoreML.Specification.PoolingLayerParams.ValidCompletePadding.paddingAmounts: array expected");
                            message.paddingAmounts = [];
                            for (var i = 0; i < object.paddingAmounts.length; ++i)
                                if ($util.Long)
                                    (message.paddingAmounts[i] = $util.Long.fromValue(object.paddingAmounts[i])).unsigned = true;
                                else if (typeof object.paddingAmounts[i] === "string")
                                    message.paddingAmounts[i] = parseInt(object.paddingAmounts[i], 10);
                                else if (typeof object.paddingAmounts[i] === "number")
                                    message.paddingAmounts[i] = object.paddingAmounts[i];
                                else if (typeof object.paddingAmounts[i] === "object")
                                    message.paddingAmounts[i] = new $util.LongBits(object.paddingAmounts[i].low >>> 0, object.paddingAmounts[i].high >>> 0).toNumber(true);
                        }
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a ValidCompletePadding message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @static
                     * @param {CoreML.Specification.PoolingLayerParams.ValidCompletePadding} message ValidCompletePadding
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ValidCompletePadding.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.paddingAmounts = [];
                        if (message.paddingAmounts && message.paddingAmounts.length) {
                            object.paddingAmounts = [];
                            for (var j = 0; j < message.paddingAmounts.length; ++j)
                                if (typeof message.paddingAmounts[j] === "number")
                                    object.paddingAmounts[j] = options.longs === String ? String(message.paddingAmounts[j]) : message.paddingAmounts[j];
                                else
                                    object.paddingAmounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.paddingAmounts[j]) : options.longs === Number ? new $util.LongBits(message.paddingAmounts[j].low >>> 0, message.paddingAmounts[j].high >>> 0).toNumber(true) : message.paddingAmounts[j];
                        }
                        return object;
                    };
    
                    /**
                     * Converts this ValidCompletePadding to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.PoolingLayerParams.ValidCompletePadding
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ValidCompletePadding.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return ValidCompletePadding;
                })();
    
                return PoolingLayerParams;
            })();
    
            Specification.PaddingLayerParams = (function() {
    
                /**
                 * Properties of a PaddingLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IPaddingLayerParams
                 * @property {CoreML.Specification.PaddingLayerParams.IPaddingConstant|null} [constant] PaddingLayerParams constant
                 * @property {CoreML.Specification.PaddingLayerParams.IPaddingReflection|null} [reflection] PaddingLayerParams reflection
                 * @property {CoreML.Specification.PaddingLayerParams.IPaddingReplication|null} [replication] PaddingLayerParams replication
                 * @property {CoreML.Specification.IBorderAmounts|null} [paddingAmounts] Amounts to be padded to the input.
                 */
    
                /**
                 * Constructs a new PaddingLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs padding along spatial dimensions.
                 * 
                 * .. code::
                 * 
                 * y = PaddingLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H_in, W_in]``.
                 * 
                 * Output
                 * A blob with shape ``[C, H_out, W_out]``.
                 * 
                 * Output dimensions are calculated as follows:
                 * 
                 * .. code::
                 * 
                 * H_out = H_in + topPaddingAmount + bottomPaddingAmount
                 * W_out = W_in + leftPaddingAmount + rightPaddingAmount
                 * 
                 * topPaddingAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
                 * bottomPaddingAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
                 * leftPaddingAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
                 * rightPaddingAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
                 * 
                 * There are three types of padding:
                 * 
                 * - ``PaddingConstant``, which fills a constant value at the border.
                 * - ``PaddingReflection``, which reflects the values at the border.
                 * - ``PaddingReplication``, which replicates the values at the border.
                 * 
                 * Given the following input:
                 * 
                 * .. code::
                 * 
                 * [1, 3, 4]  :  1   2   3   4
                 * 5   6   7   8
                 * 9   10  11  12
                 * 
                 * Here is the output of applying the padding
                 * ``(top=2, left=2, bottom=0, right=0)``
                 * with each of the supported types:
                 * 
                 * - ``PaddingConstant`` (``value = 0``):
                 * .. code::
                 * 
                 * [1, 5, 6]  :  0   0   0  0   0   0
                 * 0   0   0  0   0   0
                 * 0   0   1  2   3   4
                 * 0   0   5  6   7   8
                 * 0   0   9  10  11  12
                 * 
                 * - ``PaddingReflection``:
                 * .. code::
                 * 
                 * [1, 5, 6]  :  11  10  9  10  11  12
                 * 7   6   5  6   7   8
                 * 3   2   1  2   3   4
                 * 7   6   5  6   7   8
                 * 11  10  9  10  11  12
                 * 
                 * - ``PaddingReplication``:
                 * .. code::
                 * 
                 * [1, 5, 6]  :  1   1   1  2   3   4
                 * 1   1   1  2   3   4
                 * 1   1   1  2   3   4
                 * 5   5   5  6   7   8
                 * 9   9   9  10  11  12
                 * @implements IPaddingLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IPaddingLayerParams=} [properties] Properties to set
                 */
                function PaddingLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PaddingLayerParams constant.
                 * @member {CoreML.Specification.PaddingLayerParams.IPaddingConstant|null|undefined} constant
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @instance
                 */
                PaddingLayerParams.prototype.constant = null;
    
                /**
                 * PaddingLayerParams reflection.
                 * @member {CoreML.Specification.PaddingLayerParams.IPaddingReflection|null|undefined} reflection
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @instance
                 */
                PaddingLayerParams.prototype.reflection = null;
    
                /**
                 * PaddingLayerParams replication.
                 * @member {CoreML.Specification.PaddingLayerParams.IPaddingReplication|null|undefined} replication
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @instance
                 */
                PaddingLayerParams.prototype.replication = null;
    
                /**
                 * Amounts to be padded to the input.
                 * @member {CoreML.Specification.IBorderAmounts|null|undefined} paddingAmounts
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @instance
                 */
                PaddingLayerParams.prototype.paddingAmounts = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * PaddingLayerParams PaddingType.
                 * @member {"constant"|"reflection"|"replication"|undefined} PaddingType
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @instance
                 */
                Object.defineProperty(PaddingLayerParams.prototype, "PaddingType", {
                    get: $util.oneOfGetter($oneOfFields = ["constant", "reflection", "replication"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new PaddingLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {CoreML.Specification.IPaddingLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.PaddingLayerParams} PaddingLayerParams instance
                 */
                PaddingLayerParams.create = function create(properties) {
                    return new PaddingLayerParams(properties);
                };
    
                /**
                 * Encodes the specified PaddingLayerParams message. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {CoreML.Specification.IPaddingLayerParams} message PaddingLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PaddingLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.constant != null && message.hasOwnProperty("constant"))
                        $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.encode(message.constant, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.reflection != null && message.hasOwnProperty("reflection"))
                        $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.encode(message.reflection, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.replication != null && message.hasOwnProperty("replication"))
                        $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.encode(message.replication, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts"))
                        $root.CoreML.Specification.BorderAmounts.encode(message.paddingAmounts, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified PaddingLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {CoreML.Specification.IPaddingLayerParams} message PaddingLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PaddingLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PaddingLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.PaddingLayerParams} PaddingLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PaddingLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.constant = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.reflection = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.replication = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PaddingLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.PaddingLayerParams} PaddingLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PaddingLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PaddingLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PaddingLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.constant != null && message.hasOwnProperty("constant")) {
                        properties.PaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.verify(message.constant);
                            if (error)
                                return "constant." + error;
                        }
                    }
                    if (message.reflection != null && message.hasOwnProperty("reflection")) {
                        if (properties.PaddingType === 1)
                            return "PaddingType: multiple values";
                        properties.PaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.verify(message.reflection);
                            if (error)
                                return "reflection." + error;
                        }
                    }
                    if (message.replication != null && message.hasOwnProperty("replication")) {
                        if (properties.PaddingType === 1)
                            return "PaddingType: multiple values";
                        properties.PaddingType = 1;
                        {
                            var error = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.verify(message.replication);
                            if (error)
                                return "replication." + error;
                        }
                    }
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts")) {
                        var error = $root.CoreML.Specification.BorderAmounts.verify(message.paddingAmounts);
                        if (error)
                            return "paddingAmounts." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a PaddingLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.PaddingLayerParams} PaddingLayerParams
                 */
                PaddingLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PaddingLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.PaddingLayerParams();
                    if (object.constant != null) {
                        if (typeof object.constant !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.constant: object expected");
                        message.constant = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.fromObject(object.constant);
                    }
                    if (object.reflection != null) {
                        if (typeof object.reflection !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.reflection: object expected");
                        message.reflection = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.fromObject(object.reflection);
                    }
                    if (object.replication != null) {
                        if (typeof object.replication !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.replication: object expected");
                        message.replication = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.fromObject(object.replication);
                    }
                    if (object.paddingAmounts != null) {
                        if (typeof object.paddingAmounts !== "object")
                            throw TypeError(".CoreML.Specification.PaddingLayerParams.paddingAmounts: object expected");
                        message.paddingAmounts = $root.CoreML.Specification.BorderAmounts.fromObject(object.paddingAmounts);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PaddingLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @static
                 * @param {CoreML.Specification.PaddingLayerParams} message PaddingLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PaddingLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.paddingAmounts = null;
                    if (message.constant != null && message.hasOwnProperty("constant")) {
                        object.constant = $root.CoreML.Specification.PaddingLayerParams.PaddingConstant.toObject(message.constant, options);
                        if (options.oneofs)
                            object.PaddingType = "constant";
                    }
                    if (message.reflection != null && message.hasOwnProperty("reflection")) {
                        object.reflection = $root.CoreML.Specification.PaddingLayerParams.PaddingReflection.toObject(message.reflection, options);
                        if (options.oneofs)
                            object.PaddingType = "reflection";
                    }
                    if (message.replication != null && message.hasOwnProperty("replication")) {
                        object.replication = $root.CoreML.Specification.PaddingLayerParams.PaddingReplication.toObject(message.replication, options);
                        if (options.oneofs)
                            object.PaddingType = "replication";
                    }
                    if (message.paddingAmounts != null && message.hasOwnProperty("paddingAmounts"))
                        object.paddingAmounts = $root.CoreML.Specification.BorderAmounts.toObject(message.paddingAmounts, options);
                    return object;
                };
    
                /**
                 * Converts this PaddingLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.PaddingLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PaddingLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                PaddingLayerParams.PaddingConstant = (function() {
    
                    /**
                     * Properties of a PaddingConstant.
                     * @memberof CoreML.Specification.PaddingLayerParams
                     * @interface IPaddingConstant
                     * @property {number|null} [value] PaddingConstant value
                     */
    
                    /**
                     * Constructs a new PaddingConstant.
                     * @memberof CoreML.Specification.PaddingLayerParams
                     * @classdesc Fill a constant value in the padded region.
                     * @implements IPaddingConstant
                     * @constructor
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingConstant=} [properties] Properties to set
                     */
                    function PaddingConstant(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * PaddingConstant value.
                     * @member {number} value
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @instance
                     */
                    PaddingConstant.prototype.value = 0;
    
                    /**
                     * Creates a new PaddingConstant instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingConstant=} [properties] Properties to set
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingConstant} PaddingConstant instance
                     */
                    PaddingConstant.create = function create(properties) {
                        return new PaddingConstant(properties);
                    };
    
                    /**
                     * Encodes the specified PaddingConstant message. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.PaddingConstant.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingConstant} message PaddingConstant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PaddingConstant.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.value != null && message.hasOwnProperty("value"))
                            writer.uint32(/* id 1, wireType 5 =*/13).float(message.value);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified PaddingConstant message, length delimited. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.PaddingConstant.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingConstant} message PaddingConstant message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PaddingConstant.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a PaddingConstant message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingConstant} PaddingConstant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PaddingConstant.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams.PaddingConstant();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.value = reader.float();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a PaddingConstant message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingConstant} PaddingConstant
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PaddingConstant.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a PaddingConstant message.
                     * @function verify
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PaddingConstant.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value !== "number")
                                return "value: number expected";
                        return null;
                    };
    
                    /**
                     * Creates a PaddingConstant message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingConstant} PaddingConstant
                     */
                    PaddingConstant.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PaddingLayerParams.PaddingConstant)
                            return object;
                        var message = new $root.CoreML.Specification.PaddingLayerParams.PaddingConstant();
                        if (object.value != null)
                            message.value = Number(object.value);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a PaddingConstant message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.PaddingConstant} message PaddingConstant
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PaddingConstant.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults)
                            object.value = 0;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                        return object;
                    };
    
                    /**
                     * Converts this PaddingConstant to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingConstant
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PaddingConstant.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PaddingConstant;
                })();
    
                PaddingLayerParams.PaddingReflection = (function() {
    
                    /**
                     * Properties of a PaddingReflection.
                     * @memberof CoreML.Specification.PaddingLayerParams
                     * @interface IPaddingReflection
                     */
    
                    /**
                     * Constructs a new PaddingReflection.
                     * @memberof CoreML.Specification.PaddingLayerParams
                     * @classdesc Reflect the values at the border for padding.
                     * @implements IPaddingReflection
                     * @constructor
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReflection=} [properties] Properties to set
                     */
                    function PaddingReflection(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new PaddingReflection instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReflection=} [properties] Properties to set
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReflection} PaddingReflection instance
                     */
                    PaddingReflection.create = function create(properties) {
                        return new PaddingReflection(properties);
                    };
    
                    /**
                     * Encodes the specified PaddingReflection message. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.PaddingReflection.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReflection} message PaddingReflection message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PaddingReflection.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified PaddingReflection message, length delimited. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.PaddingReflection.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReflection} message PaddingReflection message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PaddingReflection.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a PaddingReflection message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReflection} PaddingReflection
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PaddingReflection.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams.PaddingReflection();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a PaddingReflection message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReflection} PaddingReflection
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PaddingReflection.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a PaddingReflection message.
                     * @function verify
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PaddingReflection.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a PaddingReflection message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReflection} PaddingReflection
                     */
                    PaddingReflection.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PaddingLayerParams.PaddingReflection)
                            return object;
                        return new $root.CoreML.Specification.PaddingLayerParams.PaddingReflection();
                    };
    
                    /**
                     * Creates a plain object from a PaddingReflection message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.PaddingReflection} message PaddingReflection
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PaddingReflection.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this PaddingReflection to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReflection
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PaddingReflection.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PaddingReflection;
                })();
    
                PaddingLayerParams.PaddingReplication = (function() {
    
                    /**
                     * Properties of a PaddingReplication.
                     * @memberof CoreML.Specification.PaddingLayerParams
                     * @interface IPaddingReplication
                     */
    
                    /**
                     * Constructs a new PaddingReplication.
                     * @memberof CoreML.Specification.PaddingLayerParams
                     * @classdesc Replicate the values at the border for padding.
                     * @implements IPaddingReplication
                     * @constructor
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReplication=} [properties] Properties to set
                     */
                    function PaddingReplication(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * Creates a new PaddingReplication instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReplication=} [properties] Properties to set
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReplication} PaddingReplication instance
                     */
                    PaddingReplication.create = function create(properties) {
                        return new PaddingReplication(properties);
                    };
    
                    /**
                     * Encodes the specified PaddingReplication message. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.PaddingReplication.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReplication} message PaddingReplication message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PaddingReplication.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        return writer;
                    };
    
                    /**
                     * Encodes the specified PaddingReplication message, length delimited. Does not implicitly {@link CoreML.Specification.PaddingLayerParams.PaddingReplication.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.IPaddingReplication} message PaddingReplication message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    PaddingReplication.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a PaddingReplication message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReplication} PaddingReplication
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PaddingReplication.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PaddingLayerParams.PaddingReplication();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a PaddingReplication message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReplication} PaddingReplication
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    PaddingReplication.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a PaddingReplication message.
                     * @function verify
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PaddingReplication.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };
    
                    /**
                     * Creates a PaddingReplication message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.PaddingLayerParams.PaddingReplication} PaddingReplication
                     */
                    PaddingReplication.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.PaddingLayerParams.PaddingReplication)
                            return object;
                        return new $root.CoreML.Specification.PaddingLayerParams.PaddingReplication();
                    };
    
                    /**
                     * Creates a plain object from a PaddingReplication message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @static
                     * @param {CoreML.Specification.PaddingLayerParams.PaddingReplication} message PaddingReplication
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PaddingReplication.toObject = function toObject() {
                        return {};
                    };
    
                    /**
                     * Converts this PaddingReplication to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.PaddingLayerParams.PaddingReplication
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PaddingReplication.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return PaddingReplication;
                })();
    
                return PaddingLayerParams;
            })();
    
            Specification.ConcatLayerParams = (function() {
    
                /**
                 * Properties of a ConcatLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IConcatLayerParams
                 * @property {boolean|null} [sequenceConcat] If true, concatenate along the sequence axis instead of the channel axis.
                 */
    
                /**
                 * Constructs a new ConcatLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that concatenates along the channel axis (default) or sequence axis.
                 * 
                 * .. code::
                 * 
                 * y = ConcatLayer(x1,x2,....)
                 * 
                 * Requires more than 1 input and produces 1 output.
                 * 
                 * The input and output formats are dependent on ``sequenceConcat``.
                 * 
                 * If ``sequenceConcat == true``:
                 * 
                 * Input
                 * Sequences of length ``Seq_i`` of blobs with shape ``[C, H, W]``.
                 * Output
                 * A Sequence of length ``summation(Seq_i)`` of blobs with shape ``[C, H, W]``.
                 * 
                 * If ``sequenceConcat == false``:
                 * 
                 * Input
                 * A blob with shape ``[C_i, H, W]``, where ``i = 1, 2, ...``.
                 * Output
                 * A blob with shape ``[summation(C_i), H, W]``.
                 * @implements IConcatLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IConcatLayerParams=} [properties] Properties to set
                 */
                function ConcatLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * If true, concatenate along the sequence axis instead of the channel axis.
                 * @member {boolean} sequenceConcat
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @instance
                 */
                ConcatLayerParams.prototype.sequenceConcat = false;
    
                /**
                 * Creates a new ConcatLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {CoreML.Specification.IConcatLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ConcatLayerParams} ConcatLayerParams instance
                 */
                ConcatLayerParams.create = function create(properties) {
                    return new ConcatLayerParams(properties);
                };
    
                /**
                 * Encodes the specified ConcatLayerParams message. Does not implicitly {@link CoreML.Specification.ConcatLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {CoreML.Specification.IConcatLayerParams} message ConcatLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConcatLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sequenceConcat != null && message.hasOwnProperty("sequenceConcat"))
                        writer.uint32(/* id 100, wireType 0 =*/800).bool(message.sequenceConcat);
                    return writer;
                };
    
                /**
                 * Encodes the specified ConcatLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.ConcatLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {CoreML.Specification.IConcatLayerParams} message ConcatLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ConcatLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ConcatLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ConcatLayerParams} ConcatLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConcatLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ConcatLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 100:
                            message.sequenceConcat = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ConcatLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ConcatLayerParams} ConcatLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ConcatLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ConcatLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConcatLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sequenceConcat != null && message.hasOwnProperty("sequenceConcat"))
                        if (typeof message.sequenceConcat !== "boolean")
                            return "sequenceConcat: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a ConcatLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ConcatLayerParams} ConcatLayerParams
                 */
                ConcatLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ConcatLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ConcatLayerParams();
                    if (object.sequenceConcat != null)
                        message.sequenceConcat = Boolean(object.sequenceConcat);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ConcatLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @static
                 * @param {CoreML.Specification.ConcatLayerParams} message ConcatLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConcatLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.sequenceConcat = false;
                    if (message.sequenceConcat != null && message.hasOwnProperty("sequenceConcat"))
                        object.sequenceConcat = message.sequenceConcat;
                    return object;
                };
    
                /**
                 * Converts this ConcatLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ConcatLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConcatLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ConcatLayerParams;
            })();
    
            Specification.LRNLayerParams = (function() {
    
                /**
                 * Properties of a LRNLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ILRNLayerParams
                 * @property {number|null} [alpha] LRNLayerParams alpha
                 * @property {number|null} [beta] LRNLayerParams beta
                 * @property {number|Long|null} [localSize] Number of channels in the normalization window.
                 * @property {number|null} [k] Defaults to 1 if not set or 0. Must be strictly positive.
                 */
    
                /**
                 * Constructs a new LRNLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs local response normalization (LRN).
                 * 
                 * .. code::
                 * 
                 * y = LRNLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``
                 * Output
                 * A blob with the same shape as the input.
                 * 
                 * This layer is described by the following formula:
                 * 
                 * .. math::
                 * x_i \leftarrow  \dfrac{x_i}{\left ( k + \dfrac{\alpha}{C} \sum_j x_j^2 \right )^\beta}
                 * 
                 * where the summation is done over a ``(localSize, 1, 1)`` neighborhood ---
                 * that is, over a window "across" channels in 1x1 spatial neighborhoods.
                 * @implements ILRNLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ILRNLayerParams=} [properties] Properties to set
                 */
                function LRNLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * LRNLayerParams alpha.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @instance
                 */
                LRNLayerParams.prototype.alpha = 0;
    
                /**
                 * LRNLayerParams beta.
                 * @member {number} beta
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @instance
                 */
                LRNLayerParams.prototype.beta = 0;
    
                /**
                 * Number of channels in the normalization window.
                 * @member {number|Long} localSize
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @instance
                 */
                LRNLayerParams.prototype.localSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Defaults to 1 if not set or 0. Must be strictly positive.
                 * @member {number} k
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @instance
                 */
                LRNLayerParams.prototype.k = 0;
    
                /**
                 * Creates a new LRNLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {CoreML.Specification.ILRNLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.LRNLayerParams} LRNLayerParams instance
                 */
                LRNLayerParams.create = function create(properties) {
                    return new LRNLayerParams(properties);
                };
    
                /**
                 * Encodes the specified LRNLayerParams message. Does not implicitly {@link CoreML.Specification.LRNLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {CoreML.Specification.ILRNLayerParams} message LRNLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LRNLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.beta);
                    if (message.localSize != null && message.hasOwnProperty("localSize"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.localSize);
                    if (message.k != null && message.hasOwnProperty("k"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.k);
                    return writer;
                };
    
                /**
                 * Encodes the specified LRNLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.LRNLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {CoreML.Specification.ILRNLayerParams} message LRNLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LRNLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a LRNLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.LRNLayerParams} LRNLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LRNLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LRNLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        case 2:
                            message.beta = reader.float();
                            break;
                        case 3:
                            message.localSize = reader.uint64();
                            break;
                        case 4:
                            message.k = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a LRNLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.LRNLayerParams} LRNLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LRNLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a LRNLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LRNLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        if (typeof message.beta !== "number")
                            return "beta: number expected";
                    if (message.localSize != null && message.hasOwnProperty("localSize"))
                        if (!$util.isInteger(message.localSize) && !(message.localSize && $util.isInteger(message.localSize.low) && $util.isInteger(message.localSize.high)))
                            return "localSize: integer|Long expected";
                    if (message.k != null && message.hasOwnProperty("k"))
                        if (typeof message.k !== "number")
                            return "k: number expected";
                    return null;
                };
    
                /**
                 * Creates a LRNLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.LRNLayerParams} LRNLayerParams
                 */
                LRNLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LRNLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.LRNLayerParams();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.beta != null)
                        message.beta = Number(object.beta);
                    if (object.localSize != null)
                        if ($util.Long)
                            (message.localSize = $util.Long.fromValue(object.localSize)).unsigned = true;
                        else if (typeof object.localSize === "string")
                            message.localSize = parseInt(object.localSize, 10);
                        else if (typeof object.localSize === "number")
                            message.localSize = object.localSize;
                        else if (typeof object.localSize === "object")
                            message.localSize = new $util.LongBits(object.localSize.low >>> 0, object.localSize.high >>> 0).toNumber(true);
                    if (object.k != null)
                        message.k = Number(object.k);
                    return message;
                };
    
                /**
                 * Creates a plain object from a LRNLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @static
                 * @param {CoreML.Specification.LRNLayerParams} message LRNLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LRNLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.alpha = 0;
                        object.beta = 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.localSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.localSize = options.longs === String ? "0" : 0;
                        object.k = 0;
                    }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.beta != null && message.hasOwnProperty("beta"))
                        object.beta = options.json && !isFinite(message.beta) ? String(message.beta) : message.beta;
                    if (message.localSize != null && message.hasOwnProperty("localSize"))
                        if (typeof message.localSize === "number")
                            object.localSize = options.longs === String ? String(message.localSize) : message.localSize;
                        else
                            object.localSize = options.longs === String ? $util.Long.prototype.toString.call(message.localSize) : options.longs === Number ? new $util.LongBits(message.localSize.low >>> 0, message.localSize.high >>> 0).toNumber(true) : message.localSize;
                    if (message.k != null && message.hasOwnProperty("k"))
                        object.k = options.json && !isFinite(message.k) ? String(message.k) : message.k;
                    return object;
                };
    
                /**
                 * Converts this LRNLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.LRNLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LRNLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LRNLayerParams;
            })();
    
            Specification.SoftmaxLayerParams = (function() {
    
                /**
                 * Properties of a SoftmaxLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ISoftmaxLayerParams
                 */
    
                /**
                 * Constructs a new SoftmaxLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc Softmax Normalization Layer
                 * 
                 * A layer that performs softmax normalization.
                 * Normalization is done along the channel axis.
                 * 
                 * .. code::
                 * 
                 * y = SoftmaxLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C]`` or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as the input.
                 * 
                 * This layer is described by the following formula:
                 * 
                 * .. math::
                 * x_i \leftarrow \dfrac{e^{x_i}}{\sum_i{e^{x_i}}}
                 * @implements ISoftmaxLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ISoftmaxLayerParams=} [properties] Properties to set
                 */
                function SoftmaxLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new SoftmaxLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {CoreML.Specification.ISoftmaxLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.SoftmaxLayerParams} SoftmaxLayerParams instance
                 */
                SoftmaxLayerParams.create = function create(properties) {
                    return new SoftmaxLayerParams(properties);
                };
    
                /**
                 * Encodes the specified SoftmaxLayerParams message. Does not implicitly {@link CoreML.Specification.SoftmaxLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {CoreML.Specification.ISoftmaxLayerParams} message SoftmaxLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SoftmaxLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified SoftmaxLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.SoftmaxLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {CoreML.Specification.ISoftmaxLayerParams} message SoftmaxLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SoftmaxLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SoftmaxLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SoftmaxLayerParams} SoftmaxLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SoftmaxLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SoftmaxLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SoftmaxLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SoftmaxLayerParams} SoftmaxLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SoftmaxLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SoftmaxLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SoftmaxLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a SoftmaxLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SoftmaxLayerParams} SoftmaxLayerParams
                 */
                SoftmaxLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SoftmaxLayerParams)
                        return object;
                    return new $root.CoreML.Specification.SoftmaxLayerParams();
                };
    
                /**
                 * Creates a plain object from a SoftmaxLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @static
                 * @param {CoreML.Specification.SoftmaxLayerParams} message SoftmaxLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SoftmaxLayerParams.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this SoftmaxLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SoftmaxLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SoftmaxLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SoftmaxLayerParams;
            })();
    
            Specification.SplitLayerParams = (function() {
    
                /**
                 * Properties of a SplitLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ISplitLayerParams
                 * @property {number|Long|null} [nOutputs] The number of outputs.
                 */
    
                /**
                 * Constructs a new SplitLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that uniformly splits across the channel dimension
                 * to produce a specified number of outputs.
                 * 
                 * .. code::
                 * 
                 * (y1,y2,...yN) = SplitLayer(x), where N = nOutputs
                 * 
                 * Requires 1 input and produces multiple outputs.
                 * 
                 * Input
                 * A blob with shape ``[C]`` or ``[C, H, W]``
                 * Output
                 * ``nOutputs`` blobs with shapes
                 * ``[C/nOutputs]`` or ``[C/nOutputs, H, W]``
                 * @implements ISplitLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ISplitLayerParams=} [properties] Properties to set
                 */
                function SplitLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The number of outputs.
                 * @member {number|Long} nOutputs
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @instance
                 */
                SplitLayerParams.prototype.nOutputs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new SplitLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {CoreML.Specification.ISplitLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.SplitLayerParams} SplitLayerParams instance
                 */
                SplitLayerParams.create = function create(properties) {
                    return new SplitLayerParams(properties);
                };
    
                /**
                 * Encodes the specified SplitLayerParams message. Does not implicitly {@link CoreML.Specification.SplitLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {CoreML.Specification.ISplitLayerParams} message SplitLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SplitLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nOutputs != null && message.hasOwnProperty("nOutputs"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nOutputs);
                    return writer;
                };
    
                /**
                 * Encodes the specified SplitLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.SplitLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {CoreML.Specification.ISplitLayerParams} message SplitLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SplitLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SplitLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SplitLayerParams} SplitLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SplitLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SplitLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nOutputs = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SplitLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SplitLayerParams} SplitLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SplitLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SplitLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SplitLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nOutputs != null && message.hasOwnProperty("nOutputs"))
                        if (!$util.isInteger(message.nOutputs) && !(message.nOutputs && $util.isInteger(message.nOutputs.low) && $util.isInteger(message.nOutputs.high)))
                            return "nOutputs: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a SplitLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SplitLayerParams} SplitLayerParams
                 */
                SplitLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SplitLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SplitLayerParams();
                    if (object.nOutputs != null)
                        if ($util.Long)
                            (message.nOutputs = $util.Long.fromValue(object.nOutputs)).unsigned = true;
                        else if (typeof object.nOutputs === "string")
                            message.nOutputs = parseInt(object.nOutputs, 10);
                        else if (typeof object.nOutputs === "number")
                            message.nOutputs = object.nOutputs;
                        else if (typeof object.nOutputs === "object")
                            message.nOutputs = new $util.LongBits(object.nOutputs.low >>> 0, object.nOutputs.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SplitLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @static
                 * @param {CoreML.Specification.SplitLayerParams} message SplitLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SplitLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nOutputs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nOutputs = options.longs === String ? "0" : 0;
                    if (message.nOutputs != null && message.hasOwnProperty("nOutputs"))
                        if (typeof message.nOutputs === "number")
                            object.nOutputs = options.longs === String ? String(message.nOutputs) : message.nOutputs;
                        else
                            object.nOutputs = options.longs === String ? $util.Long.prototype.toString.call(message.nOutputs) : options.longs === Number ? new $util.LongBits(message.nOutputs.low >>> 0, message.nOutputs.high >>> 0).toNumber(true) : message.nOutputs;
                    return object;
                };
    
                /**
                 * Converts this SplitLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SplitLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SplitLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SplitLayerParams;
            })();
    
            Specification.AddLayerParams = (function() {
    
                /**
                 * Properties of an AddLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IAddLayerParams
                 * @property {number|null} [alpha] Scalar to be added to the input.
                 * Only used if there is a single input.
                 */
    
                /**
                 * Constructs a new AddLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs elementwise addition.
                 * 
                 * .. code::
                 * 
                 * y = AddLayer(x1,x2,...)
                 * 
                 * Requires 1 or more than 1 input and produces 1 output.
                 * 
                 * Input
                 * One or more blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
                 * Output
                 * A blob with shape equal to the input blob.
                 * 
                 * If only one input is provided, scalar addition is performed:
                 * 
                 * .. math::
                 * y = x + \alpha
                 * @implements IAddLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IAddLayerParams=} [properties] Properties to set
                 */
                function AddLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scalar to be added to the input.
                 * Only used if there is a single input.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.AddLayerParams
                 * @instance
                 */
                AddLayerParams.prototype.alpha = 0;
    
                /**
                 * Creates a new AddLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {CoreML.Specification.IAddLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.AddLayerParams} AddLayerParams instance
                 */
                AddLayerParams.create = function create(properties) {
                    return new AddLayerParams(properties);
                };
    
                /**
                 * Encodes the specified AddLayerParams message. Does not implicitly {@link CoreML.Specification.AddLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {CoreML.Specification.IAddLayerParams} message AddLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    return writer;
                };
    
                /**
                 * Encodes the specified AddLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.AddLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {CoreML.Specification.IAddLayerParams} message AddLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AddLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an AddLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.AddLayerParams} AddLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.AddLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an AddLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.AddLayerParams} AddLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AddLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an AddLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AddLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                /**
                 * Creates an AddLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.AddLayerParams} AddLayerParams
                 */
                AddLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.AddLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.AddLayerParams();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                /**
                 * Creates a plain object from an AddLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.AddLayerParams
                 * @static
                 * @param {CoreML.Specification.AddLayerParams} message AddLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AddLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                /**
                 * Converts this AddLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.AddLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AddLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return AddLayerParams;
            })();
    
            Specification.MultiplyLayerParams = (function() {
    
                /**
                 * Properties of a MultiplyLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IMultiplyLayerParams
                 * @property {number|null} [alpha] Scalar to be multiplied with the input.
                 * Only used if there is a single input.
                 */
    
                /**
                 * Constructs a new MultiplyLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs elementwise multiplication.
                 * 
                 * .. code::
                 * 
                 * y = MultiplyLayer(x1,x2,...)
                 * 
                 * Requires 1 or more than 1 input and produces 1 output.
                 * 
                 * Input
                 * One or more blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
                 * Output
                 * A blob with shape equal to the first input blob.
                 * 
                 * If only one input is provided, scalar multiplication is performed:
                 * 
                 * .. math::
                 * y = \alpha x
                 * @implements IMultiplyLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IMultiplyLayerParams=} [properties] Properties to set
                 */
                function MultiplyLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scalar to be multiplied with the input.
                 * Only used if there is a single input.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @instance
                 */
                MultiplyLayerParams.prototype.alpha = 0;
    
                /**
                 * Creates a new MultiplyLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {CoreML.Specification.IMultiplyLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.MultiplyLayerParams} MultiplyLayerParams instance
                 */
                MultiplyLayerParams.create = function create(properties) {
                    return new MultiplyLayerParams(properties);
                };
    
                /**
                 * Encodes the specified MultiplyLayerParams message. Does not implicitly {@link CoreML.Specification.MultiplyLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {CoreML.Specification.IMultiplyLayerParams} message MultiplyLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiplyLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.alpha);
                    return writer;
                };
    
                /**
                 * Encodes the specified MultiplyLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.MultiplyLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {CoreML.Specification.IMultiplyLayerParams} message MultiplyLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MultiplyLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MultiplyLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.MultiplyLayerParams} MultiplyLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiplyLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MultiplyLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.alpha = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MultiplyLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.MultiplyLayerParams} MultiplyLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MultiplyLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MultiplyLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MultiplyLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    return null;
                };
    
                /**
                 * Creates a MultiplyLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.MultiplyLayerParams} MultiplyLayerParams
                 */
                MultiplyLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MultiplyLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.MultiplyLayerParams();
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MultiplyLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @static
                 * @param {CoreML.Specification.MultiplyLayerParams} message MultiplyLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MultiplyLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.alpha = 0;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    return object;
                };
    
                /**
                 * Converts this MultiplyLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.MultiplyLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MultiplyLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MultiplyLayerParams;
            })();
    
            Specification.UnaryFunctionLayerParams = (function() {
    
                /**
                 * Properties of an UnaryFunctionLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IUnaryFunctionLayerParams
                 * @property {CoreML.Specification.UnaryFunctionLayerParams.Operation|null} [type] UnaryFunctionLayerParams type
                 * @property {number|null} [alpha] A constant used in ``POWER`` and ``THRESHOLD`` functions.
                 * @property {number|null} [epsilon] A small constant to avoid division by 0 while normalizing variance.
                 * Defaults to ``1e-6`` if not set or set to ``0``.
                 * @property {number|null} [shift] Input is shifted by this amount
                 * before the unary function is applied.
                 * Defaults to ``0.0`` if not set.
                 * @property {number|null} [scale] Input is scaled by this amount
                 * before the unary function is applied.
                 * Defaults to ``1.0`` if not set or set to ``0``.
                 */
    
                /**
                 * Constructs a new UnaryFunctionLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that applies a unary function.
                 * 
                 * .. code::
                 * 
                 * y = UnaryFunctionLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C]`` or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as the input.
                 * 
                 * The input is first modified by shifting and scaling:
                 * 
                 * .. math::
                 * x \leftarrow \text{scale} \cdot x + \text{shift}
                 * @implements IUnaryFunctionLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IUnaryFunctionLayerParams=} [properties] Properties to set
                 */
                function UnaryFunctionLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * UnaryFunctionLayerParams type.
                 * @member {CoreML.Specification.UnaryFunctionLayerParams.Operation} type
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @instance
                 */
                UnaryFunctionLayerParams.prototype.type = 0;
    
                /**
                 * A constant used in ``POWER`` and ``THRESHOLD`` functions.
                 * @member {number} alpha
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @instance
                 */
                UnaryFunctionLayerParams.prototype.alpha = 0;
    
                /**
                 * A small constant to avoid division by 0 while normalizing variance.
                 * Defaults to ``1e-6`` if not set or set to ``0``.
                 * @member {number} epsilon
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @instance
                 */
                UnaryFunctionLayerParams.prototype.epsilon = 0;
    
                /**
                 * Input is shifted by this amount
                 * before the unary function is applied.
                 * Defaults to ``0.0`` if not set.
                 * @member {number} shift
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @instance
                 */
                UnaryFunctionLayerParams.prototype.shift = 0;
    
                /**
                 * Input is scaled by this amount
                 * before the unary function is applied.
                 * Defaults to ``1.0`` if not set or set to ``0``.
                 * @member {number} scale
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @instance
                 */
                UnaryFunctionLayerParams.prototype.scale = 0;
    
                /**
                 * Creates a new UnaryFunctionLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {CoreML.Specification.IUnaryFunctionLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.UnaryFunctionLayerParams} UnaryFunctionLayerParams instance
                 */
                UnaryFunctionLayerParams.create = function create(properties) {
                    return new UnaryFunctionLayerParams(properties);
                };
    
                /**
                 * Encodes the specified UnaryFunctionLayerParams message. Does not implicitly {@link CoreML.Specification.UnaryFunctionLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {CoreML.Specification.IUnaryFunctionLayerParams} message UnaryFunctionLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnaryFunctionLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.type != null && message.hasOwnProperty("type"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.alpha);
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.epsilon);
                    if (message.shift != null && message.hasOwnProperty("shift"))
                        writer.uint32(/* id 4, wireType 5 =*/37).float(message.shift);
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        writer.uint32(/* id 5, wireType 5 =*/45).float(message.scale);
                    return writer;
                };
    
                /**
                 * Encodes the specified UnaryFunctionLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.UnaryFunctionLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {CoreML.Specification.IUnaryFunctionLayerParams} message UnaryFunctionLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UnaryFunctionLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UnaryFunctionLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.UnaryFunctionLayerParams} UnaryFunctionLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnaryFunctionLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.UnaryFunctionLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.type = reader.int32();
                            break;
                        case 2:
                            message.alpha = reader.float();
                            break;
                        case 3:
                            message.epsilon = reader.float();
                            break;
                        case 4:
                            message.shift = reader.float();
                            break;
                        case 5:
                            message.scale = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UnaryFunctionLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.UnaryFunctionLayerParams} UnaryFunctionLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UnaryFunctionLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UnaryFunctionLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UnaryFunctionLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        if (typeof message.alpha !== "number")
                            return "alpha: number expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    if (message.shift != null && message.hasOwnProperty("shift"))
                        if (typeof message.shift !== "number")
                            return "shift: number expected";
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        if (typeof message.scale !== "number")
                            return "scale: number expected";
                    return null;
                };
    
                /**
                 * Creates an UnaryFunctionLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.UnaryFunctionLayerParams} UnaryFunctionLayerParams
                 */
                UnaryFunctionLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.UnaryFunctionLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.UnaryFunctionLayerParams();
                    switch (object.type) {
                    case "SQRT":
                    case 0:
                        message.type = 0;
                        break;
                    case "RSQRT":
                    case 1:
                        message.type = 1;
                        break;
                    case "INVERSE":
                    case 2:
                        message.type = 2;
                        break;
                    case "POWER":
                    case 3:
                        message.type = 3;
                        break;
                    case "EXP":
                    case 4:
                        message.type = 4;
                        break;
                    case "LOG":
                    case 5:
                        message.type = 5;
                        break;
                    case "ABS":
                    case 6:
                        message.type = 6;
                        break;
                    case "THRESHOLD":
                    case 7:
                        message.type = 7;
                        break;
                    }
                    if (object.alpha != null)
                        message.alpha = Number(object.alpha);
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    if (object.shift != null)
                        message.shift = Number(object.shift);
                    if (object.scale != null)
                        message.scale = Number(object.scale);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UnaryFunctionLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @static
                 * @param {CoreML.Specification.UnaryFunctionLayerParams} message UnaryFunctionLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UnaryFunctionLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "SQRT" : 0;
                        object.alpha = 0;
                        object.epsilon = 0;
                        object.shift = 0;
                        object.scale = 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.CoreML.Specification.UnaryFunctionLayerParams.Operation[message.type] : message.type;
                    if (message.alpha != null && message.hasOwnProperty("alpha"))
                        object.alpha = options.json && !isFinite(message.alpha) ? String(message.alpha) : message.alpha;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    if (message.shift != null && message.hasOwnProperty("shift"))
                        object.shift = options.json && !isFinite(message.shift) ? String(message.shift) : message.shift;
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        object.scale = options.json && !isFinite(message.scale) ? String(message.scale) : message.scale;
                    return object;
                };
    
                /**
                 * Converts this UnaryFunctionLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.UnaryFunctionLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UnaryFunctionLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * A unary operator.
                 * 
                 * The following functions are supported:
                 * 
                 * ``SQRT``
                 * .. math:: f(x) = \sqrt{x}
                 * 
                 * ``RSQRT``
                 * .. math:: f(x) = \dfrac{1}{\sqrt{x + \epsilon}}
                 * 
                 * ``INVERSE``
                 * .. math:: f(x) = \dfrac{1}{x + \epsilon}
                 * 
                 * ``POWER``
                 * .. math:: f(x) = x^\alpha
                 * 
                 * ``EXP``
                 * .. math:: f(x) = e^x
                 * 
                 * ``LOG``
                 * .. math:: f(x) = \log x
                 * 
                 * ``ABS``
                 * .. math:: f(x) = |x|
                 * 
                 * ``THRESHOLD``
                 * .. math:: f(x) = \text{max}(\alpha, x)
                 * @name CoreML.Specification.UnaryFunctionLayerParams.Operation
                 * @enum {string}
                 * @property {number} SQRT=0 SQRT value
                 * @property {number} RSQRT=1 RSQRT value
                 * @property {number} INVERSE=2 INVERSE value
                 * @property {number} POWER=3 POWER value
                 * @property {number} EXP=4 EXP value
                 * @property {number} LOG=5 LOG value
                 * @property {number} ABS=6 ABS value
                 * @property {number} THRESHOLD=7 THRESHOLD value
                 */
                UnaryFunctionLayerParams.Operation = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SQRT"] = 0;
                    values[valuesById[1] = "RSQRT"] = 1;
                    values[valuesById[2] = "INVERSE"] = 2;
                    values[valuesById[3] = "POWER"] = 3;
                    values[valuesById[4] = "EXP"] = 4;
                    values[valuesById[5] = "LOG"] = 5;
                    values[valuesById[6] = "ABS"] = 6;
                    values[valuesById[7] = "THRESHOLD"] = 7;
                    return values;
                })();
    
                return UnaryFunctionLayerParams;
            })();
    
            Specification.UpsampleLayerParams = (function() {
    
                /**
                 * Properties of an UpsampleLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IUpsampleLayerParams
                 * @property {Array.<number|Long>|null} [scalingFactor] Scaling Factor.
                 * Must be length 2 in order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * @property {CoreML.Specification.UpsampleLayerParams.InterpolationMode|null} [mode] UpsampleLayerParams mode
                 */
    
                /**
                 * Constructs a new UpsampleLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that scales up spatial dimensions.
                 * It supports two modes: nearest neighbour (default) and bilinear.
                 * 
                 * .. code::
                 * 
                 * y = UpsampleLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``.
                 * Output
                 * A blob with shape ``[C, scalingFactor[0] * H, scalingFactor[1] * W]``
                 * @implements IUpsampleLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IUpsampleLayerParams=} [properties] Properties to set
                 */
                function UpsampleLayerParams(properties) {
                    this.scalingFactor = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scaling Factor.
                 * Must be length 2 in order ``[H, W]``.
                 * If not set, default value ``[1, 1]`` is used.
                 * @member {Array.<number|Long>} scalingFactor
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @instance
                 */
                UpsampleLayerParams.prototype.scalingFactor = $util.emptyArray;
    
                /**
                 * UpsampleLayerParams mode.
                 * @member {CoreML.Specification.UpsampleLayerParams.InterpolationMode} mode
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @instance
                 */
                UpsampleLayerParams.prototype.mode = 0;
    
                /**
                 * Creates a new UpsampleLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {CoreML.Specification.IUpsampleLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.UpsampleLayerParams} UpsampleLayerParams instance
                 */
                UpsampleLayerParams.create = function create(properties) {
                    return new UpsampleLayerParams(properties);
                };
    
                /**
                 * Encodes the specified UpsampleLayerParams message. Does not implicitly {@link CoreML.Specification.UpsampleLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {CoreML.Specification.IUpsampleLayerParams} message UpsampleLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpsampleLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.scalingFactor != null && message.scalingFactor.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.scalingFactor.length; ++i)
                            writer.uint64(message.scalingFactor[i]);
                        writer.ldelim();
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.mode);
                    return writer;
                };
    
                /**
                 * Encodes the specified UpsampleLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.UpsampleLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {CoreML.Specification.IUpsampleLayerParams} message UpsampleLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpsampleLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UpsampleLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.UpsampleLayerParams} UpsampleLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpsampleLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.UpsampleLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.scalingFactor && message.scalingFactor.length))
                                message.scalingFactor = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.scalingFactor.push(reader.uint64());
                            } else
                                message.scalingFactor.push(reader.uint64());
                            break;
                        case 5:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UpsampleLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.UpsampleLayerParams} UpsampleLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpsampleLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UpsampleLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpsampleLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.scalingFactor != null && message.hasOwnProperty("scalingFactor")) {
                        if (!Array.isArray(message.scalingFactor))
                            return "scalingFactor: array expected";
                        for (var i = 0; i < message.scalingFactor.length; ++i)
                            if (!$util.isInteger(message.scalingFactor[i]) && !(message.scalingFactor[i] && $util.isInteger(message.scalingFactor[i].low) && $util.isInteger(message.scalingFactor[i].high)))
                                return "scalingFactor: integer|Long[] expected";
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates an UpsampleLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.UpsampleLayerParams} UpsampleLayerParams
                 */
                UpsampleLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.UpsampleLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.UpsampleLayerParams();
                    if (object.scalingFactor) {
                        if (!Array.isArray(object.scalingFactor))
                            throw TypeError(".CoreML.Specification.UpsampleLayerParams.scalingFactor: array expected");
                        message.scalingFactor = [];
                        for (var i = 0; i < object.scalingFactor.length; ++i)
                            if ($util.Long)
                                (message.scalingFactor[i] = $util.Long.fromValue(object.scalingFactor[i])).unsigned = true;
                            else if (typeof object.scalingFactor[i] === "string")
                                message.scalingFactor[i] = parseInt(object.scalingFactor[i], 10);
                            else if (typeof object.scalingFactor[i] === "number")
                                message.scalingFactor[i] = object.scalingFactor[i];
                            else if (typeof object.scalingFactor[i] === "object")
                                message.scalingFactor[i] = new $util.LongBits(object.scalingFactor[i].low >>> 0, object.scalingFactor[i].high >>> 0).toNumber(true);
                    }
                    switch (object.mode) {
                    case "NN":
                    case 0:
                        message.mode = 0;
                        break;
                    case "BILINEAR":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an UpsampleLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @static
                 * @param {CoreML.Specification.UpsampleLayerParams} message UpsampleLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpsampleLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.scalingFactor = [];
                    if (options.defaults)
                        object.mode = options.enums === String ? "NN" : 0;
                    if (message.scalingFactor && message.scalingFactor.length) {
                        object.scalingFactor = [];
                        for (var j = 0; j < message.scalingFactor.length; ++j)
                            if (typeof message.scalingFactor[j] === "number")
                                object.scalingFactor[j] = options.longs === String ? String(message.scalingFactor[j]) : message.scalingFactor[j];
                            else
                                object.scalingFactor[j] = options.longs === String ? $util.Long.prototype.toString.call(message.scalingFactor[j]) : options.longs === Number ? new $util.LongBits(message.scalingFactor[j].low >>> 0, message.scalingFactor[j].high >>> 0).toNumber(true) : message.scalingFactor[j];
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.UpsampleLayerParams.InterpolationMode[message.mode] : message.mode;
                    return object;
                };
    
                /**
                 * Converts this UpsampleLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.UpsampleLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpsampleLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * InterpolationMode enum.
                 * @name CoreML.Specification.UpsampleLayerParams.InterpolationMode
                 * @enum {string}
                 * @property {number} NN=0 Nearest Neighbour
                 * @property {number} BILINEAR=1 Bilinear
                 */
                UpsampleLayerParams.InterpolationMode = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "NN"] = 0;
                    values[valuesById[1] = "BILINEAR"] = 1;
                    return values;
                })();
    
                return UpsampleLayerParams;
            })();
    
            Specification.BiasLayerParams = (function() {
    
                /**
                 * Properties of a BiasLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IBiasLayerParams
                 * @property {Array.<number|Long>|null} [shape] The shape of the bias.
                 * Must be one of the following:
                 * ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
                 * @property {CoreML.Specification.IWeightParams|null} [bias] The bias values.
                 * The size must be equal to the product of the ``shape`` dimensions.
                 */
    
                /**
                 * Constructs a new BiasLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs elementwise addition of a bias,
                 * which is broadcasted to match the input shape.
                 * 
                 * .. code::
                 * 
                 * y = BiasLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as the input.
                 * @implements IBiasLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IBiasLayerParams=} [properties] Properties to set
                 */
                function BiasLayerParams(properties) {
                    this.shape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The shape of the bias.
                 * Must be one of the following:
                 * ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
                 * @member {Array.<number|Long>} shape
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @instance
                 */
                BiasLayerParams.prototype.shape = $util.emptyArray;
    
                /**
                 * The bias values.
                 * The size must be equal to the product of the ``shape`` dimensions.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} bias
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @instance
                 */
                BiasLayerParams.prototype.bias = null;
    
                /**
                 * Creates a new BiasLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {CoreML.Specification.IBiasLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.BiasLayerParams} BiasLayerParams instance
                 */
                BiasLayerParams.create = function create(properties) {
                    return new BiasLayerParams(properties);
                };
    
                /**
                 * Encodes the specified BiasLayerParams message. Does not implicitly {@link CoreML.Specification.BiasLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {CoreML.Specification.IBiasLayerParams} message BiasLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BiasLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shape != null && message.shape.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.shape.length; ++i)
                            writer.uint64(message.shape[i]);
                        writer.ldelim();
                    }
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        $root.CoreML.Specification.WeightParams.encode(message.bias, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified BiasLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.BiasLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {CoreML.Specification.IBiasLayerParams} message BiasLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BiasLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BiasLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.BiasLayerParams} BiasLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BiasLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BiasLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shape && message.shape.length))
                                message.shape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shape.push(reader.uint64());
                            } else
                                message.shape.push(reader.uint64());
                            break;
                        case 2:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BiasLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.BiasLayerParams} BiasLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BiasLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BiasLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BiasLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        if (!Array.isArray(message.shape))
                            return "shape: array expected";
                        for (var i = 0; i < message.shape.length; ++i)
                            if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                return "shape: integer|Long[] expected";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a BiasLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.BiasLayerParams} BiasLayerParams
                 */
                BiasLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BiasLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.BiasLayerParams();
                    if (object.shape) {
                        if (!Array.isArray(object.shape))
                            throw TypeError(".CoreML.Specification.BiasLayerParams.shape: array expected");
                        message.shape = [];
                        for (var i = 0; i < object.shape.length; ++i)
                            if ($util.Long)
                                (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = true;
                            else if (typeof object.shape[i] === "string")
                                message.shape[i] = parseInt(object.shape[i], 10);
                            else if (typeof object.shape[i] === "number")
                                message.shape[i] = object.shape[i];
                            else if (typeof object.shape[i] === "object")
                                message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber(true);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.BiasLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BiasLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @static
                 * @param {CoreML.Specification.BiasLayerParams} message BiasLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BiasLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.shape = [];
                    if (options.defaults)
                        object.bias = null;
                    if (message.shape && message.shape.length) {
                        object.shape = [];
                        for (var j = 0; j < message.shape.length; ++j)
                            if (typeof message.shape[j] === "number")
                                object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                            else
                                object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber(true) : message.shape[j];
                    }
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                /**
                 * Converts this BiasLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.BiasLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BiasLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BiasLayerParams;
            })();
    
            Specification.ScaleLayerParams = (function() {
    
                /**
                 * Properties of a ScaleLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IScaleLayerParams
                 * @property {Array.<number|Long>|null} [shapeScale] The shape of the scale.
                 * Must be one of the following:
                 * ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
                 * @property {CoreML.Specification.IWeightParams|null} [scale] The scale values.
                 * The size must be equal to the product of the ``shape`` dimensions.
                 * @property {boolean|null} [hasBias] ScaleLayerParams hasBias
                 * @property {Array.<number|Long>|null} [shapeBias] The shape of the bias.
                 * Must be one of the following:
                 * ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
                 * @property {CoreML.Specification.IWeightParams|null} [bias] The bias values.
                 * The size must be equal to the product of the ``shape`` dimensions.
                 */
    
                /**
                 * Constructs a new ScaleLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs elmentwise multiplication by a scale factor
                 * and optionally adds a bias;
                 * both the scale and bias are broadcasted to match the input shape.
                 * 
                 * .. code::
                 * 
                 * y = ScaleLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as the input.
                 * @implements IScaleLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IScaleLayerParams=} [properties] Properties to set
                 */
                function ScaleLayerParams(properties) {
                    this.shapeScale = [];
                    this.shapeBias = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The shape of the scale.
                 * Must be one of the following:
                 * ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
                 * @member {Array.<number|Long>} shapeScale
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @instance
                 */
                ScaleLayerParams.prototype.shapeScale = $util.emptyArray;
    
                /**
                 * The scale values.
                 * The size must be equal to the product of the ``shape`` dimensions.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} scale
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @instance
                 */
                ScaleLayerParams.prototype.scale = null;
    
                /**
                 * ScaleLayerParams hasBias.
                 * @member {boolean} hasBias
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @instance
                 */
                ScaleLayerParams.prototype.hasBias = false;
    
                /**
                 * The shape of the bias.
                 * Must be one of the following:
                 * ``[1]``, ``[C]``, ``[1, H, W]`` or ``[C, H, W]``.
                 * @member {Array.<number|Long>} shapeBias
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @instance
                 */
                ScaleLayerParams.prototype.shapeBias = $util.emptyArray;
    
                /**
                 * The bias values.
                 * The size must be equal to the product of the ``shape`` dimensions.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} bias
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @instance
                 */
                ScaleLayerParams.prototype.bias = null;
    
                /**
                 * Creates a new ScaleLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {CoreML.Specification.IScaleLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ScaleLayerParams} ScaleLayerParams instance
                 */
                ScaleLayerParams.create = function create(properties) {
                    return new ScaleLayerParams(properties);
                };
    
                /**
                 * Encodes the specified ScaleLayerParams message. Does not implicitly {@link CoreML.Specification.ScaleLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {CoreML.Specification.IScaleLayerParams} message ScaleLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ScaleLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shapeScale != null && message.shapeScale.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.shapeScale.length; ++i)
                            writer.uint64(message.shapeScale[i]);
                        writer.ldelim();
                    }
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        $root.CoreML.Specification.WeightParams.encode(message.scale, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.hasBias);
                    if (message.shapeBias != null && message.shapeBias.length) {
                        writer.uint32(/* id 4, wireType 2 =*/34).fork();
                        for (var i = 0; i < message.shapeBias.length; ++i)
                            writer.uint64(message.shapeBias[i]);
                        writer.ldelim();
                    }
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        $root.CoreML.Specification.WeightParams.encode(message.bias, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified ScaleLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.ScaleLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {CoreML.Specification.IScaleLayerParams} message ScaleLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ScaleLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ScaleLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ScaleLayerParams} ScaleLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ScaleLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ScaleLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shapeScale && message.shapeScale.length))
                                message.shapeScale = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shapeScale.push(reader.uint64());
                            } else
                                message.shapeScale.push(reader.uint64());
                            break;
                        case 2:
                            message.scale = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.hasBias = reader.bool();
                            break;
                        case 4:
                            if (!(message.shapeBias && message.shapeBias.length))
                                message.shapeBias = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shapeBias.push(reader.uint64());
                            } else
                                message.shapeBias.push(reader.uint64());
                            break;
                        case 5:
                            message.bias = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ScaleLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ScaleLayerParams} ScaleLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ScaleLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ScaleLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ScaleLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shapeScale != null && message.hasOwnProperty("shapeScale")) {
                        if (!Array.isArray(message.shapeScale))
                            return "shapeScale: array expected";
                        for (var i = 0; i < message.shapeScale.length; ++i)
                            if (!$util.isInteger(message.shapeScale[i]) && !(message.shapeScale[i] && $util.isInteger(message.shapeScale[i].low) && $util.isInteger(message.shapeScale[i].high)))
                                return "shapeScale: integer|Long[] expected";
                    }
                    if (message.scale != null && message.hasOwnProperty("scale")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.scale);
                        if (error)
                            return "scale." + error;
                    }
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        if (typeof message.hasBias !== "boolean")
                            return "hasBias: boolean expected";
                    if (message.shapeBias != null && message.hasOwnProperty("shapeBias")) {
                        if (!Array.isArray(message.shapeBias))
                            return "shapeBias: array expected";
                        for (var i = 0; i < message.shapeBias.length; ++i)
                            if (!$util.isInteger(message.shapeBias[i]) && !(message.shapeBias[i] && $util.isInteger(message.shapeBias[i].low) && $util.isInteger(message.shapeBias[i].high)))
                                return "shapeBias: integer|Long[] expected";
                    }
                    if (message.bias != null && message.hasOwnProperty("bias")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.bias);
                        if (error)
                            return "bias." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a ScaleLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ScaleLayerParams} ScaleLayerParams
                 */
                ScaleLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ScaleLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ScaleLayerParams();
                    if (object.shapeScale) {
                        if (!Array.isArray(object.shapeScale))
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.shapeScale: array expected");
                        message.shapeScale = [];
                        for (var i = 0; i < object.shapeScale.length; ++i)
                            if ($util.Long)
                                (message.shapeScale[i] = $util.Long.fromValue(object.shapeScale[i])).unsigned = true;
                            else if (typeof object.shapeScale[i] === "string")
                                message.shapeScale[i] = parseInt(object.shapeScale[i], 10);
                            else if (typeof object.shapeScale[i] === "number")
                                message.shapeScale[i] = object.shapeScale[i];
                            else if (typeof object.shapeScale[i] === "object")
                                message.shapeScale[i] = new $util.LongBits(object.shapeScale[i].low >>> 0, object.shapeScale[i].high >>> 0).toNumber(true);
                    }
                    if (object.scale != null) {
                        if (typeof object.scale !== "object")
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.scale: object expected");
                        message.scale = $root.CoreML.Specification.WeightParams.fromObject(object.scale);
                    }
                    if (object.hasBias != null)
                        message.hasBias = Boolean(object.hasBias);
                    if (object.shapeBias) {
                        if (!Array.isArray(object.shapeBias))
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.shapeBias: array expected");
                        message.shapeBias = [];
                        for (var i = 0; i < object.shapeBias.length; ++i)
                            if ($util.Long)
                                (message.shapeBias[i] = $util.Long.fromValue(object.shapeBias[i])).unsigned = true;
                            else if (typeof object.shapeBias[i] === "string")
                                message.shapeBias[i] = parseInt(object.shapeBias[i], 10);
                            else if (typeof object.shapeBias[i] === "number")
                                message.shapeBias[i] = object.shapeBias[i];
                            else if (typeof object.shapeBias[i] === "object")
                                message.shapeBias[i] = new $util.LongBits(object.shapeBias[i].low >>> 0, object.shapeBias[i].high >>> 0).toNumber(true);
                    }
                    if (object.bias != null) {
                        if (typeof object.bias !== "object")
                            throw TypeError(".CoreML.Specification.ScaleLayerParams.bias: object expected");
                        message.bias = $root.CoreML.Specification.WeightParams.fromObject(object.bias);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ScaleLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @static
                 * @param {CoreML.Specification.ScaleLayerParams} message ScaleLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ScaleLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.shapeScale = [];
                        object.shapeBias = [];
                    }
                    if (options.defaults) {
                        object.scale = null;
                        object.hasBias = false;
                        object.bias = null;
                    }
                    if (message.shapeScale && message.shapeScale.length) {
                        object.shapeScale = [];
                        for (var j = 0; j < message.shapeScale.length; ++j)
                            if (typeof message.shapeScale[j] === "number")
                                object.shapeScale[j] = options.longs === String ? String(message.shapeScale[j]) : message.shapeScale[j];
                            else
                                object.shapeScale[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shapeScale[j]) : options.longs === Number ? new $util.LongBits(message.shapeScale[j].low >>> 0, message.shapeScale[j].high >>> 0).toNumber(true) : message.shapeScale[j];
                    }
                    if (message.scale != null && message.hasOwnProperty("scale"))
                        object.scale = $root.CoreML.Specification.WeightParams.toObject(message.scale, options);
                    if (message.hasBias != null && message.hasOwnProperty("hasBias"))
                        object.hasBias = message.hasBias;
                    if (message.shapeBias && message.shapeBias.length) {
                        object.shapeBias = [];
                        for (var j = 0; j < message.shapeBias.length; ++j)
                            if (typeof message.shapeBias[j] === "number")
                                object.shapeBias[j] = options.longs === String ? String(message.shapeBias[j]) : message.shapeBias[j];
                            else
                                object.shapeBias[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shapeBias[j]) : options.longs === Number ? new $util.LongBits(message.shapeBias[j].low >>> 0, message.shapeBias[j].high >>> 0).toNumber(true) : message.shapeBias[j];
                    }
                    if (message.bias != null && message.hasOwnProperty("bias"))
                        object.bias = $root.CoreML.Specification.WeightParams.toObject(message.bias, options);
                    return object;
                };
    
                /**
                 * Converts this ScaleLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ScaleLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ScaleLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return ScaleLayerParams;
            })();
    
            Specification.LoadConstantLayerParams = (function() {
    
                /**
                 * Properties of a LoadConstantLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ILoadConstantLayerParams
                 * @property {Array.<number|Long>|null} [shape] The shape of the constant to be loaded,
                 * which must be``[C, H, W]``.
                 * @property {CoreML.Specification.IWeightParams|null} [data] The data values,
                 * of size ``C * H * W``.
                 */
    
                /**
                 * Constructs a new LoadConstantLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that loads data as a parameter and provides it as an output.
                 * 
                 * .. code::
                 * 
                 * y = LoadConstantLayer()
                 * 
                 * Takes no input. Produces 1 output.
                 * 
                 * Input
                 * None
                 * Output:
                 * A blob with shape ``[C, H, W]``
                 * @implements ILoadConstantLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ILoadConstantLayerParams=} [properties] Properties to set
                 */
                function LoadConstantLayerParams(properties) {
                    this.shape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The shape of the constant to be loaded,
                 * which must be``[C, H, W]``.
                 * @member {Array.<number|Long>} shape
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @instance
                 */
                LoadConstantLayerParams.prototype.shape = $util.emptyArray;
    
                /**
                 * The data values,
                 * of size ``C * H * W``.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} data
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @instance
                 */
                LoadConstantLayerParams.prototype.data = null;
    
                /**
                 * Creates a new LoadConstantLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {CoreML.Specification.ILoadConstantLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.LoadConstantLayerParams} LoadConstantLayerParams instance
                 */
                LoadConstantLayerParams.create = function create(properties) {
                    return new LoadConstantLayerParams(properties);
                };
    
                /**
                 * Encodes the specified LoadConstantLayerParams message. Does not implicitly {@link CoreML.Specification.LoadConstantLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {CoreML.Specification.ILoadConstantLayerParams} message LoadConstantLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LoadConstantLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shape != null && message.shape.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.shape.length; ++i)
                            writer.uint64(message.shape[i]);
                        writer.ldelim();
                    }
                    if (message.data != null && message.hasOwnProperty("data"))
                        $root.CoreML.Specification.WeightParams.encode(message.data, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified LoadConstantLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.LoadConstantLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {CoreML.Specification.ILoadConstantLayerParams} message LoadConstantLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LoadConstantLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a LoadConstantLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.LoadConstantLayerParams} LoadConstantLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LoadConstantLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LoadConstantLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shape && message.shape.length))
                                message.shape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shape.push(reader.uint64());
                            } else
                                message.shape.push(reader.uint64());
                            break;
                        case 2:
                            message.data = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a LoadConstantLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.LoadConstantLayerParams} LoadConstantLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LoadConstantLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a LoadConstantLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoadConstantLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shape != null && message.hasOwnProperty("shape")) {
                        if (!Array.isArray(message.shape))
                            return "shape: array expected";
                        for (var i = 0; i < message.shape.length; ++i)
                            if (!$util.isInteger(message.shape[i]) && !(message.shape[i] && $util.isInteger(message.shape[i].low) && $util.isInteger(message.shape[i].high)))
                                return "shape: integer|Long[] expected";
                    }
                    if (message.data != null && message.hasOwnProperty("data")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.data);
                        if (error)
                            return "data." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a LoadConstantLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.LoadConstantLayerParams} LoadConstantLayerParams
                 */
                LoadConstantLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LoadConstantLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.LoadConstantLayerParams();
                    if (object.shape) {
                        if (!Array.isArray(object.shape))
                            throw TypeError(".CoreML.Specification.LoadConstantLayerParams.shape: array expected");
                        message.shape = [];
                        for (var i = 0; i < object.shape.length; ++i)
                            if ($util.Long)
                                (message.shape[i] = $util.Long.fromValue(object.shape[i])).unsigned = true;
                            else if (typeof object.shape[i] === "string")
                                message.shape[i] = parseInt(object.shape[i], 10);
                            else if (typeof object.shape[i] === "number")
                                message.shape[i] = object.shape[i];
                            else if (typeof object.shape[i] === "object")
                                message.shape[i] = new $util.LongBits(object.shape[i].low >>> 0, object.shape[i].high >>> 0).toNumber(true);
                    }
                    if (object.data != null) {
                        if (typeof object.data !== "object")
                            throw TypeError(".CoreML.Specification.LoadConstantLayerParams.data: object expected");
                        message.data = $root.CoreML.Specification.WeightParams.fromObject(object.data);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a LoadConstantLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @static
                 * @param {CoreML.Specification.LoadConstantLayerParams} message LoadConstantLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoadConstantLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.shape = [];
                    if (options.defaults)
                        object.data = null;
                    if (message.shape && message.shape.length) {
                        object.shape = [];
                        for (var j = 0; j < message.shape.length; ++j)
                            if (typeof message.shape[j] === "number")
                                object.shape[j] = options.longs === String ? String(message.shape[j]) : message.shape[j];
                            else
                                object.shape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.shape[j]) : options.longs === Number ? new $util.LongBits(message.shape[j].low >>> 0, message.shape[j].high >>> 0).toNumber(true) : message.shape[j];
                    }
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = $root.CoreML.Specification.WeightParams.toObject(message.data, options);
                    return object;
                };
    
                /**
                 * Converts this LoadConstantLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.LoadConstantLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoadConstantLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LoadConstantLayerParams;
            })();
    
            Specification.L2NormalizeLayerParams = (function() {
    
                /**
                 * Properties of a L2NormalizeLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IL2NormalizeLayerParams
                 * @property {number|null} [epsilon] A small constant to avoid division by 0 while normalizing variance.
                 * Defaults to ``1e-6`` if not set or set to ``0``.
                 */
    
                /**
                 * Constructs a new L2NormalizeLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs L2 normalization, i.e. divides by the
                 * the square root of the sum of squares of all elements of input.
                 * 
                 * .. code::
                 * 
                 * y = L2NormalizeLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C]`` or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as the input.
                 * 
                 * This layer is described by the following formula:
                 * 
                 * .. math::
                 * x_i \leftarrow \dfrac{x_i}{\sqrt{\sum{x_i^2} + \epsilon}}
                 * @implements IL2NormalizeLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IL2NormalizeLayerParams=} [properties] Properties to set
                 */
                function L2NormalizeLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * A small constant to avoid division by 0 while normalizing variance.
                 * Defaults to ``1e-6`` if not set or set to ``0``.
                 * @member {number} epsilon
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @instance
                 */
                L2NormalizeLayerParams.prototype.epsilon = 0;
    
                /**
                 * Creates a new L2NormalizeLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.IL2NormalizeLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.L2NormalizeLayerParams} L2NormalizeLayerParams instance
                 */
                L2NormalizeLayerParams.create = function create(properties) {
                    return new L2NormalizeLayerParams(properties);
                };
    
                /**
                 * Encodes the specified L2NormalizeLayerParams message. Does not implicitly {@link CoreML.Specification.L2NormalizeLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.IL2NormalizeLayerParams} message L2NormalizeLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                L2NormalizeLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.epsilon);
                    return writer;
                };
    
                /**
                 * Encodes the specified L2NormalizeLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.L2NormalizeLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.IL2NormalizeLayerParams} message L2NormalizeLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                L2NormalizeLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a L2NormalizeLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.L2NormalizeLayerParams} L2NormalizeLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                L2NormalizeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.L2NormalizeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.epsilon = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a L2NormalizeLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.L2NormalizeLayerParams} L2NormalizeLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                L2NormalizeLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a L2NormalizeLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                L2NormalizeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    return null;
                };
    
                /**
                 * Creates a L2NormalizeLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.L2NormalizeLayerParams} L2NormalizeLayerParams
                 */
                L2NormalizeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.L2NormalizeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.L2NormalizeLayerParams();
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    return message;
                };
    
                /**
                 * Creates a plain object from a L2NormalizeLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.L2NormalizeLayerParams} message L2NormalizeLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                L2NormalizeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.epsilon = 0;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    return object;
                };
    
                /**
                 * Converts this L2NormalizeLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.L2NormalizeLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                L2NormalizeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return L2NormalizeLayerParams;
            })();
    
            Specification.FlattenLayerParams = (function() {
    
                /**
                 * Properties of a FlattenLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IFlattenLayerParams
                 * @property {CoreML.Specification.FlattenLayerParams.FlattenOrder|null} [mode] FlattenLayerParams mode
                 */
    
                /**
                 * Constructs a new FlattenLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that flattens the input.
                 * 
                 * .. code::
                 * 
                 * y = FlattenLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``.
                 * Output
                 * A blob with shape ``[C * H * W, 1, 1]``
                 * 
                 * There are two flatten orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
                 * ``CHANNEL_FIRST`` does not require data to be rearranged,
                 * because row major ordering is used by internal storage.
                 * ``CHANNEL_LAST`` requires data to be rearranged.
                 * @implements IFlattenLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IFlattenLayerParams=} [properties] Properties to set
                 */
                function FlattenLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * FlattenLayerParams mode.
                 * @member {CoreML.Specification.FlattenLayerParams.FlattenOrder} mode
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @instance
                 */
                FlattenLayerParams.prototype.mode = 0;
    
                /**
                 * Creates a new FlattenLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {CoreML.Specification.IFlattenLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.FlattenLayerParams} FlattenLayerParams instance
                 */
                FlattenLayerParams.create = function create(properties) {
                    return new FlattenLayerParams(properties);
                };
    
                /**
                 * Encodes the specified FlattenLayerParams message. Does not implicitly {@link CoreML.Specification.FlattenLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {CoreML.Specification.IFlattenLayerParams} message FlattenLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FlattenLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    return writer;
                };
    
                /**
                 * Encodes the specified FlattenLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.FlattenLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {CoreML.Specification.IFlattenLayerParams} message FlattenLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FlattenLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a FlattenLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.FlattenLayerParams} FlattenLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FlattenLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.FlattenLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a FlattenLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.FlattenLayerParams} FlattenLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FlattenLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a FlattenLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FlattenLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a FlattenLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.FlattenLayerParams} FlattenLayerParams
                 */
                FlattenLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.FlattenLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.FlattenLayerParams();
                    switch (object.mode) {
                    case "CHANNEL_FIRST":
                    case 0:
                        message.mode = 0;
                        break;
                    case "CHANNEL_LAST":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a FlattenLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @static
                 * @param {CoreML.Specification.FlattenLayerParams} message FlattenLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FlattenLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.mode = options.enums === String ? "CHANNEL_FIRST" : 0;
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.FlattenLayerParams.FlattenOrder[message.mode] : message.mode;
                    return object;
                };
    
                /**
                 * Converts this FlattenLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.FlattenLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FlattenLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * FlattenOrder enum.
                 * @name CoreML.Specification.FlattenLayerParams.FlattenOrder
                 * @enum {string}
                 * @property {number} CHANNEL_FIRST=0 CHANNEL_FIRST value
                 * @property {number} CHANNEL_LAST=1 CHANNEL_LAST value
                 */
                FlattenLayerParams.FlattenOrder = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHANNEL_FIRST"] = 0;
                    values[valuesById[1] = "CHANNEL_LAST"] = 1;
                    return values;
                })();
    
                return FlattenLayerParams;
            })();
    
            Specification.ReshapeLayerParams = (function() {
    
                /**
                 * Properties of a ReshapeLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IReshapeLayerParams
                 * @property {Array.<number|Long>|null} [targetShape] The shape of the output.
                 * Must be of length 3 or 4.
                 * If set to 3, ``targetShape`` is interpreted as
                 * ``[C_out, H_out, W_out]``, and sequence length of the input is preserved.
                 * If set to 4, ``targetShape`` is interpreted as
                 * ``[Seq_out, C_out, H_out, W_out]``,
                 * where ``Seq_out`` is the new sequence length.
                 * @property {CoreML.Specification.ReshapeLayerParams.ReshapeOrder|null} [mode] ReshapeLayerParams mode
                 */
    
                /**
                 * Constructs a new ReshapeLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that recasts the input into a new shape.
                 * 
                 * .. code::
                 * 
                 * y = ReshapeLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]`` or ``[Seq, C, H, W]``.
                 * Output
                 * A blob with shape ``[C_out, H_out, W_out]``
                 * or ``[Seq_out, C_out, H_out, W_out]``.
                 * 
                 * There are two reshape orders: ``CHANNEL_FIRST`` and ``CHANNEL_LAST``.
                 * ``CHANNEL_FIRST`` is equivalent to
                 * flattening the input to ``[C * H * W, 1, 1]`` in channel first order
                 * and then reshaping it to the target shape;
                 * no data rearrangement is required.
                 * ``CHANNEL_LAST`` is equivalent to
                 * flattening the input to ``[H * W * C, 1, 1]`` in channel last order,
                 * reshaping it to ``[H_out, W_out, C_out]`` (it is now in "H_out-major"" order),
                 * and then permuting it to ``[C_out, H_out, W_out]``;
                 * both the flattening and permuting requires the data to be rearranged.
                 * @implements IReshapeLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IReshapeLayerParams=} [properties] Properties to set
                 */
                function ReshapeLayerParams(properties) {
                    this.targetShape = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The shape of the output.
                 * Must be of length 3 or 4.
                 * If set to 3, ``targetShape`` is interpreted as
                 * ``[C_out, H_out, W_out]``, and sequence length of the input is preserved.
                 * If set to 4, ``targetShape`` is interpreted as
                 * ``[Seq_out, C_out, H_out, W_out]``,
                 * where ``Seq_out`` is the new sequence length.
                 * @member {Array.<number|Long>} targetShape
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @instance
                 */
                ReshapeLayerParams.prototype.targetShape = $util.emptyArray;
    
                /**
                 * ReshapeLayerParams mode.
                 * @member {CoreML.Specification.ReshapeLayerParams.ReshapeOrder} mode
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @instance
                 */
                ReshapeLayerParams.prototype.mode = 0;
    
                /**
                 * Creates a new ReshapeLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {CoreML.Specification.IReshapeLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ReshapeLayerParams} ReshapeLayerParams instance
                 */
                ReshapeLayerParams.create = function create(properties) {
                    return new ReshapeLayerParams(properties);
                };
    
                /**
                 * Encodes the specified ReshapeLayerParams message. Does not implicitly {@link CoreML.Specification.ReshapeLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {CoreML.Specification.IReshapeLayerParams} message ReshapeLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReshapeLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.targetShape != null && message.targetShape.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.targetShape.length; ++i)
                            writer.int64(message.targetShape[i]);
                        writer.ldelim();
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.mode);
                    return writer;
                };
    
                /**
                 * Encodes the specified ReshapeLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.ReshapeLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {CoreML.Specification.IReshapeLayerParams} message ReshapeLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReshapeLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReshapeLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ReshapeLayerParams} ReshapeLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReshapeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ReshapeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.targetShape && message.targetShape.length))
                                message.targetShape = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.targetShape.push(reader.int64());
                            } else
                                message.targetShape.push(reader.int64());
                            break;
                        case 2:
                            message.mode = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReshapeLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ReshapeLayerParams} ReshapeLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReshapeLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReshapeLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReshapeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.targetShape != null && message.hasOwnProperty("targetShape")) {
                        if (!Array.isArray(message.targetShape))
                            return "targetShape: array expected";
                        for (var i = 0; i < message.targetShape.length; ++i)
                            if (!$util.isInteger(message.targetShape[i]) && !(message.targetShape[i] && $util.isInteger(message.targetShape[i].low) && $util.isInteger(message.targetShape[i].high)))
                                return "targetShape: integer|Long[] expected";
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a ReshapeLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ReshapeLayerParams} ReshapeLayerParams
                 */
                ReshapeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ReshapeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ReshapeLayerParams();
                    if (object.targetShape) {
                        if (!Array.isArray(object.targetShape))
                            throw TypeError(".CoreML.Specification.ReshapeLayerParams.targetShape: array expected");
                        message.targetShape = [];
                        for (var i = 0; i < object.targetShape.length; ++i)
                            if ($util.Long)
                                (message.targetShape[i] = $util.Long.fromValue(object.targetShape[i])).unsigned = false;
                            else if (typeof object.targetShape[i] === "string")
                                message.targetShape[i] = parseInt(object.targetShape[i], 10);
                            else if (typeof object.targetShape[i] === "number")
                                message.targetShape[i] = object.targetShape[i];
                            else if (typeof object.targetShape[i] === "object")
                                message.targetShape[i] = new $util.LongBits(object.targetShape[i].low >>> 0, object.targetShape[i].high >>> 0).toNumber();
                    }
                    switch (object.mode) {
                    case "CHANNEL_FIRST":
                    case 0:
                        message.mode = 0;
                        break;
                    case "CHANNEL_LAST":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReshapeLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @static
                 * @param {CoreML.Specification.ReshapeLayerParams} message ReshapeLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReshapeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.targetShape = [];
                    if (options.defaults)
                        object.mode = options.enums === String ? "CHANNEL_FIRST" : 0;
                    if (message.targetShape && message.targetShape.length) {
                        object.targetShape = [];
                        for (var j = 0; j < message.targetShape.length; ++j)
                            if (typeof message.targetShape[j] === "number")
                                object.targetShape[j] = options.longs === String ? String(message.targetShape[j]) : message.targetShape[j];
                            else
                                object.targetShape[j] = options.longs === String ? $util.Long.prototype.toString.call(message.targetShape[j]) : options.longs === Number ? new $util.LongBits(message.targetShape[j].low >>> 0, message.targetShape[j].high >>> 0).toNumber() : message.targetShape[j];
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.ReshapeLayerParams.ReshapeOrder[message.mode] : message.mode;
                    return object;
                };
    
                /**
                 * Converts this ReshapeLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ReshapeLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReshapeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * ReshapeOrder enum.
                 * @name CoreML.Specification.ReshapeLayerParams.ReshapeOrder
                 * @enum {string}
                 * @property {number} CHANNEL_FIRST=0 CHANNEL_FIRST value
                 * @property {number} CHANNEL_LAST=1 CHANNEL_LAST value
                 */
                ReshapeLayerParams.ReshapeOrder = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHANNEL_FIRST"] = 0;
                    values[valuesById[1] = "CHANNEL_LAST"] = 1;
                    return values;
                })();
    
                return ReshapeLayerParams;
            })();
    
            Specification.PermuteLayerParams = (function() {
    
                /**
                 * Properties of a PermuteLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IPermuteLayerParams
                 * @property {Array.<number|Long>|null} [axis] The order in which to permute the dimensions.
                 * Must have length 4 and a permutation of ``[0, 1, 2, 3]``.
                 */
    
                /**
                 * Constructs a new PermuteLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that rearranges the dimensions and data of an input.
                 * 
                 * .. code::
                 * 
                 * y = PermuteLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A sequence of 3-dimensional blobs. ``InputShape = [Seq, C, H, W]``.
                 * Output
                 * A sequence of a different length of 3-dimensional blobs.
                 * Shape: ``[InputShape[axis[0]], InputShape[axis[1]],
                 * InputShape[axis[2]], InputShape[axis[3]]]``. Hence output is a sequence of length ``InputShape[axis[0]]``.
                 * 
                 * Examples:
                 * 
                 * - If ``axis`` is set to ``[0, 3, 1, 2]``,
                 * then the output has shape ``[W,C,H]``
                 * and has the same sequence length that of the input.
                 * 
                 * - If ``axis`` is set to ``[3, 1, 2, 0]``,
                 * and the input is a sequence of data
                 * with length ``Seq`` and shape ``[C, 1, 1]``,
                 * then the output is a unit sequence of data with shape ``[C, 1, Seq]``.
                 * 
                 * - If ``axis`` is set to ``[0, 3, 2, 1]``,
                 * the output is a reverse of the input: ``[C, H, W] -> [W, H, C]``.
                 * 
                 * - If ``axis`` is not set, or is set to ``[0, 1, 2, 3]``,
                 * the output is the same as the input.
                 * @implements IPermuteLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IPermuteLayerParams=} [properties] Properties to set
                 */
                function PermuteLayerParams(properties) {
                    this.axis = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The order in which to permute the dimensions.
                 * Must have length 4 and a permutation of ``[0, 1, 2, 3]``.
                 * @member {Array.<number|Long>} axis
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @instance
                 */
                PermuteLayerParams.prototype.axis = $util.emptyArray;
    
                /**
                 * Creates a new PermuteLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {CoreML.Specification.IPermuteLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.PermuteLayerParams} PermuteLayerParams instance
                 */
                PermuteLayerParams.create = function create(properties) {
                    return new PermuteLayerParams(properties);
                };
    
                /**
                 * Encodes the specified PermuteLayerParams message. Does not implicitly {@link CoreML.Specification.PermuteLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {CoreML.Specification.IPermuteLayerParams} message PermuteLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PermuteLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.axis != null && message.axis.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.axis.length; ++i)
                            writer.uint64(message.axis[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified PermuteLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.PermuteLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {CoreML.Specification.IPermuteLayerParams} message PermuteLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PermuteLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PermuteLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.PermuteLayerParams} PermuteLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PermuteLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PermuteLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.axis && message.axis.length))
                                message.axis = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.axis.push(reader.uint64());
                            } else
                                message.axis.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PermuteLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.PermuteLayerParams} PermuteLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PermuteLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PermuteLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PermuteLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.axis != null && message.hasOwnProperty("axis")) {
                        if (!Array.isArray(message.axis))
                            return "axis: array expected";
                        for (var i = 0; i < message.axis.length; ++i)
                            if (!$util.isInteger(message.axis[i]) && !(message.axis[i] && $util.isInteger(message.axis[i].low) && $util.isInteger(message.axis[i].high)))
                                return "axis: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a PermuteLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.PermuteLayerParams} PermuteLayerParams
                 */
                PermuteLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PermuteLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.PermuteLayerParams();
                    if (object.axis) {
                        if (!Array.isArray(object.axis))
                            throw TypeError(".CoreML.Specification.PermuteLayerParams.axis: array expected");
                        message.axis = [];
                        for (var i = 0; i < object.axis.length; ++i)
                            if ($util.Long)
                                (message.axis[i] = $util.Long.fromValue(object.axis[i])).unsigned = true;
                            else if (typeof object.axis[i] === "string")
                                message.axis[i] = parseInt(object.axis[i], 10);
                            else if (typeof object.axis[i] === "number")
                                message.axis[i] = object.axis[i];
                            else if (typeof object.axis[i] === "object")
                                message.axis[i] = new $util.LongBits(object.axis[i].low >>> 0, object.axis[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a PermuteLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @static
                 * @param {CoreML.Specification.PermuteLayerParams} message PermuteLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PermuteLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.axis = [];
                    if (message.axis && message.axis.length) {
                        object.axis = [];
                        for (var j = 0; j < message.axis.length; ++j)
                            if (typeof message.axis[j] === "number")
                                object.axis[j] = options.longs === String ? String(message.axis[j]) : message.axis[j];
                            else
                                object.axis[j] = options.longs === String ? $util.Long.prototype.toString.call(message.axis[j]) : options.longs === Number ? new $util.LongBits(message.axis[j].low >>> 0, message.axis[j].high >>> 0).toNumber(true) : message.axis[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this PermuteLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.PermuteLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PermuteLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PermuteLayerParams;
            })();
    
            Specification.ReorganizeDataLayerParams = (function() {
    
                /**
                 * Properties of a ReorganizeDataLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IReorganizeDataLayerParams
                 * @property {CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType|null} [mode] ReorganizeDataLayerParams mode
                 * @property {number|Long|null} [blockSize] must be greater than 1
                 */
    
                /**
                 * Constructs a new ReorganizeDataLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that reorganizes data in the input in specific ways.
                 * 
                 * .. code::
                 * 
                 * y = ReorganizeDataLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``.
                 * Output
                 * A blob with shape ``[C_out, H_out, W_out]``.
                 * 
                 * mode == SPACE_TO_DEPTH
                 * ``[C_out, H_out, W_out]`` : ``[C * blockSize * blockSize, H/blockSize, W/blockSize]``.
                 * blockSize must divide H and W.
                 * Data is moved from the spatial dimensions to the channel dimension. Input is spatially divided into
                 * non-overlapping blocks of size blockSize X blockSize and data from each block is moved into the
                 * channel dimension.
                 * 
                 * mode == DEPTH_TO_SPACE
                 * ``[C_out, H_out, W_out]`` : ``[C/(blockSize * blockSize), H * blockSize, W * blockSize]``.
                 * Square of blockSize must divide C.
                 * Reverse of SPACE_TO_DEPTH. Data is moved from the channel dimension to the spatial dimensions.
                 * @implements IReorganizeDataLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IReorganizeDataLayerParams=} [properties] Properties to set
                 */
                function ReorganizeDataLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReorganizeDataLayerParams mode.
                 * @member {CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType} mode
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @instance
                 */
                ReorganizeDataLayerParams.prototype.mode = 0;
    
                /**
                 * must be greater than 1
                 * @member {number|Long} blockSize
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @instance
                 */
                ReorganizeDataLayerParams.prototype.blockSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new ReorganizeDataLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {CoreML.Specification.IReorganizeDataLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ReorganizeDataLayerParams} ReorganizeDataLayerParams instance
                 */
                ReorganizeDataLayerParams.create = function create(properties) {
                    return new ReorganizeDataLayerParams(properties);
                };
    
                /**
                 * Encodes the specified ReorganizeDataLayerParams message. Does not implicitly {@link CoreML.Specification.ReorganizeDataLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {CoreML.Specification.IReorganizeDataLayerParams} message ReorganizeDataLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReorganizeDataLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.blockSize);
                    return writer;
                };
    
                /**
                 * Encodes the specified ReorganizeDataLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.ReorganizeDataLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {CoreML.Specification.IReorganizeDataLayerParams} message ReorganizeDataLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReorganizeDataLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReorganizeDataLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ReorganizeDataLayerParams} ReorganizeDataLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReorganizeDataLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ReorganizeDataLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        case 2:
                            message.blockSize = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReorganizeDataLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ReorganizeDataLayerParams} ReorganizeDataLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReorganizeDataLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReorganizeDataLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReorganizeDataLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                        if (!$util.isInteger(message.blockSize) && !(message.blockSize && $util.isInteger(message.blockSize.low) && $util.isInteger(message.blockSize.high)))
                            return "blockSize: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a ReorganizeDataLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ReorganizeDataLayerParams} ReorganizeDataLayerParams
                 */
                ReorganizeDataLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ReorganizeDataLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ReorganizeDataLayerParams();
                    switch (object.mode) {
                    case "SPACE_TO_DEPTH":
                    case 0:
                        message.mode = 0;
                        break;
                    case "DEPTH_TO_SPACE":
                    case 1:
                        message.mode = 1;
                        break;
                    }
                    if (object.blockSize != null)
                        if ($util.Long)
                            (message.blockSize = $util.Long.fromValue(object.blockSize)).unsigned = true;
                        else if (typeof object.blockSize === "string")
                            message.blockSize = parseInt(object.blockSize, 10);
                        else if (typeof object.blockSize === "number")
                            message.blockSize = object.blockSize;
                        else if (typeof object.blockSize === "object")
                            message.blockSize = new $util.LongBits(object.blockSize.low >>> 0, object.blockSize.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReorganizeDataLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @static
                 * @param {CoreML.Specification.ReorganizeDataLayerParams} message ReorganizeDataLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReorganizeDataLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mode = options.enums === String ? "SPACE_TO_DEPTH" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.blockSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.blockSize = options.longs === String ? "0" : 0;
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType[message.mode] : message.mode;
                    if (message.blockSize != null && message.hasOwnProperty("blockSize"))
                        if (typeof message.blockSize === "number")
                            object.blockSize = options.longs === String ? String(message.blockSize) : message.blockSize;
                        else
                            object.blockSize = options.longs === String ? $util.Long.prototype.toString.call(message.blockSize) : options.longs === Number ? new $util.LongBits(message.blockSize.low >>> 0, message.blockSize.high >>> 0).toNumber(true) : message.blockSize;
                    return object;
                };
    
                /**
                 * Converts this ReorganizeDataLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ReorganizeDataLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReorganizeDataLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * ReorganizationType enum.
                 * @name CoreML.Specification.ReorganizeDataLayerParams.ReorganizationType
                 * @enum {string}
                 * @property {number} SPACE_TO_DEPTH=0 SPACE_TO_DEPTH value
                 * @property {number} DEPTH_TO_SPACE=1 DEPTH_TO_SPACE value
                 */
                ReorganizeDataLayerParams.ReorganizationType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SPACE_TO_DEPTH"] = 0;
                    values[valuesById[1] = "DEPTH_TO_SPACE"] = 1;
                    return values;
                })();
    
                return ReorganizeDataLayerParams;
            })();
    
            Specification.SliceLayerParams = (function() {
    
                /**
                 * Properties of a SliceLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ISliceLayerParams
                 * @property {number|Long|null} [startIndex] start of the sliced section. Inclusive.
                 * @property {number|Long|null} [endIndex] end of sliced section. Exclusive.
                 * @property {number|Long|null} [stride] The step size. Must be positive.
                 * @property {CoreML.Specification.SliceLayerParams.SliceAxis|null} [axis] SliceLayerParams axis
                 */
    
                /**
                 * Constructs a new SliceLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that slices the input data along a given axis.
                 * 
                 * .. code::
                 * 
                 * y = SliceLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[Seq, C, H, W]``.
                 * Output
                 * A blob with shape ``[Seq_out, C_out, H_out, W_out]``.
                 * 
                 * Sliced section is taken from the interval ``[startIndex, endIndex)``, i.e.
                 * startIndex is inclusive while endIndex is exclusive.
                 * stride must be positive and represents the step size for slicing.
                 * startIndex must be non-negative. Negative indexing is supported for endIndex: -1 denotes N, -2 denotes N-1
                 * and so on, where N is the length of the dimension to be sliced.
                 * @implements ISliceLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ISliceLayerParams=} [properties] Properties to set
                 */
                function SliceLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * start of the sliced section. Inclusive.
                 * @member {number|Long} startIndex
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @instance
                 */
                SliceLayerParams.prototype.startIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * end of sliced section. Exclusive.
                 * @member {number|Long} endIndex
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @instance
                 */
                SliceLayerParams.prototype.endIndex = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                /**
                 * The step size. Must be positive.
                 * @member {number|Long} stride
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @instance
                 */
                SliceLayerParams.prototype.stride = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * SliceLayerParams axis.
                 * @member {CoreML.Specification.SliceLayerParams.SliceAxis} axis
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @instance
                 */
                SliceLayerParams.prototype.axis = 0;
    
                /**
                 * Creates a new SliceLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {CoreML.Specification.ISliceLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.SliceLayerParams} SliceLayerParams instance
                 */
                SliceLayerParams.create = function create(properties) {
                    return new SliceLayerParams(properties);
                };
    
                /**
                 * Encodes the specified SliceLayerParams message. Does not implicitly {@link CoreML.Specification.SliceLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {CoreML.Specification.ISliceLayerParams} message SliceLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SliceLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.startIndex);
                    if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.endIndex);
                    if (message.stride != null && message.hasOwnProperty("stride"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.stride);
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.axis);
                    return writer;
                };
    
                /**
                 * Encodes the specified SliceLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.SliceLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {CoreML.Specification.ISliceLayerParams} message SliceLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SliceLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SliceLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SliceLayerParams} SliceLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SliceLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SliceLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.startIndex = reader.uint64();
                            break;
                        case 2:
                            message.endIndex = reader.int64();
                            break;
                        case 3:
                            message.stride = reader.uint64();
                            break;
                        case 4:
                            message.axis = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SliceLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SliceLayerParams} SliceLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SliceLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SliceLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SliceLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        if (!$util.isInteger(message.startIndex) && !(message.startIndex && $util.isInteger(message.startIndex.low) && $util.isInteger(message.startIndex.high)))
                            return "startIndex: integer|Long expected";
                    if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                        if (!$util.isInteger(message.endIndex) && !(message.endIndex && $util.isInteger(message.endIndex.low) && $util.isInteger(message.endIndex.high)))
                            return "endIndex: integer|Long expected";
                    if (message.stride != null && message.hasOwnProperty("stride"))
                        if (!$util.isInteger(message.stride) && !(message.stride && $util.isInteger(message.stride.low) && $util.isInteger(message.stride.high)))
                            return "stride: integer|Long expected";
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        switch (message.axis) {
                        default:
                            return "axis: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a SliceLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SliceLayerParams} SliceLayerParams
                 */
                SliceLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SliceLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SliceLayerParams();
                    if (object.startIndex != null)
                        if ($util.Long)
                            (message.startIndex = $util.Long.fromValue(object.startIndex)).unsigned = true;
                        else if (typeof object.startIndex === "string")
                            message.startIndex = parseInt(object.startIndex, 10);
                        else if (typeof object.startIndex === "number")
                            message.startIndex = object.startIndex;
                        else if (typeof object.startIndex === "object")
                            message.startIndex = new $util.LongBits(object.startIndex.low >>> 0, object.startIndex.high >>> 0).toNumber(true);
                    if (object.endIndex != null)
                        if ($util.Long)
                            (message.endIndex = $util.Long.fromValue(object.endIndex)).unsigned = false;
                        else if (typeof object.endIndex === "string")
                            message.endIndex = parseInt(object.endIndex, 10);
                        else if (typeof object.endIndex === "number")
                            message.endIndex = object.endIndex;
                        else if (typeof object.endIndex === "object")
                            message.endIndex = new $util.LongBits(object.endIndex.low >>> 0, object.endIndex.high >>> 0).toNumber();
                    if (object.stride != null)
                        if ($util.Long)
                            (message.stride = $util.Long.fromValue(object.stride)).unsigned = true;
                        else if (typeof object.stride === "string")
                            message.stride = parseInt(object.stride, 10);
                        else if (typeof object.stride === "number")
                            message.stride = object.stride;
                        else if (typeof object.stride === "object")
                            message.stride = new $util.LongBits(object.stride.low >>> 0, object.stride.high >>> 0).toNumber(true);
                    switch (object.axis) {
                    case "CHANNEL_AXIS":
                    case 0:
                        message.axis = 0;
                        break;
                    case "HEIGHT_AXIS":
                    case 1:
                        message.axis = 1;
                        break;
                    case "WIDTH_AXIS":
                    case 2:
                        message.axis = 2;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SliceLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @static
                 * @param {CoreML.Specification.SliceLayerParams} message SliceLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SliceLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.startIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.startIndex = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.endIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.endIndex = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.stride = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.stride = options.longs === String ? "0" : 0;
                        object.axis = options.enums === String ? "CHANNEL_AXIS" : 0;
                    }
                    if (message.startIndex != null && message.hasOwnProperty("startIndex"))
                        if (typeof message.startIndex === "number")
                            object.startIndex = options.longs === String ? String(message.startIndex) : message.startIndex;
                        else
                            object.startIndex = options.longs === String ? $util.Long.prototype.toString.call(message.startIndex) : options.longs === Number ? new $util.LongBits(message.startIndex.low >>> 0, message.startIndex.high >>> 0).toNumber(true) : message.startIndex;
                    if (message.endIndex != null && message.hasOwnProperty("endIndex"))
                        if (typeof message.endIndex === "number")
                            object.endIndex = options.longs === String ? String(message.endIndex) : message.endIndex;
                        else
                            object.endIndex = options.longs === String ? $util.Long.prototype.toString.call(message.endIndex) : options.longs === Number ? new $util.LongBits(message.endIndex.low >>> 0, message.endIndex.high >>> 0).toNumber() : message.endIndex;
                    if (message.stride != null && message.hasOwnProperty("stride"))
                        if (typeof message.stride === "number")
                            object.stride = options.longs === String ? String(message.stride) : message.stride;
                        else
                            object.stride = options.longs === String ? $util.Long.prototype.toString.call(message.stride) : options.longs === Number ? new $util.LongBits(message.stride.low >>> 0, message.stride.high >>> 0).toNumber(true) : message.stride;
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        object.axis = options.enums === String ? $root.CoreML.Specification.SliceLayerParams.SliceAxis[message.axis] : message.axis;
                    return object;
                };
    
                /**
                 * Converts this SliceLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SliceLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SliceLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * SliceAxis enum.
                 * @name CoreML.Specification.SliceLayerParams.SliceAxis
                 * @enum {string}
                 * @property {number} CHANNEL_AXIS=0 CHANNEL_AXIS value
                 * @property {number} HEIGHT_AXIS=1 HEIGHT_AXIS value
                 * @property {number} WIDTH_AXIS=2 WIDTH_AXIS value
                 */
                SliceLayerParams.SliceAxis = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHANNEL_AXIS"] = 0;
                    values[valuesById[1] = "HEIGHT_AXIS"] = 1;
                    values[valuesById[2] = "WIDTH_AXIS"] = 2;
                    return values;
                })();
    
                return SliceLayerParams;
            })();
    
            Specification.ReduceLayerParams = (function() {
    
                /**
                 * Properties of a ReduceLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IReduceLayerParams
                 * @property {CoreML.Specification.ReduceLayerParams.ReduceOperation|null} [mode] ReduceLayerParams mode
                 * @property {number|null} [epsilon] Used if mode is ``LOGSUM``.
                 * Defaults to ``1e-6`` if not set or is set to ``0``.
                 * @property {CoreML.Specification.ReduceLayerParams.ReduceAxis|null} [axis] ReduceLayerParams axis
                 */
    
                /**
                 * Constructs a new ReduceLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that reduces the input using a specified operation.
                 * 
                 * .. code::
                 * 
                 * y = ReduceLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C, H, W]``.
                 * Output
                 * A blob whose shape depends on the value of axis, the dimension(s) along which reduction is performed.
                 * if axis == C   : ``[1, H, W]``
                 * if axis == H   : ``[C, 1, W]``
                 * if axis == W   : ``[C, H, 1]``
                 * if axis == HW  : ``[C, 1, 1]``
                 * if axis == CHW : ``[1, 1, 1]`` [Default]
                 * @implements IReduceLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IReduceLayerParams=} [properties] Properties to set
                 */
                function ReduceLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * ReduceLayerParams mode.
                 * @member {CoreML.Specification.ReduceLayerParams.ReduceOperation} mode
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @instance
                 */
                ReduceLayerParams.prototype.mode = 0;
    
                /**
                 * Used if mode is ``LOGSUM``.
                 * Defaults to ``1e-6`` if not set or is set to ``0``.
                 * @member {number} epsilon
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @instance
                 */
                ReduceLayerParams.prototype.epsilon = 0;
    
                /**
                 * ReduceLayerParams axis.
                 * @member {CoreML.Specification.ReduceLayerParams.ReduceAxis} axis
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @instance
                 */
                ReduceLayerParams.prototype.axis = 0;
    
                /**
                 * Creates a new ReduceLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {CoreML.Specification.IReduceLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.ReduceLayerParams} ReduceLayerParams instance
                 */
                ReduceLayerParams.create = function create(properties) {
                    return new ReduceLayerParams(properties);
                };
    
                /**
                 * Encodes the specified ReduceLayerParams message. Does not implicitly {@link CoreML.Specification.ReduceLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {CoreML.Specification.IReduceLayerParams} message ReduceLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReduceLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.epsilon);
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.axis);
                    return writer;
                };
    
                /**
                 * Encodes the specified ReduceLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.ReduceLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {CoreML.Specification.IReduceLayerParams} message ReduceLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReduceLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a ReduceLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.ReduceLayerParams} ReduceLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReduceLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.ReduceLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.mode = reader.int32();
                            break;
                        case 2:
                            message.epsilon = reader.float();
                            break;
                        case 3:
                            message.axis = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a ReduceLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.ReduceLayerParams} ReduceLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReduceLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a ReduceLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReduceLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        switch (message.mode) {
                        default:
                            return "mode: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        switch (message.axis) {
                        default:
                            return "axis: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a ReduceLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.ReduceLayerParams} ReduceLayerParams
                 */
                ReduceLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.ReduceLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.ReduceLayerParams();
                    switch (object.mode) {
                    case "SUM":
                    case 0:
                        message.mode = 0;
                        break;
                    case "AVG":
                    case 1:
                        message.mode = 1;
                        break;
                    case "PROD":
                    case 2:
                        message.mode = 2;
                        break;
                    case "LOGSUM":
                    case 3:
                        message.mode = 3;
                        break;
                    case "SUMSQUARE":
                    case 4:
                        message.mode = 4;
                        break;
                    case "L1":
                    case 5:
                        message.mode = 5;
                        break;
                    case "L2":
                    case 6:
                        message.mode = 6;
                        break;
                    case "MAX":
                    case 7:
                        message.mode = 7;
                        break;
                    case "MIN":
                    case 8:
                        message.mode = 8;
                        break;
                    case "ARGMAX":
                    case 9:
                        message.mode = 9;
                        break;
                    }
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    switch (object.axis) {
                    case "CHW":
                    case 0:
                        message.axis = 0;
                        break;
                    case "HW":
                    case 1:
                        message.axis = 1;
                        break;
                    case "C":
                    case 2:
                        message.axis = 2;
                        break;
                    case "H":
                    case 3:
                        message.axis = 3;
                        break;
                    case "W":
                    case 4:
                        message.axis = 4;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a ReduceLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @static
                 * @param {CoreML.Specification.ReduceLayerParams} message ReduceLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReduceLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.mode = options.enums === String ? "SUM" : 0;
                        object.epsilon = 0;
                        object.axis = options.enums === String ? "CHW" : 0;
                    }
                    if (message.mode != null && message.hasOwnProperty("mode"))
                        object.mode = options.enums === String ? $root.CoreML.Specification.ReduceLayerParams.ReduceOperation[message.mode] : message.mode;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    if (message.axis != null && message.hasOwnProperty("axis"))
                        object.axis = options.enums === String ? $root.CoreML.Specification.ReduceLayerParams.ReduceAxis[message.axis] : message.axis;
                    return object;
                };
    
                /**
                 * Converts this ReduceLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.ReduceLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReduceLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * ReduceOperation enum.
                 * @name CoreML.Specification.ReduceLayerParams.ReduceOperation
                 * @enum {string}
                 * @property {number} SUM=0 SUM value
                 * @property {number} AVG=1 AVG value
                 * @property {number} PROD=2 PROD value
                 * @property {number} LOGSUM=3 LOGSUM value
                 * @property {number} SUMSQUARE=4 SUMSQUARE value
                 * @property {number} L1=5 L1 value
                 * @property {number} L2=6 L2 value
                 * @property {number} MAX=7 MAX value
                 * @property {number} MIN=8 MIN value
                 * @property {number} ARGMAX=9 only supported with axis = C, H or W.
                 */
                ReduceLayerParams.ReduceOperation = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "SUM"] = 0;
                    values[valuesById[1] = "AVG"] = 1;
                    values[valuesById[2] = "PROD"] = 2;
                    values[valuesById[3] = "LOGSUM"] = 3;
                    values[valuesById[4] = "SUMSQUARE"] = 4;
                    values[valuesById[5] = "L1"] = 5;
                    values[valuesById[6] = "L2"] = 6;
                    values[valuesById[7] = "MAX"] = 7;
                    values[valuesById[8] = "MIN"] = 8;
                    values[valuesById[9] = "ARGMAX"] = 9;
                    return values;
                })();
    
                /**
                 * ReduceAxis enum.
                 * @name CoreML.Specification.ReduceLayerParams.ReduceAxis
                 * @enum {string}
                 * @property {number} CHW=0 CHW value
                 * @property {number} HW=1 HW value
                 * @property {number} C=2 C value
                 * @property {number} H=3 H value
                 * @property {number} W=4 W value
                 */
                ReduceLayerParams.ReduceAxis = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "CHW"] = 0;
                    values[valuesById[1] = "HW"] = 1;
                    values[valuesById[2] = "C"] = 2;
                    values[valuesById[3] = "H"] = 3;
                    values[valuesById[4] = "W"] = 4;
                    return values;
                })();
    
                return ReduceLayerParams;
            })();
    
            Specification.CropLayerParams = (function() {
    
                /**
                 * Properties of a CropLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ICropLayerParams
                 * @property {CoreML.Specification.IBorderAmounts|null} [cropAmounts] The amounts to be cropped from the input.
                 * Used only if a single input is provided.
                 * @property {Array.<number|Long>|null} [offset] The offset amounts.
                 * Used only if two inputs are provided.
                 * Must be of length 2, in order ``[H, W]``.
                 */
    
                /**
                 * Constructs a new CropLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that crops the spatial dimensions of an input.
                 * If two inputs are provided, the shape of the second input is used as the reference shape.
                 * 
                 * .. code::
                 * 
                 * y = CropLayer(x1) or y = CropLayer(x1,x2)
                 * 
                 * Requires 1 or 2 inputs and produces 1 output.
                 * 
                 * Input
                 * - 1 input case: A blob with shape ``[C, H_in, W_in]``.
                 * - 2 input case: 1st blob with shape ``[C, H_in, W_in]``, 2nd blob with shape ``[C, H_out, W_out]``.
                 * 
                 * Output
                 * A blob with shape ``[C, H_out, W_out]``.
                 * 
                 * If one input is used, output is computed as follows:
                 * 
                 * .. code::
                 * 
                 * y = x1[:, topCropAmount:H_in - bottomCropAmount, leftCropAmount:W_in - rightCropAmount]
                 * 
                 * topCropAmount == Height startEdgeSize == borderAmounts[0].startEdgeSize
                 * bottomCropAmount == Height endEdgeSize == borderAmounts[0].endEdgeSize
                 * leftCropAmount == Width startEdgeSize == borderAmounts[1].startEdgeSize
                 * rightCropAmount == Width endEdgeSize == borderAmounts[1].endEdgeSize
                 * 
                 * H_out = H_in - topCropAmount - bottomCropAmount
                 * W_out = W_in - leftCropAmount - rightCropAmount
                 * 
                 * If two inputs are used, output is computed as follows:
                 * 
                 * .. code::
                 * 
                 * y = x1[:, offset[0]:offset[0] + H_out, offset[1]:offset[1] + W_out]
                 * @implements ICropLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ICropLayerParams=} [properties] Properties to set
                 */
                function CropLayerParams(properties) {
                    this.offset = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The amounts to be cropped from the input.
                 * Used only if a single input is provided.
                 * @member {CoreML.Specification.IBorderAmounts|null|undefined} cropAmounts
                 * @memberof CoreML.Specification.CropLayerParams
                 * @instance
                 */
                CropLayerParams.prototype.cropAmounts = null;
    
                /**
                 * The offset amounts.
                 * Used only if two inputs are provided.
                 * Must be of length 2, in order ``[H, W]``.
                 * @member {Array.<number|Long>} offset
                 * @memberof CoreML.Specification.CropLayerParams
                 * @instance
                 */
                CropLayerParams.prototype.offset = $util.emptyArray;
    
                /**
                 * Creates a new CropLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {CoreML.Specification.ICropLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.CropLayerParams} CropLayerParams instance
                 */
                CropLayerParams.create = function create(properties) {
                    return new CropLayerParams(properties);
                };
    
                /**
                 * Encodes the specified CropLayerParams message. Does not implicitly {@link CoreML.Specification.CropLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {CoreML.Specification.ICropLayerParams} message CropLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CropLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cropAmounts != null && message.hasOwnProperty("cropAmounts"))
                        $root.CoreML.Specification.BorderAmounts.encode(message.cropAmounts, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.offset != null && message.offset.length) {
                        writer.uint32(/* id 5, wireType 2 =*/42).fork();
                        for (var i = 0; i < message.offset.length; ++i)
                            writer.uint64(message.offset[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified CropLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.CropLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {CoreML.Specification.ICropLayerParams} message CropLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CropLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CropLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.CropLayerParams} CropLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CropLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CropLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cropAmounts = $root.CoreML.Specification.BorderAmounts.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.offset && message.offset.length))
                                message.offset = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.offset.push(reader.uint64());
                            } else
                                message.offset.push(reader.uint64());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CropLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.CropLayerParams} CropLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CropLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CropLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CropLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cropAmounts != null && message.hasOwnProperty("cropAmounts")) {
                        var error = $root.CoreML.Specification.BorderAmounts.verify(message.cropAmounts);
                        if (error)
                            return "cropAmounts." + error;
                    }
                    if (message.offset != null && message.hasOwnProperty("offset")) {
                        if (!Array.isArray(message.offset))
                            return "offset: array expected";
                        for (var i = 0; i < message.offset.length; ++i)
                            if (!$util.isInteger(message.offset[i]) && !(message.offset[i] && $util.isInteger(message.offset[i].low) && $util.isInteger(message.offset[i].high)))
                                return "offset: integer|Long[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a CropLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.CropLayerParams} CropLayerParams
                 */
                CropLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CropLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.CropLayerParams();
                    if (object.cropAmounts != null) {
                        if (typeof object.cropAmounts !== "object")
                            throw TypeError(".CoreML.Specification.CropLayerParams.cropAmounts: object expected");
                        message.cropAmounts = $root.CoreML.Specification.BorderAmounts.fromObject(object.cropAmounts);
                    }
                    if (object.offset) {
                        if (!Array.isArray(object.offset))
                            throw TypeError(".CoreML.Specification.CropLayerParams.offset: array expected");
                        message.offset = [];
                        for (var i = 0; i < object.offset.length; ++i)
                            if ($util.Long)
                                (message.offset[i] = $util.Long.fromValue(object.offset[i])).unsigned = true;
                            else if (typeof object.offset[i] === "string")
                                message.offset[i] = parseInt(object.offset[i], 10);
                            else if (typeof object.offset[i] === "number")
                                message.offset[i] = object.offset[i];
                            else if (typeof object.offset[i] === "object")
                                message.offset[i] = new $util.LongBits(object.offset[i].low >>> 0, object.offset[i].high >>> 0).toNumber(true);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a CropLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.CropLayerParams
                 * @static
                 * @param {CoreML.Specification.CropLayerParams} message CropLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CropLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.offset = [];
                    if (options.defaults)
                        object.cropAmounts = null;
                    if (message.cropAmounts != null && message.hasOwnProperty("cropAmounts"))
                        object.cropAmounts = $root.CoreML.Specification.BorderAmounts.toObject(message.cropAmounts, options);
                    if (message.offset && message.offset.length) {
                        object.offset = [];
                        for (var j = 0; j < message.offset.length; ++j)
                            if (typeof message.offset[j] === "number")
                                object.offset[j] = options.longs === String ? String(message.offset[j]) : message.offset[j];
                            else
                                object.offset[j] = options.longs === String ? $util.Long.prototype.toString.call(message.offset[j]) : options.longs === Number ? new $util.LongBits(message.offset[j].low >>> 0, message.offset[j].high >>> 0).toNumber(true) : message.offset[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this CropLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.CropLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CropLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return CropLayerParams;
            })();
    
            Specification.AverageLayerParams = (function() {
    
                /**
                 * Properties of an AverageLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IAverageLayerParams
                 */
    
                /**
                 * Constructs a new AverageLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that computes the elementwise average of the inputs.
                 * 
                 * .. code::
                 * 
                 * y = AverageLayer(x1,x2,...)
                 * 
                 * Requires multiple inputs and produces 1 output.
                 * 
                 * Input
                 * Multiple blobs with broadcastable shapes ``[1]``, ``[C]``, ``[1, H, W]``, or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as each input.
                 * @implements IAverageLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IAverageLayerParams=} [properties] Properties to set
                 */
                function AverageLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new AverageLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {CoreML.Specification.IAverageLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.AverageLayerParams} AverageLayerParams instance
                 */
                AverageLayerParams.create = function create(properties) {
                    return new AverageLayerParams(properties);
                };
    
                /**
                 * Encodes the specified AverageLayerParams message. Does not implicitly {@link CoreML.Specification.AverageLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {CoreML.Specification.IAverageLayerParams} message AverageLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AverageLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified AverageLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.AverageLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {CoreML.Specification.IAverageLayerParams} message AverageLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AverageLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an AverageLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.AverageLayerParams} AverageLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AverageLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.AverageLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an AverageLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.AverageLayerParams} AverageLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AverageLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an AverageLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AverageLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates an AverageLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.AverageLayerParams} AverageLayerParams
                 */
                AverageLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.AverageLayerParams)
                        return object;
                    return new $root.CoreML.Specification.AverageLayerParams();
                };
    
                /**
                 * Creates a plain object from an AverageLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @static
                 * @param {CoreML.Specification.AverageLayerParams} message AverageLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AverageLayerParams.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this AverageLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.AverageLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AverageLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return AverageLayerParams;
            })();
    
            Specification.MaxLayerParams = (function() {
    
                /**
                 * Properties of a MaxLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IMaxLayerParams
                 */
    
                /**
                 * Constructs a new MaxLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that computes the elementwise maximum over the inputs.
                 * 
                 * .. code::
                 * 
                 * y = MaxLayer(x1,x2,...)
                 * 
                 * Requires multiple inputs and produces 1 output.
                 * 
                 * Input
                 * Multiple blobs, each with shape ``[C]`` or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as each input.
                 * @implements IMaxLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IMaxLayerParams=} [properties] Properties to set
                 */
                function MaxLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new MaxLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {CoreML.Specification.IMaxLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.MaxLayerParams} MaxLayerParams instance
                 */
                MaxLayerParams.create = function create(properties) {
                    return new MaxLayerParams(properties);
                };
    
                /**
                 * Encodes the specified MaxLayerParams message. Does not implicitly {@link CoreML.Specification.MaxLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {CoreML.Specification.IMaxLayerParams} message MaxLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MaxLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MaxLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.MaxLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {CoreML.Specification.IMaxLayerParams} message MaxLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MaxLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MaxLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.MaxLayerParams} MaxLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MaxLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MaxLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MaxLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.MaxLayerParams} MaxLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MaxLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MaxLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MaxLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MaxLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.MaxLayerParams} MaxLayerParams
                 */
                MaxLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MaxLayerParams)
                        return object;
                    return new $root.CoreML.Specification.MaxLayerParams();
                };
    
                /**
                 * Creates a plain object from a MaxLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @static
                 * @param {CoreML.Specification.MaxLayerParams} message MaxLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MaxLayerParams.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MaxLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.MaxLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MaxLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MaxLayerParams;
            })();
    
            Specification.MinLayerParams = (function() {
    
                /**
                 * Properties of a MinLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IMinLayerParams
                 */
    
                /**
                 * Constructs a new MinLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that computes the elementwise minimum over the inputs.
                 * 
                 * .. code::
                 * 
                 * y = MinLayer(x1,x2,...)
                 * 
                 * Requires multiple inputs and produces 1 output.
                 * 
                 * Input
                 * Multiple blobs, each with shape ``[C]`` or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as each input.
                 * @implements IMinLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IMinLayerParams=} [properties] Properties to set
                 */
                function MinLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new MinLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {CoreML.Specification.IMinLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.MinLayerParams} MinLayerParams instance
                 */
                MinLayerParams.create = function create(properties) {
                    return new MinLayerParams(properties);
                };
    
                /**
                 * Encodes the specified MinLayerParams message. Does not implicitly {@link CoreML.Specification.MinLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {CoreML.Specification.IMinLayerParams} message MinLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MinLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified MinLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.MinLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {CoreML.Specification.IMinLayerParams} message MinLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MinLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MinLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.MinLayerParams} MinLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MinLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MinLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MinLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.MinLayerParams} MinLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MinLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MinLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MinLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a MinLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.MinLayerParams} MinLayerParams
                 */
                MinLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MinLayerParams)
                        return object;
                    return new $root.CoreML.Specification.MinLayerParams();
                };
    
                /**
                 * Creates a plain object from a MinLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.MinLayerParams
                 * @static
                 * @param {CoreML.Specification.MinLayerParams} message MinLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MinLayerParams.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this MinLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.MinLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MinLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MinLayerParams;
            })();
    
            Specification.DotProductLayerParams = (function() {
    
                /**
                 * Properties of a DotProductLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IDotProductLayerParams
                 * @property {boolean|null} [cosineSimilarity] If true, inputs are normalized first,
                 * thereby computing the cosine similarity.
                 */
    
                /**
                 * Constructs a new DotProductLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that computes the dot product of two vectors.
                 * 
                 * .. code::
                 * 
                 * y = DotProductLayer(x1,x2)
                 * 
                 * Requires 2 inputs and produces 1 output.
                 * 
                 * Input
                 * Two blobs with shape ``[C]``.
                 * Output
                 * A scalar.
                 * @implements IDotProductLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IDotProductLayerParams=} [properties] Properties to set
                 */
                function DotProductLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * If true, inputs are normalized first,
                 * thereby computing the cosine similarity.
                 * @member {boolean} cosineSimilarity
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @instance
                 */
                DotProductLayerParams.prototype.cosineSimilarity = false;
    
                /**
                 * Creates a new DotProductLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {CoreML.Specification.IDotProductLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.DotProductLayerParams} DotProductLayerParams instance
                 */
                DotProductLayerParams.create = function create(properties) {
                    return new DotProductLayerParams(properties);
                };
    
                /**
                 * Encodes the specified DotProductLayerParams message. Does not implicitly {@link CoreML.Specification.DotProductLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {CoreML.Specification.IDotProductLayerParams} message DotProductLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DotProductLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.cosineSimilarity != null && message.hasOwnProperty("cosineSimilarity"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.cosineSimilarity);
                    return writer;
                };
    
                /**
                 * Encodes the specified DotProductLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.DotProductLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {CoreML.Specification.IDotProductLayerParams} message DotProductLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DotProductLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DotProductLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DotProductLayerParams} DotProductLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DotProductLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DotProductLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.cosineSimilarity = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DotProductLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DotProductLayerParams} DotProductLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DotProductLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DotProductLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DotProductLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cosineSimilarity != null && message.hasOwnProperty("cosineSimilarity"))
                        if (typeof message.cosineSimilarity !== "boolean")
                            return "cosineSimilarity: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a DotProductLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DotProductLayerParams} DotProductLayerParams
                 */
                DotProductLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DotProductLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.DotProductLayerParams();
                    if (object.cosineSimilarity != null)
                        message.cosineSimilarity = Boolean(object.cosineSimilarity);
                    return message;
                };
    
                /**
                 * Creates a plain object from a DotProductLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @static
                 * @param {CoreML.Specification.DotProductLayerParams} message DotProductLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DotProductLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.cosineSimilarity = false;
                    if (message.cosineSimilarity != null && message.hasOwnProperty("cosineSimilarity"))
                        object.cosineSimilarity = message.cosineSimilarity;
                    return object;
                };
    
                /**
                 * Converts this DotProductLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DotProductLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DotProductLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DotProductLayerParams;
            })();
    
            Specification.MeanVarianceNormalizeLayerParams = (function() {
    
                /**
                 * Properties of a MeanVarianceNormalizeLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IMeanVarianceNormalizeLayerParams
                 * @property {boolean|null} [acrossChannels] If true, mean and variance are computed across channels.
                 * @property {boolean|null} [normalizeVariance] If false, only mean is subtracted.
                 * @property {number|null} [epsilon] A small constant to avoid division by 0 while normalizing variance.
                 * Defaults to ``1e-6`` if not set or set to ``0``.
                 */
    
                /**
                 * Constructs a new MeanVarianceNormalizeLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that performs mean variance normalization.
                 * 
                 * .. code::
                 * 
                 * y = MeanVarianceNormalizeLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A blob with shape ``[C]`` or ``[C, H, W]``.
                 * Output
                 * A blob with the same shape as the input.
                 * 
                 * If ``acrossChannels == true``
                 * normalization is performed on flattened input.
                 * 
                 * If ``acrossChannels == false``
                 * normalization is performed within a channel,
                 * across spatial dimensions.
                 * @implements IMeanVarianceNormalizeLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IMeanVarianceNormalizeLayerParams=} [properties] Properties to set
                 */
                function MeanVarianceNormalizeLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * If true, mean and variance are computed across channels.
                 * @member {boolean} acrossChannels
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @instance
                 */
                MeanVarianceNormalizeLayerParams.prototype.acrossChannels = false;
    
                /**
                 * If false, only mean is subtracted.
                 * @member {boolean} normalizeVariance
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @instance
                 */
                MeanVarianceNormalizeLayerParams.prototype.normalizeVariance = false;
    
                /**
                 * A small constant to avoid division by 0 while normalizing variance.
                 * Defaults to ``1e-6`` if not set or set to ``0``.
                 * @member {number} epsilon
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @instance
                 */
                MeanVarianceNormalizeLayerParams.prototype.epsilon = 0;
    
                /**
                 * Creates a new MeanVarianceNormalizeLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.IMeanVarianceNormalizeLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.MeanVarianceNormalizeLayerParams} MeanVarianceNormalizeLayerParams instance
                 */
                MeanVarianceNormalizeLayerParams.create = function create(properties) {
                    return new MeanVarianceNormalizeLayerParams(properties);
                };
    
                /**
                 * Encodes the specified MeanVarianceNormalizeLayerParams message. Does not implicitly {@link CoreML.Specification.MeanVarianceNormalizeLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.IMeanVarianceNormalizeLayerParams} message MeanVarianceNormalizeLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MeanVarianceNormalizeLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.acrossChannels != null && message.hasOwnProperty("acrossChannels"))
                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.acrossChannels);
                    if (message.normalizeVariance != null && message.hasOwnProperty("normalizeVariance"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.normalizeVariance);
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        writer.uint32(/* id 3, wireType 5 =*/29).float(message.epsilon);
                    return writer;
                };
    
                /**
                 * Encodes the specified MeanVarianceNormalizeLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.MeanVarianceNormalizeLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.IMeanVarianceNormalizeLayerParams} message MeanVarianceNormalizeLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                MeanVarianceNormalizeLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a MeanVarianceNormalizeLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.MeanVarianceNormalizeLayerParams} MeanVarianceNormalizeLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MeanVarianceNormalizeLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.MeanVarianceNormalizeLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.acrossChannels = reader.bool();
                            break;
                        case 2:
                            message.normalizeVariance = reader.bool();
                            break;
                        case 3:
                            message.epsilon = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a MeanVarianceNormalizeLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.MeanVarianceNormalizeLayerParams} MeanVarianceNormalizeLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                MeanVarianceNormalizeLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a MeanVarianceNormalizeLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MeanVarianceNormalizeLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.acrossChannels != null && message.hasOwnProperty("acrossChannels"))
                        if (typeof message.acrossChannels !== "boolean")
                            return "acrossChannels: boolean expected";
                    if (message.normalizeVariance != null && message.hasOwnProperty("normalizeVariance"))
                        if (typeof message.normalizeVariance !== "boolean")
                            return "normalizeVariance: boolean expected";
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        if (typeof message.epsilon !== "number")
                            return "epsilon: number expected";
                    return null;
                };
    
                /**
                 * Creates a MeanVarianceNormalizeLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.MeanVarianceNormalizeLayerParams} MeanVarianceNormalizeLayerParams
                 */
                MeanVarianceNormalizeLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.MeanVarianceNormalizeLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.MeanVarianceNormalizeLayerParams();
                    if (object.acrossChannels != null)
                        message.acrossChannels = Boolean(object.acrossChannels);
                    if (object.normalizeVariance != null)
                        message.normalizeVariance = Boolean(object.normalizeVariance);
                    if (object.epsilon != null)
                        message.epsilon = Number(object.epsilon);
                    return message;
                };
    
                /**
                 * Creates a plain object from a MeanVarianceNormalizeLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @static
                 * @param {CoreML.Specification.MeanVarianceNormalizeLayerParams} message MeanVarianceNormalizeLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MeanVarianceNormalizeLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.acrossChannels = false;
                        object.normalizeVariance = false;
                        object.epsilon = 0;
                    }
                    if (message.acrossChannels != null && message.hasOwnProperty("acrossChannels"))
                        object.acrossChannels = message.acrossChannels;
                    if (message.normalizeVariance != null && message.hasOwnProperty("normalizeVariance"))
                        object.normalizeVariance = message.normalizeVariance;
                    if (message.epsilon != null && message.hasOwnProperty("epsilon"))
                        object.epsilon = options.json && !isFinite(message.epsilon) ? String(message.epsilon) : message.epsilon;
                    return object;
                };
    
                /**
                 * Converts this MeanVarianceNormalizeLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.MeanVarianceNormalizeLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MeanVarianceNormalizeLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return MeanVarianceNormalizeLayerParams;
            })();
    
            Specification.SequenceRepeatLayerParams = (function() {
    
                /**
                 * Properties of a SequenceRepeatLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ISequenceRepeatLayerParams
                 * @property {number|Long|null} [nRepetitions] Number of repetitions.
                 * Defaults to ``1`` if not set or set to ``0``.
                 */
    
                /**
                 * Constructs a new SequenceRepeatLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A layer that repeats a sequence.
                 * 
                 * .. code::
                 * 
                 * y = SequenceRepeatLayer(x)
                 * 
                 * Requires 1 input and produces 1 output.
                 * 
                 * Input
                 * A sequence of blobs, i.e. shape is either ``[Seq, C]`` or ``[Seq, C, H, W]``.
                 * Output
                 * A sequence of length ``nRepetitions * Seq``
                 * with shape corresponding to the input,
                 * i.e. shape is either ``[nRepetitions * Seq, C]`` or ``[nRepetitions * Seq, C, H, W]``.
                 * @implements ISequenceRepeatLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ISequenceRepeatLayerParams=} [properties] Properties to set
                 */
                function SequenceRepeatLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Number of repetitions.
                 * Defaults to ``1`` if not set or set to ``0``.
                 * @member {number|Long} nRepetitions
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @instance
                 */
                SequenceRepeatLayerParams.prototype.nRepetitions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Creates a new SequenceRepeatLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {CoreML.Specification.ISequenceRepeatLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.SequenceRepeatLayerParams} SequenceRepeatLayerParams instance
                 */
                SequenceRepeatLayerParams.create = function create(properties) {
                    return new SequenceRepeatLayerParams(properties);
                };
    
                /**
                 * Encodes the specified SequenceRepeatLayerParams message. Does not implicitly {@link CoreML.Specification.SequenceRepeatLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {CoreML.Specification.ISequenceRepeatLayerParams} message SequenceRepeatLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SequenceRepeatLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nRepetitions != null && message.hasOwnProperty("nRepetitions"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nRepetitions);
                    return writer;
                };
    
                /**
                 * Encodes the specified SequenceRepeatLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.SequenceRepeatLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {CoreML.Specification.ISequenceRepeatLayerParams} message SequenceRepeatLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SequenceRepeatLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SequenceRepeatLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SequenceRepeatLayerParams} SequenceRepeatLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SequenceRepeatLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SequenceRepeatLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nRepetitions = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SequenceRepeatLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SequenceRepeatLayerParams} SequenceRepeatLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SequenceRepeatLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SequenceRepeatLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SequenceRepeatLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nRepetitions != null && message.hasOwnProperty("nRepetitions"))
                        if (!$util.isInteger(message.nRepetitions) && !(message.nRepetitions && $util.isInteger(message.nRepetitions.low) && $util.isInteger(message.nRepetitions.high)))
                            return "nRepetitions: integer|Long expected";
                    return null;
                };
    
                /**
                 * Creates a SequenceRepeatLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SequenceRepeatLayerParams} SequenceRepeatLayerParams
                 */
                SequenceRepeatLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SequenceRepeatLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SequenceRepeatLayerParams();
                    if (object.nRepetitions != null)
                        if ($util.Long)
                            (message.nRepetitions = $util.Long.fromValue(object.nRepetitions)).unsigned = true;
                        else if (typeof object.nRepetitions === "string")
                            message.nRepetitions = parseInt(object.nRepetitions, 10);
                        else if (typeof object.nRepetitions === "number")
                            message.nRepetitions = object.nRepetitions;
                        else if (typeof object.nRepetitions === "object")
                            message.nRepetitions = new $util.LongBits(object.nRepetitions.low >>> 0, object.nRepetitions.high >>> 0).toNumber(true);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SequenceRepeatLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @static
                 * @param {CoreML.Specification.SequenceRepeatLayerParams} message SequenceRepeatLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SequenceRepeatLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nRepetitions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nRepetitions = options.longs === String ? "0" : 0;
                    if (message.nRepetitions != null && message.hasOwnProperty("nRepetitions"))
                        if (typeof message.nRepetitions === "number")
                            object.nRepetitions = options.longs === String ? String(message.nRepetitions) : message.nRepetitions;
                        else
                            object.nRepetitions = options.longs === String ? $util.Long.prototype.toString.call(message.nRepetitions) : options.longs === Number ? new $util.LongBits(message.nRepetitions.low >>> 0, message.nRepetitions.high >>> 0).toNumber(true) : message.nRepetitions;
                    return object;
                };
    
                /**
                 * Converts this SequenceRepeatLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SequenceRepeatLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SequenceRepeatLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SequenceRepeatLayerParams;
            })();
    
            Specification.SimpleRecurrentLayerParams = (function() {
    
                /**
                 * Properties of a SimpleRecurrentLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ISimpleRecurrentLayerParams
                 * @property {number|Long|null} [inputVectorSize] The size of the input vectors.
                 * @property {number|Long|null} [outputVectorSize] SimpleRecurrentLayerParams outputVectorSize
                 * @property {CoreML.Specification.IActivationParams|null} [activation] Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @property {boolean|null} [sequenceOutput] If false output is just the result after final state update.
                 * If true, output is a sequence, containing outputs at all time steps.
                 * @property {boolean|null} [hasBiasVector] If false, no bias is added.
                 * @property {CoreML.Specification.IWeightParams|null} [weightMatrix] Weight matrix W.
                 * @property {CoreML.Specification.IWeightParams|null} [recursionMatrix] Recursion Weight matrix R.
                 * @property {CoreML.Specification.IWeightParams|null} [biasVector] Bias vector b.
                 * @property {boolean|null} [reverseInput] SimpleRecurrentLayerParams reverseInput
                 */
    
                /**
                 * Constructs a new SimpleRecurrentLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A simple recurrent layer.
                 * 
                 * .. code::
                 * 
                 * y_t = SimpleRecurrentLayer(x_t, y_{t-1})
                 * 
                 * Input
                 * A sequence of vectors of size ``inputVectorSize``
                 * with shape ``[Seq, inputVectorSize]``.
                 * Output
                 * A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
                 * 
                 * - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
                 * - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
                 * 
                 * This layer is described by the following equation:
                 * 
                 * .. math::
                 * \boldsymbol{y_t} = f(\mathrm{clip}(W \boldsymbol{x_t} + \
                 * R \boldsymbol{y_{t-1}} + b))
                 * 
                 * - ``W`` is a 2-dimensional weight matrix
                 * (``[outputVectorSize, inputVectorSize]``, row-major)
                 * - ``R`` is a 2-dimensional recursion matrix
                 * (``[outputVectorSize, outputVectorSize]``, row-major)
                 * - ``b`` is a 1-dimensional bias vector (``[outputVectorSize]``)
                 * - ``f()`` is an activation
                 * - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
                 * @implements ISimpleRecurrentLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ISimpleRecurrentLayerParams=} [properties] Properties to set
                 */
                function SimpleRecurrentLayerParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * The size of the input vectors.
                 * @member {number|Long} inputVectorSize
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * SimpleRecurrentLayerParams outputVectorSize.
                 * @member {number|Long} outputVectorSize
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @member {CoreML.Specification.IActivationParams|null|undefined} activation
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.activation = null;
    
                /**
                 * If false output is just the result after final state update.
                 * If true, output is a sequence, containing outputs at all time steps.
                 * @member {boolean} sequenceOutput
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.sequenceOutput = false;
    
                /**
                 * If false, no bias is added.
                 * @member {boolean} hasBiasVector
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.hasBiasVector = false;
    
                /**
                 * Weight matrix W.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} weightMatrix
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.weightMatrix = null;
    
                /**
                 * Recursion Weight matrix R.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} recursionMatrix
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.recursionMatrix = null;
    
                /**
                 * Bias vector b.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} biasVector
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.biasVector = null;
    
                /**
                 * SimpleRecurrentLayerParams reverseInput.
                 * @member {boolean} reverseInput
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 */
                SimpleRecurrentLayerParams.prototype.reverseInput = false;
    
                /**
                 * Creates a new SimpleRecurrentLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {CoreML.Specification.ISimpleRecurrentLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.SimpleRecurrentLayerParams} SimpleRecurrentLayerParams instance
                 */
                SimpleRecurrentLayerParams.create = function create(properties) {
                    return new SimpleRecurrentLayerParams(properties);
                };
    
                /**
                 * Encodes the specified SimpleRecurrentLayerParams message. Does not implicitly {@link CoreML.Specification.SimpleRecurrentLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {CoreML.Specification.ISimpleRecurrentLayerParams} message SimpleRecurrentLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SimpleRecurrentLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inputVectorSize);
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputVectorSize);
                    if (message.activation != null && message.hasOwnProperty("activation"))
                        $root.CoreML.Specification.ActivationParams.encode(message.activation, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.sequenceOutput);
                    if (message.hasBiasVector != null && message.hasOwnProperty("hasBiasVector"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.hasBiasVector);
                    if (message.weightMatrix != null && message.hasOwnProperty("weightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.weightMatrix, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                    if (message.recursionMatrix != null && message.hasOwnProperty("recursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.recursionMatrix, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                    if (message.biasVector != null && message.hasOwnProperty("biasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.biasVector, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        writer.uint32(/* id 100, wireType 0 =*/800).bool(message.reverseInput);
                    return writer;
                };
    
                /**
                 * Encodes the specified SimpleRecurrentLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.SimpleRecurrentLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {CoreML.Specification.ISimpleRecurrentLayerParams} message SimpleRecurrentLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SimpleRecurrentLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SimpleRecurrentLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SimpleRecurrentLayerParams} SimpleRecurrentLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SimpleRecurrentLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SimpleRecurrentLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            message.activation = $root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32());
                            break;
                        case 15:
                            message.sequenceOutput = reader.bool();
                            break;
                        case 20:
                            message.hasBiasVector = reader.bool();
                            break;
                        case 30:
                            message.weightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.recursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.biasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.reverseInput = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SimpleRecurrentLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SimpleRecurrentLayerParams} SimpleRecurrentLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SimpleRecurrentLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SimpleRecurrentLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SimpleRecurrentLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activation != null && message.hasOwnProperty("activation")) {
                        var error = $root.CoreML.Specification.ActivationParams.verify(message.activation);
                        if (error)
                            return "activation." + error;
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        if (typeof message.sequenceOutput !== "boolean")
                            return "sequenceOutput: boolean expected";
                    if (message.hasBiasVector != null && message.hasOwnProperty("hasBiasVector"))
                        if (typeof message.hasBiasVector !== "boolean")
                            return "hasBiasVector: boolean expected";
                    if (message.weightMatrix != null && message.hasOwnProperty("weightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.weightMatrix);
                        if (error)
                            return "weightMatrix." + error;
                    }
                    if (message.recursionMatrix != null && message.hasOwnProperty("recursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.recursionMatrix);
                        if (error)
                            return "recursionMatrix." + error;
                    }
                    if (message.biasVector != null && message.hasOwnProperty("biasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.biasVector);
                        if (error)
                            return "biasVector." + error;
                    }
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        if (typeof message.reverseInput !== "boolean")
                            return "reverseInput: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a SimpleRecurrentLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SimpleRecurrentLayerParams} SimpleRecurrentLayerParams
                 */
                SimpleRecurrentLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SimpleRecurrentLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.SimpleRecurrentLayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activation != null) {
                        if (typeof object.activation !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.activation: object expected");
                        message.activation = $root.CoreML.Specification.ActivationParams.fromObject(object.activation);
                    }
                    if (object.sequenceOutput != null)
                        message.sequenceOutput = Boolean(object.sequenceOutput);
                    if (object.hasBiasVector != null)
                        message.hasBiasVector = Boolean(object.hasBiasVector);
                    if (object.weightMatrix != null) {
                        if (typeof object.weightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.weightMatrix: object expected");
                        message.weightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.weightMatrix);
                    }
                    if (object.recursionMatrix != null) {
                        if (typeof object.recursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.recursionMatrix: object expected");
                        message.recursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.recursionMatrix);
                    }
                    if (object.biasVector != null) {
                        if (typeof object.biasVector !== "object")
                            throw TypeError(".CoreML.Specification.SimpleRecurrentLayerParams.biasVector: object expected");
                        message.biasVector = $root.CoreML.Specification.WeightParams.fromObject(object.biasVector);
                    }
                    if (object.reverseInput != null)
                        message.reverseInput = Boolean(object.reverseInput);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SimpleRecurrentLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @static
                 * @param {CoreML.Specification.SimpleRecurrentLayerParams} message SimpleRecurrentLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SimpleRecurrentLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.activation = null;
                        object.sequenceOutput = false;
                        object.hasBiasVector = false;
                        object.weightMatrix = null;
                        object.recursionMatrix = null;
                        object.biasVector = null;
                        object.reverseInput = false;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activation != null && message.hasOwnProperty("activation"))
                        object.activation = $root.CoreML.Specification.ActivationParams.toObject(message.activation, options);
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        object.sequenceOutput = message.sequenceOutput;
                    if (message.hasBiasVector != null && message.hasOwnProperty("hasBiasVector"))
                        object.hasBiasVector = message.hasBiasVector;
                    if (message.weightMatrix != null && message.hasOwnProperty("weightMatrix"))
                        object.weightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.weightMatrix, options);
                    if (message.recursionMatrix != null && message.hasOwnProperty("recursionMatrix"))
                        object.recursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.recursionMatrix, options);
                    if (message.biasVector != null && message.hasOwnProperty("biasVector"))
                        object.biasVector = $root.CoreML.Specification.WeightParams.toObject(message.biasVector, options);
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        object.reverseInput = message.reverseInput;
                    return object;
                };
    
                /**
                 * Converts this SimpleRecurrentLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SimpleRecurrentLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SimpleRecurrentLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SimpleRecurrentLayerParams;
            })();
    
            Specification.GRULayerParams = (function() {
    
                /**
                 * Properties of a GRULayerParams.
                 * @memberof CoreML.Specification
                 * @interface IGRULayerParams
                 * @property {number|Long|null} [inputVectorSize] Size of the input vectors.
                 * @property {number|Long|null} [outputVectorSize] GRULayerParams outputVectorSize
                 * @property {Array.<CoreML.Specification.IActivationParams>|null} [activations] 2 element array representing activations [f(), g()] in that order.
                 * Typical values used = [sigmoid, tanh].
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @property {boolean|null} [sequenceOutput] If false output is just the result after final state update.
                 * If true, output is a sequence, containing outputs at all time steps.
                 * @property {boolean|null} [hasBiasVectors] If false, no biases (``b_z``, ``b_r``, ``b_o``) are added.
                 * @property {CoreML.Specification.IWeightParams|null} [updateGateWeightMatrix] Weight Matrix W_z.
                 * @property {CoreML.Specification.IWeightParams|null} [resetGateWeightMatrix] Weight Matrix W_r.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGateWeightMatrix] Weight Matrix W_o.
                 * @property {CoreML.Specification.IWeightParams|null} [updateGateRecursionMatrix] Recursion Weight Matrix R_z.
                 * @property {CoreML.Specification.IWeightParams|null} [resetGateRecursionMatrix] Recursion Weight Matrix R_r.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGateRecursionMatrix] Recursion Weight Matrix R_o.
                 * @property {CoreML.Specification.IWeightParams|null} [updateGateBiasVector] Bias vector b_z.
                 * @property {CoreML.Specification.IWeightParams|null} [resetGateBiasVector] Bias vector b_r.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGateBiasVector] GRULayerParams outputGateBiasVector
                 * @property {boolean|null} [reverseInput] If true, then the node processes the input sequence from right to left
                 */
    
                /**
                 * Constructs a new GRULayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc Gated-Recurrent Unit (GRU) Layer
                 * 
                 * .. code::
                 * 
                 * y_t = GRULayer(x_t, y_{t-1})
                 * 
                 * Input
                 * A sequence of vectors of size ``inputVectorSize``
                 * with shape ``[Seq, inputVectorSize]``.
                 * Output
                 * A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
                 * 
                 * - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
                 * - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
                 * 
                 * This layer is described by the following equations:
                 * 
                 * Update Gate
                 * .. math::
                 * \boldsymbol{z_t} = \
                 * f(\mathrm{clip}(W_z \boldsymbol{x_t} + \
                 * R_z \boldsymbol{y_{t-1}} + b_z)
                 * 
                 * Reset Gate
                 * .. math::
                 * \boldsymbol{r_t} = \
                 * f(\mathrm{clip}(W_r \boldsymbol{x_t} + \
                 * R_r \boldsymbol{y_{t-1}} + b_r))
                 * 
                 * Cell Memory State
                 * .. math::
                 * \boldsymbol{c_t} = \
                 * \boldsymbol{y_{t-1}} \odot \boldsymbol{r_t}
                 * 
                 * Output Gate
                 * .. math::
                 * \boldsymbol{o_t} = \
                 * g(\mathrm{clip}(W_o \boldsymbol{x_t} + \
                 * R_o \boldsymbol{c_t} + b_o))
                 * 
                 * Output
                 * .. math::
                 * \boldsymbol{y_t} = \
                 * (1 - \boldsymbol{z_t}) \odot \boldsymbol{o_t} + \
                 * \boldsymbol{z_t} \odot \boldsymbol{y_{t-1}}
                 * 
                 * - ``W_z``, ``W_r``, ``W_o`` are 2-dimensional input weight matrices
                 * (``[outputVectorSize, inputVectorSize]``, row-major)
                 * - ``R_z``, ``R_r``, ``R_o`` are 2-dimensional recursion matrices
                 * (``[outputVectorSize, outputVectorSize]``, row-major)
                 * - ``b_z``, ``b_r``, ``b_o`` are 1-dimensional bias vectors
                 * (``[outputVectorSize]``)
                 * - ``f()``, ``g()`` are activations
                 * - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
                 * - ``⊙`` denotes the elementwise product of matrices
                 * @implements IGRULayerParams
                 * @constructor
                 * @param {CoreML.Specification.IGRULayerParams=} [properties] Properties to set
                 */
                function GRULayerParams(properties) {
                    this.activations = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Size of the input vectors.
                 * @member {number|Long} inputVectorSize
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * GRULayerParams outputVectorSize.
                 * @member {number|Long} outputVectorSize
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * 2 element array representing activations [f(), g()] in that order.
                 * Typical values used = [sigmoid, tanh].
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @member {Array.<CoreML.Specification.IActivationParams>} activations
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.activations = $util.emptyArray;
    
                /**
                 * If false output is just the result after final state update.
                 * If true, output is a sequence, containing outputs at all time steps.
                 * @member {boolean} sequenceOutput
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.sequenceOutput = false;
    
                /**
                 * If false, no biases (``b_z``, ``b_r``, ``b_o``) are added.
                 * @member {boolean} hasBiasVectors
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.hasBiasVectors = false;
    
                /**
                 * Weight Matrix W_z.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} updateGateWeightMatrix
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.updateGateWeightMatrix = null;
    
                /**
                 * Weight Matrix W_r.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} resetGateWeightMatrix
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.resetGateWeightMatrix = null;
    
                /**
                 * Weight Matrix W_o.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGateWeightMatrix
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.outputGateWeightMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_z.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} updateGateRecursionMatrix
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.updateGateRecursionMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_r.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} resetGateRecursionMatrix
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.resetGateRecursionMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_o.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGateRecursionMatrix
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.outputGateRecursionMatrix = null;
    
                /**
                 * Bias vector b_z.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} updateGateBiasVector
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.updateGateBiasVector = null;
    
                /**
                 * Bias vector b_r.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} resetGateBiasVector
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.resetGateBiasVector = null;
    
                /**
                 * GRULayerParams outputGateBiasVector.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGateBiasVector
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.outputGateBiasVector = null;
    
                /**
                 * If true, then the node processes the input sequence from right to left
                 * @member {boolean} reverseInput
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 */
                GRULayerParams.prototype.reverseInput = false;
    
                /**
                 * Creates a new GRULayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {CoreML.Specification.IGRULayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.GRULayerParams} GRULayerParams instance
                 */
                GRULayerParams.create = function create(properties) {
                    return new GRULayerParams(properties);
                };
    
                /**
                 * Encodes the specified GRULayerParams message. Does not implicitly {@link CoreML.Specification.GRULayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {CoreML.Specification.IGRULayerParams} message GRULayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GRULayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inputVectorSize);
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputVectorSize);
                    if (message.activations != null && message.activations.length)
                        for (var i = 0; i < message.activations.length; ++i)
                            $root.CoreML.Specification.ActivationParams.encode(message.activations[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        writer.uint32(/* id 15, wireType 0 =*/120).bool(message.sequenceOutput);
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.hasBiasVectors);
                    if (message.updateGateWeightMatrix != null && message.hasOwnProperty("updateGateWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.updateGateWeightMatrix, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
                    if (message.resetGateWeightMatrix != null && message.hasOwnProperty("resetGateWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.resetGateWeightMatrix, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGateWeightMatrix, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
                    if (message.updateGateRecursionMatrix != null && message.hasOwnProperty("updateGateRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.updateGateRecursionMatrix, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
                    if (message.resetGateRecursionMatrix != null && message.hasOwnProperty("resetGateRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.resetGateRecursionMatrix, writer.uint32(/* id 51, wireType 2 =*/410).fork()).ldelim();
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGateRecursionMatrix, writer.uint32(/* id 52, wireType 2 =*/418).fork()).ldelim();
                    if (message.updateGateBiasVector != null && message.hasOwnProperty("updateGateBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.updateGateBiasVector, writer.uint32(/* id 70, wireType 2 =*/562).fork()).ldelim();
                    if (message.resetGateBiasVector != null && message.hasOwnProperty("resetGateBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.resetGateBiasVector, writer.uint32(/* id 71, wireType 2 =*/570).fork()).ldelim();
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGateBiasVector, writer.uint32(/* id 72, wireType 2 =*/578).fork()).ldelim();
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        writer.uint32(/* id 100, wireType 0 =*/800).bool(message.reverseInput);
                    return writer;
                };
    
                /**
                 * Encodes the specified GRULayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.GRULayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {CoreML.Specification.IGRULayerParams} message GRULayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GRULayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a GRULayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.GRULayerParams} GRULayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GRULayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.GRULayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            if (!(message.activations && message.activations.length))
                                message.activations = [];
                            message.activations.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.sequenceOutput = reader.bool();
                            break;
                        case 20:
                            message.hasBiasVectors = reader.bool();
                            break;
                        case 30:
                            message.updateGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 31:
                            message.resetGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 32:
                            message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 50:
                            message.updateGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 51:
                            message.resetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 52:
                            message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 70:
                            message.updateGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 71:
                            message.resetGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 72:
                            message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.reverseInput = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a GRULayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.GRULayerParams} GRULayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GRULayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a GRULayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GRULayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activations != null && message.hasOwnProperty("activations")) {
                        if (!Array.isArray(message.activations))
                            return "activations: array expected";
                        for (var i = 0; i < message.activations.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activations[i]);
                            if (error)
                                return "activations." + error;
                        }
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        if (typeof message.sequenceOutput !== "boolean")
                            return "sequenceOutput: boolean expected";
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        if (typeof message.hasBiasVectors !== "boolean")
                            return "hasBiasVectors: boolean expected";
                    if (message.updateGateWeightMatrix != null && message.hasOwnProperty("updateGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.updateGateWeightMatrix);
                        if (error)
                            return "updateGateWeightMatrix." + error;
                    }
                    if (message.resetGateWeightMatrix != null && message.hasOwnProperty("resetGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.resetGateWeightMatrix);
                        if (error)
                            return "resetGateWeightMatrix." + error;
                    }
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateWeightMatrix);
                        if (error)
                            return "outputGateWeightMatrix." + error;
                    }
                    if (message.updateGateRecursionMatrix != null && message.hasOwnProperty("updateGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.updateGateRecursionMatrix);
                        if (error)
                            return "updateGateRecursionMatrix." + error;
                    }
                    if (message.resetGateRecursionMatrix != null && message.hasOwnProperty("resetGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.resetGateRecursionMatrix);
                        if (error)
                            return "resetGateRecursionMatrix." + error;
                    }
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateRecursionMatrix);
                        if (error)
                            return "outputGateRecursionMatrix." + error;
                    }
                    if (message.updateGateBiasVector != null && message.hasOwnProperty("updateGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.updateGateBiasVector);
                        if (error)
                            return "updateGateBiasVector." + error;
                    }
                    if (message.resetGateBiasVector != null && message.hasOwnProperty("resetGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.resetGateBiasVector);
                        if (error)
                            return "resetGateBiasVector." + error;
                    }
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateBiasVector);
                        if (error)
                            return "outputGateBiasVector." + error;
                    }
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        if (typeof message.reverseInput !== "boolean")
                            return "reverseInput: boolean expected";
                    return null;
                };
    
                /**
                 * Creates a GRULayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.GRULayerParams} GRULayerParams
                 */
                GRULayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.GRULayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.GRULayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activations) {
                        if (!Array.isArray(object.activations))
                            throw TypeError(".CoreML.Specification.GRULayerParams.activations: array expected");
                        message.activations = [];
                        for (var i = 0; i < object.activations.length; ++i) {
                            if (typeof object.activations[i] !== "object")
                                throw TypeError(".CoreML.Specification.GRULayerParams.activations: object expected");
                            message.activations[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activations[i]);
                        }
                    }
                    if (object.sequenceOutput != null)
                        message.sequenceOutput = Boolean(object.sequenceOutput);
                    if (object.hasBiasVectors != null)
                        message.hasBiasVectors = Boolean(object.hasBiasVectors);
                    if (object.updateGateWeightMatrix != null) {
                        if (typeof object.updateGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.updateGateWeightMatrix: object expected");
                        message.updateGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.updateGateWeightMatrix);
                    }
                    if (object.resetGateWeightMatrix != null) {
                        if (typeof object.resetGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.resetGateWeightMatrix: object expected");
                        message.resetGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.resetGateWeightMatrix);
                    }
                    if (object.outputGateWeightMatrix != null) {
                        if (typeof object.outputGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.outputGateWeightMatrix: object expected");
                        message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateWeightMatrix);
                    }
                    if (object.updateGateRecursionMatrix != null) {
                        if (typeof object.updateGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.updateGateRecursionMatrix: object expected");
                        message.updateGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.updateGateRecursionMatrix);
                    }
                    if (object.resetGateRecursionMatrix != null) {
                        if (typeof object.resetGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.resetGateRecursionMatrix: object expected");
                        message.resetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.resetGateRecursionMatrix);
                    }
                    if (object.outputGateRecursionMatrix != null) {
                        if (typeof object.outputGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.outputGateRecursionMatrix: object expected");
                        message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateRecursionMatrix);
                    }
                    if (object.updateGateBiasVector != null) {
                        if (typeof object.updateGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.updateGateBiasVector: object expected");
                        message.updateGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.updateGateBiasVector);
                    }
                    if (object.resetGateBiasVector != null) {
                        if (typeof object.resetGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.resetGateBiasVector: object expected");
                        message.resetGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.resetGateBiasVector);
                    }
                    if (object.outputGateBiasVector != null) {
                        if (typeof object.outputGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.GRULayerParams.outputGateBiasVector: object expected");
                        message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateBiasVector);
                    }
                    if (object.reverseInput != null)
                        message.reverseInput = Boolean(object.reverseInput);
                    return message;
                };
    
                /**
                 * Creates a plain object from a GRULayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.GRULayerParams
                 * @static
                 * @param {CoreML.Specification.GRULayerParams} message GRULayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GRULayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.activations = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.sequenceOutput = false;
                        object.hasBiasVectors = false;
                        object.updateGateWeightMatrix = null;
                        object.resetGateWeightMatrix = null;
                        object.outputGateWeightMatrix = null;
                        object.updateGateRecursionMatrix = null;
                        object.resetGateRecursionMatrix = null;
                        object.outputGateRecursionMatrix = null;
                        object.updateGateBiasVector = null;
                        object.resetGateBiasVector = null;
                        object.outputGateBiasVector = null;
                        object.reverseInput = false;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activations && message.activations.length) {
                        object.activations = [];
                        for (var j = 0; j < message.activations.length; ++j)
                            object.activations[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activations[j], options);
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        object.sequenceOutput = message.sequenceOutput;
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        object.hasBiasVectors = message.hasBiasVectors;
                    if (message.updateGateWeightMatrix != null && message.hasOwnProperty("updateGateWeightMatrix"))
                        object.updateGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.updateGateWeightMatrix, options);
                    if (message.resetGateWeightMatrix != null && message.hasOwnProperty("resetGateWeightMatrix"))
                        object.resetGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.resetGateWeightMatrix, options);
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix"))
                        object.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateWeightMatrix, options);
                    if (message.updateGateRecursionMatrix != null && message.hasOwnProperty("updateGateRecursionMatrix"))
                        object.updateGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.updateGateRecursionMatrix, options);
                    if (message.resetGateRecursionMatrix != null && message.hasOwnProperty("resetGateRecursionMatrix"))
                        object.resetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.resetGateRecursionMatrix, options);
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix"))
                        object.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateRecursionMatrix, options);
                    if (message.updateGateBiasVector != null && message.hasOwnProperty("updateGateBiasVector"))
                        object.updateGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.updateGateBiasVector, options);
                    if (message.resetGateBiasVector != null && message.hasOwnProperty("resetGateBiasVector"))
                        object.resetGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.resetGateBiasVector, options);
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector"))
                        object.outputGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.outputGateBiasVector, options);
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        object.reverseInput = message.reverseInput;
                    return object;
                };
    
                /**
                 * Converts this GRULayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.GRULayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GRULayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return GRULayerParams;
            })();
    
            Specification.LSTMParams = (function() {
    
                /**
                 * Properties of a LSTMParams.
                 * @memberof CoreML.Specification
                 * @interface ILSTMParams
                 * @property {boolean|null} [sequenceOutput] If true, output is a sequence, containing outputs at all time steps.
                 * If false, output is just the result after final state update.
                 * @property {boolean|null} [hasBiasVectors] If false, no biases (``b_i``, ``b_f``, ``b_z``, ``b_o``) are added.
                 * @property {boolean|null} [forgetBias] If true, a vector of ``1`` values is added to ``b_f``.
                 * @property {boolean|null} [hasPeepholeVectors] If true, peephole vectors are included.
                 * @property {boolean|null} [coupledInputAndForgetGate] If the coupled Input and Forget flag is on, the behaviour of
                 * ``c_t`` is changed to the following (i.e. forget gate is not used):
                 * 
                 * .. math::
                 * \boldsymbol{c_t} = \
                 * \boldsymbol{c_{t-1}} \odot (1 - \boldsymbol{i_t}) + \
                 * \boldsymbol{i_t} \odot \boldsymbol{z_t}
                 * @property {number|null} [cellClipThreshold] Places a limit on the maximum and minimum values of ``c_t``.
                 * c_t = min(c_t, cellClipThreshold)
                 * c_t = max(c_t, -cellClipThreshold)
                 * If 0, it is set to its default value = 50.0.
                 */
    
                /**
                 * Constructs a new LSTMParams.
                 * @memberof CoreML.Specification
                 * @classdesc Long short-term memory (LSTM) parameters.
                 * 
                 * This is described by the following equations:
                 * 
                 * Input Gate
                 * .. math::
                 * \boldsymbol{i_t} = \
                 * f(\mathrm{clip}(W_i \boldsymbol{x_t} + \
                 * R_i \boldsymbol{y_{t-1}} + \
                 * p_i \odot c_{t-1} + b_i))
                 * 
                 * Forget Gate
                 * .. math::
                 * \boldsymbol{f_t} = \
                 * f(\mathrm{clip}(W_f \boldsymbol{x_t} + \
                 * R_f \boldsymbol{y_{t-1}} + \
                 * p_f \odot c_{t-1} + b_f))
                 * 
                 * Block Input
                 * .. math::
                 * \boldsymbol{z_t} = \
                 * g(\mathrm{clip}(W_z \boldsymbol{x_t} + \
                 * R_z \boldsymbol{y_{t-1}} + b_z))
                 * 
                 * Cell Memory State
                 * .. math::
                 * \boldsymbol{c_t} = \
                 * \boldsymbol{c_{t-1}} \odot \boldsymbol{f_t} + \
                 * \boldsymbol{i_t} \odot \boldsymbol{z_t}
                 * 
                 * Output Gate
                 * .. math::
                 * \boldsymbol{o_t} = \
                 * f(\mathrm{clip}(W_o \boldsymbol{x_t} + \
                 * R_o \boldsymbol{y_{t-1}} + \
                 * p_o \odot c_t + b_o))
                 * 
                 * Output
                 * .. math::
                 * \boldsymbol{y_t} = \
                 * h(\boldsymbol{c_t}) \odot \boldsymbol{o_t}
                 * 
                 * - ``W_i``, ``W_f``, ``W_z``, ``W_o`` are 2-dimensional input weight matrices
                 * (``[outputVectorSize, inputVectorSize]``, row-major)
                 * - ``R_i``, ``R_f``, ``R_z``, ``R_o`` are 2-dimensional recursion matrices
                 * (``[outputVectorSize, outputVectorSize]``, row-major)
                 * - ``b_i``, ``b_f``, ``b_z``, ``b_o`` are 1-dimensional bias vectors
                 * (``[outputVectorSize]``)
                 * - ``p_``, ``p_f``, ``p_o`` are 1-dimensional peephole vectors
                 * (``[outputVectorSize]``)
                 * - ``f()``, ``g()``, ``h()`` are activations
                 * - ``clip()`` is a function that constrains values between ``[-50.0, 50.0]``
                 * - ``⊙`` denotes the elementwise product of matrices
                 * @implements ILSTMParams
                 * @constructor
                 * @param {CoreML.Specification.ILSTMParams=} [properties] Properties to set
                 */
                function LSTMParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * If true, output is a sequence, containing outputs at all time steps.
                 * If false, output is just the result after final state update.
                 * @member {boolean} sequenceOutput
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 */
                LSTMParams.prototype.sequenceOutput = false;
    
                /**
                 * If false, no biases (``b_i``, ``b_f``, ``b_z``, ``b_o``) are added.
                 * @member {boolean} hasBiasVectors
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 */
                LSTMParams.prototype.hasBiasVectors = false;
    
                /**
                 * If true, a vector of ``1`` values is added to ``b_f``.
                 * @member {boolean} forgetBias
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 */
                LSTMParams.prototype.forgetBias = false;
    
                /**
                 * If true, peephole vectors are included.
                 * @member {boolean} hasPeepholeVectors
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 */
                LSTMParams.prototype.hasPeepholeVectors = false;
    
                /**
                 * If the coupled Input and Forget flag is on, the behaviour of
                 * ``c_t`` is changed to the following (i.e. forget gate is not used):
                 * 
                 * .. math::
                 * \boldsymbol{c_t} = \
                 * \boldsymbol{c_{t-1}} \odot (1 - \boldsymbol{i_t}) + \
                 * \boldsymbol{i_t} \odot \boldsymbol{z_t}
                 * @member {boolean} coupledInputAndForgetGate
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 */
                LSTMParams.prototype.coupledInputAndForgetGate = false;
    
                /**
                 * Places a limit on the maximum and minimum values of ``c_t``.
                 * c_t = min(c_t, cellClipThreshold)
                 * c_t = max(c_t, -cellClipThreshold)
                 * If 0, it is set to its default value = 50.0.
                 * @member {number} cellClipThreshold
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 */
                LSTMParams.prototype.cellClipThreshold = 0;
    
                /**
                 * Creates a new LSTMParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {CoreML.Specification.ILSTMParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.LSTMParams} LSTMParams instance
                 */
                LSTMParams.create = function create(properties) {
                    return new LSTMParams(properties);
                };
    
                /**
                 * Encodes the specified LSTMParams message. Does not implicitly {@link CoreML.Specification.LSTMParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {CoreML.Specification.ILSTMParams} message LSTMParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LSTMParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.sequenceOutput);
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.hasBiasVectors);
                    if (message.forgetBias != null && message.hasOwnProperty("forgetBias"))
                        writer.uint32(/* id 30, wireType 0 =*/240).bool(message.forgetBias);
                    if (message.hasPeepholeVectors != null && message.hasOwnProperty("hasPeepholeVectors"))
                        writer.uint32(/* id 40, wireType 0 =*/320).bool(message.hasPeepholeVectors);
                    if (message.coupledInputAndForgetGate != null && message.hasOwnProperty("coupledInputAndForgetGate"))
                        writer.uint32(/* id 50, wireType 0 =*/400).bool(message.coupledInputAndForgetGate);
                    if (message.cellClipThreshold != null && message.hasOwnProperty("cellClipThreshold"))
                        writer.uint32(/* id 60, wireType 5 =*/485).float(message.cellClipThreshold);
                    return writer;
                };
    
                /**
                 * Encodes the specified LSTMParams message, length delimited. Does not implicitly {@link CoreML.Specification.LSTMParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {CoreML.Specification.ILSTMParams} message LSTMParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LSTMParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a LSTMParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.LSTMParams} LSTMParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LSTMParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LSTMParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.sequenceOutput = reader.bool();
                            break;
                        case 20:
                            message.hasBiasVectors = reader.bool();
                            break;
                        case 30:
                            message.forgetBias = reader.bool();
                            break;
                        case 40:
                            message.hasPeepholeVectors = reader.bool();
                            break;
                        case 50:
                            message.coupledInputAndForgetGate = reader.bool();
                            break;
                        case 60:
                            message.cellClipThreshold = reader.float();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a LSTMParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.LSTMParams} LSTMParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LSTMParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a LSTMParams message.
                 * @function verify
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LSTMParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        if (typeof message.sequenceOutput !== "boolean")
                            return "sequenceOutput: boolean expected";
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        if (typeof message.hasBiasVectors !== "boolean")
                            return "hasBiasVectors: boolean expected";
                    if (message.forgetBias != null && message.hasOwnProperty("forgetBias"))
                        if (typeof message.forgetBias !== "boolean")
                            return "forgetBias: boolean expected";
                    if (message.hasPeepholeVectors != null && message.hasOwnProperty("hasPeepholeVectors"))
                        if (typeof message.hasPeepholeVectors !== "boolean")
                            return "hasPeepholeVectors: boolean expected";
                    if (message.coupledInputAndForgetGate != null && message.hasOwnProperty("coupledInputAndForgetGate"))
                        if (typeof message.coupledInputAndForgetGate !== "boolean")
                            return "coupledInputAndForgetGate: boolean expected";
                    if (message.cellClipThreshold != null && message.hasOwnProperty("cellClipThreshold"))
                        if (typeof message.cellClipThreshold !== "number")
                            return "cellClipThreshold: number expected";
                    return null;
                };
    
                /**
                 * Creates a LSTMParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.LSTMParams} LSTMParams
                 */
                LSTMParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LSTMParams)
                        return object;
                    var message = new $root.CoreML.Specification.LSTMParams();
                    if (object.sequenceOutput != null)
                        message.sequenceOutput = Boolean(object.sequenceOutput);
                    if (object.hasBiasVectors != null)
                        message.hasBiasVectors = Boolean(object.hasBiasVectors);
                    if (object.forgetBias != null)
                        message.forgetBias = Boolean(object.forgetBias);
                    if (object.hasPeepholeVectors != null)
                        message.hasPeepholeVectors = Boolean(object.hasPeepholeVectors);
                    if (object.coupledInputAndForgetGate != null)
                        message.coupledInputAndForgetGate = Boolean(object.coupledInputAndForgetGate);
                    if (object.cellClipThreshold != null)
                        message.cellClipThreshold = Number(object.cellClipThreshold);
                    return message;
                };
    
                /**
                 * Creates a plain object from a LSTMParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.LSTMParams
                 * @static
                 * @param {CoreML.Specification.LSTMParams} message LSTMParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LSTMParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.sequenceOutput = false;
                        object.hasBiasVectors = false;
                        object.forgetBias = false;
                        object.hasPeepholeVectors = false;
                        object.coupledInputAndForgetGate = false;
                        object.cellClipThreshold = 0;
                    }
                    if (message.sequenceOutput != null && message.hasOwnProperty("sequenceOutput"))
                        object.sequenceOutput = message.sequenceOutput;
                    if (message.hasBiasVectors != null && message.hasOwnProperty("hasBiasVectors"))
                        object.hasBiasVectors = message.hasBiasVectors;
                    if (message.forgetBias != null && message.hasOwnProperty("forgetBias"))
                        object.forgetBias = message.forgetBias;
                    if (message.hasPeepholeVectors != null && message.hasOwnProperty("hasPeepholeVectors"))
                        object.hasPeepholeVectors = message.hasPeepholeVectors;
                    if (message.coupledInputAndForgetGate != null && message.hasOwnProperty("coupledInputAndForgetGate"))
                        object.coupledInputAndForgetGate = message.coupledInputAndForgetGate;
                    if (message.cellClipThreshold != null && message.hasOwnProperty("cellClipThreshold"))
                        object.cellClipThreshold = options.json && !isFinite(message.cellClipThreshold) ? String(message.cellClipThreshold) : message.cellClipThreshold;
                    return object;
                };
    
                /**
                 * Converts this LSTMParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.LSTMParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LSTMParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LSTMParams;
            })();
    
            Specification.LSTMWeightParams = (function() {
    
                /**
                 * Properties of a LSTMWeightParams.
                 * @memberof CoreML.Specification
                 * @interface ILSTMWeightParams
                 * @property {CoreML.Specification.IWeightParams|null} [inputGateWeightMatrix] Weight Matrix W_i.
                 * @property {CoreML.Specification.IWeightParams|null} [forgetGateWeightMatrix] Weight Matrix W_f.
                 * @property {CoreML.Specification.IWeightParams|null} [blockInputWeightMatrix] Weight Matrix W_z.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGateWeightMatrix] Weight Matrix W_o.
                 * @property {CoreML.Specification.IWeightParams|null} [inputGateRecursionMatrix] Recursion Weight Matrix R_i.
                 * @property {CoreML.Specification.IWeightParams|null} [forgetGateRecursionMatrix] Recursion Weight Matrix R_f.
                 * @property {CoreML.Specification.IWeightParams|null} [blockInputRecursionMatrix] Recursion Weight Matrix R_z.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGateRecursionMatrix] Recursion Weight Matrix R_o.
                 * @property {CoreML.Specification.IWeightParams|null} [inputGateBiasVector] Bias vector b_i.
                 * @property {CoreML.Specification.IWeightParams|null} [forgetGateBiasVector] Bias vector b_f.
                 * @property {CoreML.Specification.IWeightParams|null} [blockInputBiasVector] Bias vector b_z.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGateBiasVector] Bias vector b_o.
                 * @property {CoreML.Specification.IWeightParams|null} [inputGatePeepholeVector] Peephole vector p_i.
                 * @property {CoreML.Specification.IWeightParams|null} [forgetGatePeepholeVector] Peephole vector p_f.
                 * @property {CoreML.Specification.IWeightParams|null} [outputGatePeepholeVector] Peephole vector p_o.
                 */
    
                /**
                 * Constructs a new LSTMWeightParams.
                 * @memberof CoreML.Specification
                 * @classdesc Weights for long short-term memory (LSTM) layers
                 * @implements ILSTMWeightParams
                 * @constructor
                 * @param {CoreML.Specification.ILSTMWeightParams=} [properties] Properties to set
                 */
                function LSTMWeightParams(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Weight Matrix W_i.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} inputGateWeightMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.inputGateWeightMatrix = null;
    
                /**
                 * Weight Matrix W_f.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} forgetGateWeightMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.forgetGateWeightMatrix = null;
    
                /**
                 * Weight Matrix W_z.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} blockInputWeightMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.blockInputWeightMatrix = null;
    
                /**
                 * Weight Matrix W_o.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGateWeightMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.outputGateWeightMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_i.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} inputGateRecursionMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.inputGateRecursionMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_f.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} forgetGateRecursionMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.forgetGateRecursionMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_z.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} blockInputRecursionMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.blockInputRecursionMatrix = null;
    
                /**
                 * Recursion Weight Matrix R_o.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGateRecursionMatrix
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.outputGateRecursionMatrix = null;
    
                /**
                 * Bias vector b_i.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} inputGateBiasVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.inputGateBiasVector = null;
    
                /**
                 * Bias vector b_f.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} forgetGateBiasVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.forgetGateBiasVector = null;
    
                /**
                 * Bias vector b_z.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} blockInputBiasVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.blockInputBiasVector = null;
    
                /**
                 * Bias vector b_o.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGateBiasVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.outputGateBiasVector = null;
    
                /**
                 * Peephole vector p_i.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} inputGatePeepholeVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.inputGatePeepholeVector = null;
    
                /**
                 * Peephole vector p_f.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} forgetGatePeepholeVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.forgetGatePeepholeVector = null;
    
                /**
                 * Peephole vector p_o.
                 * @member {CoreML.Specification.IWeightParams|null|undefined} outputGatePeepholeVector
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 */
                LSTMWeightParams.prototype.outputGatePeepholeVector = null;
    
                /**
                 * Creates a new LSTMWeightParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {CoreML.Specification.ILSTMWeightParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.LSTMWeightParams} LSTMWeightParams instance
                 */
                LSTMWeightParams.create = function create(properties) {
                    return new LSTMWeightParams(properties);
                };
    
                /**
                 * Encodes the specified LSTMWeightParams message. Does not implicitly {@link CoreML.Specification.LSTMWeightParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {CoreML.Specification.ILSTMWeightParams} message LSTMWeightParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LSTMWeightParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputGateWeightMatrix != null && message.hasOwnProperty("inputGateWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.inputGateWeightMatrix, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.forgetGateWeightMatrix != null && message.hasOwnProperty("forgetGateWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.forgetGateWeightMatrix, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.blockInputWeightMatrix != null && message.hasOwnProperty("blockInputWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.blockInputWeightMatrix, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGateWeightMatrix, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.inputGateRecursionMatrix != null && message.hasOwnProperty("inputGateRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.inputGateRecursionMatrix, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.forgetGateRecursionMatrix != null && message.hasOwnProperty("forgetGateRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.forgetGateRecursionMatrix, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    if (message.blockInputRecursionMatrix != null && message.hasOwnProperty("blockInputRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.blockInputRecursionMatrix, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGateRecursionMatrix, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                    if (message.inputGateBiasVector != null && message.hasOwnProperty("inputGateBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.inputGateBiasVector, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
                    if (message.forgetGateBiasVector != null && message.hasOwnProperty("forgetGateBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.forgetGateBiasVector, writer.uint32(/* id 41, wireType 2 =*/330).fork()).ldelim();
                    if (message.blockInputBiasVector != null && message.hasOwnProperty("blockInputBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.blockInputBiasVector, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGateBiasVector, writer.uint32(/* id 43, wireType 2 =*/346).fork()).ldelim();
                    if (message.inputGatePeepholeVector != null && message.hasOwnProperty("inputGatePeepholeVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.inputGatePeepholeVector, writer.uint32(/* id 60, wireType 2 =*/482).fork()).ldelim();
                    if (message.forgetGatePeepholeVector != null && message.hasOwnProperty("forgetGatePeepholeVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.forgetGatePeepholeVector, writer.uint32(/* id 61, wireType 2 =*/490).fork()).ldelim();
                    if (message.outputGatePeepholeVector != null && message.hasOwnProperty("outputGatePeepholeVector"))
                        $root.CoreML.Specification.WeightParams.encode(message.outputGatePeepholeVector, writer.uint32(/* id 62, wireType 2 =*/498).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified LSTMWeightParams message, length delimited. Does not implicitly {@link CoreML.Specification.LSTMWeightParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {CoreML.Specification.ILSTMWeightParams} message LSTMWeightParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LSTMWeightParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a LSTMWeightParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.LSTMWeightParams} LSTMWeightParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LSTMWeightParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LSTMWeightParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.forgetGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.blockInputWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.inputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.forgetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.blockInputRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 23:
                            message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.inputGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 41:
                            message.forgetGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 42:
                            message.blockInputBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 43:
                            message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 60:
                            message.inputGatePeepholeVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 61:
                            message.forgetGatePeepholeVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        case 62:
                            message.outputGatePeepholeVector = $root.CoreML.Specification.WeightParams.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a LSTMWeightParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.LSTMWeightParams} LSTMWeightParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LSTMWeightParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a LSTMWeightParams message.
                 * @function verify
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LSTMWeightParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputGateWeightMatrix != null && message.hasOwnProperty("inputGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGateWeightMatrix);
                        if (error)
                            return "inputGateWeightMatrix." + error;
                    }
                    if (message.forgetGateWeightMatrix != null && message.hasOwnProperty("forgetGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGateWeightMatrix);
                        if (error)
                            return "forgetGateWeightMatrix." + error;
                    }
                    if (message.blockInputWeightMatrix != null && message.hasOwnProperty("blockInputWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.blockInputWeightMatrix);
                        if (error)
                            return "blockInputWeightMatrix." + error;
                    }
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateWeightMatrix);
                        if (error)
                            return "outputGateWeightMatrix." + error;
                    }
                    if (message.inputGateRecursionMatrix != null && message.hasOwnProperty("inputGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGateRecursionMatrix);
                        if (error)
                            return "inputGateRecursionMatrix." + error;
                    }
                    if (message.forgetGateRecursionMatrix != null && message.hasOwnProperty("forgetGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGateRecursionMatrix);
                        if (error)
                            return "forgetGateRecursionMatrix." + error;
                    }
                    if (message.blockInputRecursionMatrix != null && message.hasOwnProperty("blockInputRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.blockInputRecursionMatrix);
                        if (error)
                            return "blockInputRecursionMatrix." + error;
                    }
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateRecursionMatrix);
                        if (error)
                            return "outputGateRecursionMatrix." + error;
                    }
                    if (message.inputGateBiasVector != null && message.hasOwnProperty("inputGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGateBiasVector);
                        if (error)
                            return "inputGateBiasVector." + error;
                    }
                    if (message.forgetGateBiasVector != null && message.hasOwnProperty("forgetGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGateBiasVector);
                        if (error)
                            return "forgetGateBiasVector." + error;
                    }
                    if (message.blockInputBiasVector != null && message.hasOwnProperty("blockInputBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.blockInputBiasVector);
                        if (error)
                            return "blockInputBiasVector." + error;
                    }
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGateBiasVector);
                        if (error)
                            return "outputGateBiasVector." + error;
                    }
                    if (message.inputGatePeepholeVector != null && message.hasOwnProperty("inputGatePeepholeVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.inputGatePeepholeVector);
                        if (error)
                            return "inputGatePeepholeVector." + error;
                    }
                    if (message.forgetGatePeepholeVector != null && message.hasOwnProperty("forgetGatePeepholeVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.forgetGatePeepholeVector);
                        if (error)
                            return "forgetGatePeepholeVector." + error;
                    }
                    if (message.outputGatePeepholeVector != null && message.hasOwnProperty("outputGatePeepholeVector")) {
                        var error = $root.CoreML.Specification.WeightParams.verify(message.outputGatePeepholeVector);
                        if (error)
                            return "outputGatePeepholeVector." + error;
                    }
                    return null;
                };
    
                /**
                 * Creates a LSTMWeightParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.LSTMWeightParams} LSTMWeightParams
                 */
                LSTMWeightParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LSTMWeightParams)
                        return object;
                    var message = new $root.CoreML.Specification.LSTMWeightParams();
                    if (object.inputGateWeightMatrix != null) {
                        if (typeof object.inputGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGateWeightMatrix: object expected");
                        message.inputGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.inputGateWeightMatrix);
                    }
                    if (object.forgetGateWeightMatrix != null) {
                        if (typeof object.forgetGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGateWeightMatrix: object expected");
                        message.forgetGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGateWeightMatrix);
                    }
                    if (object.blockInputWeightMatrix != null) {
                        if (typeof object.blockInputWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.blockInputWeightMatrix: object expected");
                        message.blockInputWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.blockInputWeightMatrix);
                    }
                    if (object.outputGateWeightMatrix != null) {
                        if (typeof object.outputGateWeightMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGateWeightMatrix: object expected");
                        message.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateWeightMatrix);
                    }
                    if (object.inputGateRecursionMatrix != null) {
                        if (typeof object.inputGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGateRecursionMatrix: object expected");
                        message.inputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.inputGateRecursionMatrix);
                    }
                    if (object.forgetGateRecursionMatrix != null) {
                        if (typeof object.forgetGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGateRecursionMatrix: object expected");
                        message.forgetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGateRecursionMatrix);
                    }
                    if (object.blockInputRecursionMatrix != null) {
                        if (typeof object.blockInputRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.blockInputRecursionMatrix: object expected");
                        message.blockInputRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.blockInputRecursionMatrix);
                    }
                    if (object.outputGateRecursionMatrix != null) {
                        if (typeof object.outputGateRecursionMatrix !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGateRecursionMatrix: object expected");
                        message.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateRecursionMatrix);
                    }
                    if (object.inputGateBiasVector != null) {
                        if (typeof object.inputGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGateBiasVector: object expected");
                        message.inputGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.inputGateBiasVector);
                    }
                    if (object.forgetGateBiasVector != null) {
                        if (typeof object.forgetGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGateBiasVector: object expected");
                        message.forgetGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGateBiasVector);
                    }
                    if (object.blockInputBiasVector != null) {
                        if (typeof object.blockInputBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.blockInputBiasVector: object expected");
                        message.blockInputBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.blockInputBiasVector);
                    }
                    if (object.outputGateBiasVector != null) {
                        if (typeof object.outputGateBiasVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGateBiasVector: object expected");
                        message.outputGateBiasVector = $root.CoreML.Specification.WeightParams.fromObject(object.outputGateBiasVector);
                    }
                    if (object.inputGatePeepholeVector != null) {
                        if (typeof object.inputGatePeepholeVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.inputGatePeepholeVector: object expected");
                        message.inputGatePeepholeVector = $root.CoreML.Specification.WeightParams.fromObject(object.inputGatePeepholeVector);
                    }
                    if (object.forgetGatePeepholeVector != null) {
                        if (typeof object.forgetGatePeepholeVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.forgetGatePeepholeVector: object expected");
                        message.forgetGatePeepholeVector = $root.CoreML.Specification.WeightParams.fromObject(object.forgetGatePeepholeVector);
                    }
                    if (object.outputGatePeepholeVector != null) {
                        if (typeof object.outputGatePeepholeVector !== "object")
                            throw TypeError(".CoreML.Specification.LSTMWeightParams.outputGatePeepholeVector: object expected");
                        message.outputGatePeepholeVector = $root.CoreML.Specification.WeightParams.fromObject(object.outputGatePeepholeVector);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a LSTMWeightParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @static
                 * @param {CoreML.Specification.LSTMWeightParams} message LSTMWeightParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LSTMWeightParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.inputGateWeightMatrix = null;
                        object.forgetGateWeightMatrix = null;
                        object.blockInputWeightMatrix = null;
                        object.outputGateWeightMatrix = null;
                        object.inputGateRecursionMatrix = null;
                        object.forgetGateRecursionMatrix = null;
                        object.blockInputRecursionMatrix = null;
                        object.outputGateRecursionMatrix = null;
                        object.inputGateBiasVector = null;
                        object.forgetGateBiasVector = null;
                        object.blockInputBiasVector = null;
                        object.outputGateBiasVector = null;
                        object.inputGatePeepholeVector = null;
                        object.forgetGatePeepholeVector = null;
                        object.outputGatePeepholeVector = null;
                    }
                    if (message.inputGateWeightMatrix != null && message.hasOwnProperty("inputGateWeightMatrix"))
                        object.inputGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.inputGateWeightMatrix, options);
                    if (message.forgetGateWeightMatrix != null && message.hasOwnProperty("forgetGateWeightMatrix"))
                        object.forgetGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.forgetGateWeightMatrix, options);
                    if (message.blockInputWeightMatrix != null && message.hasOwnProperty("blockInputWeightMatrix"))
                        object.blockInputWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.blockInputWeightMatrix, options);
                    if (message.outputGateWeightMatrix != null && message.hasOwnProperty("outputGateWeightMatrix"))
                        object.outputGateWeightMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateWeightMatrix, options);
                    if (message.inputGateRecursionMatrix != null && message.hasOwnProperty("inputGateRecursionMatrix"))
                        object.inputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.inputGateRecursionMatrix, options);
                    if (message.forgetGateRecursionMatrix != null && message.hasOwnProperty("forgetGateRecursionMatrix"))
                        object.forgetGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.forgetGateRecursionMatrix, options);
                    if (message.blockInputRecursionMatrix != null && message.hasOwnProperty("blockInputRecursionMatrix"))
                        object.blockInputRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.blockInputRecursionMatrix, options);
                    if (message.outputGateRecursionMatrix != null && message.hasOwnProperty("outputGateRecursionMatrix"))
                        object.outputGateRecursionMatrix = $root.CoreML.Specification.WeightParams.toObject(message.outputGateRecursionMatrix, options);
                    if (message.inputGateBiasVector != null && message.hasOwnProperty("inputGateBiasVector"))
                        object.inputGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.inputGateBiasVector, options);
                    if (message.forgetGateBiasVector != null && message.hasOwnProperty("forgetGateBiasVector"))
                        object.forgetGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.forgetGateBiasVector, options);
                    if (message.blockInputBiasVector != null && message.hasOwnProperty("blockInputBiasVector"))
                        object.blockInputBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.blockInputBiasVector, options);
                    if (message.outputGateBiasVector != null && message.hasOwnProperty("outputGateBiasVector"))
                        object.outputGateBiasVector = $root.CoreML.Specification.WeightParams.toObject(message.outputGateBiasVector, options);
                    if (message.inputGatePeepholeVector != null && message.hasOwnProperty("inputGatePeepholeVector"))
                        object.inputGatePeepholeVector = $root.CoreML.Specification.WeightParams.toObject(message.inputGatePeepholeVector, options);
                    if (message.forgetGatePeepholeVector != null && message.hasOwnProperty("forgetGatePeepholeVector"))
                        object.forgetGatePeepholeVector = $root.CoreML.Specification.WeightParams.toObject(message.forgetGatePeepholeVector, options);
                    if (message.outputGatePeepholeVector != null && message.hasOwnProperty("outputGatePeepholeVector"))
                        object.outputGatePeepholeVector = $root.CoreML.Specification.WeightParams.toObject(message.outputGatePeepholeVector, options);
                    return object;
                };
    
                /**
                 * Converts this LSTMWeightParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.LSTMWeightParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LSTMWeightParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LSTMWeightParams;
            })();
    
            Specification.UniDirectionalLSTMLayerParams = (function() {
    
                /**
                 * Properties of an UniDirectionalLSTMLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IUniDirectionalLSTMLayerParams
                 * @property {number|Long|null} [inputVectorSize] Size of the input vectors.
                 * @property {number|Long|null} [outputVectorSize] UniDirectionalLSTMLayerParams outputVectorSize
                 * @property {Array.<CoreML.Specification.IActivationParams>|null} [activations] 3 element array representing activations [f(),g(),h()] in that order.
                 * Typical values used = [sigmoid, tanh, tanh].
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @property {CoreML.Specification.ILSTMParams|null} [params] UniDirectionalLSTMLayerParams params
                 * @property {CoreML.Specification.ILSTMWeightParams|null} [weightParams] UniDirectionalLSTMLayerParams weightParams
                 * @property {boolean|null} [reverseInput] If true, then the node processes the input sequence from right to left
                 */
    
                /**
                 * Constructs a new UniDirectionalLSTMLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc A unidirectional long short-term memory (LSTM) layer.
                 * 
                 * .. code::
                 * 
                 * (y_t, c_t) = UniDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1})
                 * 
                 * Input
                 * A sequence of vectors of size ``inputVectorSize``
                 * with shape ``[Seq, inputVectorSize]``.
                 * Output
                 * A vector of size ``outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
                 * 
                 * - Output Shape: ``[1,outputVectorSize]`` , if ``sequenceOutput == false``
                 * - Output Shape: ``[Seq,outputVectorSize]`` , if ``sequenceOutput == true``
                 * @implements IUniDirectionalLSTMLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IUniDirectionalLSTMLayerParams=} [properties] Properties to set
                 */
                function UniDirectionalLSTMLayerParams(properties) {
                    this.activations = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Size of the input vectors.
                 * @member {number|Long} inputVectorSize
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 */
                UniDirectionalLSTMLayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * UniDirectionalLSTMLayerParams outputVectorSize.
                 * @member {number|Long} outputVectorSize
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 */
                UniDirectionalLSTMLayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * 3 element array representing activations [f(),g(),h()] in that order.
                 * Typical values used = [sigmoid, tanh, tanh].
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @member {Array.<CoreML.Specification.IActivationParams>} activations
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 */
                UniDirectionalLSTMLayerParams.prototype.activations = $util.emptyArray;
    
                /**
                 * UniDirectionalLSTMLayerParams params.
                 * @member {CoreML.Specification.ILSTMParams|null|undefined} params
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 */
                UniDirectionalLSTMLayerParams.prototype.params = null;
    
                /**
                 * UniDirectionalLSTMLayerParams weightParams.
                 * @member {CoreML.Specification.ILSTMWeightParams|null|undefined} weightParams
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 */
                UniDirectionalLSTMLayerParams.prototype.weightParams = null;
    
                /**
                 * If true, then the node processes the input sequence from right to left
                 * @member {boolean} reverseInput
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 */
                UniDirectionalLSTMLayerParams.prototype.reverseInput = false;
    
                /**
                 * Creates a new UniDirectionalLSTMLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.IUniDirectionalLSTMLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.UniDirectionalLSTMLayerParams} UniDirectionalLSTMLayerParams instance
                 */
                UniDirectionalLSTMLayerParams.create = function create(properties) {
                    return new UniDirectionalLSTMLayerParams(properties);
                };
    
                /**
                 * Encodes the specified UniDirectionalLSTMLayerParams message. Does not implicitly {@link CoreML.Specification.UniDirectionalLSTMLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.IUniDirectionalLSTMLayerParams} message UniDirectionalLSTMLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UniDirectionalLSTMLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inputVectorSize);
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputVectorSize);
                    if (message.activations != null && message.activations.length)
                        for (var i = 0; i < message.activations.length; ++i)
                            $root.CoreML.Specification.ActivationParams.encode(message.activations[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.params != null && message.hasOwnProperty("params"))
                        $root.CoreML.Specification.LSTMParams.encode(message.params, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.weightParams != null && message.hasOwnProperty("weightParams"))
                        $root.CoreML.Specification.LSTMWeightParams.encode(message.weightParams, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        writer.uint32(/* id 100, wireType 0 =*/800).bool(message.reverseInput);
                    return writer;
                };
    
                /**
                 * Encodes the specified UniDirectionalLSTMLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.UniDirectionalLSTMLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.IUniDirectionalLSTMLayerParams} message UniDirectionalLSTMLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UniDirectionalLSTMLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an UniDirectionalLSTMLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.UniDirectionalLSTMLayerParams} UniDirectionalLSTMLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UniDirectionalLSTMLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.UniDirectionalLSTMLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            if (!(message.activations && message.activations.length))
                                message.activations = [];
                            message.activations.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.params = $root.CoreML.Specification.LSTMParams.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.weightParams = $root.CoreML.Specification.LSTMWeightParams.decode(reader, reader.uint32());
                            break;
                        case 100:
                            message.reverseInput = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an UniDirectionalLSTMLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.UniDirectionalLSTMLayerParams} UniDirectionalLSTMLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UniDirectionalLSTMLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an UniDirectionalLSTMLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UniDirectionalLSTMLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activations != null && message.hasOwnProperty("activations")) {
                        if (!Array.isArray(message.activations))
                            return "activations: array expected";
                        for (var i = 0; i < message.activations.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activations[i]);
                            if (error)
                                return "activations." + error;
                        }
                    }
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.CoreML.Specification.LSTMParams.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.weightParams != null && message.hasOwnProperty("weightParams")) {
                        var error = $root.CoreML.Specification.LSTMWeightParams.verify(message.weightParams);
                        if (error)
                            return "weightParams." + error;
                    }
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        if (typeof message.reverseInput !== "boolean")
                            return "reverseInput: boolean expected";
                    return null;
                };
    
                /**
                 * Creates an UniDirectionalLSTMLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.UniDirectionalLSTMLayerParams} UniDirectionalLSTMLayerParams
                 */
                UniDirectionalLSTMLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.UniDirectionalLSTMLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.UniDirectionalLSTMLayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activations) {
                        if (!Array.isArray(object.activations))
                            throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.activations: array expected");
                        message.activations = [];
                        for (var i = 0; i < object.activations.length; ++i) {
                            if (typeof object.activations[i] !== "object")
                                throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.activations: object expected");
                            message.activations[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activations[i]);
                        }
                    }
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.params: object expected");
                        message.params = $root.CoreML.Specification.LSTMParams.fromObject(object.params);
                    }
                    if (object.weightParams != null) {
                        if (typeof object.weightParams !== "object")
                            throw TypeError(".CoreML.Specification.UniDirectionalLSTMLayerParams.weightParams: object expected");
                        message.weightParams = $root.CoreML.Specification.LSTMWeightParams.fromObject(object.weightParams);
                    }
                    if (object.reverseInput != null)
                        message.reverseInput = Boolean(object.reverseInput);
                    return message;
                };
    
                /**
                 * Creates a plain object from an UniDirectionalLSTMLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.UniDirectionalLSTMLayerParams} message UniDirectionalLSTMLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UniDirectionalLSTMLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.activations = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.params = null;
                        object.weightParams = null;
                        object.reverseInput = false;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activations && message.activations.length) {
                        object.activations = [];
                        for (var j = 0; j < message.activations.length; ++j)
                            object.activations[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activations[j], options);
                    }
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.CoreML.Specification.LSTMParams.toObject(message.params, options);
                    if (message.weightParams != null && message.hasOwnProperty("weightParams"))
                        object.weightParams = $root.CoreML.Specification.LSTMWeightParams.toObject(message.weightParams, options);
                    if (message.reverseInput != null && message.hasOwnProperty("reverseInput"))
                        object.reverseInput = message.reverseInput;
                    return object;
                };
    
                /**
                 * Converts this UniDirectionalLSTMLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.UniDirectionalLSTMLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UniDirectionalLSTMLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return UniDirectionalLSTMLayerParams;
            })();
    
            Specification.BiDirectionalLSTMLayerParams = (function() {
    
                /**
                 * Properties of a BiDirectionalLSTMLayerParams.
                 * @memberof CoreML.Specification
                 * @interface IBiDirectionalLSTMLayerParams
                 * @property {number|Long|null} [inputVectorSize] Size of the input vectors.
                 * @property {number|Long|null} [outputVectorSize] Size of the outputs vectors.
                 * It is same for both forward and backward LSTMs.
                 * @property {Array.<CoreML.Specification.IActivationParams>|null} [activationsForwardLSTM] 3 element array representing activations [f(),g(),h()] in that order.
                 * Typical values used = [sigmoid, tanh, tanh].
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @property {Array.<CoreML.Specification.IActivationParams>|null} [activationsBackwardLSTM] Currently, backward LSTM activations
                 * must be same as the ones for the forward LSTM.
                 * @property {CoreML.Specification.ILSTMParams|null} [params] Common parameters shared by the forward and backward LSTMs.
                 * @property {Array.<CoreML.Specification.ILSTMWeightParams>|null} [weightParams] Weights and biases.
                 * Must be a length 2 message,
                 * for the forward and backward LSTM respectively.
                 */
    
                /**
                 * Constructs a new BiDirectionalLSTMLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc Bidirectional long short-term memory (LSTM) layer
                 * 
                 * .. code::
                 * 
                 * (y_t, c_t, y_t_reverse, c_t_reverse) = BiDirectionalLSTMLayer(x_t, y_{t-1}, c_{t-1}, y_{t-1}_reverse, c_{t-1}_reverse)
                 * 
                 * Input
                 * A sequence of vectors of size ``inputVectorSize``
                 * with shape ``[Seq, inputVectorSize]``.
                 * Output
                 * A vector of size ``2 * outputVectorSize``. It is either the final output or a sequence of outputs at all time steps.
                 * 
                 * - Output Shape: ``[1, 2 * outputVectorSize]`` , if ``sequenceOutput == false``
                 * - Output Shape: ``[Seq, 2 * outputVectorSize]`` , if ``sequenceOutput == true``
                 * 
                 * The first LSTM operates on the input sequence in the forward direction.
                 * The second LSTM operates on the input sequence in the reverse direction.
                 * 
                 * Example: given the input sequence ``[x_1, x_2, x_3]``,
                 * where ``x_i`` are vectors at time index ``i``:
                 * 
                 * The forward LSTM output is ``[yf_1, yf_2, yf_3]``,
                 * 
                 * where ``yf_i`` are vectors of size ``outputVectorSize``:
                 * 
                 * - ``yf_1`` is the output at the end of sequence {``x_1``}
                 * - ``yf_2`` is the output at the end of sequence {``x_1``, ``x_2``}
                 * - ``yf_3`` is the output at the end of sequence {``x_1``, ``x_2``, ``x_3``}
                 * 
                 * The backward LSTM output: ``[yb_1, yb_2, yb_3]``,
                 * 
                 * where ``yb_i`` are vectors of size ``outputVectorSize``:
                 * 
                 * - ``yb_1`` is the output at the end of sequence {``x_3``}
                 * - ``yb_2`` is the output at the end of sequence {``x_3``, ``x_2``}
                 * - ``yb_3`` is the output at the end of sequence {``x_3``, ``x_2``, ``x_1``}
                 * 
                 * Output of the bi-dir layer:
                 * 
                 * - if ``sequenceOutput = True`` : { ``[yf_1, yb_3]``,  ``[yf_2, yb_2]``,  ``[yf_3, yb_1]`` }
                 * - if ``sequenceOutput = False`` : { ``[yf_3, yb_3]`` }
                 * @implements IBiDirectionalLSTMLayerParams
                 * @constructor
                 * @param {CoreML.Specification.IBiDirectionalLSTMLayerParams=} [properties] Properties to set
                 */
                function BiDirectionalLSTMLayerParams(properties) {
                    this.activationsForwardLSTM = [];
                    this.activationsBackwardLSTM = [];
                    this.weightParams = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Size of the input vectors.
                 * @member {number|Long} inputVectorSize
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 */
                BiDirectionalLSTMLayerParams.prototype.inputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * Size of the outputs vectors.
                 * It is same for both forward and backward LSTMs.
                 * @member {number|Long} outputVectorSize
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 */
                BiDirectionalLSTMLayerParams.prototype.outputVectorSize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * 3 element array representing activations [f(),g(),h()] in that order.
                 * Typical values used = [sigmoid, tanh, tanh].
                 * Activations supported are Linear, Sigmoid, Tanh, ReLU, Scaled Tanh (alpha = 1.71, beta = 2/3), Hard sigmoid (alpha = 0.2, beta = 0.5)
                 * @member {Array.<CoreML.Specification.IActivationParams>} activationsForwardLSTM
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 */
                BiDirectionalLSTMLayerParams.prototype.activationsForwardLSTM = $util.emptyArray;
    
                /**
                 * Currently, backward LSTM activations
                 * must be same as the ones for the forward LSTM.
                 * @member {Array.<CoreML.Specification.IActivationParams>} activationsBackwardLSTM
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 */
                BiDirectionalLSTMLayerParams.prototype.activationsBackwardLSTM = $util.emptyArray;
    
                /**
                 * Common parameters shared by the forward and backward LSTMs.
                 * @member {CoreML.Specification.ILSTMParams|null|undefined} params
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 */
                BiDirectionalLSTMLayerParams.prototype.params = null;
    
                /**
                 * Weights and biases.
                 * Must be a length 2 message,
                 * for the forward and backward LSTM respectively.
                 * @member {Array.<CoreML.Specification.ILSTMWeightParams>} weightParams
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 */
                BiDirectionalLSTMLayerParams.prototype.weightParams = $util.emptyArray;
    
                /**
                 * Creates a new BiDirectionalLSTMLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.IBiDirectionalLSTMLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.BiDirectionalLSTMLayerParams} BiDirectionalLSTMLayerParams instance
                 */
                BiDirectionalLSTMLayerParams.create = function create(properties) {
                    return new BiDirectionalLSTMLayerParams(properties);
                };
    
                /**
                 * Encodes the specified BiDirectionalLSTMLayerParams message. Does not implicitly {@link CoreML.Specification.BiDirectionalLSTMLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.IBiDirectionalLSTMLayerParams} message BiDirectionalLSTMLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BiDirectionalLSTMLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.inputVectorSize);
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.outputVectorSize);
                    if (message.activationsForwardLSTM != null && message.activationsForwardLSTM.length)
                        for (var i = 0; i < message.activationsForwardLSTM.length; ++i)
                            $root.CoreML.Specification.ActivationParams.encode(message.activationsForwardLSTM[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.activationsBackwardLSTM != null && message.activationsBackwardLSTM.length)
                        for (var i = 0; i < message.activationsBackwardLSTM.length; ++i)
                            $root.CoreML.Specification.ActivationParams.encode(message.activationsBackwardLSTM[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.params != null && message.hasOwnProperty("params"))
                        $root.CoreML.Specification.LSTMParams.encode(message.params, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
                    if (message.weightParams != null && message.weightParams.length)
                        for (var i = 0; i < message.weightParams.length; ++i)
                            $root.CoreML.Specification.LSTMWeightParams.encode(message.weightParams[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified BiDirectionalLSTMLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.BiDirectionalLSTMLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.IBiDirectionalLSTMLayerParams} message BiDirectionalLSTMLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                BiDirectionalLSTMLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a BiDirectionalLSTMLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.BiDirectionalLSTMLayerParams} BiDirectionalLSTMLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BiDirectionalLSTMLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.BiDirectionalLSTMLayerParams();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.inputVectorSize = reader.uint64();
                            break;
                        case 2:
                            message.outputVectorSize = reader.uint64();
                            break;
                        case 10:
                            if (!(message.activationsForwardLSTM && message.activationsForwardLSTM.length))
                                message.activationsForwardLSTM = [];
                            message.activationsForwardLSTM.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 11:
                            if (!(message.activationsBackwardLSTM && message.activationsBackwardLSTM.length))
                                message.activationsBackwardLSTM = [];
                            message.activationsBackwardLSTM.push($root.CoreML.Specification.ActivationParams.decode(reader, reader.uint32()));
                            break;
                        case 15:
                            message.params = $root.CoreML.Specification.LSTMParams.decode(reader, reader.uint32());
                            break;
                        case 20:
                            if (!(message.weightParams && message.weightParams.length))
                                message.weightParams = [];
                            message.weightParams.push($root.CoreML.Specification.LSTMWeightParams.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a BiDirectionalLSTMLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.BiDirectionalLSTMLayerParams} BiDirectionalLSTMLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                BiDirectionalLSTMLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a BiDirectionalLSTMLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                BiDirectionalLSTMLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (!$util.isInteger(message.inputVectorSize) && !(message.inputVectorSize && $util.isInteger(message.inputVectorSize.low) && $util.isInteger(message.inputVectorSize.high)))
                            return "inputVectorSize: integer|Long expected";
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (!$util.isInteger(message.outputVectorSize) && !(message.outputVectorSize && $util.isInteger(message.outputVectorSize.low) && $util.isInteger(message.outputVectorSize.high)))
                            return "outputVectorSize: integer|Long expected";
                    if (message.activationsForwardLSTM != null && message.hasOwnProperty("activationsForwardLSTM")) {
                        if (!Array.isArray(message.activationsForwardLSTM))
                            return "activationsForwardLSTM: array expected";
                        for (var i = 0; i < message.activationsForwardLSTM.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activationsForwardLSTM[i]);
                            if (error)
                                return "activationsForwardLSTM." + error;
                        }
                    }
                    if (message.activationsBackwardLSTM != null && message.hasOwnProperty("activationsBackwardLSTM")) {
                        if (!Array.isArray(message.activationsBackwardLSTM))
                            return "activationsBackwardLSTM: array expected";
                        for (var i = 0; i < message.activationsBackwardLSTM.length; ++i) {
                            var error = $root.CoreML.Specification.ActivationParams.verify(message.activationsBackwardLSTM[i]);
                            if (error)
                                return "activationsBackwardLSTM." + error;
                        }
                    }
                    if (message.params != null && message.hasOwnProperty("params")) {
                        var error = $root.CoreML.Specification.LSTMParams.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.weightParams != null && message.hasOwnProperty("weightParams")) {
                        if (!Array.isArray(message.weightParams))
                            return "weightParams: array expected";
                        for (var i = 0; i < message.weightParams.length; ++i) {
                            var error = $root.CoreML.Specification.LSTMWeightParams.verify(message.weightParams[i]);
                            if (error)
                                return "weightParams." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a BiDirectionalLSTMLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.BiDirectionalLSTMLayerParams} BiDirectionalLSTMLayerParams
                 */
                BiDirectionalLSTMLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.BiDirectionalLSTMLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.BiDirectionalLSTMLayerParams();
                    if (object.inputVectorSize != null)
                        if ($util.Long)
                            (message.inputVectorSize = $util.Long.fromValue(object.inputVectorSize)).unsigned = true;
                        else if (typeof object.inputVectorSize === "string")
                            message.inputVectorSize = parseInt(object.inputVectorSize, 10);
                        else if (typeof object.inputVectorSize === "number")
                            message.inputVectorSize = object.inputVectorSize;
                        else if (typeof object.inputVectorSize === "object")
                            message.inputVectorSize = new $util.LongBits(object.inputVectorSize.low >>> 0, object.inputVectorSize.high >>> 0).toNumber(true);
                    if (object.outputVectorSize != null)
                        if ($util.Long)
                            (message.outputVectorSize = $util.Long.fromValue(object.outputVectorSize)).unsigned = true;
                        else if (typeof object.outputVectorSize === "string")
                            message.outputVectorSize = parseInt(object.outputVectorSize, 10);
                        else if (typeof object.outputVectorSize === "number")
                            message.outputVectorSize = object.outputVectorSize;
                        else if (typeof object.outputVectorSize === "object")
                            message.outputVectorSize = new $util.LongBits(object.outputVectorSize.low >>> 0, object.outputVectorSize.high >>> 0).toNumber(true);
                    if (object.activationsForwardLSTM) {
                        if (!Array.isArray(object.activationsForwardLSTM))
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM: array expected");
                        message.activationsForwardLSTM = [];
                        for (var i = 0; i < object.activationsForwardLSTM.length; ++i) {
                            if (typeof object.activationsForwardLSTM[i] !== "object")
                                throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsForwardLSTM: object expected");
                            message.activationsForwardLSTM[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activationsForwardLSTM[i]);
                        }
                    }
                    if (object.activationsBackwardLSTM) {
                        if (!Array.isArray(object.activationsBackwardLSTM))
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM: array expected");
                        message.activationsBackwardLSTM = [];
                        for (var i = 0; i < object.activationsBackwardLSTM.length; ++i) {
                            if (typeof object.activationsBackwardLSTM[i] !== "object")
                                throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.activationsBackwardLSTM: object expected");
                            message.activationsBackwardLSTM[i] = $root.CoreML.Specification.ActivationParams.fromObject(object.activationsBackwardLSTM[i]);
                        }
                    }
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.params: object expected");
                        message.params = $root.CoreML.Specification.LSTMParams.fromObject(object.params);
                    }
                    if (object.weightParams) {
                        if (!Array.isArray(object.weightParams))
                            throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams: array expected");
                        message.weightParams = [];
                        for (var i = 0; i < object.weightParams.length; ++i) {
                            if (typeof object.weightParams[i] !== "object")
                                throw TypeError(".CoreML.Specification.BiDirectionalLSTMLayerParams.weightParams: object expected");
                            message.weightParams[i] = $root.CoreML.Specification.LSTMWeightParams.fromObject(object.weightParams[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a BiDirectionalLSTMLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @static
                 * @param {CoreML.Specification.BiDirectionalLSTMLayerParams} message BiDirectionalLSTMLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                BiDirectionalLSTMLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.activationsForwardLSTM = [];
                        object.activationsBackwardLSTM = [];
                        object.weightParams = [];
                    }
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.inputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.inputVectorSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.outputVectorSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.outputVectorSize = options.longs === String ? "0" : 0;
                        object.params = null;
                    }
                    if (message.inputVectorSize != null && message.hasOwnProperty("inputVectorSize"))
                        if (typeof message.inputVectorSize === "number")
                            object.inputVectorSize = options.longs === String ? String(message.inputVectorSize) : message.inputVectorSize;
                        else
                            object.inputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.inputVectorSize) : options.longs === Number ? new $util.LongBits(message.inputVectorSize.low >>> 0, message.inputVectorSize.high >>> 0).toNumber(true) : message.inputVectorSize;
                    if (message.outputVectorSize != null && message.hasOwnProperty("outputVectorSize"))
                        if (typeof message.outputVectorSize === "number")
                            object.outputVectorSize = options.longs === String ? String(message.outputVectorSize) : message.outputVectorSize;
                        else
                            object.outputVectorSize = options.longs === String ? $util.Long.prototype.toString.call(message.outputVectorSize) : options.longs === Number ? new $util.LongBits(message.outputVectorSize.low >>> 0, message.outputVectorSize.high >>> 0).toNumber(true) : message.outputVectorSize;
                    if (message.activationsForwardLSTM && message.activationsForwardLSTM.length) {
                        object.activationsForwardLSTM = [];
                        for (var j = 0; j < message.activationsForwardLSTM.length; ++j)
                            object.activationsForwardLSTM[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activationsForwardLSTM[j], options);
                    }
                    if (message.activationsBackwardLSTM && message.activationsBackwardLSTM.length) {
                        object.activationsBackwardLSTM = [];
                        for (var j = 0; j < message.activationsBackwardLSTM.length; ++j)
                            object.activationsBackwardLSTM[j] = $root.CoreML.Specification.ActivationParams.toObject(message.activationsBackwardLSTM[j], options);
                    }
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.CoreML.Specification.LSTMParams.toObject(message.params, options);
                    if (message.weightParams && message.weightParams.length) {
                        object.weightParams = [];
                        for (var j = 0; j < message.weightParams.length; ++j)
                            object.weightParams[j] = $root.CoreML.Specification.LSTMWeightParams.toObject(message.weightParams[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this BiDirectionalLSTMLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.BiDirectionalLSTMLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                BiDirectionalLSTMLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return BiDirectionalLSTMLayerParams;
            })();
    
            Specification.CustomLayerParams = (function() {
    
                /**
                 * Properties of a CustomLayerParams.
                 * @memberof CoreML.Specification
                 * @interface ICustomLayerParams
                 * @property {string|null} [className] CustomLayerParams className
                 * @property {Array.<CoreML.Specification.IWeightParams>|null} [weights] CustomLayerParams weights
                 * @property {Object.<string,CoreML.Specification.CustomLayerParams.ICustomLayerParamValue>|null} [parameters] CustomLayerParams parameters
                 * @property {string|null} [description] CustomLayerParams description
                 */
    
                /**
                 * Constructs a new CustomLayerParams.
                 * @memberof CoreML.Specification
                 * @classdesc Represents a CustomLayerParams.
                 * @implements ICustomLayerParams
                 * @constructor
                 * @param {CoreML.Specification.ICustomLayerParams=} [properties] Properties to set
                 */
                function CustomLayerParams(properties) {
                    this.weights = [];
                    this.parameters = {};
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * CustomLayerParams className.
                 * @member {string} className
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @instance
                 */
                CustomLayerParams.prototype.className = "";
    
                /**
                 * CustomLayerParams weights.
                 * @member {Array.<CoreML.Specification.IWeightParams>} weights
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @instance
                 */
                CustomLayerParams.prototype.weights = $util.emptyArray;
    
                /**
                 * CustomLayerParams parameters.
                 * @member {Object.<string,CoreML.Specification.CustomLayerParams.ICustomLayerParamValue>} parameters
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @instance
                 */
                CustomLayerParams.prototype.parameters = $util.emptyObject;
    
                /**
                 * CustomLayerParams description.
                 * @member {string} description
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @instance
                 */
                CustomLayerParams.prototype.description = "";
    
                /**
                 * Creates a new CustomLayerParams instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {CoreML.Specification.ICustomLayerParams=} [properties] Properties to set
                 * @returns {CoreML.Specification.CustomLayerParams} CustomLayerParams instance
                 */
                CustomLayerParams.create = function create(properties) {
                    return new CustomLayerParams(properties);
                };
    
                /**
                 * Encodes the specified CustomLayerParams message. Does not implicitly {@link CoreML.Specification.CustomLayerParams.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {CoreML.Specification.ICustomLayerParams} message CustomLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomLayerParams.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.className != null && message.hasOwnProperty("className"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.className);
                    if (message.weights != null && message.weights.length)
                        for (var i = 0; i < message.weights.length; ++i)
                            $root.CoreML.Specification.WeightParams.encode(message.weights[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.parameters != null && message.hasOwnProperty("parameters"))
                        for (var keys = Object.keys(message.parameters), i = 0; i < keys.length; ++i) {
                            writer.uint32(/* id 30, wireType 2 =*/242).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                            $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.encode(message.parameters[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                        }
                    if (message.description != null && message.hasOwnProperty("description"))
                        writer.uint32(/* id 40, wireType 2 =*/322).string(message.description);
                    return writer;
                };
    
                /**
                 * Encodes the specified CustomLayerParams message, length delimited. Does not implicitly {@link CoreML.Specification.CustomLayerParams.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {CoreML.Specification.ICustomLayerParams} message CustomLayerParams message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CustomLayerParams.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a CustomLayerParams message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.CustomLayerParams} CustomLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomLayerParams.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CustomLayerParams(), key;
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.className = reader.string();
                            break;
                        case 20:
                            if (!(message.weights && message.weights.length))
                                message.weights = [];
                            message.weights.push($root.CoreML.Specification.WeightParams.decode(reader, reader.uint32()));
                            break;
                        case 30:
                            reader.skip().pos++;
                            if (message.parameters === $util.emptyObject)
                                message.parameters = {};
                            key = reader.string();
                            reader.pos++;
                            message.parameters[key] = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.decode(reader, reader.uint32());
                            break;
                        case 40:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a CustomLayerParams message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.CustomLayerParams} CustomLayerParams
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CustomLayerParams.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a CustomLayerParams message.
                 * @function verify
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CustomLayerParams.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.className != null && message.hasOwnProperty("className"))
                        if (!$util.isString(message.className))
                            return "className: string expected";
                    if (message.weights != null && message.hasOwnProperty("weights")) {
                        if (!Array.isArray(message.weights))
                            return "weights: array expected";
                        for (var i = 0; i < message.weights.length; ++i) {
                            var error = $root.CoreML.Specification.WeightParams.verify(message.weights[i]);
                            if (error)
                                return "weights." + error;
                        }
                    }
                    if (message.parameters != null && message.hasOwnProperty("parameters")) {
                        if (!$util.isObject(message.parameters))
                            return "parameters: object expected";
                        var key = Object.keys(message.parameters);
                        for (var i = 0; i < key.length; ++i) {
                            var error = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.verify(message.parameters[key[i]]);
                            if (error)
                                return "parameters." + error;
                        }
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };
    
                /**
                 * Creates a CustomLayerParams message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.CustomLayerParams} CustomLayerParams
                 */
                CustomLayerParams.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.CustomLayerParams)
                        return object;
                    var message = new $root.CoreML.Specification.CustomLayerParams();
                    if (object.className != null)
                        message.className = String(object.className);
                    if (object.weights) {
                        if (!Array.isArray(object.weights))
                            throw TypeError(".CoreML.Specification.CustomLayerParams.weights: array expected");
                        message.weights = [];
                        for (var i = 0; i < object.weights.length; ++i) {
                            if (typeof object.weights[i] !== "object")
                                throw TypeError(".CoreML.Specification.CustomLayerParams.weights: object expected");
                            message.weights[i] = $root.CoreML.Specification.WeightParams.fromObject(object.weights[i]);
                        }
                    }
                    if (object.parameters) {
                        if (typeof object.parameters !== "object")
                            throw TypeError(".CoreML.Specification.CustomLayerParams.parameters: object expected");
                        message.parameters = {};
                        for (var keys = Object.keys(object.parameters), i = 0; i < keys.length; ++i) {
                            if (typeof object.parameters[keys[i]] !== "object")
                                throw TypeError(".CoreML.Specification.CustomLayerParams.parameters: object expected");
                            message.parameters[keys[i]] = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.fromObject(object.parameters[keys[i]]);
                        }
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };
    
                /**
                 * Creates a plain object from a CustomLayerParams message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @static
                 * @param {CoreML.Specification.CustomLayerParams} message CustomLayerParams
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CustomLayerParams.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.weights = [];
                    if (options.objects || options.defaults)
                        object.parameters = {};
                    if (options.defaults) {
                        object.className = "";
                        object.description = "";
                    }
                    if (message.className != null && message.hasOwnProperty("className"))
                        object.className = message.className;
                    if (message.weights && message.weights.length) {
                        object.weights = [];
                        for (var j = 0; j < message.weights.length; ++j)
                            object.weights[j] = $root.CoreML.Specification.WeightParams.toObject(message.weights[j], options);
                    }
                    var keys2;
                    if (message.parameters && (keys2 = Object.keys(message.parameters)).length) {
                        object.parameters = {};
                        for (var j = 0; j < keys2.length; ++j)
                            object.parameters[keys2[j]] = $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue.toObject(message.parameters[keys2[j]], options);
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };
    
                /**
                 * Converts this CustomLayerParams to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.CustomLayerParams
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CustomLayerParams.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                CustomLayerParams.CustomLayerParamValue = (function() {
    
                    /**
                     * Properties of a CustomLayerParamValue.
                     * @memberof CoreML.Specification.CustomLayerParams
                     * @interface ICustomLayerParamValue
                     * @property {number|null} [doubleValue] CustomLayerParamValue doubleValue
                     * @property {string|null} [stringValue] CustomLayerParamValue stringValue
                     * @property {number|null} [intValue] CustomLayerParamValue intValue
                     * @property {number|Long|null} [longValue] CustomLayerParamValue longValue
                     * @property {boolean|null} [boolValue] CustomLayerParamValue boolValue
                     */
    
                    /**
                     * Constructs a new CustomLayerParamValue.
                     * @memberof CoreML.Specification.CustomLayerParams
                     * @classdesc Represents a CustomLayerParamValue.
                     * @implements ICustomLayerParamValue
                     * @constructor
                     * @param {CoreML.Specification.CustomLayerParams.ICustomLayerParamValue=} [properties] Properties to set
                     */
                    function CustomLayerParamValue(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * CustomLayerParamValue doubleValue.
                     * @member {number} doubleValue
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     */
                    CustomLayerParamValue.prototype.doubleValue = 0;
    
                    /**
                     * CustomLayerParamValue stringValue.
                     * @member {string} stringValue
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     */
                    CustomLayerParamValue.prototype.stringValue = "";
    
                    /**
                     * CustomLayerParamValue intValue.
                     * @member {number} intValue
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     */
                    CustomLayerParamValue.prototype.intValue = 0;
    
                    /**
                     * CustomLayerParamValue longValue.
                     * @member {number|Long} longValue
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     */
                    CustomLayerParamValue.prototype.longValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;
    
                    /**
                     * CustomLayerParamValue boolValue.
                     * @member {boolean} boolValue
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     */
                    CustomLayerParamValue.prototype.boolValue = false;
    
                    // OneOf field names bound to virtual getters and setters
                    var $oneOfFields;
    
                    /**
                     * CustomLayerParamValue value.
                     * @member {"doubleValue"|"stringValue"|"intValue"|"longValue"|"boolValue"|undefined} value
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     */
                    Object.defineProperty(CustomLayerParamValue.prototype, "value", {
                        get: $util.oneOfGetter($oneOfFields = ["doubleValue", "stringValue", "intValue", "longValue", "boolValue"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });
    
                    /**
                     * Creates a new CustomLayerParamValue instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {CoreML.Specification.CustomLayerParams.ICustomLayerParamValue=} [properties] Properties to set
                     * @returns {CoreML.Specification.CustomLayerParams.CustomLayerParamValue} CustomLayerParamValue instance
                     */
                    CustomLayerParamValue.create = function create(properties) {
                        return new CustomLayerParamValue(properties);
                    };
    
                    /**
                     * Encodes the specified CustomLayerParamValue message. Does not implicitly {@link CoreML.Specification.CustomLayerParams.CustomLayerParamValue.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {CoreML.Specification.CustomLayerParams.ICustomLayerParamValue} message CustomLayerParamValue message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CustomLayerParamValue.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                            writer.uint32(/* id 10, wireType 1 =*/81).double(message.doubleValue);
                        if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                            writer.uint32(/* id 20, wireType 2 =*/162).string(message.stringValue);
                        if (message.intValue != null && message.hasOwnProperty("intValue"))
                            writer.uint32(/* id 30, wireType 0 =*/240).int32(message.intValue);
                        if (message.longValue != null && message.hasOwnProperty("longValue"))
                            writer.uint32(/* id 40, wireType 0 =*/320).int64(message.longValue);
                        if (message.boolValue != null && message.hasOwnProperty("boolValue"))
                            writer.uint32(/* id 50, wireType 0 =*/400).bool(message.boolValue);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified CustomLayerParamValue message, length delimited. Does not implicitly {@link CoreML.Specification.CustomLayerParams.CustomLayerParamValue.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {CoreML.Specification.CustomLayerParams.ICustomLayerParamValue} message CustomLayerParamValue message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    CustomLayerParamValue.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a CustomLayerParamValue message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.CustomLayerParams.CustomLayerParamValue} CustomLayerParamValue
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CustomLayerParamValue.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 10:
                                message.doubleValue = reader.double();
                                break;
                            case 20:
                                message.stringValue = reader.string();
                                break;
                            case 30:
                                message.intValue = reader.int32();
                                break;
                            case 40:
                                message.longValue = reader.int64();
                                break;
                            case 50:
                                message.boolValue = reader.bool();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a CustomLayerParamValue message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.CustomLayerParams.CustomLayerParamValue} CustomLayerParamValue
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    CustomLayerParamValue.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a CustomLayerParamValue message.
                     * @function verify
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CustomLayerParamValue.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        var properties = {};
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                            properties.value = 1;
                            if (typeof message.doubleValue !== "number")
                                return "doubleValue: number expected";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isString(message.stringValue))
                                return "stringValue: string expected";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.intValue))
                                return "intValue: integer expected";
                        }
                        if (message.longValue != null && message.hasOwnProperty("longValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.longValue) && !(message.longValue && $util.isInteger(message.longValue.low) && $util.isInteger(message.longValue.high)))
                                return "longValue: integer|Long expected";
                        }
                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (typeof message.boolValue !== "boolean")
                                return "boolValue: boolean expected";
                        }
                        return null;
                    };
    
                    /**
                     * Creates a CustomLayerParamValue message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.CustomLayerParams.CustomLayerParamValue} CustomLayerParamValue
                     */
                    CustomLayerParamValue.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue)
                            return object;
                        var message = new $root.CoreML.Specification.CustomLayerParams.CustomLayerParamValue();
                        if (object.doubleValue != null)
                            message.doubleValue = Number(object.doubleValue);
                        if (object.stringValue != null)
                            message.stringValue = String(object.stringValue);
                        if (object.intValue != null)
                            message.intValue = object.intValue | 0;
                        if (object.longValue != null)
                            if ($util.Long)
                                (message.longValue = $util.Long.fromValue(object.longValue)).unsigned = false;
                            else if (typeof object.longValue === "string")
                                message.longValue = parseInt(object.longValue, 10);
                            else if (typeof object.longValue === "number")
                                message.longValue = object.longValue;
                            else if (typeof object.longValue === "object")
                                message.longValue = new $util.LongBits(object.longValue.low >>> 0, object.longValue.high >>> 0).toNumber();
                        if (object.boolValue != null)
                            message.boolValue = Boolean(object.boolValue);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a CustomLayerParamValue message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @static
                     * @param {CoreML.Specification.CustomLayerParams.CustomLayerParamValue} message CustomLayerParamValue
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CustomLayerParamValue.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                            object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                            if (options.oneofs)
                                object.value = "doubleValue";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            object.stringValue = message.stringValue;
                            if (options.oneofs)
                                object.value = "stringValue";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            object.intValue = message.intValue;
                            if (options.oneofs)
                                object.value = "intValue";
                        }
                        if (message.longValue != null && message.hasOwnProperty("longValue")) {
                            if (typeof message.longValue === "number")
                                object.longValue = options.longs === String ? String(message.longValue) : message.longValue;
                            else
                                object.longValue = options.longs === String ? $util.Long.prototype.toString.call(message.longValue) : options.longs === Number ? new $util.LongBits(message.longValue.low >>> 0, message.longValue.high >>> 0).toNumber() : message.longValue;
                            if (options.oneofs)
                                object.value = "longValue";
                        }
                        if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                            object.boolValue = message.boolValue;
                            if (options.oneofs)
                                object.value = "boolValue";
                        }
                        return object;
                    };
    
                    /**
                     * Converts this CustomLayerParamValue to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.CustomLayerParams.CustomLayerParamValue
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CustomLayerParamValue.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    return CustomLayerParamValue;
                })();
    
                return CustomLayerParams;
            })();
    
            Specification.NeuralNetworkClassifier = (function() {
    
                /**
                 * Properties of a NeuralNetworkClassifier.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetworkClassifier
                 * @property {Array.<CoreML.Specification.INeuralNetworkLayer>|null} [layers] NeuralNetworkClassifier layers
                 * @property {Array.<CoreML.Specification.INeuralNetworkPreprocessing>|null} [preprocessing] NeuralNetworkClassifier preprocessing
                 * @property {CoreML.Specification.IStringVector|null} [stringClassLabels] NeuralNetworkClassifier stringClassLabels
                 * @property {CoreML.Specification.IInt64Vector|null} [int64ClassLabels] NeuralNetworkClassifier int64ClassLabels
                 * @property {string|null} [labelProbabilityLayerName] The name of the output blob which will be used as the predicted
                 * probabilities of each class label.
                 */
    
                /**
                 * Constructs a new NeuralNetworkClassifier.
                 * @memberof CoreML.Specification
                 * @classdesc A neural network specialized as a classifier.
                 * @implements INeuralNetworkClassifier
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetworkClassifier=} [properties] Properties to set
                 */
                function NeuralNetworkClassifier(properties) {
                    this.layers = [];
                    this.preprocessing = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NeuralNetworkClassifier layers.
                 * @member {Array.<CoreML.Specification.INeuralNetworkLayer>} layers
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 */
                NeuralNetworkClassifier.prototype.layers = $util.emptyArray;
    
                /**
                 * NeuralNetworkClassifier preprocessing.
                 * @member {Array.<CoreML.Specification.INeuralNetworkPreprocessing>} preprocessing
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 */
                NeuralNetworkClassifier.prototype.preprocessing = $util.emptyArray;
    
                /**
                 * NeuralNetworkClassifier stringClassLabels.
                 * @member {CoreML.Specification.IStringVector|null|undefined} stringClassLabels
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 */
                NeuralNetworkClassifier.prototype.stringClassLabels = null;
    
                /**
                 * NeuralNetworkClassifier int64ClassLabels.
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} int64ClassLabels
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 */
                NeuralNetworkClassifier.prototype.int64ClassLabels = null;
    
                /**
                 * The name of the output blob which will be used as the predicted
                 * probabilities of each class label.
                 * @member {string} labelProbabilityLayerName
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 */
                NeuralNetworkClassifier.prototype.labelProbabilityLayerName = "";
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Mapping from indexed vector of probabilities to class label
                 * @member {"stringClassLabels"|"int64ClassLabels"|undefined} ClassLabels
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 */
                Object.defineProperty(NeuralNetworkClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new NeuralNetworkClassifier instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkClassifier=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetworkClassifier} NeuralNetworkClassifier instance
                 */
                NeuralNetworkClassifier.create = function create(properties) {
                    return new NeuralNetworkClassifier(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetworkClassifier message. Does not implicitly {@link CoreML.Specification.NeuralNetworkClassifier.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkClassifier} message NeuralNetworkClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkClassifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.layers != null && message.layers.length)
                        for (var i = 0; i < message.layers.length; ++i)
                            $root.CoreML.Specification.NeuralNetworkLayer.encode(message.layers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.preprocessing != null && message.preprocessing.length)
                        for (var i = 0; i < message.preprocessing.length; ++i)
                            $root.CoreML.Specification.NeuralNetworkPreprocessing.encode(message.preprocessing[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels"))
                        $root.CoreML.Specification.StringVector.encode(message.stringClassLabels, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels"))
                        $root.CoreML.Specification.Int64Vector.encode(message.int64ClassLabels, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                    if (message.labelProbabilityLayerName != null && message.hasOwnProperty("labelProbabilityLayerName"))
                        writer.uint32(/* id 200, wireType 2 =*/1602).string(message.labelProbabilityLayerName);
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetworkClassifier message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetworkClassifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkClassifier} message NeuralNetworkClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkClassifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetworkClassifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetworkClassifier} NeuralNetworkClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.layers && message.layers.length))
                                message.layers = [];
                            message.layers.push($root.CoreML.Specification.NeuralNetworkLayer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.preprocessing && message.preprocessing.length))
                                message.preprocessing = [];
                            message.preprocessing.push($root.CoreML.Specification.NeuralNetworkPreprocessing.decode(reader, reader.uint32()));
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 200:
                            message.labelProbabilityLayerName = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetworkClassifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetworkClassifier} NeuralNetworkClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkClassifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetworkClassifier message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetworkClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.layers != null && message.hasOwnProperty("layers")) {
                        if (!Array.isArray(message.layers))
                            return "layers: array expected";
                        for (var i = 0; i < message.layers.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkLayer.verify(message.layers[i]);
                            if (error)
                                return "layers." + error;
                        }
                    }
                    if (message.preprocessing != null && message.hasOwnProperty("preprocessing")) {
                        if (!Array.isArray(message.preprocessing))
                            return "preprocessing: array expected";
                        for (var i = 0; i < message.preprocessing.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkPreprocessing.verify(message.preprocessing[i]);
                            if (error)
                                return "preprocessing." + error;
                        }
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    if (message.labelProbabilityLayerName != null && message.hasOwnProperty("labelProbabilityLayerName"))
                        if (!$util.isString(message.labelProbabilityLayerName))
                            return "labelProbabilityLayerName: string expected";
                    return null;
                };
    
                /**
                 * Creates a NeuralNetworkClassifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetworkClassifier} NeuralNetworkClassifier
                 */
                NeuralNetworkClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkClassifier();
                    if (object.layers) {
                        if (!Array.isArray(object.layers))
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.layers: array expected");
                        message.layers = [];
                        for (var i = 0; i < object.layers.length; ++i) {
                            if (typeof object.layers[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.layers: object expected");
                            message.layers[i] = $root.CoreML.Specification.NeuralNetworkLayer.fromObject(object.layers[i]);
                        }
                    }
                    if (object.preprocessing) {
                        if (!Array.isArray(object.preprocessing))
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.preprocessing: array expected");
                        message.preprocessing = [];
                        for (var i = 0; i < object.preprocessing.length; ++i) {
                            if (typeof object.preprocessing[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.preprocessing: object expected");
                            message.preprocessing[i] = $root.CoreML.Specification.NeuralNetworkPreprocessing.fromObject(object.preprocessing[i]);
                        }
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.NeuralNetworkClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    if (object.labelProbabilityLayerName != null)
                        message.labelProbabilityLayerName = String(object.labelProbabilityLayerName);
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetworkClassifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @static
                 * @param {CoreML.Specification.NeuralNetworkClassifier} message NeuralNetworkClassifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetworkClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.layers = [];
                        object.preprocessing = [];
                    }
                    if (options.defaults)
                        object.labelProbabilityLayerName = "";
                    if (message.layers && message.layers.length) {
                        object.layers = [];
                        for (var j = 0; j < message.layers.length; ++j)
                            object.layers[j] = $root.CoreML.Specification.NeuralNetworkLayer.toObject(message.layers[j], options);
                    }
                    if (message.preprocessing && message.preprocessing.length) {
                        object.preprocessing = [];
                        for (var j = 0; j < message.preprocessing.length; ++j)
                            object.preprocessing[j] = $root.CoreML.Specification.NeuralNetworkPreprocessing.toObject(message.preprocessing[j], options);
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    if (message.labelProbabilityLayerName != null && message.hasOwnProperty("labelProbabilityLayerName"))
                        object.labelProbabilityLayerName = message.labelProbabilityLayerName;
                    return object;
                };
    
                /**
                 * Converts this NeuralNetworkClassifier to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetworkClassifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetworkClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkClassifier;
            })();
    
            Specification.NeuralNetworkRegressor = (function() {
    
                /**
                 * Properties of a NeuralNetworkRegressor.
                 * @memberof CoreML.Specification
                 * @interface INeuralNetworkRegressor
                 * @property {Array.<CoreML.Specification.INeuralNetworkLayer>|null} [layers] NeuralNetworkRegressor layers
                 * @property {Array.<CoreML.Specification.INeuralNetworkPreprocessing>|null} [preprocessing] NeuralNetworkRegressor preprocessing
                 */
    
                /**
                 * Constructs a new NeuralNetworkRegressor.
                 * @memberof CoreML.Specification
                 * @classdesc A neural network specialized as a regressor.
                 * @implements INeuralNetworkRegressor
                 * @constructor
                 * @param {CoreML.Specification.INeuralNetworkRegressor=} [properties] Properties to set
                 */
                function NeuralNetworkRegressor(properties) {
                    this.layers = [];
                    this.preprocessing = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * NeuralNetworkRegressor layers.
                 * @member {Array.<CoreML.Specification.INeuralNetworkLayer>} layers
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @instance
                 */
                NeuralNetworkRegressor.prototype.layers = $util.emptyArray;
    
                /**
                 * NeuralNetworkRegressor preprocessing.
                 * @member {Array.<CoreML.Specification.INeuralNetworkPreprocessing>} preprocessing
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @instance
                 */
                NeuralNetworkRegressor.prototype.preprocessing = $util.emptyArray;
    
                /**
                 * Creates a new NeuralNetworkRegressor instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkRegressor=} [properties] Properties to set
                 * @returns {CoreML.Specification.NeuralNetworkRegressor} NeuralNetworkRegressor instance
                 */
                NeuralNetworkRegressor.create = function create(properties) {
                    return new NeuralNetworkRegressor(properties);
                };
    
                /**
                 * Encodes the specified NeuralNetworkRegressor message. Does not implicitly {@link CoreML.Specification.NeuralNetworkRegressor.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkRegressor} message NeuralNetworkRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkRegressor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.layers != null && message.layers.length)
                        for (var i = 0; i < message.layers.length; ++i)
                            $root.CoreML.Specification.NeuralNetworkLayer.encode(message.layers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.preprocessing != null && message.preprocessing.length)
                        for (var i = 0; i < message.preprocessing.length; ++i)
                            $root.CoreML.Specification.NeuralNetworkPreprocessing.encode(message.preprocessing[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified NeuralNetworkRegressor message, length delimited. Does not implicitly {@link CoreML.Specification.NeuralNetworkRegressor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {CoreML.Specification.INeuralNetworkRegressor} message NeuralNetworkRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NeuralNetworkRegressor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a NeuralNetworkRegressor message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.NeuralNetworkRegressor} NeuralNetworkRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.NeuralNetworkRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.layers && message.layers.length))
                                message.layers = [];
                            message.layers.push($root.CoreML.Specification.NeuralNetworkLayer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            if (!(message.preprocessing && message.preprocessing.length))
                                message.preprocessing = [];
                            message.preprocessing.push($root.CoreML.Specification.NeuralNetworkPreprocessing.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a NeuralNetworkRegressor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.NeuralNetworkRegressor} NeuralNetworkRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NeuralNetworkRegressor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a NeuralNetworkRegressor message.
                 * @function verify
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NeuralNetworkRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.layers != null && message.hasOwnProperty("layers")) {
                        if (!Array.isArray(message.layers))
                            return "layers: array expected";
                        for (var i = 0; i < message.layers.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkLayer.verify(message.layers[i]);
                            if (error)
                                return "layers." + error;
                        }
                    }
                    if (message.preprocessing != null && message.hasOwnProperty("preprocessing")) {
                        if (!Array.isArray(message.preprocessing))
                            return "preprocessing: array expected";
                        for (var i = 0; i < message.preprocessing.length; ++i) {
                            var error = $root.CoreML.Specification.NeuralNetworkPreprocessing.verify(message.preprocessing[i]);
                            if (error)
                                return "preprocessing." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a NeuralNetworkRegressor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.NeuralNetworkRegressor} NeuralNetworkRegressor
                 */
                NeuralNetworkRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.NeuralNetworkRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.NeuralNetworkRegressor();
                    if (object.layers) {
                        if (!Array.isArray(object.layers))
                            throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.layers: array expected");
                        message.layers = [];
                        for (var i = 0; i < object.layers.length; ++i) {
                            if (typeof object.layers[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.layers: object expected");
                            message.layers[i] = $root.CoreML.Specification.NeuralNetworkLayer.fromObject(object.layers[i]);
                        }
                    }
                    if (object.preprocessing) {
                        if (!Array.isArray(object.preprocessing))
                            throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.preprocessing: array expected");
                        message.preprocessing = [];
                        for (var i = 0; i < object.preprocessing.length; ++i) {
                            if (typeof object.preprocessing[i] !== "object")
                                throw TypeError(".CoreML.Specification.NeuralNetworkRegressor.preprocessing: object expected");
                            message.preprocessing[i] = $root.CoreML.Specification.NeuralNetworkPreprocessing.fromObject(object.preprocessing[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a NeuralNetworkRegressor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @static
                 * @param {CoreML.Specification.NeuralNetworkRegressor} message NeuralNetworkRegressor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NeuralNetworkRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.layers = [];
                        object.preprocessing = [];
                    }
                    if (message.layers && message.layers.length) {
                        object.layers = [];
                        for (var j = 0; j < message.layers.length; ++j)
                            object.layers[j] = $root.CoreML.Specification.NeuralNetworkLayer.toObject(message.layers[j], options);
                    }
                    if (message.preprocessing && message.preprocessing.length) {
                        object.preprocessing = [];
                        for (var j = 0; j < message.preprocessing.length; ++j)
                            object.preprocessing[j] = $root.CoreML.Specification.NeuralNetworkPreprocessing.toObject(message.preprocessing[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this NeuralNetworkRegressor to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.NeuralNetworkRegressor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NeuralNetworkRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return NeuralNetworkRegressor;
            })();
    
            Specification.Normalizer = (function() {
    
                /**
                 * Properties of a Normalizer.
                 * @memberof CoreML.Specification
                 * @interface INormalizer
                 * @property {CoreML.Specification.Normalizer.NormType|null} [normType] Normalizer normType
                 */
    
                /**
                 * Constructs a new Normalizer.
                 * @memberof CoreML.Specification
                 * @classdesc A normalization preprocessor.
                 * @implements INormalizer
                 * @constructor
                 * @param {CoreML.Specification.INormalizer=} [properties] Properties to set
                 */
                function Normalizer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Normalizer normType.
                 * @member {CoreML.Specification.Normalizer.NormType} normType
                 * @memberof CoreML.Specification.Normalizer
                 * @instance
                 */
                Normalizer.prototype.normType = 0;
    
                /**
                 * Creates a new Normalizer instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {CoreML.Specification.INormalizer=} [properties] Properties to set
                 * @returns {CoreML.Specification.Normalizer} Normalizer instance
                 */
                Normalizer.create = function create(properties) {
                    return new Normalizer(properties);
                };
    
                /**
                 * Encodes the specified Normalizer message. Does not implicitly {@link CoreML.Specification.Normalizer.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {CoreML.Specification.INormalizer} message Normalizer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Normalizer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.normType != null && message.hasOwnProperty("normType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.normType);
                    return writer;
                };
    
                /**
                 * Encodes the specified Normalizer message, length delimited. Does not implicitly {@link CoreML.Specification.Normalizer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {CoreML.Specification.INormalizer} message Normalizer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Normalizer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Normalizer message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Normalizer} Normalizer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Normalizer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Normalizer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.normType = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Normalizer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Normalizer} Normalizer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Normalizer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Normalizer message.
                 * @function verify
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Normalizer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.normType != null && message.hasOwnProperty("normType"))
                        switch (message.normType) {
                        default:
                            return "normType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a Normalizer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Normalizer} Normalizer
                 */
                Normalizer.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Normalizer)
                        return object;
                    var message = new $root.CoreML.Specification.Normalizer();
                    switch (object.normType) {
                    case "LMax":
                    case 0:
                        message.normType = 0;
                        break;
                    case "L1":
                    case 1:
                        message.normType = 1;
                        break;
                    case "L2":
                    case 2:
                        message.normType = 2;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Normalizer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Normalizer
                 * @static
                 * @param {CoreML.Specification.Normalizer} message Normalizer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Normalizer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.normType = options.enums === String ? "LMax" : 0;
                    if (message.normType != null && message.hasOwnProperty("normType"))
                        object.normType = options.enums === String ? $root.CoreML.Specification.Normalizer.NormType[message.normType] : message.normType;
                    return object;
                };
    
                /**
                 * Converts this Normalizer to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Normalizer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Normalizer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * There are three normalization modes,
                 * which have the corresponding formulas:
                 * 
                 * Max
                 * .. math::
                 * max(x_i)
                 * 
                 * L1
                 * .. math::
                 * z = ||x||_1 = \sum_{i=1}^{n} |x_i|
                 * 
                 * L2
                 * .. math::
                 * z = ||x||_2 = \sqrt{\sum_{i=1}^{n} x_i^2}
                 * @name CoreML.Specification.Normalizer.NormType
                 * @enum {string}
                 * @property {number} LMax=0 LMax value
                 * @property {number} L1=1 L1 value
                 * @property {number} L2=2 L2 value
                 */
                Normalizer.NormType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "LMax"] = 0;
                    values[valuesById[1] = "L1"] = 1;
                    values[valuesById[2] = "L2"] = 2;
                    return values;
                })();
    
                return Normalizer;
            })();
    
            Specification.OneHotEncoder = (function() {
    
                /**
                 * Properties of an OneHotEncoder.
                 * @memberof CoreML.Specification
                 * @interface IOneHotEncoder
                 * @property {CoreML.Specification.IStringVector|null} [stringCategories] OneHotEncoder stringCategories
                 * @property {CoreML.Specification.IInt64Vector|null} [int64Categories] OneHotEncoder int64Categories
                 * @property {boolean|null} [outputSparse] OneHotEncoder outputSparse
                 * @property {CoreML.Specification.OneHotEncoder.HandleUnknown|null} [handleUnknown] OneHotEncoder handleUnknown
                 */
    
                /**
                 * Constructs a new OneHotEncoder.
                 * @memberof CoreML.Specification
                 * @classdesc Transforms a categorical feature into an array. The array will be all
                 * zeros expect a single entry of one.
                 * 
                 * Each categorical value will map to an index, this mapping is given by
                 * either the ``stringCategories`` parameter or the ``int64Categories``
                 * parameter.
                 * @implements IOneHotEncoder
                 * @constructor
                 * @param {CoreML.Specification.IOneHotEncoder=} [properties] Properties to set
                 */
                function OneHotEncoder(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * OneHotEncoder stringCategories.
                 * @member {CoreML.Specification.IStringVector|null|undefined} stringCategories
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @instance
                 */
                OneHotEncoder.prototype.stringCategories = null;
    
                /**
                 * OneHotEncoder int64Categories.
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} int64Categories
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @instance
                 */
                OneHotEncoder.prototype.int64Categories = null;
    
                /**
                 * OneHotEncoder outputSparse.
                 * @member {boolean} outputSparse
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @instance
                 */
                OneHotEncoder.prototype.outputSparse = false;
    
                /**
                 * OneHotEncoder handleUnknown.
                 * @member {CoreML.Specification.OneHotEncoder.HandleUnknown} handleUnknown
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @instance
                 */
                OneHotEncoder.prototype.handleUnknown = 0;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Mapping to be used for the encoding. The position of the category in
                 * the below vector determines where the single one entry will be in the
                 * output.
                 * @member {"stringCategories"|"int64Categories"|undefined} CategoryType
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @instance
                 */
                Object.defineProperty(OneHotEncoder.prototype, "CategoryType", {
                    get: $util.oneOfGetter($oneOfFields = ["stringCategories", "int64Categories"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new OneHotEncoder instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {CoreML.Specification.IOneHotEncoder=} [properties] Properties to set
                 * @returns {CoreML.Specification.OneHotEncoder} OneHotEncoder instance
                 */
                OneHotEncoder.create = function create(properties) {
                    return new OneHotEncoder(properties);
                };
    
                /**
                 * Encodes the specified OneHotEncoder message. Does not implicitly {@link CoreML.Specification.OneHotEncoder.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {CoreML.Specification.IOneHotEncoder} message OneHotEncoder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneHotEncoder.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.stringCategories != null && message.hasOwnProperty("stringCategories"))
                        $root.CoreML.Specification.StringVector.encode(message.stringCategories, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.int64Categories != null && message.hasOwnProperty("int64Categories"))
                        $root.CoreML.Specification.Int64Vector.encode(message.int64Categories, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.outputSparse != null && message.hasOwnProperty("outputSparse"))
                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.outputSparse);
                    if (message.handleUnknown != null && message.hasOwnProperty("handleUnknown"))
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.handleUnknown);
                    return writer;
                };
    
                /**
                 * Encodes the specified OneHotEncoder message, length delimited. Does not implicitly {@link CoreML.Specification.OneHotEncoder.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {CoreML.Specification.IOneHotEncoder} message OneHotEncoder message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                OneHotEncoder.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes an OneHotEncoder message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.OneHotEncoder} OneHotEncoder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneHotEncoder.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.OneHotEncoder();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.stringCategories = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.int64Categories = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        case 10:
                            message.outputSparse = reader.bool();
                            break;
                        case 11:
                            message.handleUnknown = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes an OneHotEncoder message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.OneHotEncoder} OneHotEncoder
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                OneHotEncoder.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies an OneHotEncoder message.
                 * @function verify
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OneHotEncoder.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.stringCategories != null && message.hasOwnProperty("stringCategories")) {
                        properties.CategoryType = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringCategories);
                            if (error)
                                return "stringCategories." + error;
                        }
                    }
                    if (message.int64Categories != null && message.hasOwnProperty("int64Categories")) {
                        if (properties.CategoryType === 1)
                            return "CategoryType: multiple values";
                        properties.CategoryType = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64Categories);
                            if (error)
                                return "int64Categories." + error;
                        }
                    }
                    if (message.outputSparse != null && message.hasOwnProperty("outputSparse"))
                        if (typeof message.outputSparse !== "boolean")
                            return "outputSparse: boolean expected";
                    if (message.handleUnknown != null && message.hasOwnProperty("handleUnknown"))
                        switch (message.handleUnknown) {
                        default:
                            return "handleUnknown: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates an OneHotEncoder message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.OneHotEncoder} OneHotEncoder
                 */
                OneHotEncoder.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.OneHotEncoder)
                        return object;
                    var message = new $root.CoreML.Specification.OneHotEncoder();
                    if (object.stringCategories != null) {
                        if (typeof object.stringCategories !== "object")
                            throw TypeError(".CoreML.Specification.OneHotEncoder.stringCategories: object expected");
                        message.stringCategories = $root.CoreML.Specification.StringVector.fromObject(object.stringCategories);
                    }
                    if (object.int64Categories != null) {
                        if (typeof object.int64Categories !== "object")
                            throw TypeError(".CoreML.Specification.OneHotEncoder.int64Categories: object expected");
                        message.int64Categories = $root.CoreML.Specification.Int64Vector.fromObject(object.int64Categories);
                    }
                    if (object.outputSparse != null)
                        message.outputSparse = Boolean(object.outputSparse);
                    switch (object.handleUnknown) {
                    case "ErrorOnUnknown":
                    case 0:
                        message.handleUnknown = 0;
                        break;
                    case "IgnoreUnknown":
                    case 1:
                        message.handleUnknown = 1;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from an OneHotEncoder message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @static
                 * @param {CoreML.Specification.OneHotEncoder} message OneHotEncoder
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OneHotEncoder.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.outputSparse = false;
                        object.handleUnknown = options.enums === String ? "ErrorOnUnknown" : 0;
                    }
                    if (message.stringCategories != null && message.hasOwnProperty("stringCategories")) {
                        object.stringCategories = $root.CoreML.Specification.StringVector.toObject(message.stringCategories, options);
                        if (options.oneofs)
                            object.CategoryType = "stringCategories";
                    }
                    if (message.int64Categories != null && message.hasOwnProperty("int64Categories")) {
                        object.int64Categories = $root.CoreML.Specification.Int64Vector.toObject(message.int64Categories, options);
                        if (options.oneofs)
                            object.CategoryType = "int64Categories";
                    }
                    if (message.outputSparse != null && message.hasOwnProperty("outputSparse"))
                        object.outputSparse = message.outputSparse;
                    if (message.handleUnknown != null && message.hasOwnProperty("handleUnknown"))
                        object.handleUnknown = options.enums === String ? $root.CoreML.Specification.OneHotEncoder.HandleUnknown[message.handleUnknown] : message.handleUnknown;
                    return object;
                };
    
                /**
                 * Converts this OneHotEncoder to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.OneHotEncoder
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OneHotEncoder.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                /**
                 * HandleUnknown enum.
                 * @name CoreML.Specification.OneHotEncoder.HandleUnknown
                 * @enum {string}
                 * @property {number} ErrorOnUnknown=0 ErrorOnUnknown value
                 * @property {number} IgnoreUnknown=1 IgnoreUnknown value
                 */
                OneHotEncoder.HandleUnknown = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ErrorOnUnknown"] = 0;
                    values[valuesById[1] = "IgnoreUnknown"] = 1;
                    return values;
                })();
    
                return OneHotEncoder;
            })();
    
            Specification.Scaler = (function() {
    
                /**
                 * Properties of a Scaler.
                 * @memberof CoreML.Specification
                 * @interface IScaler
                 * @property {Array.<number>|null} [shiftValue] Scaler shiftValue
                 * @property {Array.<number>|null} [scaleValue] Scaler scaleValue
                 */
    
                /**
                 * Constructs a new Scaler.
                 * @memberof CoreML.Specification
                 * @classdesc A scaling operation.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * f(x) = scaleValue \cdot (x + shiftValue)
                 * 
                 * If the ``scaleValue`` is not given, the default value 1 is used.
                 * If the ``shiftValue`` is not given, the default value 0 is used.
                 * 
                 * If ``scaleValue`` and ``shiftValue`` are each a single value
                 * and the input is an array, then the scale and shift are applied
                 * to each element of the array.
                 * 
                 * If the input is an integer, then it is converted to a double to
                 * perform the scaling operation. If the output type is an integer,
                 * then it is cast to an integer. If that cast is lossy, then an
                 * error is generated.
                 * @implements IScaler
                 * @constructor
                 * @param {CoreML.Specification.IScaler=} [properties] Properties to set
                 */
                function Scaler(properties) {
                    this.shiftValue = [];
                    this.scaleValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Scaler shiftValue.
                 * @member {Array.<number>} shiftValue
                 * @memberof CoreML.Specification.Scaler
                 * @instance
                 */
                Scaler.prototype.shiftValue = $util.emptyArray;
    
                /**
                 * Scaler scaleValue.
                 * @member {Array.<number>} scaleValue
                 * @memberof CoreML.Specification.Scaler
                 * @instance
                 */
                Scaler.prototype.scaleValue = $util.emptyArray;
    
                /**
                 * Creates a new Scaler instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {CoreML.Specification.IScaler=} [properties] Properties to set
                 * @returns {CoreML.Specification.Scaler} Scaler instance
                 */
                Scaler.create = function create(properties) {
                    return new Scaler(properties);
                };
    
                /**
                 * Encodes the specified Scaler message. Does not implicitly {@link CoreML.Specification.Scaler.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {CoreML.Specification.IScaler} message Scaler message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Scaler.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.shiftValue != null && message.shiftValue.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.shiftValue.length; ++i)
                            writer.double(message.shiftValue[i]);
                        writer.ldelim();
                    }
                    if (message.scaleValue != null && message.scaleValue.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.scaleValue.length; ++i)
                            writer.double(message.scaleValue[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified Scaler message, length delimited. Does not implicitly {@link CoreML.Specification.Scaler.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {CoreML.Specification.IScaler} message Scaler message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Scaler.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Scaler message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Scaler} Scaler
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Scaler.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Scaler();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.shiftValue && message.shiftValue.length))
                                message.shiftValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.shiftValue.push(reader.double());
                            } else
                                message.shiftValue.push(reader.double());
                            break;
                        case 2:
                            if (!(message.scaleValue && message.scaleValue.length))
                                message.scaleValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.scaleValue.push(reader.double());
                            } else
                                message.scaleValue.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Scaler message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Scaler} Scaler
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Scaler.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Scaler message.
                 * @function verify
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Scaler.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.shiftValue != null && message.hasOwnProperty("shiftValue")) {
                        if (!Array.isArray(message.shiftValue))
                            return "shiftValue: array expected";
                        for (var i = 0; i < message.shiftValue.length; ++i)
                            if (typeof message.shiftValue[i] !== "number")
                                return "shiftValue: number[] expected";
                    }
                    if (message.scaleValue != null && message.hasOwnProperty("scaleValue")) {
                        if (!Array.isArray(message.scaleValue))
                            return "scaleValue: array expected";
                        for (var i = 0; i < message.scaleValue.length; ++i)
                            if (typeof message.scaleValue[i] !== "number")
                                return "scaleValue: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a Scaler message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Scaler} Scaler
                 */
                Scaler.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Scaler)
                        return object;
                    var message = new $root.CoreML.Specification.Scaler();
                    if (object.shiftValue) {
                        if (!Array.isArray(object.shiftValue))
                            throw TypeError(".CoreML.Specification.Scaler.shiftValue: array expected");
                        message.shiftValue = [];
                        for (var i = 0; i < object.shiftValue.length; ++i)
                            message.shiftValue[i] = Number(object.shiftValue[i]);
                    }
                    if (object.scaleValue) {
                        if (!Array.isArray(object.scaleValue))
                            throw TypeError(".CoreML.Specification.Scaler.scaleValue: array expected");
                        message.scaleValue = [];
                        for (var i = 0; i < object.scaleValue.length; ++i)
                            message.scaleValue[i] = Number(object.scaleValue[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Scaler message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Scaler
                 * @static
                 * @param {CoreML.Specification.Scaler} message Scaler
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Scaler.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.shiftValue = [];
                        object.scaleValue = [];
                    }
                    if (message.shiftValue && message.shiftValue.length) {
                        object.shiftValue = [];
                        for (var j = 0; j < message.shiftValue.length; ++j)
                            object.shiftValue[j] = options.json && !isFinite(message.shiftValue[j]) ? String(message.shiftValue[j]) : message.shiftValue[j];
                    }
                    if (message.scaleValue && message.scaleValue.length) {
                        object.scaleValue = [];
                        for (var j = 0; j < message.scaleValue.length; ++j)
                            object.scaleValue[j] = options.json && !isFinite(message.scaleValue[j]) ? String(message.scaleValue[j]) : message.scaleValue[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this Scaler to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Scaler
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Scaler.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Scaler;
            })();
    
            Specification.LinearKernel = (function() {
    
                /**
                 * Properties of a LinearKernel.
                 * @memberof CoreML.Specification
                 * @interface ILinearKernel
                 */
    
                /**
                 * Constructs a new LinearKernel.
                 * @memberof CoreML.Specification
                 * @classdesc A linear kernel.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * K(\boldsymbol{x}, \boldsymbol{x'}) = \boldsymbol{x}^T \boldsymbol{x'}
                 * @implements ILinearKernel
                 * @constructor
                 * @param {CoreML.Specification.ILinearKernel=} [properties] Properties to set
                 */
                function LinearKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Creates a new LinearKernel instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {CoreML.Specification.ILinearKernel=} [properties] Properties to set
                 * @returns {CoreML.Specification.LinearKernel} LinearKernel instance
                 */
                LinearKernel.create = function create(properties) {
                    return new LinearKernel(properties);
                };
    
                /**
                 * Encodes the specified LinearKernel message. Does not implicitly {@link CoreML.Specification.LinearKernel.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {CoreML.Specification.ILinearKernel} message LinearKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LinearKernel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };
    
                /**
                 * Encodes the specified LinearKernel message, length delimited. Does not implicitly {@link CoreML.Specification.LinearKernel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {CoreML.Specification.ILinearKernel} message LinearKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                LinearKernel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a LinearKernel message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.LinearKernel} LinearKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LinearKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.LinearKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a LinearKernel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.LinearKernel} LinearKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                LinearKernel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a LinearKernel message.
                 * @function verify
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LinearKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };
    
                /**
                 * Creates a LinearKernel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.LinearKernel} LinearKernel
                 */
                LinearKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.LinearKernel)
                        return object;
                    return new $root.CoreML.Specification.LinearKernel();
                };
    
                /**
                 * Creates a plain object from a LinearKernel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.LinearKernel
                 * @static
                 * @param {CoreML.Specification.LinearKernel} message LinearKernel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LinearKernel.toObject = function toObject() {
                    return {};
                };
    
                /**
                 * Converts this LinearKernel to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.LinearKernel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LinearKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return LinearKernel;
            })();
    
            Specification.RBFKernel = (function() {
    
                /**
                 * Properties of a RBFKernel.
                 * @memberof CoreML.Specification
                 * @interface IRBFKernel
                 * @property {number|null} [gamma] RBFKernel gamma
                 */
    
                /**
                 * Constructs a new RBFKernel.
                 * @memberof CoreML.Specification
                 * @classdesc A Gaussian radial basis function (RBF) kernel.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * K(\boldsymbol{x}, \boldsymbol{x'}) = \
                 * \exp(-\gamma || \boldsymbol{x} - \boldsymbol{x'} ||^2 )
                 * @implements IRBFKernel
                 * @constructor
                 * @param {CoreML.Specification.IRBFKernel=} [properties] Properties to set
                 */
                function RBFKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * RBFKernel gamma.
                 * @member {number} gamma
                 * @memberof CoreML.Specification.RBFKernel
                 * @instance
                 */
                RBFKernel.prototype.gamma = 0;
    
                /**
                 * Creates a new RBFKernel instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {CoreML.Specification.IRBFKernel=} [properties] Properties to set
                 * @returns {CoreML.Specification.RBFKernel} RBFKernel instance
                 */
                RBFKernel.create = function create(properties) {
                    return new RBFKernel(properties);
                };
    
                /**
                 * Encodes the specified RBFKernel message. Does not implicitly {@link CoreML.Specification.RBFKernel.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {CoreML.Specification.IRBFKernel} message RBFKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RBFKernel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.gamma);
                    return writer;
                };
    
                /**
                 * Encodes the specified RBFKernel message, length delimited. Does not implicitly {@link CoreML.Specification.RBFKernel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {CoreML.Specification.IRBFKernel} message RBFKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                RBFKernel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a RBFKernel message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.RBFKernel} RBFKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RBFKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.RBFKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.gamma = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a RBFKernel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.RBFKernel} RBFKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                RBFKernel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a RBFKernel message.
                 * @function verify
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RBFKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        if (typeof message.gamma !== "number")
                            return "gamma: number expected";
                    return null;
                };
    
                /**
                 * Creates a RBFKernel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.RBFKernel} RBFKernel
                 */
                RBFKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.RBFKernel)
                        return object;
                    var message = new $root.CoreML.Specification.RBFKernel();
                    if (object.gamma != null)
                        message.gamma = Number(object.gamma);
                    return message;
                };
    
                /**
                 * Creates a plain object from a RBFKernel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.RBFKernel
                 * @static
                 * @param {CoreML.Specification.RBFKernel} message RBFKernel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RBFKernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.gamma = 0;
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
                    return object;
                };
    
                /**
                 * Converts this RBFKernel to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.RBFKernel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RBFKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return RBFKernel;
            })();
    
            Specification.PolyKernel = (function() {
    
                /**
                 * Properties of a PolyKernel.
                 * @memberof CoreML.Specification
                 * @interface IPolyKernel
                 * @property {number|null} [degree] PolyKernel degree
                 * @property {number|null} [c] PolyKernel c
                 * @property {number|null} [gamma] PolyKernel gamma
                 */
    
                /**
                 * Constructs a new PolyKernel.
                 * @memberof CoreML.Specification
                 * @classdesc A polynomial kernel.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * K(\boldsymbol{x}, \boldsymbol{x'}) = \
                 * (\gamma \boldsymbol{x}^T \boldsymbol{x'} + c)^{degree}
                 * @implements IPolyKernel
                 * @constructor
                 * @param {CoreML.Specification.IPolyKernel=} [properties] Properties to set
                 */
                function PolyKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * PolyKernel degree.
                 * @member {number} degree
                 * @memberof CoreML.Specification.PolyKernel
                 * @instance
                 */
                PolyKernel.prototype.degree = 0;
    
                /**
                 * PolyKernel c.
                 * @member {number} c
                 * @memberof CoreML.Specification.PolyKernel
                 * @instance
                 */
                PolyKernel.prototype.c = 0;
    
                /**
                 * PolyKernel gamma.
                 * @member {number} gamma
                 * @memberof CoreML.Specification.PolyKernel
                 * @instance
                 */
                PolyKernel.prototype.gamma = 0;
    
                /**
                 * Creates a new PolyKernel instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {CoreML.Specification.IPolyKernel=} [properties] Properties to set
                 * @returns {CoreML.Specification.PolyKernel} PolyKernel instance
                 */
                PolyKernel.create = function create(properties) {
                    return new PolyKernel(properties);
                };
    
                /**
                 * Encodes the specified PolyKernel message. Does not implicitly {@link CoreML.Specification.PolyKernel.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {CoreML.Specification.IPolyKernel} message PolyKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PolyKernel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.degree != null && message.hasOwnProperty("degree"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.degree);
                    if (message.c != null && message.hasOwnProperty("c"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.c);
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        writer.uint32(/* id 3, wireType 1 =*/25).double(message.gamma);
                    return writer;
                };
    
                /**
                 * Encodes the specified PolyKernel message, length delimited. Does not implicitly {@link CoreML.Specification.PolyKernel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {CoreML.Specification.IPolyKernel} message PolyKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PolyKernel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a PolyKernel message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.PolyKernel} PolyKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PolyKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.PolyKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.degree = reader.int32();
                            break;
                        case 2:
                            message.c = reader.double();
                            break;
                        case 3:
                            message.gamma = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a PolyKernel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.PolyKernel} PolyKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PolyKernel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a PolyKernel message.
                 * @function verify
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PolyKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.degree != null && message.hasOwnProperty("degree"))
                        if (!$util.isInteger(message.degree))
                            return "degree: integer expected";
                    if (message.c != null && message.hasOwnProperty("c"))
                        if (typeof message.c !== "number")
                            return "c: number expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        if (typeof message.gamma !== "number")
                            return "gamma: number expected";
                    return null;
                };
    
                /**
                 * Creates a PolyKernel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.PolyKernel} PolyKernel
                 */
                PolyKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.PolyKernel)
                        return object;
                    var message = new $root.CoreML.Specification.PolyKernel();
                    if (object.degree != null)
                        message.degree = object.degree | 0;
                    if (object.c != null)
                        message.c = Number(object.c);
                    if (object.gamma != null)
                        message.gamma = Number(object.gamma);
                    return message;
                };
    
                /**
                 * Creates a plain object from a PolyKernel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.PolyKernel
                 * @static
                 * @param {CoreML.Specification.PolyKernel} message PolyKernel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PolyKernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.degree = 0;
                        object.c = 0;
                        object.gamma = 0;
                    }
                    if (message.degree != null && message.hasOwnProperty("degree"))
                        object.degree = message.degree;
                    if (message.c != null && message.hasOwnProperty("c"))
                        object.c = options.json && !isFinite(message.c) ? String(message.c) : message.c;
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
                    return object;
                };
    
                /**
                 * Converts this PolyKernel to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.PolyKernel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PolyKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return PolyKernel;
            })();
    
            Specification.SigmoidKernel = (function() {
    
                /**
                 * Properties of a SigmoidKernel.
                 * @memberof CoreML.Specification
                 * @interface ISigmoidKernel
                 * @property {number|null} [gamma] SigmoidKernel gamma
                 * @property {number|null} [c] SigmoidKernel c
                 */
    
                /**
                 * Constructs a new SigmoidKernel.
                 * @memberof CoreML.Specification
                 * @classdesc A sigmoid kernel.
                 * 
                 * This function has the following formula:
                 * 
                 * .. math::
                 * K(\boldsymbol{x}, \boldsymbol{x'}) = \
                 * \tanh(\gamma \boldsymbol{x}^T \boldsymbol{x'} + c)
                 * @implements ISigmoidKernel
                 * @constructor
                 * @param {CoreML.Specification.ISigmoidKernel=} [properties] Properties to set
                 */
                function SigmoidKernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SigmoidKernel gamma.
                 * @member {number} gamma
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @instance
                 */
                SigmoidKernel.prototype.gamma = 0;
    
                /**
                 * SigmoidKernel c.
                 * @member {number} c
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @instance
                 */
                SigmoidKernel.prototype.c = 0;
    
                /**
                 * Creates a new SigmoidKernel instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {CoreML.Specification.ISigmoidKernel=} [properties] Properties to set
                 * @returns {CoreML.Specification.SigmoidKernel} SigmoidKernel instance
                 */
                SigmoidKernel.create = function create(properties) {
                    return new SigmoidKernel(properties);
                };
    
                /**
                 * Encodes the specified SigmoidKernel message. Does not implicitly {@link CoreML.Specification.SigmoidKernel.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {CoreML.Specification.ISigmoidKernel} message SigmoidKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SigmoidKernel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        writer.uint32(/* id 1, wireType 1 =*/9).double(message.gamma);
                    if (message.c != null && message.hasOwnProperty("c"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.c);
                    return writer;
                };
    
                /**
                 * Encodes the specified SigmoidKernel message, length delimited. Does not implicitly {@link CoreML.Specification.SigmoidKernel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {CoreML.Specification.ISigmoidKernel} message SigmoidKernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SigmoidKernel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SigmoidKernel message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SigmoidKernel} SigmoidKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SigmoidKernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SigmoidKernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.gamma = reader.double();
                            break;
                        case 2:
                            message.c = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SigmoidKernel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SigmoidKernel} SigmoidKernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SigmoidKernel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SigmoidKernel message.
                 * @function verify
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SigmoidKernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        if (typeof message.gamma !== "number")
                            return "gamma: number expected";
                    if (message.c != null && message.hasOwnProperty("c"))
                        if (typeof message.c !== "number")
                            return "c: number expected";
                    return null;
                };
    
                /**
                 * Creates a SigmoidKernel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SigmoidKernel} SigmoidKernel
                 */
                SigmoidKernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SigmoidKernel)
                        return object;
                    var message = new $root.CoreML.Specification.SigmoidKernel();
                    if (object.gamma != null)
                        message.gamma = Number(object.gamma);
                    if (object.c != null)
                        message.c = Number(object.c);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SigmoidKernel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @static
                 * @param {CoreML.Specification.SigmoidKernel} message SigmoidKernel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SigmoidKernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.gamma = 0;
                        object.c = 0;
                    }
                    if (message.gamma != null && message.hasOwnProperty("gamma"))
                        object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
                    if (message.c != null && message.hasOwnProperty("c"))
                        object.c = options.json && !isFinite(message.c) ? String(message.c) : message.c;
                    return object;
                };
    
                /**
                 * Converts this SigmoidKernel to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SigmoidKernel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SigmoidKernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SigmoidKernel;
            })();
    
            Specification.Kernel = (function() {
    
                /**
                 * Properties of a Kernel.
                 * @memberof CoreML.Specification
                 * @interface IKernel
                 * @property {CoreML.Specification.ILinearKernel|null} [linearKernel] Kernel linearKernel
                 * @property {CoreML.Specification.IRBFKernel|null} [rbfKernel] Kernel rbfKernel
                 * @property {CoreML.Specification.IPolyKernel|null} [polyKernel] Kernel polyKernel
                 * @property {CoreML.Specification.ISigmoidKernel|null} [sigmoidKernel] Kernel sigmoidKernel
                 */
    
                /**
                 * Constructs a new Kernel.
                 * @memberof CoreML.Specification
                 * @classdesc A kernel.
                 * @implements IKernel
                 * @constructor
                 * @param {CoreML.Specification.IKernel=} [properties] Properties to set
                 */
                function Kernel(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Kernel linearKernel.
                 * @member {CoreML.Specification.ILinearKernel|null|undefined} linearKernel
                 * @memberof CoreML.Specification.Kernel
                 * @instance
                 */
                Kernel.prototype.linearKernel = null;
    
                /**
                 * Kernel rbfKernel.
                 * @member {CoreML.Specification.IRBFKernel|null|undefined} rbfKernel
                 * @memberof CoreML.Specification.Kernel
                 * @instance
                 */
                Kernel.prototype.rbfKernel = null;
    
                /**
                 * Kernel polyKernel.
                 * @member {CoreML.Specification.IPolyKernel|null|undefined} polyKernel
                 * @memberof CoreML.Specification.Kernel
                 * @instance
                 */
                Kernel.prototype.polyKernel = null;
    
                /**
                 * Kernel sigmoidKernel.
                 * @member {CoreML.Specification.ISigmoidKernel|null|undefined} sigmoidKernel
                 * @memberof CoreML.Specification.Kernel
                 * @instance
                 */
                Kernel.prototype.sigmoidKernel = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * Kernel kernel.
                 * @member {"linearKernel"|"rbfKernel"|"polyKernel"|"sigmoidKernel"|undefined} kernel
                 * @memberof CoreML.Specification.Kernel
                 * @instance
                 */
                Object.defineProperty(Kernel.prototype, "kernel", {
                    get: $util.oneOfGetter($oneOfFields = ["linearKernel", "rbfKernel", "polyKernel", "sigmoidKernel"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new Kernel instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {CoreML.Specification.IKernel=} [properties] Properties to set
                 * @returns {CoreML.Specification.Kernel} Kernel instance
                 */
                Kernel.create = function create(properties) {
                    return new Kernel(properties);
                };
    
                /**
                 * Encodes the specified Kernel message. Does not implicitly {@link CoreML.Specification.Kernel.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {CoreML.Specification.IKernel} message Kernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Kernel.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.linearKernel != null && message.hasOwnProperty("linearKernel"))
                        $root.CoreML.Specification.LinearKernel.encode(message.linearKernel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.rbfKernel != null && message.hasOwnProperty("rbfKernel"))
                        $root.CoreML.Specification.RBFKernel.encode(message.rbfKernel, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.polyKernel != null && message.hasOwnProperty("polyKernel"))
                        $root.CoreML.Specification.PolyKernel.encode(message.polyKernel, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.sigmoidKernel != null && message.hasOwnProperty("sigmoidKernel"))
                        $root.CoreML.Specification.SigmoidKernel.encode(message.sigmoidKernel, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified Kernel message, length delimited. Does not implicitly {@link CoreML.Specification.Kernel.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {CoreML.Specification.IKernel} message Kernel message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Kernel.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Kernel message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Kernel} Kernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Kernel.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Kernel();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.linearKernel = $root.CoreML.Specification.LinearKernel.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.rbfKernel = $root.CoreML.Specification.RBFKernel.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.polyKernel = $root.CoreML.Specification.PolyKernel.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.sigmoidKernel = $root.CoreML.Specification.SigmoidKernel.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Kernel message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Kernel} Kernel
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Kernel.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Kernel message.
                 * @function verify
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Kernel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.linearKernel != null && message.hasOwnProperty("linearKernel")) {
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.LinearKernel.verify(message.linearKernel);
                            if (error)
                                return "linearKernel." + error;
                        }
                    }
                    if (message.rbfKernel != null && message.hasOwnProperty("rbfKernel")) {
                        if (properties.kernel === 1)
                            return "kernel: multiple values";
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.RBFKernel.verify(message.rbfKernel);
                            if (error)
                                return "rbfKernel." + error;
                        }
                    }
                    if (message.polyKernel != null && message.hasOwnProperty("polyKernel")) {
                        if (properties.kernel === 1)
                            return "kernel: multiple values";
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.PolyKernel.verify(message.polyKernel);
                            if (error)
                                return "polyKernel." + error;
                        }
                    }
                    if (message.sigmoidKernel != null && message.hasOwnProperty("sigmoidKernel")) {
                        if (properties.kernel === 1)
                            return "kernel: multiple values";
                        properties.kernel = 1;
                        {
                            var error = $root.CoreML.Specification.SigmoidKernel.verify(message.sigmoidKernel);
                            if (error)
                                return "sigmoidKernel." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a Kernel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Kernel} Kernel
                 */
                Kernel.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Kernel)
                        return object;
                    var message = new $root.CoreML.Specification.Kernel();
                    if (object.linearKernel != null) {
                        if (typeof object.linearKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.linearKernel: object expected");
                        message.linearKernel = $root.CoreML.Specification.LinearKernel.fromObject(object.linearKernel);
                    }
                    if (object.rbfKernel != null) {
                        if (typeof object.rbfKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.rbfKernel: object expected");
                        message.rbfKernel = $root.CoreML.Specification.RBFKernel.fromObject(object.rbfKernel);
                    }
                    if (object.polyKernel != null) {
                        if (typeof object.polyKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.polyKernel: object expected");
                        message.polyKernel = $root.CoreML.Specification.PolyKernel.fromObject(object.polyKernel);
                    }
                    if (object.sigmoidKernel != null) {
                        if (typeof object.sigmoidKernel !== "object")
                            throw TypeError(".CoreML.Specification.Kernel.sigmoidKernel: object expected");
                        message.sigmoidKernel = $root.CoreML.Specification.SigmoidKernel.fromObject(object.sigmoidKernel);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Kernel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Kernel
                 * @static
                 * @param {CoreML.Specification.Kernel} message Kernel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Kernel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.linearKernel != null && message.hasOwnProperty("linearKernel")) {
                        object.linearKernel = $root.CoreML.Specification.LinearKernel.toObject(message.linearKernel, options);
                        if (options.oneofs)
                            object.kernel = "linearKernel";
                    }
                    if (message.rbfKernel != null && message.hasOwnProperty("rbfKernel")) {
                        object.rbfKernel = $root.CoreML.Specification.RBFKernel.toObject(message.rbfKernel, options);
                        if (options.oneofs)
                            object.kernel = "rbfKernel";
                    }
                    if (message.polyKernel != null && message.hasOwnProperty("polyKernel")) {
                        object.polyKernel = $root.CoreML.Specification.PolyKernel.toObject(message.polyKernel, options);
                        if (options.oneofs)
                            object.kernel = "polyKernel";
                    }
                    if (message.sigmoidKernel != null && message.hasOwnProperty("sigmoidKernel")) {
                        object.sigmoidKernel = $root.CoreML.Specification.SigmoidKernel.toObject(message.sigmoidKernel, options);
                        if (options.oneofs)
                            object.kernel = "sigmoidKernel";
                    }
                    return object;
                };
    
                /**
                 * Converts this Kernel to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Kernel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Kernel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Kernel;
            })();
    
            Specification.SparseNode = (function() {
    
                /**
                 * Properties of a SparseNode.
                 * @memberof CoreML.Specification
                 * @interface ISparseNode
                 * @property {number|null} [index] SparseNode index
                 * @property {number|null} [value] SparseNode value
                 */
    
                /**
                 * Constructs a new SparseNode.
                 * @memberof CoreML.Specification
                 * @classdesc A sparse node.
                 * @implements ISparseNode
                 * @constructor
                 * @param {CoreML.Specification.ISparseNode=} [properties] Properties to set
                 */
                function SparseNode(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SparseNode index.
                 * @member {number} index
                 * @memberof CoreML.Specification.SparseNode
                 * @instance
                 */
                SparseNode.prototype.index = 0;
    
                /**
                 * SparseNode value.
                 * @member {number} value
                 * @memberof CoreML.Specification.SparseNode
                 * @instance
                 */
                SparseNode.prototype.value = 0;
    
                /**
                 * Creates a new SparseNode instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {CoreML.Specification.ISparseNode=} [properties] Properties to set
                 * @returns {CoreML.Specification.SparseNode} SparseNode instance
                 */
                SparseNode.create = function create(properties) {
                    return new SparseNode(properties);
                };
    
                /**
                 * Encodes the specified SparseNode message. Does not implicitly {@link CoreML.Specification.SparseNode.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {CoreML.Specification.ISparseNode} message SparseNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SparseNode.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.index != null && message.hasOwnProperty("index"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
                    if (message.value != null && message.hasOwnProperty("value"))
                        writer.uint32(/* id 2, wireType 1 =*/17).double(message.value);
                    return writer;
                };
    
                /**
                 * Encodes the specified SparseNode message, length delimited. Does not implicitly {@link CoreML.Specification.SparseNode.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {CoreML.Specification.ISparseNode} message SparseNode message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SparseNode.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SparseNode message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SparseNode} SparseNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SparseNode.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SparseNode();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.index = reader.int32();
                            break;
                        case 2:
                            message.value = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SparseNode message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SparseNode} SparseNode
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SparseNode.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SparseNode message.
                 * @function verify
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SparseNode.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.index != null && message.hasOwnProperty("index"))
                        if (!$util.isInteger(message.index))
                            return "index: integer expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    return null;
                };
    
                /**
                 * Creates a SparseNode message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SparseNode} SparseNode
                 */
                SparseNode.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SparseNode)
                        return object;
                    var message = new $root.CoreML.Specification.SparseNode();
                    if (object.index != null)
                        message.index = object.index | 0;
                    if (object.value != null)
                        message.value = Number(object.value);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SparseNode message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SparseNode
                 * @static
                 * @param {CoreML.Specification.SparseNode} message SparseNode
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SparseNode.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.index = 0;
                        object.value = 0;
                    }
                    if (message.index != null && message.hasOwnProperty("index"))
                        object.index = message.index;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    return object;
                };
    
                /**
                 * Converts this SparseNode to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SparseNode
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SparseNode.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SparseNode;
            })();
    
            Specification.SparseVector = (function() {
    
                /**
                 * Properties of a SparseVector.
                 * @memberof CoreML.Specification
                 * @interface ISparseVector
                 * @property {Array.<CoreML.Specification.ISparseNode>|null} [nodes] SparseVector nodes
                 */
    
                /**
                 * Constructs a new SparseVector.
                 * @memberof CoreML.Specification
                 * @classdesc A sparse vector.
                 * @implements ISparseVector
                 * @constructor
                 * @param {CoreML.Specification.ISparseVector=} [properties] Properties to set
                 */
                function SparseVector(properties) {
                    this.nodes = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SparseVector nodes.
                 * @member {Array.<CoreML.Specification.ISparseNode>} nodes
                 * @memberof CoreML.Specification.SparseVector
                 * @instance
                 */
                SparseVector.prototype.nodes = $util.emptyArray;
    
                /**
                 * Creates a new SparseVector instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {CoreML.Specification.ISparseVector=} [properties] Properties to set
                 * @returns {CoreML.Specification.SparseVector} SparseVector instance
                 */
                SparseVector.create = function create(properties) {
                    return new SparseVector(properties);
                };
    
                /**
                 * Encodes the specified SparseVector message. Does not implicitly {@link CoreML.Specification.SparseVector.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {CoreML.Specification.ISparseVector} message SparseVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SparseVector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodes != null && message.nodes.length)
                        for (var i = 0; i < message.nodes.length; ++i)
                            $root.CoreML.Specification.SparseNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SparseVector message, length delimited. Does not implicitly {@link CoreML.Specification.SparseVector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {CoreML.Specification.ISparseVector} message SparseVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SparseVector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SparseVector message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SparseVector} SparseVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SparseVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SparseVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.CoreML.Specification.SparseNode.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SparseVector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SparseVector} SparseVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SparseVector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SparseVector message.
                 * @function verify
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SparseVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (var i = 0; i < message.nodes.length; ++i) {
                            var error = $root.CoreML.Specification.SparseNode.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SparseVector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SparseVector} SparseVector
                 */
                SparseVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SparseVector)
                        return object;
                    var message = new $root.CoreML.Specification.SparseVector();
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".CoreML.Specification.SparseVector.nodes: array expected");
                        message.nodes = [];
                        for (var i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".CoreML.Specification.SparseVector.nodes: object expected");
                            message.nodes[i] = $root.CoreML.Specification.SparseNode.fromObject(object.nodes[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SparseVector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SparseVector
                 * @static
                 * @param {CoreML.Specification.SparseVector} message SparseVector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SparseVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.nodes = [];
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (var j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.CoreML.Specification.SparseNode.toObject(message.nodes[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SparseVector to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SparseVector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SparseVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SparseVector;
            })();
    
            Specification.SparseSupportVectors = (function() {
    
                /**
                 * Properties of a SparseSupportVectors.
                 * @memberof CoreML.Specification
                 * @interface ISparseSupportVectors
                 * @property {Array.<CoreML.Specification.ISparseVector>|null} [vectors] SparseSupportVectors vectors
                 */
    
                /**
                 * Constructs a new SparseSupportVectors.
                 * @memberof CoreML.Specification
                 * @classdesc One or more sparse support vectors.
                 * @implements ISparseSupportVectors
                 * @constructor
                 * @param {CoreML.Specification.ISparseSupportVectors=} [properties] Properties to set
                 */
                function SparseSupportVectors(properties) {
                    this.vectors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SparseSupportVectors vectors.
                 * @member {Array.<CoreML.Specification.ISparseVector>} vectors
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @instance
                 */
                SparseSupportVectors.prototype.vectors = $util.emptyArray;
    
                /**
                 * Creates a new SparseSupportVectors instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {CoreML.Specification.ISparseSupportVectors=} [properties] Properties to set
                 * @returns {CoreML.Specification.SparseSupportVectors} SparseSupportVectors instance
                 */
                SparseSupportVectors.create = function create(properties) {
                    return new SparseSupportVectors(properties);
                };
    
                /**
                 * Encodes the specified SparseSupportVectors message. Does not implicitly {@link CoreML.Specification.SparseSupportVectors.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {CoreML.Specification.ISparseSupportVectors} message SparseSupportVectors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SparseSupportVectors.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vectors != null && message.vectors.length)
                        for (var i = 0; i < message.vectors.length; ++i)
                            $root.CoreML.Specification.SparseVector.encode(message.vectors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SparseSupportVectors message, length delimited. Does not implicitly {@link CoreML.Specification.SparseSupportVectors.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {CoreML.Specification.ISparseSupportVectors} message SparseSupportVectors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SparseSupportVectors.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SparseSupportVectors message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SparseSupportVectors} SparseSupportVectors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SparseSupportVectors.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SparseSupportVectors();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vectors && message.vectors.length))
                                message.vectors = [];
                            message.vectors.push($root.CoreML.Specification.SparseVector.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SparseSupportVectors message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SparseSupportVectors} SparseSupportVectors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SparseSupportVectors.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SparseSupportVectors message.
                 * @function verify
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SparseSupportVectors.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vectors != null && message.hasOwnProperty("vectors")) {
                        if (!Array.isArray(message.vectors))
                            return "vectors: array expected";
                        for (var i = 0; i < message.vectors.length; ++i) {
                            var error = $root.CoreML.Specification.SparseVector.verify(message.vectors[i]);
                            if (error)
                                return "vectors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SparseSupportVectors message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SparseSupportVectors} SparseSupportVectors
                 */
                SparseSupportVectors.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SparseSupportVectors)
                        return object;
                    var message = new $root.CoreML.Specification.SparseSupportVectors();
                    if (object.vectors) {
                        if (!Array.isArray(object.vectors))
                            throw TypeError(".CoreML.Specification.SparseSupportVectors.vectors: array expected");
                        message.vectors = [];
                        for (var i = 0; i < object.vectors.length; ++i) {
                            if (typeof object.vectors[i] !== "object")
                                throw TypeError(".CoreML.Specification.SparseSupportVectors.vectors: object expected");
                            message.vectors[i] = $root.CoreML.Specification.SparseVector.fromObject(object.vectors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SparseSupportVectors message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @static
                 * @param {CoreML.Specification.SparseSupportVectors} message SparseSupportVectors
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SparseSupportVectors.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vectors = [];
                    if (message.vectors && message.vectors.length) {
                        object.vectors = [];
                        for (var j = 0; j < message.vectors.length; ++j)
                            object.vectors[j] = $root.CoreML.Specification.SparseVector.toObject(message.vectors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this SparseSupportVectors to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SparseSupportVectors
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SparseSupportVectors.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SparseSupportVectors;
            })();
    
            Specification.DenseVector = (function() {
    
                /**
                 * Properties of a DenseVector.
                 * @memberof CoreML.Specification
                 * @interface IDenseVector
                 * @property {Array.<number>|null} [values] DenseVector values
                 */
    
                /**
                 * Constructs a new DenseVector.
                 * @memberof CoreML.Specification
                 * @classdesc A dense vector.
                 * @implements IDenseVector
                 * @constructor
                 * @param {CoreML.Specification.IDenseVector=} [properties] Properties to set
                 */
                function DenseVector(properties) {
                    this.values = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DenseVector values.
                 * @member {Array.<number>} values
                 * @memberof CoreML.Specification.DenseVector
                 * @instance
                 */
                DenseVector.prototype.values = $util.emptyArray;
    
                /**
                 * Creates a new DenseVector instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {CoreML.Specification.IDenseVector=} [properties] Properties to set
                 * @returns {CoreML.Specification.DenseVector} DenseVector instance
                 */
                DenseVector.create = function create(properties) {
                    return new DenseVector(properties);
                };
    
                /**
                 * Encodes the specified DenseVector message. Does not implicitly {@link CoreML.Specification.DenseVector.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {CoreML.Specification.IDenseVector} message DenseVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DenseVector.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.values != null && message.values.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.values.length; ++i)
                            writer.double(message.values[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified DenseVector message, length delimited. Does not implicitly {@link CoreML.Specification.DenseVector.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {CoreML.Specification.IDenseVector} message DenseVector message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DenseVector.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DenseVector message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DenseVector} DenseVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DenseVector.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DenseVector();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.values && message.values.length))
                                message.values = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.values.push(reader.double());
                            } else
                                message.values.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DenseVector message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DenseVector} DenseVector
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DenseVector.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DenseVector message.
                 * @function verify
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DenseVector.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (var i = 0; i < message.values.length; ++i)
                            if (typeof message.values[i] !== "number")
                                return "values: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a DenseVector message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DenseVector} DenseVector
                 */
                DenseVector.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DenseVector)
                        return object;
                    var message = new $root.CoreML.Specification.DenseVector();
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".CoreML.Specification.DenseVector.values: array expected");
                        message.values = [];
                        for (var i = 0; i < object.values.length; ++i)
                            message.values[i] = Number(object.values[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DenseVector message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DenseVector
                 * @static
                 * @param {CoreML.Specification.DenseVector} message DenseVector
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DenseVector.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (var j = 0; j < message.values.length; ++j)
                            object.values[j] = options.json && !isFinite(message.values[j]) ? String(message.values[j]) : message.values[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this DenseVector to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DenseVector
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DenseVector.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DenseVector;
            })();
    
            Specification.DenseSupportVectors = (function() {
    
                /**
                 * Properties of a DenseSupportVectors.
                 * @memberof CoreML.Specification
                 * @interface IDenseSupportVectors
                 * @property {Array.<CoreML.Specification.IDenseVector>|null} [vectors] DenseSupportVectors vectors
                 */
    
                /**
                 * Constructs a new DenseSupportVectors.
                 * @memberof CoreML.Specification
                 * @classdesc One or more dense support vectors.
                 * @implements IDenseSupportVectors
                 * @constructor
                 * @param {CoreML.Specification.IDenseSupportVectors=} [properties] Properties to set
                 */
                function DenseSupportVectors(properties) {
                    this.vectors = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * DenseSupportVectors vectors.
                 * @member {Array.<CoreML.Specification.IDenseVector>} vectors
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @instance
                 */
                DenseSupportVectors.prototype.vectors = $util.emptyArray;
    
                /**
                 * Creates a new DenseSupportVectors instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {CoreML.Specification.IDenseSupportVectors=} [properties] Properties to set
                 * @returns {CoreML.Specification.DenseSupportVectors} DenseSupportVectors instance
                 */
                DenseSupportVectors.create = function create(properties) {
                    return new DenseSupportVectors(properties);
                };
    
                /**
                 * Encodes the specified DenseSupportVectors message. Does not implicitly {@link CoreML.Specification.DenseSupportVectors.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {CoreML.Specification.IDenseSupportVectors} message DenseSupportVectors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DenseSupportVectors.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.vectors != null && message.vectors.length)
                        for (var i = 0; i < message.vectors.length; ++i)
                            $root.CoreML.Specification.DenseVector.encode(message.vectors[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified DenseSupportVectors message, length delimited. Does not implicitly {@link CoreML.Specification.DenseSupportVectors.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {CoreML.Specification.IDenseSupportVectors} message DenseSupportVectors message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DenseSupportVectors.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a DenseSupportVectors message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.DenseSupportVectors} DenseSupportVectors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DenseSupportVectors.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.DenseSupportVectors();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.vectors && message.vectors.length))
                                message.vectors = [];
                            message.vectors.push($root.CoreML.Specification.DenseVector.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a DenseSupportVectors message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.DenseSupportVectors} DenseSupportVectors
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DenseSupportVectors.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a DenseSupportVectors message.
                 * @function verify
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DenseSupportVectors.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.vectors != null && message.hasOwnProperty("vectors")) {
                        if (!Array.isArray(message.vectors))
                            return "vectors: array expected";
                        for (var i = 0; i < message.vectors.length; ++i) {
                            var error = $root.CoreML.Specification.DenseVector.verify(message.vectors[i]);
                            if (error)
                                return "vectors." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a DenseSupportVectors message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.DenseSupportVectors} DenseSupportVectors
                 */
                DenseSupportVectors.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.DenseSupportVectors)
                        return object;
                    var message = new $root.CoreML.Specification.DenseSupportVectors();
                    if (object.vectors) {
                        if (!Array.isArray(object.vectors))
                            throw TypeError(".CoreML.Specification.DenseSupportVectors.vectors: array expected");
                        message.vectors = [];
                        for (var i = 0; i < object.vectors.length; ++i) {
                            if (typeof object.vectors[i] !== "object")
                                throw TypeError(".CoreML.Specification.DenseSupportVectors.vectors: object expected");
                            message.vectors[i] = $root.CoreML.Specification.DenseVector.fromObject(object.vectors[i]);
                        }
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a DenseSupportVectors message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @static
                 * @param {CoreML.Specification.DenseSupportVectors} message DenseSupportVectors
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DenseSupportVectors.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.vectors = [];
                    if (message.vectors && message.vectors.length) {
                        object.vectors = [];
                        for (var j = 0; j < message.vectors.length; ++j)
                            object.vectors[j] = $root.CoreML.Specification.DenseVector.toObject(message.vectors[j], options);
                    }
                    return object;
                };
    
                /**
                 * Converts this DenseSupportVectors to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.DenseSupportVectors
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DenseSupportVectors.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return DenseSupportVectors;
            })();
    
            Specification.Coefficients = (function() {
    
                /**
                 * Properties of a Coefficients.
                 * @memberof CoreML.Specification
                 * @interface ICoefficients
                 * @property {Array.<number>|null} [alpha] Coefficients alpha
                 */
    
                /**
                 * Constructs a new Coefficients.
                 * @memberof CoreML.Specification
                 * @classdesc One or more coefficients.
                 * @implements ICoefficients
                 * @constructor
                 * @param {CoreML.Specification.ICoefficients=} [properties] Properties to set
                 */
                function Coefficients(properties) {
                    this.alpha = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * Coefficients alpha.
                 * @member {Array.<number>} alpha
                 * @memberof CoreML.Specification.Coefficients
                 * @instance
                 */
                Coefficients.prototype.alpha = $util.emptyArray;
    
                /**
                 * Creates a new Coefficients instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {CoreML.Specification.ICoefficients=} [properties] Properties to set
                 * @returns {CoreML.Specification.Coefficients} Coefficients instance
                 */
                Coefficients.create = function create(properties) {
                    return new Coefficients(properties);
                };
    
                /**
                 * Encodes the specified Coefficients message. Does not implicitly {@link CoreML.Specification.Coefficients.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {CoreML.Specification.ICoefficients} message Coefficients message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Coefficients.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.alpha != null && message.alpha.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.alpha.length; ++i)
                            writer.double(message.alpha[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified Coefficients message, length delimited. Does not implicitly {@link CoreML.Specification.Coefficients.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {CoreML.Specification.ICoefficients} message Coefficients message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Coefficients.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a Coefficients message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.Coefficients} Coefficients
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Coefficients.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.Coefficients();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.alpha && message.alpha.length))
                                message.alpha = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.alpha.push(reader.double());
                            } else
                                message.alpha.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a Coefficients message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.Coefficients} Coefficients
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Coefficients.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a Coefficients message.
                 * @function verify
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Coefficients.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.alpha != null && message.hasOwnProperty("alpha")) {
                        if (!Array.isArray(message.alpha))
                            return "alpha: array expected";
                        for (var i = 0; i < message.alpha.length; ++i)
                            if (typeof message.alpha[i] !== "number")
                                return "alpha: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a Coefficients message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.Coefficients} Coefficients
                 */
                Coefficients.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.Coefficients)
                        return object;
                    var message = new $root.CoreML.Specification.Coefficients();
                    if (object.alpha) {
                        if (!Array.isArray(object.alpha))
                            throw TypeError(".CoreML.Specification.Coefficients.alpha: array expected");
                        message.alpha = [];
                        for (var i = 0; i < object.alpha.length; ++i)
                            message.alpha[i] = Number(object.alpha[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a Coefficients message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.Coefficients
                 * @static
                 * @param {CoreML.Specification.Coefficients} message Coefficients
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Coefficients.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.alpha = [];
                    if (message.alpha && message.alpha.length) {
                        object.alpha = [];
                        for (var j = 0; j < message.alpha.length; ++j)
                            object.alpha[j] = options.json && !isFinite(message.alpha[j]) ? String(message.alpha[j]) : message.alpha[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this Coefficients to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.Coefficients
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Coefficients.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return Coefficients;
            })();
    
            Specification.SupportVectorRegressor = (function() {
    
                /**
                 * Properties of a SupportVectorRegressor.
                 * @memberof CoreML.Specification
                 * @interface ISupportVectorRegressor
                 * @property {CoreML.Specification.IKernel|null} [kernel] SupportVectorRegressor kernel
                 * @property {CoreML.Specification.ISparseSupportVectors|null} [sparseSupportVectors] SupportVectorRegressor sparseSupportVectors
                 * @property {CoreML.Specification.IDenseSupportVectors|null} [denseSupportVectors] SupportVectorRegressor denseSupportVectors
                 * @property {CoreML.Specification.ICoefficients|null} [coefficients] SupportVectorRegressor coefficients
                 * @property {number|null} [rho] SupportVectorRegressor rho
                 */
    
                /**
                 * Constructs a new SupportVectorRegressor.
                 * @memberof CoreML.Specification
                 * @classdesc A support vector regressor.
                 * @implements ISupportVectorRegressor
                 * @constructor
                 * @param {CoreML.Specification.ISupportVectorRegressor=} [properties] Properties to set
                 */
                function SupportVectorRegressor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SupportVectorRegressor kernel.
                 * @member {CoreML.Specification.IKernel|null|undefined} kernel
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 */
                SupportVectorRegressor.prototype.kernel = null;
    
                /**
                 * SupportVectorRegressor sparseSupportVectors.
                 * @member {CoreML.Specification.ISparseSupportVectors|null|undefined} sparseSupportVectors
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 */
                SupportVectorRegressor.prototype.sparseSupportVectors = null;
    
                /**
                 * SupportVectorRegressor denseSupportVectors.
                 * @member {CoreML.Specification.IDenseSupportVectors|null|undefined} denseSupportVectors
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 */
                SupportVectorRegressor.prototype.denseSupportVectors = null;
    
                /**
                 * SupportVectorRegressor coefficients.
                 * @member {CoreML.Specification.ICoefficients|null|undefined} coefficients
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 */
                SupportVectorRegressor.prototype.coefficients = null;
    
                /**
                 * SupportVectorRegressor rho.
                 * @member {number} rho
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 */
                SupportVectorRegressor.prototype.rho = 0;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * SupportVectorRegressor supportVectors.
                 * @member {"sparseSupportVectors"|"denseSupportVectors"|undefined} supportVectors
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 */
                Object.defineProperty(SupportVectorRegressor.prototype, "supportVectors", {
                    get: $util.oneOfGetter($oneOfFields = ["sparseSupportVectors", "denseSupportVectors"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new SupportVectorRegressor instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {CoreML.Specification.ISupportVectorRegressor=} [properties] Properties to set
                 * @returns {CoreML.Specification.SupportVectorRegressor} SupportVectorRegressor instance
                 */
                SupportVectorRegressor.create = function create(properties) {
                    return new SupportVectorRegressor(properties);
                };
    
                /**
                 * Encodes the specified SupportVectorRegressor message. Does not implicitly {@link CoreML.Specification.SupportVectorRegressor.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {CoreML.Specification.ISupportVectorRegressor} message SupportVectorRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportVectorRegressor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kernel != null && message.hasOwnProperty("kernel"))
                        $root.CoreML.Specification.Kernel.encode(message.kernel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors"))
                        $root.CoreML.Specification.SparseSupportVectors.encode(message.sparseSupportVectors, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors"))
                        $root.CoreML.Specification.DenseSupportVectors.encode(message.denseSupportVectors, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.coefficients != null && message.hasOwnProperty("coefficients"))
                        $root.CoreML.Specification.Coefficients.encode(message.coefficients, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.rho != null && message.hasOwnProperty("rho"))
                        writer.uint32(/* id 5, wireType 1 =*/41).double(message.rho);
                    return writer;
                };
    
                /**
                 * Encodes the specified SupportVectorRegressor message, length delimited. Does not implicitly {@link CoreML.Specification.SupportVectorRegressor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {CoreML.Specification.ISupportVectorRegressor} message SupportVectorRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportVectorRegressor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SupportVectorRegressor message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SupportVectorRegressor} SupportVectorRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportVectorRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SupportVectorRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kernel = $root.CoreML.Specification.Kernel.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.coefficients = $root.CoreML.Specification.Coefficients.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.rho = reader.double();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SupportVectorRegressor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SupportVectorRegressor} SupportVectorRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportVectorRegressor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SupportVectorRegressor message.
                 * @function verify
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SupportVectorRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.kernel != null && message.hasOwnProperty("kernel")) {
                        var error = $root.CoreML.Specification.Kernel.verify(message.kernel);
                        if (error)
                            return "kernel." + error;
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.SparseSupportVectors.verify(message.sparseSupportVectors);
                            if (error)
                                return "sparseSupportVectors." + error;
                        }
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        if (properties.supportVectors === 1)
                            return "supportVectors: multiple values";
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.DenseSupportVectors.verify(message.denseSupportVectors);
                            if (error)
                                return "denseSupportVectors." + error;
                        }
                    }
                    if (message.coefficients != null && message.hasOwnProperty("coefficients")) {
                        var error = $root.CoreML.Specification.Coefficients.verify(message.coefficients);
                        if (error)
                            return "coefficients." + error;
                    }
                    if (message.rho != null && message.hasOwnProperty("rho"))
                        if (typeof message.rho !== "number")
                            return "rho: number expected";
                    return null;
                };
    
                /**
                 * Creates a SupportVectorRegressor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SupportVectorRegressor} SupportVectorRegressor
                 */
                SupportVectorRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SupportVectorRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.SupportVectorRegressor();
                    if (object.kernel != null) {
                        if (typeof object.kernel !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.kernel: object expected");
                        message.kernel = $root.CoreML.Specification.Kernel.fromObject(object.kernel);
                    }
                    if (object.sparseSupportVectors != null) {
                        if (typeof object.sparseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.sparseSupportVectors: object expected");
                        message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.fromObject(object.sparseSupportVectors);
                    }
                    if (object.denseSupportVectors != null) {
                        if (typeof object.denseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.denseSupportVectors: object expected");
                        message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.fromObject(object.denseSupportVectors);
                    }
                    if (object.coefficients != null) {
                        if (typeof object.coefficients !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorRegressor.coefficients: object expected");
                        message.coefficients = $root.CoreML.Specification.Coefficients.fromObject(object.coefficients);
                    }
                    if (object.rho != null)
                        message.rho = Number(object.rho);
                    return message;
                };
    
                /**
                 * Creates a plain object from a SupportVectorRegressor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @static
                 * @param {CoreML.Specification.SupportVectorRegressor} message SupportVectorRegressor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SupportVectorRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.kernel = null;
                        object.coefficients = null;
                        object.rho = 0;
                    }
                    if (message.kernel != null && message.hasOwnProperty("kernel"))
                        object.kernel = $root.CoreML.Specification.Kernel.toObject(message.kernel, options);
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        object.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.toObject(message.sparseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "sparseSupportVectors";
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        object.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.toObject(message.denseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "denseSupportVectors";
                    }
                    if (message.coefficients != null && message.hasOwnProperty("coefficients"))
                        object.coefficients = $root.CoreML.Specification.Coefficients.toObject(message.coefficients, options);
                    if (message.rho != null && message.hasOwnProperty("rho"))
                        object.rho = options.json && !isFinite(message.rho) ? String(message.rho) : message.rho;
                    return object;
                };
    
                /**
                 * Converts this SupportVectorRegressor to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SupportVectorRegressor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SupportVectorRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SupportVectorRegressor;
            })();
    
            Specification.SupportVectorClassifier = (function() {
    
                /**
                 * Properties of a SupportVectorClassifier.
                 * @memberof CoreML.Specification
                 * @interface ISupportVectorClassifier
                 * @property {CoreML.Specification.IKernel|null} [kernel] SupportVectorClassifier kernel
                 * @property {Array.<number>|null} [numberOfSupportVectorsPerClass] The number of support vectors for each class.
                 * @property {CoreML.Specification.ISparseSupportVectors|null} [sparseSupportVectors] SupportVectorClassifier sparseSupportVectors
                 * @property {CoreML.Specification.IDenseSupportVectors|null} [denseSupportVectors] SupportVectorClassifier denseSupportVectors
                 * @property {Array.<CoreML.Specification.ICoefficients>|null} [coefficients] The coefficients, essentially a two dimensional array of
                 * size: (numberOfClasses-1) by (total number of support vectors)
                 * @property {Array.<number>|null} [rho] Constants for decision function,
                 * with K*(K-1) / 2 elements,
                 * where K is the number of classes.
                 * @property {Array.<number>|null} [probA] Pairwise probability information for A vs B classifier.
                 * Total of K*(K-1)/2 elements where K is the number of classes.
                 * These fields are optional,
                 * and only required if you want probabilities or multi class predictions.
                 * @property {Array.<number>|null} [probB] SupportVectorClassifier probB
                 * @property {CoreML.Specification.IStringVector|null} [stringClassLabels] SupportVectorClassifier stringClassLabels
                 * @property {CoreML.Specification.IInt64Vector|null} [int64ClassLabels] SupportVectorClassifier int64ClassLabels
                 */
    
                /**
                 * Constructs a new SupportVectorClassifier.
                 * @memberof CoreML.Specification
                 * @classdesc A support vector classifier
                 * @implements ISupportVectorClassifier
                 * @constructor
                 * @param {CoreML.Specification.ISupportVectorClassifier=} [properties] Properties to set
                 */
                function SupportVectorClassifier(properties) {
                    this.numberOfSupportVectorsPerClass = [];
                    this.coefficients = [];
                    this.rho = [];
                    this.probA = [];
                    this.probB = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * SupportVectorClassifier kernel.
                 * @member {CoreML.Specification.IKernel|null|undefined} kernel
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.kernel = null;
    
                /**
                 * The number of support vectors for each class.
                 * @member {Array.<number>} numberOfSupportVectorsPerClass
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.numberOfSupportVectorsPerClass = $util.emptyArray;
    
                /**
                 * SupportVectorClassifier sparseSupportVectors.
                 * @member {CoreML.Specification.ISparseSupportVectors|null|undefined} sparseSupportVectors
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.sparseSupportVectors = null;
    
                /**
                 * SupportVectorClassifier denseSupportVectors.
                 * @member {CoreML.Specification.IDenseSupportVectors|null|undefined} denseSupportVectors
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.denseSupportVectors = null;
    
                /**
                 * The coefficients, essentially a two dimensional array of
                 * size: (numberOfClasses-1) by (total number of support vectors)
                 * @member {Array.<CoreML.Specification.ICoefficients>} coefficients
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.coefficients = $util.emptyArray;
    
                /**
                 * Constants for decision function,
                 * with K*(K-1) / 2 elements,
                 * where K is the number of classes.
                 * @member {Array.<number>} rho
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.rho = $util.emptyArray;
    
                /**
                 * Pairwise probability information for A vs B classifier.
                 * Total of K*(K-1)/2 elements where K is the number of classes.
                 * These fields are optional,
                 * and only required if you want probabilities or multi class predictions.
                 * @member {Array.<number>} probA
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.probA = $util.emptyArray;
    
                /**
                 * SupportVectorClassifier probB.
                 * @member {Array.<number>} probB
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.probB = $util.emptyArray;
    
                /**
                 * SupportVectorClassifier stringClassLabels.
                 * @member {CoreML.Specification.IStringVector|null|undefined} stringClassLabels
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.stringClassLabels = null;
    
                /**
                 * SupportVectorClassifier int64ClassLabels.
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} int64ClassLabels
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                SupportVectorClassifier.prototype.int64ClassLabels = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * The support vectors, in either sparse or dense format.
                 * @member {"sparseSupportVectors"|"denseSupportVectors"|undefined} supportVectors
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                Object.defineProperty(SupportVectorClassifier.prototype, "supportVectors", {
                    get: $util.oneOfGetter($oneOfFields = ["sparseSupportVectors", "denseSupportVectors"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Class label mapping.
                 * @member {"stringClassLabels"|"int64ClassLabels"|undefined} ClassLabels
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 */
                Object.defineProperty(SupportVectorClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new SupportVectorClassifier instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {CoreML.Specification.ISupportVectorClassifier=} [properties] Properties to set
                 * @returns {CoreML.Specification.SupportVectorClassifier} SupportVectorClassifier instance
                 */
                SupportVectorClassifier.create = function create(properties) {
                    return new SupportVectorClassifier(properties);
                };
    
                /**
                 * Encodes the specified SupportVectorClassifier message. Does not implicitly {@link CoreML.Specification.SupportVectorClassifier.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {CoreML.Specification.ISupportVectorClassifier} message SupportVectorClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportVectorClassifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.kernel != null && message.hasOwnProperty("kernel"))
                        $root.CoreML.Specification.Kernel.encode(message.kernel, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.numberOfSupportVectorsPerClass != null && message.numberOfSupportVectorsPerClass.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.numberOfSupportVectorsPerClass.length; ++i)
                            writer.int32(message.numberOfSupportVectorsPerClass[i]);
                        writer.ldelim();
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors"))
                        $root.CoreML.Specification.SparseSupportVectors.encode(message.sparseSupportVectors, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors"))
                        $root.CoreML.Specification.DenseSupportVectors.encode(message.denseSupportVectors, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.coefficients != null && message.coefficients.length)
                        for (var i = 0; i < message.coefficients.length; ++i)
                            $root.CoreML.Specification.Coefficients.encode(message.coefficients[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.rho != null && message.rho.length) {
                        writer.uint32(/* id 6, wireType 2 =*/50).fork();
                        for (var i = 0; i < message.rho.length; ++i)
                            writer.double(message.rho[i]);
                        writer.ldelim();
                    }
                    if (message.probA != null && message.probA.length) {
                        writer.uint32(/* id 7, wireType 2 =*/58).fork();
                        for (var i = 0; i < message.probA.length; ++i)
                            writer.double(message.probA[i]);
                        writer.ldelim();
                    }
                    if (message.probB != null && message.probB.length) {
                        writer.uint32(/* id 8, wireType 2 =*/66).fork();
                        for (var i = 0; i < message.probB.length; ++i)
                            writer.double(message.probB[i]);
                        writer.ldelim();
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels"))
                        $root.CoreML.Specification.StringVector.encode(message.stringClassLabels, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels"))
                        $root.CoreML.Specification.Int64Vector.encode(message.int64ClassLabels, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified SupportVectorClassifier message, length delimited. Does not implicitly {@link CoreML.Specification.SupportVectorClassifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {CoreML.Specification.ISupportVectorClassifier} message SupportVectorClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SupportVectorClassifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a SupportVectorClassifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.SupportVectorClassifier} SupportVectorClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportVectorClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.SupportVectorClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.kernel = $root.CoreML.Specification.Kernel.decode(reader, reader.uint32());
                            break;
                        case 2:
                            if (!(message.numberOfSupportVectorsPerClass && message.numberOfSupportVectorsPerClass.length))
                                message.numberOfSupportVectorsPerClass = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.numberOfSupportVectorsPerClass.push(reader.int32());
                            } else
                                message.numberOfSupportVectorsPerClass.push(reader.int32());
                            break;
                        case 3:
                            message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.decode(reader, reader.uint32());
                            break;
                        case 5:
                            if (!(message.coefficients && message.coefficients.length))
                                message.coefficients = [];
                            message.coefficients.push($root.CoreML.Specification.Coefficients.decode(reader, reader.uint32()));
                            break;
                        case 6:
                            if (!(message.rho && message.rho.length))
                                message.rho = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.rho.push(reader.double());
                            } else
                                message.rho.push(reader.double());
                            break;
                        case 7:
                            if (!(message.probA && message.probA.length))
                                message.probA = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.probA.push(reader.double());
                            } else
                                message.probA.push(reader.double());
                            break;
                        case 8:
                            if (!(message.probB && message.probB.length))
                                message.probB = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.probB.push(reader.double());
                            } else
                                message.probB.push(reader.double());
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a SupportVectorClassifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.SupportVectorClassifier} SupportVectorClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SupportVectorClassifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a SupportVectorClassifier message.
                 * @function verify
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SupportVectorClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.kernel != null && message.hasOwnProperty("kernel")) {
                        var error = $root.CoreML.Specification.Kernel.verify(message.kernel);
                        if (error)
                            return "kernel." + error;
                    }
                    if (message.numberOfSupportVectorsPerClass != null && message.hasOwnProperty("numberOfSupportVectorsPerClass")) {
                        if (!Array.isArray(message.numberOfSupportVectorsPerClass))
                            return "numberOfSupportVectorsPerClass: array expected";
                        for (var i = 0; i < message.numberOfSupportVectorsPerClass.length; ++i)
                            if (!$util.isInteger(message.numberOfSupportVectorsPerClass[i]))
                                return "numberOfSupportVectorsPerClass: integer[] expected";
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.SparseSupportVectors.verify(message.sparseSupportVectors);
                            if (error)
                                return "sparseSupportVectors." + error;
                        }
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        if (properties.supportVectors === 1)
                            return "supportVectors: multiple values";
                        properties.supportVectors = 1;
                        {
                            var error = $root.CoreML.Specification.DenseSupportVectors.verify(message.denseSupportVectors);
                            if (error)
                                return "denseSupportVectors." + error;
                        }
                    }
                    if (message.coefficients != null && message.hasOwnProperty("coefficients")) {
                        if (!Array.isArray(message.coefficients))
                            return "coefficients: array expected";
                        for (var i = 0; i < message.coefficients.length; ++i) {
                            var error = $root.CoreML.Specification.Coefficients.verify(message.coefficients[i]);
                            if (error)
                                return "coefficients." + error;
                        }
                    }
                    if (message.rho != null && message.hasOwnProperty("rho")) {
                        if (!Array.isArray(message.rho))
                            return "rho: array expected";
                        for (var i = 0; i < message.rho.length; ++i)
                            if (typeof message.rho[i] !== "number")
                                return "rho: number[] expected";
                    }
                    if (message.probA != null && message.hasOwnProperty("probA")) {
                        if (!Array.isArray(message.probA))
                            return "probA: array expected";
                        for (var i = 0; i < message.probA.length; ++i)
                            if (typeof message.probA[i] !== "number")
                                return "probA: number[] expected";
                    }
                    if (message.probB != null && message.hasOwnProperty("probB")) {
                        if (!Array.isArray(message.probB))
                            return "probB: array expected";
                        for (var i = 0; i < message.probB.length; ++i)
                            if (typeof message.probB[i] !== "number")
                                return "probB: number[] expected";
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a SupportVectorClassifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.SupportVectorClassifier} SupportVectorClassifier
                 */
                SupportVectorClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.SupportVectorClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.SupportVectorClassifier();
                    if (object.kernel != null) {
                        if (typeof object.kernel !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.kernel: object expected");
                        message.kernel = $root.CoreML.Specification.Kernel.fromObject(object.kernel);
                    }
                    if (object.numberOfSupportVectorsPerClass) {
                        if (!Array.isArray(object.numberOfSupportVectorsPerClass))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.numberOfSupportVectorsPerClass: array expected");
                        message.numberOfSupportVectorsPerClass = [];
                        for (var i = 0; i < object.numberOfSupportVectorsPerClass.length; ++i)
                            message.numberOfSupportVectorsPerClass[i] = object.numberOfSupportVectorsPerClass[i] | 0;
                    }
                    if (object.sparseSupportVectors != null) {
                        if (typeof object.sparseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.sparseSupportVectors: object expected");
                        message.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.fromObject(object.sparseSupportVectors);
                    }
                    if (object.denseSupportVectors != null) {
                        if (typeof object.denseSupportVectors !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.denseSupportVectors: object expected");
                        message.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.fromObject(object.denseSupportVectors);
                    }
                    if (object.coefficients) {
                        if (!Array.isArray(object.coefficients))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.coefficients: array expected");
                        message.coefficients = [];
                        for (var i = 0; i < object.coefficients.length; ++i) {
                            if (typeof object.coefficients[i] !== "object")
                                throw TypeError(".CoreML.Specification.SupportVectorClassifier.coefficients: object expected");
                            message.coefficients[i] = $root.CoreML.Specification.Coefficients.fromObject(object.coefficients[i]);
                        }
                    }
                    if (object.rho) {
                        if (!Array.isArray(object.rho))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.rho: array expected");
                        message.rho = [];
                        for (var i = 0; i < object.rho.length; ++i)
                            message.rho[i] = Number(object.rho[i]);
                    }
                    if (object.probA) {
                        if (!Array.isArray(object.probA))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.probA: array expected");
                        message.probA = [];
                        for (var i = 0; i < object.probA.length; ++i)
                            message.probA[i] = Number(object.probA[i]);
                    }
                    if (object.probB) {
                        if (!Array.isArray(object.probB))
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.probB: array expected");
                        message.probB = [];
                        for (var i = 0; i < object.probB.length; ++i)
                            message.probB[i] = Number(object.probB[i]);
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.SupportVectorClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a SupportVectorClassifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @static
                 * @param {CoreML.Specification.SupportVectorClassifier} message SupportVectorClassifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SupportVectorClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.numberOfSupportVectorsPerClass = [];
                        object.coefficients = [];
                        object.rho = [];
                        object.probA = [];
                        object.probB = [];
                    }
                    if (options.defaults)
                        object.kernel = null;
                    if (message.kernel != null && message.hasOwnProperty("kernel"))
                        object.kernel = $root.CoreML.Specification.Kernel.toObject(message.kernel, options);
                    if (message.numberOfSupportVectorsPerClass && message.numberOfSupportVectorsPerClass.length) {
                        object.numberOfSupportVectorsPerClass = [];
                        for (var j = 0; j < message.numberOfSupportVectorsPerClass.length; ++j)
                            object.numberOfSupportVectorsPerClass[j] = message.numberOfSupportVectorsPerClass[j];
                    }
                    if (message.sparseSupportVectors != null && message.hasOwnProperty("sparseSupportVectors")) {
                        object.sparseSupportVectors = $root.CoreML.Specification.SparseSupportVectors.toObject(message.sparseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "sparseSupportVectors";
                    }
                    if (message.denseSupportVectors != null && message.hasOwnProperty("denseSupportVectors")) {
                        object.denseSupportVectors = $root.CoreML.Specification.DenseSupportVectors.toObject(message.denseSupportVectors, options);
                        if (options.oneofs)
                            object.supportVectors = "denseSupportVectors";
                    }
                    if (message.coefficients && message.coefficients.length) {
                        object.coefficients = [];
                        for (var j = 0; j < message.coefficients.length; ++j)
                            object.coefficients[j] = $root.CoreML.Specification.Coefficients.toObject(message.coefficients[j], options);
                    }
                    if (message.rho && message.rho.length) {
                        object.rho = [];
                        for (var j = 0; j < message.rho.length; ++j)
                            object.rho[j] = options.json && !isFinite(message.rho[j]) ? String(message.rho[j]) : message.rho[j];
                    }
                    if (message.probA && message.probA.length) {
                        object.probA = [];
                        for (var j = 0; j < message.probA.length; ++j)
                            object.probA[j] = options.json && !isFinite(message.probA[j]) ? String(message.probA[j]) : message.probA[j];
                    }
                    if (message.probB && message.probB.length) {
                        object.probB = [];
                        for (var j = 0; j < message.probB.length; ++j)
                            object.probB[j] = options.json && !isFinite(message.probB[j]) ? String(message.probB[j]) : message.probB[j];
                    }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    return object;
                };
    
                /**
                 * Converts this SupportVectorClassifier to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.SupportVectorClassifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SupportVectorClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return SupportVectorClassifier;
            })();
    
            /**
             * A tree ensemble post-evaluation transform.
             * @name CoreML.Specification.TreeEnsemblePostEvaluationTransform
             * @enum {string}
             * @property {number} NoTransform=0 NoTransform value
             * @property {number} Classification_SoftMax=1 Classification_SoftMax value
             * @property {number} Regression_Logistic=2 Regression_Logistic value
             * @property {number} Classification_SoftMaxWithZeroClassReference=3 Classification_SoftMaxWithZeroClassReference value
             */
            Specification.TreeEnsemblePostEvaluationTransform = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "NoTransform"] = 0;
                values[valuesById[1] = "Classification_SoftMax"] = 1;
                values[valuesById[2] = "Regression_Logistic"] = 2;
                values[valuesById[3] = "Classification_SoftMaxWithZeroClassReference"] = 3;
                return values;
            })();
    
            Specification.TreeEnsembleParameters = (function() {
    
                /**
                 * Properties of a TreeEnsembleParameters.
                 * @memberof CoreML.Specification
                 * @interface ITreeEnsembleParameters
                 * @property {Array.<CoreML.Specification.TreeEnsembleParameters.ITreeNode>|null} [nodes] TreeEnsembleParameters nodes
                 * @property {number|Long|null} [numPredictionDimensions] The number of prediction dimensions or classes in the model.
                 * 
                 * All instances of ``evaluationIndex`` in a leaf node
                 * must be less than this value,
                 * and the number of values in the ``basePredictionValue`` field
                 * must be equal to this value.
                 * 
                 * For regression,
                 * this is the dimension of the prediction.
                 * For classification,
                 * this is the number of classes.
                 * @property {Array.<number>|null} [basePredictionValue] The base prediction value.
                 * 
                 * The number of values in this must match
                 * the default values of the tree model.
                 */
    
                /**
                 * Constructs a new TreeEnsembleParameters.
                 * @memberof CoreML.Specification
                 * @classdesc Tree ensemble parameters.
                 * @implements ITreeEnsembleParameters
                 * @constructor
                 * @param {CoreML.Specification.ITreeEnsembleParameters=} [properties] Properties to set
                 */
                function TreeEnsembleParameters(properties) {
                    this.nodes = [];
                    this.basePredictionValue = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TreeEnsembleParameters nodes.
                 * @member {Array.<CoreML.Specification.TreeEnsembleParameters.ITreeNode>} nodes
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @instance
                 */
                TreeEnsembleParameters.prototype.nodes = $util.emptyArray;
    
                /**
                 * The number of prediction dimensions or classes in the model.
                 * 
                 * All instances of ``evaluationIndex`` in a leaf node
                 * must be less than this value,
                 * and the number of values in the ``basePredictionValue`` field
                 * must be equal to this value.
                 * 
                 * For regression,
                 * this is the dimension of the prediction.
                 * For classification,
                 * this is the number of classes.
                 * @member {number|Long} numPredictionDimensions
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @instance
                 */
                TreeEnsembleParameters.prototype.numPredictionDimensions = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                /**
                 * The base prediction value.
                 * 
                 * The number of values in this must match
                 * the default values of the tree model.
                 * @member {Array.<number>} basePredictionValue
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @instance
                 */
                TreeEnsembleParameters.prototype.basePredictionValue = $util.emptyArray;
    
                /**
                 * Creates a new TreeEnsembleParameters instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleParameters=} [properties] Properties to set
                 * @returns {CoreML.Specification.TreeEnsembleParameters} TreeEnsembleParameters instance
                 */
                TreeEnsembleParameters.create = function create(properties) {
                    return new TreeEnsembleParameters(properties);
                };
    
                /**
                 * Encodes the specified TreeEnsembleParameters message. Does not implicitly {@link CoreML.Specification.TreeEnsembleParameters.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleParameters} message TreeEnsembleParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TreeEnsembleParameters.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nodes != null && message.nodes.length)
                        for (var i = 0; i < message.nodes.length; ++i)
                            $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.numPredictionDimensions != null && message.hasOwnProperty("numPredictionDimensions"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.numPredictionDimensions);
                    if (message.basePredictionValue != null && message.basePredictionValue.length) {
                        writer.uint32(/* id 3, wireType 2 =*/26).fork();
                        for (var i = 0; i < message.basePredictionValue.length; ++i)
                            writer.double(message.basePredictionValue[i]);
                        writer.ldelim();
                    }
                    return writer;
                };
    
                /**
                 * Encodes the specified TreeEnsembleParameters message, length delimited. Does not implicitly {@link CoreML.Specification.TreeEnsembleParameters.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleParameters} message TreeEnsembleParameters message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TreeEnsembleParameters.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a TreeEnsembleParameters message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.TreeEnsembleParameters} TreeEnsembleParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TreeEnsembleParameters.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleParameters();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.nodes && message.nodes.length))
                                message.nodes = [];
                            message.nodes.push($root.CoreML.Specification.TreeEnsembleParameters.TreeNode.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.numPredictionDimensions = reader.uint64();
                            break;
                        case 3:
                            if (!(message.basePredictionValue && message.basePredictionValue.length))
                                message.basePredictionValue = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.basePredictionValue.push(reader.double());
                            } else
                                message.basePredictionValue.push(reader.double());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a TreeEnsembleParameters message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.TreeEnsembleParameters} TreeEnsembleParameters
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TreeEnsembleParameters.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a TreeEnsembleParameters message.
                 * @function verify
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TreeEnsembleParameters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!Array.isArray(message.nodes))
                            return "nodes: array expected";
                        for (var i = 0; i < message.nodes.length; ++i) {
                            var error = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.verify(message.nodes[i]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    if (message.numPredictionDimensions != null && message.hasOwnProperty("numPredictionDimensions"))
                        if (!$util.isInteger(message.numPredictionDimensions) && !(message.numPredictionDimensions && $util.isInteger(message.numPredictionDimensions.low) && $util.isInteger(message.numPredictionDimensions.high)))
                            return "numPredictionDimensions: integer|Long expected";
                    if (message.basePredictionValue != null && message.hasOwnProperty("basePredictionValue")) {
                        if (!Array.isArray(message.basePredictionValue))
                            return "basePredictionValue: array expected";
                        for (var i = 0; i < message.basePredictionValue.length; ++i)
                            if (typeof message.basePredictionValue[i] !== "number")
                                return "basePredictionValue: number[] expected";
                    }
                    return null;
                };
    
                /**
                 * Creates a TreeEnsembleParameters message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.TreeEnsembleParameters} TreeEnsembleParameters
                 */
                TreeEnsembleParameters.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.TreeEnsembleParameters)
                        return object;
                    var message = new $root.CoreML.Specification.TreeEnsembleParameters();
                    if (object.nodes) {
                        if (!Array.isArray(object.nodes))
                            throw TypeError(".CoreML.Specification.TreeEnsembleParameters.nodes: array expected");
                        message.nodes = [];
                        for (var i = 0; i < object.nodes.length; ++i) {
                            if (typeof object.nodes[i] !== "object")
                                throw TypeError(".CoreML.Specification.TreeEnsembleParameters.nodes: object expected");
                            message.nodes[i] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.fromObject(object.nodes[i]);
                        }
                    }
                    if (object.numPredictionDimensions != null)
                        if ($util.Long)
                            (message.numPredictionDimensions = $util.Long.fromValue(object.numPredictionDimensions)).unsigned = true;
                        else if (typeof object.numPredictionDimensions === "string")
                            message.numPredictionDimensions = parseInt(object.numPredictionDimensions, 10);
                        else if (typeof object.numPredictionDimensions === "number")
                            message.numPredictionDimensions = object.numPredictionDimensions;
                        else if (typeof object.numPredictionDimensions === "object")
                            message.numPredictionDimensions = new $util.LongBits(object.numPredictionDimensions.low >>> 0, object.numPredictionDimensions.high >>> 0).toNumber(true);
                    if (object.basePredictionValue) {
                        if (!Array.isArray(object.basePredictionValue))
                            throw TypeError(".CoreML.Specification.TreeEnsembleParameters.basePredictionValue: array expected");
                        message.basePredictionValue = [];
                        for (var i = 0; i < object.basePredictionValue.length; ++i)
                            message.basePredictionValue[i] = Number(object.basePredictionValue[i]);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a TreeEnsembleParameters message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @static
                 * @param {CoreML.Specification.TreeEnsembleParameters} message TreeEnsembleParameters
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TreeEnsembleParameters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.nodes = [];
                        object.basePredictionValue = [];
                    }
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.numPredictionDimensions = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.numPredictionDimensions = options.longs === String ? "0" : 0;
                    if (message.nodes && message.nodes.length) {
                        object.nodes = [];
                        for (var j = 0; j < message.nodes.length; ++j)
                            object.nodes[j] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.toObject(message.nodes[j], options);
                    }
                    if (message.numPredictionDimensions != null && message.hasOwnProperty("numPredictionDimensions"))
                        if (typeof message.numPredictionDimensions === "number")
                            object.numPredictionDimensions = options.longs === String ? String(message.numPredictionDimensions) : message.numPredictionDimensions;
                        else
                            object.numPredictionDimensions = options.longs === String ? $util.Long.prototype.toString.call(message.numPredictionDimensions) : options.longs === Number ? new $util.LongBits(message.numPredictionDimensions.low >>> 0, message.numPredictionDimensions.high >>> 0).toNumber(true) : message.numPredictionDimensions;
                    if (message.basePredictionValue && message.basePredictionValue.length) {
                        object.basePredictionValue = [];
                        for (var j = 0; j < message.basePredictionValue.length; ++j)
                            object.basePredictionValue[j] = options.json && !isFinite(message.basePredictionValue[j]) ? String(message.basePredictionValue[j]) : message.basePredictionValue[j];
                    }
                    return object;
                };
    
                /**
                 * Converts this TreeEnsembleParameters to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.TreeEnsembleParameters
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TreeEnsembleParameters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                TreeEnsembleParameters.TreeNode = (function() {
    
                    /**
                     * Properties of a TreeNode.
                     * @memberof CoreML.Specification.TreeEnsembleParameters
                     * @interface ITreeNode
                     * @property {number|Long|null} [treeId] TreeNode treeId
                     * @property {number|Long|null} [nodeId] TreeNode nodeId
                     * @property {CoreML.Specification.TreeEnsembleParameters.TreeNode.TreeNodeBehavior|null} [nodeBehavior] The branch mode parameters.
                     * 
                     * If branch is false,
                     * then the parameters in this section must be filled in
                     * to determine how the branching functions.
                     * @property {number|Long|null} [branchFeatureIndex] If the node behavior mode is a branch mode,
                     * then these values must be filled in.
                     * @property {number|null} [branchFeatureValue] TreeNode branchFeatureValue
                     * @property {number|Long|null} [trueChildNodeId] TreeNode trueChildNodeId
                     * @property {number|Long|null} [falseChildNodeId] TreeNode falseChildNodeId
                     * @property {boolean|null} [missingValueTracksTrueChild] TreeNode missingValueTracksTrueChild
                     * @property {Array.<CoreML.Specification.TreeEnsembleParameters.TreeNode.IEvaluationInfo>|null} [evaluationInfo] TreeNode evaluationInfo
                     * @property {number|null} [relativeHitRate] The relative hit rate of a node for optimization purposes.
                     * 
                     * This value has no effect on the accuracy of the result;
                     * it allows the tree to optimize for frequent branches.
                     * The value is relative,
                     * compared to the hit rates of other branch nodes.
                     * 
                     * You typically use a proportion of training samples
                     * that reached this node
                     * or some similar metric to derive this value.
                     */
    
                    /**
                     * Constructs a new TreeNode.
                     * @memberof CoreML.Specification.TreeEnsembleParameters
                     * @classdesc Represents a TreeNode.
                     * @implements ITreeNode
                     * @constructor
                     * @param {CoreML.Specification.TreeEnsembleParameters.ITreeNode=} [properties] Properties to set
                     */
                    function TreeNode(properties) {
                        this.evaluationInfo = [];
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }
    
                    /**
                     * TreeNode treeId.
                     * @member {number|Long} treeId
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.treeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TreeNode nodeId.
                     * @member {number|Long} nodeId
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.nodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * The branch mode parameters.
                     * 
                     * If branch is false,
                     * then the parameters in this section must be filled in
                     * to determine how the branching functions.
                     * @member {CoreML.Specification.TreeEnsembleParameters.TreeNode.TreeNodeBehavior} nodeBehavior
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.nodeBehavior = 0;
    
                    /**
                     * If the node behavior mode is a branch mode,
                     * then these values must be filled in.
                     * @member {number|Long} branchFeatureIndex
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.branchFeatureIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TreeNode branchFeatureValue.
                     * @member {number} branchFeatureValue
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.branchFeatureValue = 0;
    
                    /**
                     * TreeNode trueChildNodeId.
                     * @member {number|Long} trueChildNodeId
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.trueChildNodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TreeNode falseChildNodeId.
                     * @member {number|Long} falseChildNodeId
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.falseChildNodeId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                    /**
                     * TreeNode missingValueTracksTrueChild.
                     * @member {boolean} missingValueTracksTrueChild
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.missingValueTracksTrueChild = false;
    
                    /**
                     * TreeNode evaluationInfo.
                     * @member {Array.<CoreML.Specification.TreeEnsembleParameters.TreeNode.IEvaluationInfo>} evaluationInfo
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.evaluationInfo = $util.emptyArray;
    
                    /**
                     * The relative hit rate of a node for optimization purposes.
                     * 
                     * This value has no effect on the accuracy of the result;
                     * it allows the tree to optimize for frequent branches.
                     * The value is relative,
                     * compared to the hit rates of other branch nodes.
                     * 
                     * You typically use a proportion of training samples
                     * that reached this node
                     * or some similar metric to derive this value.
                     * @member {number} relativeHitRate
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     */
                    TreeNode.prototype.relativeHitRate = 0;
    
                    /**
                     * Creates a new TreeNode instance using the specified properties.
                     * @function create
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {CoreML.Specification.TreeEnsembleParameters.ITreeNode=} [properties] Properties to set
                     * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode} TreeNode instance
                     */
                    TreeNode.create = function create(properties) {
                        return new TreeNode(properties);
                    };
    
                    /**
                     * Encodes the specified TreeNode message. Does not implicitly {@link CoreML.Specification.TreeEnsembleParameters.TreeNode.verify|verify} messages.
                     * @function encode
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {CoreML.Specification.TreeEnsembleParameters.ITreeNode} message TreeNode message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TreeNode.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.treeId != null && message.hasOwnProperty("treeId"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.treeId);
                        if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nodeId);
                        if (message.nodeBehavior != null && message.hasOwnProperty("nodeBehavior"))
                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.nodeBehavior);
                        if (message.branchFeatureIndex != null && message.hasOwnProperty("branchFeatureIndex"))
                            writer.uint32(/* id 10, wireType 0 =*/80).uint64(message.branchFeatureIndex);
                        if (message.branchFeatureValue != null && message.hasOwnProperty("branchFeatureValue"))
                            writer.uint32(/* id 11, wireType 1 =*/89).double(message.branchFeatureValue);
                        if (message.trueChildNodeId != null && message.hasOwnProperty("trueChildNodeId"))
                            writer.uint32(/* id 12, wireType 0 =*/96).uint64(message.trueChildNodeId);
                        if (message.falseChildNodeId != null && message.hasOwnProperty("falseChildNodeId"))
                            writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.falseChildNodeId);
                        if (message.missingValueTracksTrueChild != null && message.hasOwnProperty("missingValueTracksTrueChild"))
                            writer.uint32(/* id 14, wireType 0 =*/112).bool(message.missingValueTracksTrueChild);
                        if (message.evaluationInfo != null && message.evaluationInfo.length)
                            for (var i = 0; i < message.evaluationInfo.length; ++i)
                                $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.encode(message.evaluationInfo[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                        if (message.relativeHitRate != null && message.hasOwnProperty("relativeHitRate"))
                            writer.uint32(/* id 30, wireType 1 =*/241).double(message.relativeHitRate);
                        return writer;
                    };
    
                    /**
                     * Encodes the specified TreeNode message, length delimited. Does not implicitly {@link CoreML.Specification.TreeEnsembleParameters.TreeNode.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {CoreML.Specification.TreeEnsembleParameters.ITreeNode} message TreeNode message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    TreeNode.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };
    
                    /**
                     * Decodes a TreeNode message from the specified reader or buffer.
                     * @function decode
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode} TreeNode
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TreeNode.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.treeId = reader.uint64();
                                break;
                            case 2:
                                message.nodeId = reader.uint64();
                                break;
                            case 3:
                                message.nodeBehavior = reader.int32();
                                break;
                            case 10:
                                message.branchFeatureIndex = reader.uint64();
                                break;
                            case 11:
                                message.branchFeatureValue = reader.double();
                                break;
                            case 12:
                                message.trueChildNodeId = reader.uint64();
                                break;
                            case 13:
                                message.falseChildNodeId = reader.uint64();
                                break;
                            case 14:
                                message.missingValueTracksTrueChild = reader.bool();
                                break;
                            case 20:
                                if (!(message.evaluationInfo && message.evaluationInfo.length))
                                    message.evaluationInfo = [];
                                message.evaluationInfo.push($root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.decode(reader, reader.uint32()));
                                break;
                            case 30:
                                message.relativeHitRate = reader.double();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };
    
                    /**
                     * Decodes a TreeNode message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode} TreeNode
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    TreeNode.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };
    
                    /**
                     * Verifies a TreeNode message.
                     * @function verify
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TreeNode.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.treeId != null && message.hasOwnProperty("treeId"))
                            if (!$util.isInteger(message.treeId) && !(message.treeId && $util.isInteger(message.treeId.low) && $util.isInteger(message.treeId.high)))
                                return "treeId: integer|Long expected";
                        if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                            if (!$util.isInteger(message.nodeId) && !(message.nodeId && $util.isInteger(message.nodeId.low) && $util.isInteger(message.nodeId.high)))
                                return "nodeId: integer|Long expected";
                        if (message.nodeBehavior != null && message.hasOwnProperty("nodeBehavior"))
                            switch (message.nodeBehavior) {
                            default:
                                return "nodeBehavior: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.branchFeatureIndex != null && message.hasOwnProperty("branchFeatureIndex"))
                            if (!$util.isInteger(message.branchFeatureIndex) && !(message.branchFeatureIndex && $util.isInteger(message.branchFeatureIndex.low) && $util.isInteger(message.branchFeatureIndex.high)))
                                return "branchFeatureIndex: integer|Long expected";
                        if (message.branchFeatureValue != null && message.hasOwnProperty("branchFeatureValue"))
                            if (typeof message.branchFeatureValue !== "number")
                                return "branchFeatureValue: number expected";
                        if (message.trueChildNodeId != null && message.hasOwnProperty("trueChildNodeId"))
                            if (!$util.isInteger(message.trueChildNodeId) && !(message.trueChildNodeId && $util.isInteger(message.trueChildNodeId.low) && $util.isInteger(message.trueChildNodeId.high)))
                                return "trueChildNodeId: integer|Long expected";
                        if (message.falseChildNodeId != null && message.hasOwnProperty("falseChildNodeId"))
                            if (!$util.isInteger(message.falseChildNodeId) && !(message.falseChildNodeId && $util.isInteger(message.falseChildNodeId.low) && $util.isInteger(message.falseChildNodeId.high)))
                                return "falseChildNodeId: integer|Long expected";
                        if (message.missingValueTracksTrueChild != null && message.hasOwnProperty("missingValueTracksTrueChild"))
                            if (typeof message.missingValueTracksTrueChild !== "boolean")
                                return "missingValueTracksTrueChild: boolean expected";
                        if (message.evaluationInfo != null && message.hasOwnProperty("evaluationInfo")) {
                            if (!Array.isArray(message.evaluationInfo))
                                return "evaluationInfo: array expected";
                            for (var i = 0; i < message.evaluationInfo.length; ++i) {
                                var error = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.verify(message.evaluationInfo[i]);
                                if (error)
                                    return "evaluationInfo." + error;
                            }
                        }
                        if (message.relativeHitRate != null && message.hasOwnProperty("relativeHitRate"))
                            if (typeof message.relativeHitRate !== "number")
                                return "relativeHitRate: number expected";
                        return null;
                    };
    
                    /**
                     * Creates a TreeNode message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode} TreeNode
                     */
                    TreeNode.fromObject = function fromObject(object) {
                        if (object instanceof $root.CoreML.Specification.TreeEnsembleParameters.TreeNode)
                            return object;
                        var message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode();
                        if (object.treeId != null)
                            if ($util.Long)
                                (message.treeId = $util.Long.fromValue(object.treeId)).unsigned = true;
                            else if (typeof object.treeId === "string")
                                message.treeId = parseInt(object.treeId, 10);
                            else if (typeof object.treeId === "number")
                                message.treeId = object.treeId;
                            else if (typeof object.treeId === "object")
                                message.treeId = new $util.LongBits(object.treeId.low >>> 0, object.treeId.high >>> 0).toNumber(true);
                        if (object.nodeId != null)
                            if ($util.Long)
                                (message.nodeId = $util.Long.fromValue(object.nodeId)).unsigned = true;
                            else if (typeof object.nodeId === "string")
                                message.nodeId = parseInt(object.nodeId, 10);
                            else if (typeof object.nodeId === "number")
                                message.nodeId = object.nodeId;
                            else if (typeof object.nodeId === "object")
                                message.nodeId = new $util.LongBits(object.nodeId.low >>> 0, object.nodeId.high >>> 0).toNumber(true);
                        switch (object.nodeBehavior) {
                        case "BranchOnValueLessThanEqual":
                        case 0:
                            message.nodeBehavior = 0;
                            break;
                        case "BranchOnValueLessThan":
                        case 1:
                            message.nodeBehavior = 1;
                            break;
                        case "BranchOnValueGreaterThanEqual":
                        case 2:
                            message.nodeBehavior = 2;
                            break;
                        case "BranchOnValueGreaterThan":
                        case 3:
                            message.nodeBehavior = 3;
                            break;
                        case "BranchOnValueEqual":
                        case 4:
                            message.nodeBehavior = 4;
                            break;
                        case "BranchOnValueNotEqual":
                        case 5:
                            message.nodeBehavior = 5;
                            break;
                        case "LeafNode":
                        case 6:
                            message.nodeBehavior = 6;
                            break;
                        }
                        if (object.branchFeatureIndex != null)
                            if ($util.Long)
                                (message.branchFeatureIndex = $util.Long.fromValue(object.branchFeatureIndex)).unsigned = true;
                            else if (typeof object.branchFeatureIndex === "string")
                                message.branchFeatureIndex = parseInt(object.branchFeatureIndex, 10);
                            else if (typeof object.branchFeatureIndex === "number")
                                message.branchFeatureIndex = object.branchFeatureIndex;
                            else if (typeof object.branchFeatureIndex === "object")
                                message.branchFeatureIndex = new $util.LongBits(object.branchFeatureIndex.low >>> 0, object.branchFeatureIndex.high >>> 0).toNumber(true);
                        if (object.branchFeatureValue != null)
                            message.branchFeatureValue = Number(object.branchFeatureValue);
                        if (object.trueChildNodeId != null)
                            if ($util.Long)
                                (message.trueChildNodeId = $util.Long.fromValue(object.trueChildNodeId)).unsigned = true;
                            else if (typeof object.trueChildNodeId === "string")
                                message.trueChildNodeId = parseInt(object.trueChildNodeId, 10);
                            else if (typeof object.trueChildNodeId === "number")
                                message.trueChildNodeId = object.trueChildNodeId;
                            else if (typeof object.trueChildNodeId === "object")
                                message.trueChildNodeId = new $util.LongBits(object.trueChildNodeId.low >>> 0, object.trueChildNodeId.high >>> 0).toNumber(true);
                        if (object.falseChildNodeId != null)
                            if ($util.Long)
                                (message.falseChildNodeId = $util.Long.fromValue(object.falseChildNodeId)).unsigned = true;
                            else if (typeof object.falseChildNodeId === "string")
                                message.falseChildNodeId = parseInt(object.falseChildNodeId, 10);
                            else if (typeof object.falseChildNodeId === "number")
                                message.falseChildNodeId = object.falseChildNodeId;
                            else if (typeof object.falseChildNodeId === "object")
                                message.falseChildNodeId = new $util.LongBits(object.falseChildNodeId.low >>> 0, object.falseChildNodeId.high >>> 0).toNumber(true);
                        if (object.missingValueTracksTrueChild != null)
                            message.missingValueTracksTrueChild = Boolean(object.missingValueTracksTrueChild);
                        if (object.evaluationInfo) {
                            if (!Array.isArray(object.evaluationInfo))
                                throw TypeError(".CoreML.Specification.TreeEnsembleParameters.TreeNode.evaluationInfo: array expected");
                            message.evaluationInfo = [];
                            for (var i = 0; i < object.evaluationInfo.length; ++i) {
                                if (typeof object.evaluationInfo[i] !== "object")
                                    throw TypeError(".CoreML.Specification.TreeEnsembleParameters.TreeNode.evaluationInfo: object expected");
                                message.evaluationInfo[i] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.fromObject(object.evaluationInfo[i]);
                            }
                        }
                        if (object.relativeHitRate != null)
                            message.relativeHitRate = Number(object.relativeHitRate);
                        return message;
                    };
    
                    /**
                     * Creates a plain object from a TreeNode message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @static
                     * @param {CoreML.Specification.TreeEnsembleParameters.TreeNode} message TreeNode
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TreeNode.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.arrays || options.defaults)
                            object.evaluationInfo = [];
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.treeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.treeId = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nodeId = options.longs === String ? "0" : 0;
                            object.nodeBehavior = options.enums === String ? "BranchOnValueLessThanEqual" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.branchFeatureIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.branchFeatureIndex = options.longs === String ? "0" : 0;
                            object.branchFeatureValue = 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.trueChildNodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.trueChildNodeId = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.falseChildNodeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.falseChildNodeId = options.longs === String ? "0" : 0;
                            object.missingValueTracksTrueChild = false;
                            object.relativeHitRate = 0;
                        }
                        if (message.treeId != null && message.hasOwnProperty("treeId"))
                            if (typeof message.treeId === "number")
                                object.treeId = options.longs === String ? String(message.treeId) : message.treeId;
                            else
                                object.treeId = options.longs === String ? $util.Long.prototype.toString.call(message.treeId) : options.longs === Number ? new $util.LongBits(message.treeId.low >>> 0, message.treeId.high >>> 0).toNumber(true) : message.treeId;
                        if (message.nodeId != null && message.hasOwnProperty("nodeId"))
                            if (typeof message.nodeId === "number")
                                object.nodeId = options.longs === String ? String(message.nodeId) : message.nodeId;
                            else
                                object.nodeId = options.longs === String ? $util.Long.prototype.toString.call(message.nodeId) : options.longs === Number ? new $util.LongBits(message.nodeId.low >>> 0, message.nodeId.high >>> 0).toNumber(true) : message.nodeId;
                        if (message.nodeBehavior != null && message.hasOwnProperty("nodeBehavior"))
                            object.nodeBehavior = options.enums === String ? $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.TreeNodeBehavior[message.nodeBehavior] : message.nodeBehavior;
                        if (message.branchFeatureIndex != null && message.hasOwnProperty("branchFeatureIndex"))
                            if (typeof message.branchFeatureIndex === "number")
                                object.branchFeatureIndex = options.longs === String ? String(message.branchFeatureIndex) : message.branchFeatureIndex;
                            else
                                object.branchFeatureIndex = options.longs === String ? $util.Long.prototype.toString.call(message.branchFeatureIndex) : options.longs === Number ? new $util.LongBits(message.branchFeatureIndex.low >>> 0, message.branchFeatureIndex.high >>> 0).toNumber(true) : message.branchFeatureIndex;
                        if (message.branchFeatureValue != null && message.hasOwnProperty("branchFeatureValue"))
                            object.branchFeatureValue = options.json && !isFinite(message.branchFeatureValue) ? String(message.branchFeatureValue) : message.branchFeatureValue;
                        if (message.trueChildNodeId != null && message.hasOwnProperty("trueChildNodeId"))
                            if (typeof message.trueChildNodeId === "number")
                                object.trueChildNodeId = options.longs === String ? String(message.trueChildNodeId) : message.trueChildNodeId;
                            else
                                object.trueChildNodeId = options.longs === String ? $util.Long.prototype.toString.call(message.trueChildNodeId) : options.longs === Number ? new $util.LongBits(message.trueChildNodeId.low >>> 0, message.trueChildNodeId.high >>> 0).toNumber(true) : message.trueChildNodeId;
                        if (message.falseChildNodeId != null && message.hasOwnProperty("falseChildNodeId"))
                            if (typeof message.falseChildNodeId === "number")
                                object.falseChildNodeId = options.longs === String ? String(message.falseChildNodeId) : message.falseChildNodeId;
                            else
                                object.falseChildNodeId = options.longs === String ? $util.Long.prototype.toString.call(message.falseChildNodeId) : options.longs === Number ? new $util.LongBits(message.falseChildNodeId.low >>> 0, message.falseChildNodeId.high >>> 0).toNumber(true) : message.falseChildNodeId;
                        if (message.missingValueTracksTrueChild != null && message.hasOwnProperty("missingValueTracksTrueChild"))
                            object.missingValueTracksTrueChild = message.missingValueTracksTrueChild;
                        if (message.evaluationInfo && message.evaluationInfo.length) {
                            object.evaluationInfo = [];
                            for (var j = 0; j < message.evaluationInfo.length; ++j)
                                object.evaluationInfo[j] = $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.toObject(message.evaluationInfo[j], options);
                        }
                        if (message.relativeHitRate != null && message.hasOwnProperty("relativeHitRate"))
                            object.relativeHitRate = options.json && !isFinite(message.relativeHitRate) ? String(message.relativeHitRate) : message.relativeHitRate;
                        return object;
                    };
    
                    /**
                     * Converts this TreeNode to JSON.
                     * @function toJSON
                     * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TreeNode.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };
    
                    /**
                     * TreeNodeBehavior enum.
                     * @name CoreML.Specification.TreeEnsembleParameters.TreeNode.TreeNodeBehavior
                     * @enum {string}
                     * @property {number} BranchOnValueLessThanEqual=0 BranchOnValueLessThanEqual value
                     * @property {number} BranchOnValueLessThan=1 BranchOnValueLessThan value
                     * @property {number} BranchOnValueGreaterThanEqual=2 BranchOnValueGreaterThanEqual value
                     * @property {number} BranchOnValueGreaterThan=3 BranchOnValueGreaterThan value
                     * @property {number} BranchOnValueEqual=4 BranchOnValueEqual value
                     * @property {number} BranchOnValueNotEqual=5 BranchOnValueNotEqual value
                     * @property {number} LeafNode=6 LeafNode value
                     */
                    TreeNode.TreeNodeBehavior = (function() {
                        var valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "BranchOnValueLessThanEqual"] = 0;
                        values[valuesById[1] = "BranchOnValueLessThan"] = 1;
                        values[valuesById[2] = "BranchOnValueGreaterThanEqual"] = 2;
                        values[valuesById[3] = "BranchOnValueGreaterThan"] = 3;
                        values[valuesById[4] = "BranchOnValueEqual"] = 4;
                        values[valuesById[5] = "BranchOnValueNotEqual"] = 5;
                        values[valuesById[6] = "LeafNode"] = 6;
                        return values;
                    })();
    
                    TreeNode.EvaluationInfo = (function() {
    
                        /**
                         * Properties of an EvaluationInfo.
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                         * @interface IEvaluationInfo
                         * @property {number|Long|null} [evaluationIndex] EvaluationInfo evaluationIndex
                         * @property {number|null} [evaluationValue] EvaluationInfo evaluationValue
                         */
    
                        /**
                         * Constructs a new EvaluationInfo.
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode
                         * @classdesc The leaf mode.
                         * 
                         * If ``nodeBahavior`` == ``LeafNode``,
                         * then the evaluationValue is added to the base prediction value
                         * in order to get the final prediction.
                         * To support multiclass classification
                         * as well as regression and binary classification,
                         * the evaluation value is encoded here as a sparse vector,
                         * with evaluationIndex being the index of the base vector
                         * that evaluation value is added to.
                         * In the single class case,
                         * it is expected that evaluationIndex is exactly 0.
                         * @implements IEvaluationInfo
                         * @constructor
                         * @param {CoreML.Specification.TreeEnsembleParameters.TreeNode.IEvaluationInfo=} [properties] Properties to set
                         */
                        function EvaluationInfo(properties) {
                            if (properties)
                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }
    
                        /**
                         * EvaluationInfo evaluationIndex.
                         * @member {number|Long} evaluationIndex
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @instance
                         */
                        EvaluationInfo.prototype.evaluationIndex = $util.Long ? $util.Long.fromBits(0,0,true) : 0;
    
                        /**
                         * EvaluationInfo evaluationValue.
                         * @member {number} evaluationValue
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @instance
                         */
                        EvaluationInfo.prototype.evaluationValue = 0;
    
                        /**
                         * Creates a new EvaluationInfo instance using the specified properties.
                         * @function create
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {CoreML.Specification.TreeEnsembleParameters.TreeNode.IEvaluationInfo=} [properties] Properties to set
                         * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo} EvaluationInfo instance
                         */
                        EvaluationInfo.create = function create(properties) {
                            return new EvaluationInfo(properties);
                        };
    
                        /**
                         * Encodes the specified EvaluationInfo message. Does not implicitly {@link CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.verify|verify} messages.
                         * @function encode
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {CoreML.Specification.TreeEnsembleParameters.TreeNode.IEvaluationInfo} message EvaluationInfo message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        EvaluationInfo.encode = function encode(message, writer) {
                            if (!writer)
                                writer = $Writer.create();
                            if (message.evaluationIndex != null && message.hasOwnProperty("evaluationIndex"))
                                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.evaluationIndex);
                            if (message.evaluationValue != null && message.hasOwnProperty("evaluationValue"))
                                writer.uint32(/* id 2, wireType 1 =*/17).double(message.evaluationValue);
                            return writer;
                        };
    
                        /**
                         * Encodes the specified EvaluationInfo message, length delimited. Does not implicitly {@link CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo.verify|verify} messages.
                         * @function encodeDelimited
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {CoreML.Specification.TreeEnsembleParameters.TreeNode.IEvaluationInfo} message EvaluationInfo message or plain object to encode
                         * @param {$protobuf.Writer} [writer] Writer to encode to
                         * @returns {$protobuf.Writer} Writer
                         */
                        EvaluationInfo.encodeDelimited = function encodeDelimited(message, writer) {
                            return this.encode(message, writer).ldelim();
                        };
    
                        /**
                         * Decodes an EvaluationInfo message from the specified reader or buffer.
                         * @function decode
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @param {number} [length] Message length if known beforehand
                         * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo} EvaluationInfo
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        EvaluationInfo.decode = function decode(reader, length) {
                            if (!(reader instanceof $Reader))
                                reader = $Reader.create(reader);
                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo();
                            while (reader.pos < end) {
                                var tag = reader.uint32();
                                switch (tag >>> 3) {
                                case 1:
                                    message.evaluationIndex = reader.uint64();
                                    break;
                                case 2:
                                    message.evaluationValue = reader.double();
                                    break;
                                default:
                                    reader.skipType(tag & 7);
                                    break;
                                }
                            }
                            return message;
                        };
    
                        /**
                         * Decodes an EvaluationInfo message from the specified reader or buffer, length delimited.
                         * @function decodeDelimited
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                         * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo} EvaluationInfo
                         * @throws {Error} If the payload is not a reader or valid buffer
                         * @throws {$protobuf.util.ProtocolError} If required fields are missing
                         */
                        EvaluationInfo.decodeDelimited = function decodeDelimited(reader) {
                            if (!(reader instanceof $Reader))
                                reader = new $Reader(reader);
                            return this.decode(reader, reader.uint32());
                        };
    
                        /**
                         * Verifies an EvaluationInfo message.
                         * @function verify
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        EvaluationInfo.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.evaluationIndex != null && message.hasOwnProperty("evaluationIndex"))
                                if (!$util.isInteger(message.evaluationIndex) && !(message.evaluationIndex && $util.isInteger(message.evaluationIndex.low) && $util.isInteger(message.evaluationIndex.high)))
                                    return "evaluationIndex: integer|Long expected";
                            if (message.evaluationValue != null && message.hasOwnProperty("evaluationValue"))
                                if (typeof message.evaluationValue !== "number")
                                    return "evaluationValue: number expected";
                            return null;
                        };
    
                        /**
                         * Creates an EvaluationInfo message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo} EvaluationInfo
                         */
                        EvaluationInfo.fromObject = function fromObject(object) {
                            if (object instanceof $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo)
                                return object;
                            var message = new $root.CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo();
                            if (object.evaluationIndex != null)
                                if ($util.Long)
                                    (message.evaluationIndex = $util.Long.fromValue(object.evaluationIndex)).unsigned = true;
                                else if (typeof object.evaluationIndex === "string")
                                    message.evaluationIndex = parseInt(object.evaluationIndex, 10);
                                else if (typeof object.evaluationIndex === "number")
                                    message.evaluationIndex = object.evaluationIndex;
                                else if (typeof object.evaluationIndex === "object")
                                    message.evaluationIndex = new $util.LongBits(object.evaluationIndex.low >>> 0, object.evaluationIndex.high >>> 0).toNumber(true);
                            if (object.evaluationValue != null)
                                message.evaluationValue = Number(object.evaluationValue);
                            return message;
                        };
    
                        /**
                         * Creates a plain object from an EvaluationInfo message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @static
                         * @param {CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo} message EvaluationInfo
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        EvaluationInfo.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            var object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    var long = new $util.Long(0, 0, true);
                                    object.evaluationIndex = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.evaluationIndex = options.longs === String ? "0" : 0;
                                object.evaluationValue = 0;
                            }
                            if (message.evaluationIndex != null && message.hasOwnProperty("evaluationIndex"))
                                if (typeof message.evaluationIndex === "number")
                                    object.evaluationIndex = options.longs === String ? String(message.evaluationIndex) : message.evaluationIndex;
                                else
                                    object.evaluationIndex = options.longs === String ? $util.Long.prototype.toString.call(message.evaluationIndex) : options.longs === Number ? new $util.LongBits(message.evaluationIndex.low >>> 0, message.evaluationIndex.high >>> 0).toNumber(true) : message.evaluationIndex;
                            if (message.evaluationValue != null && message.hasOwnProperty("evaluationValue"))
                                object.evaluationValue = options.json && !isFinite(message.evaluationValue) ? String(message.evaluationValue) : message.evaluationValue;
                            return object;
                        };
    
                        /**
                         * Converts this EvaluationInfo to JSON.
                         * @function toJSON
                         * @memberof CoreML.Specification.TreeEnsembleParameters.TreeNode.EvaluationInfo
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        EvaluationInfo.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };
    
                        return EvaluationInfo;
                    })();
    
                    return TreeNode;
                })();
    
                return TreeEnsembleParameters;
            })();
    
            Specification.TreeEnsembleClassifier = (function() {
    
                /**
                 * Properties of a TreeEnsembleClassifier.
                 * @memberof CoreML.Specification
                 * @interface ITreeEnsembleClassifier
                 * @property {CoreML.Specification.ITreeEnsembleParameters|null} [treeEnsemble] TreeEnsembleClassifier treeEnsemble
                 * @property {CoreML.Specification.TreeEnsemblePostEvaluationTransform|null} [postEvaluationTransform] TreeEnsembleClassifier postEvaluationTransform
                 * @property {CoreML.Specification.IStringVector|null} [stringClassLabels] TreeEnsembleClassifier stringClassLabels
                 * @property {CoreML.Specification.IInt64Vector|null} [int64ClassLabels] TreeEnsembleClassifier int64ClassLabels
                 */
    
                /**
                 * Constructs a new TreeEnsembleClassifier.
                 * @memberof CoreML.Specification
                 * @classdesc A tree ensemble classifier.
                 * @implements ITreeEnsembleClassifier
                 * @constructor
                 * @param {CoreML.Specification.ITreeEnsembleClassifier=} [properties] Properties to set
                 */
                function TreeEnsembleClassifier(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TreeEnsembleClassifier treeEnsemble.
                 * @member {CoreML.Specification.ITreeEnsembleParameters|null|undefined} treeEnsemble
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @instance
                 */
                TreeEnsembleClassifier.prototype.treeEnsemble = null;
    
                /**
                 * TreeEnsembleClassifier postEvaluationTransform.
                 * @member {CoreML.Specification.TreeEnsemblePostEvaluationTransform} postEvaluationTransform
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @instance
                 */
                TreeEnsembleClassifier.prototype.postEvaluationTransform = 0;
    
                /**
                 * TreeEnsembleClassifier stringClassLabels.
                 * @member {CoreML.Specification.IStringVector|null|undefined} stringClassLabels
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @instance
                 */
                TreeEnsembleClassifier.prototype.stringClassLabels = null;
    
                /**
                 * TreeEnsembleClassifier int64ClassLabels.
                 * @member {CoreML.Specification.IInt64Vector|null|undefined} int64ClassLabels
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @instance
                 */
                TreeEnsembleClassifier.prototype.int64ClassLabels = null;
    
                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;
    
                /**
                 * TreeEnsembleClassifier ClassLabels.
                 * @member {"stringClassLabels"|"int64ClassLabels"|undefined} ClassLabels
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @instance
                 */
                Object.defineProperty(TreeEnsembleClassifier.prototype, "ClassLabels", {
                    get: $util.oneOfGetter($oneOfFields = ["stringClassLabels", "int64ClassLabels"]),
                    set: $util.oneOfSetter($oneOfFields)
                });
    
                /**
                 * Creates a new TreeEnsembleClassifier instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleClassifier=} [properties] Properties to set
                 * @returns {CoreML.Specification.TreeEnsembleClassifier} TreeEnsembleClassifier instance
                 */
                TreeEnsembleClassifier.create = function create(properties) {
                    return new TreeEnsembleClassifier(properties);
                };
    
                /**
                 * Encodes the specified TreeEnsembleClassifier message. Does not implicitly {@link CoreML.Specification.TreeEnsembleClassifier.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleClassifier} message TreeEnsembleClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TreeEnsembleClassifier.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble"))
                        $root.CoreML.Specification.TreeEnsembleParameters.encode(message.treeEnsemble, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.postEvaluationTransform);
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels"))
                        $root.CoreML.Specification.StringVector.encode(message.stringClassLabels, writer.uint32(/* id 100, wireType 2 =*/802).fork()).ldelim();
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels"))
                        $root.CoreML.Specification.Int64Vector.encode(message.int64ClassLabels, writer.uint32(/* id 101, wireType 2 =*/810).fork()).ldelim();
                    return writer;
                };
    
                /**
                 * Encodes the specified TreeEnsembleClassifier message, length delimited. Does not implicitly {@link CoreML.Specification.TreeEnsembleClassifier.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleClassifier} message TreeEnsembleClassifier message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TreeEnsembleClassifier.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a TreeEnsembleClassifier message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.TreeEnsembleClassifier} TreeEnsembleClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TreeEnsembleClassifier.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleClassifier();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        case 100:
                            message.stringClassLabels = $root.CoreML.Specification.StringVector.decode(reader, reader.uint32());
                            break;
                        case 101:
                            message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a TreeEnsembleClassifier message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.TreeEnsembleClassifier} TreeEnsembleClassifier
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TreeEnsembleClassifier.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a TreeEnsembleClassifier message.
                 * @function verify
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TreeEnsembleClassifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble")) {
                        var error = $root.CoreML.Specification.TreeEnsembleParameters.verify(message.treeEnsemble);
                        if (error)
                            return "treeEnsemble." + error;
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.StringVector.verify(message.stringClassLabels);
                            if (error)
                                return "stringClassLabels." + error;
                        }
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        if (properties.ClassLabels === 1)
                            return "ClassLabels: multiple values";
                        properties.ClassLabels = 1;
                        {
                            var error = $root.CoreML.Specification.Int64Vector.verify(message.int64ClassLabels);
                            if (error)
                                return "int64ClassLabels." + error;
                        }
                    }
                    return null;
                };
    
                /**
                 * Creates a TreeEnsembleClassifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.TreeEnsembleClassifier} TreeEnsembleClassifier
                 */
                TreeEnsembleClassifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.TreeEnsembleClassifier)
                        return object;
                    var message = new $root.CoreML.Specification.TreeEnsembleClassifier();
                    if (object.treeEnsemble != null) {
                        if (typeof object.treeEnsemble !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleClassifier.treeEnsemble: object expected");
                        message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.fromObject(object.treeEnsemble);
                    }
                    switch (object.postEvaluationTransform) {
                    case "NoTransform":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Classification_SoftMax":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    case "Regression_Logistic":
                    case 2:
                        message.postEvaluationTransform = 2;
                        break;
                    case "Classification_SoftMaxWithZeroClassReference":
                    case 3:
                        message.postEvaluationTransform = 3;
                        break;
                    }
                    if (object.stringClassLabels != null) {
                        if (typeof object.stringClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleClassifier.stringClassLabels: object expected");
                        message.stringClassLabels = $root.CoreML.Specification.StringVector.fromObject(object.stringClassLabels);
                    }
                    if (object.int64ClassLabels != null) {
                        if (typeof object.int64ClassLabels !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleClassifier.int64ClassLabels: object expected");
                        message.int64ClassLabels = $root.CoreML.Specification.Int64Vector.fromObject(object.int64ClassLabels);
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a TreeEnsembleClassifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @static
                 * @param {CoreML.Specification.TreeEnsembleClassifier} message TreeEnsembleClassifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TreeEnsembleClassifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.treeEnsemble = null;
                        object.postEvaluationTransform = options.enums === String ? "NoTransform" : 0;
                    }
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble"))
                        object.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.toObject(message.treeEnsemble, options);
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.TreeEnsemblePostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    if (message.stringClassLabels != null && message.hasOwnProperty("stringClassLabels")) {
                        object.stringClassLabels = $root.CoreML.Specification.StringVector.toObject(message.stringClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "stringClassLabels";
                    }
                    if (message.int64ClassLabels != null && message.hasOwnProperty("int64ClassLabels")) {
                        object.int64ClassLabels = $root.CoreML.Specification.Int64Vector.toObject(message.int64ClassLabels, options);
                        if (options.oneofs)
                            object.ClassLabels = "int64ClassLabels";
                    }
                    return object;
                };
    
                /**
                 * Converts this TreeEnsembleClassifier to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.TreeEnsembleClassifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TreeEnsembleClassifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return TreeEnsembleClassifier;
            })();
    
            Specification.TreeEnsembleRegressor = (function() {
    
                /**
                 * Properties of a TreeEnsembleRegressor.
                 * @memberof CoreML.Specification
                 * @interface ITreeEnsembleRegressor
                 * @property {CoreML.Specification.ITreeEnsembleParameters|null} [treeEnsemble] TreeEnsembleRegressor treeEnsemble
                 * @property {CoreML.Specification.TreeEnsemblePostEvaluationTransform|null} [postEvaluationTransform] TreeEnsembleRegressor postEvaluationTransform
                 */
    
                /**
                 * Constructs a new TreeEnsembleRegressor.
                 * @memberof CoreML.Specification
                 * @classdesc A tree ensemble regressor.
                 * @implements ITreeEnsembleRegressor
                 * @constructor
                 * @param {CoreML.Specification.ITreeEnsembleRegressor=} [properties] Properties to set
                 */
                function TreeEnsembleRegressor(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }
    
                /**
                 * TreeEnsembleRegressor treeEnsemble.
                 * @member {CoreML.Specification.ITreeEnsembleParameters|null|undefined} treeEnsemble
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @instance
                 */
                TreeEnsembleRegressor.prototype.treeEnsemble = null;
    
                /**
                 * TreeEnsembleRegressor postEvaluationTransform.
                 * @member {CoreML.Specification.TreeEnsemblePostEvaluationTransform} postEvaluationTransform
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @instance
                 */
                TreeEnsembleRegressor.prototype.postEvaluationTransform = 0;
    
                /**
                 * Creates a new TreeEnsembleRegressor instance using the specified properties.
                 * @function create
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleRegressor=} [properties] Properties to set
                 * @returns {CoreML.Specification.TreeEnsembleRegressor} TreeEnsembleRegressor instance
                 */
                TreeEnsembleRegressor.create = function create(properties) {
                    return new TreeEnsembleRegressor(properties);
                };
    
                /**
                 * Encodes the specified TreeEnsembleRegressor message. Does not implicitly {@link CoreML.Specification.TreeEnsembleRegressor.verify|verify} messages.
                 * @function encode
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleRegressor} message TreeEnsembleRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TreeEnsembleRegressor.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble"))
                        $root.CoreML.Specification.TreeEnsembleParameters.encode(message.treeEnsemble, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.postEvaluationTransform);
                    return writer;
                };
    
                /**
                 * Encodes the specified TreeEnsembleRegressor message, length delimited. Does not implicitly {@link CoreML.Specification.TreeEnsembleRegressor.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {CoreML.Specification.ITreeEnsembleRegressor} message TreeEnsembleRegressor message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TreeEnsembleRegressor.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };
    
                /**
                 * Decodes a TreeEnsembleRegressor message from the specified reader or buffer.
                 * @function decode
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {CoreML.Specification.TreeEnsembleRegressor} TreeEnsembleRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TreeEnsembleRegressor.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.CoreML.Specification.TreeEnsembleRegressor();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.postEvaluationTransform = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };
    
                /**
                 * Decodes a TreeEnsembleRegressor message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {CoreML.Specification.TreeEnsembleRegressor} TreeEnsembleRegressor
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TreeEnsembleRegressor.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };
    
                /**
                 * Verifies a TreeEnsembleRegressor message.
                 * @function verify
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TreeEnsembleRegressor.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble")) {
                        var error = $root.CoreML.Specification.TreeEnsembleParameters.verify(message.treeEnsemble);
                        if (error)
                            return "treeEnsemble." + error;
                    }
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        switch (message.postEvaluationTransform) {
                        default:
                            return "postEvaluationTransform: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };
    
                /**
                 * Creates a TreeEnsembleRegressor message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {CoreML.Specification.TreeEnsembleRegressor} TreeEnsembleRegressor
                 */
                TreeEnsembleRegressor.fromObject = function fromObject(object) {
                    if (object instanceof $root.CoreML.Specification.TreeEnsembleRegressor)
                        return object;
                    var message = new $root.CoreML.Specification.TreeEnsembleRegressor();
                    if (object.treeEnsemble != null) {
                        if (typeof object.treeEnsemble !== "object")
                            throw TypeError(".CoreML.Specification.TreeEnsembleRegressor.treeEnsemble: object expected");
                        message.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.fromObject(object.treeEnsemble);
                    }
                    switch (object.postEvaluationTransform) {
                    case "NoTransform":
                    case 0:
                        message.postEvaluationTransform = 0;
                        break;
                    case "Classification_SoftMax":
                    case 1:
                        message.postEvaluationTransform = 1;
                        break;
                    case "Regression_Logistic":
                    case 2:
                        message.postEvaluationTransform = 2;
                        break;
                    case "Classification_SoftMaxWithZeroClassReference":
                    case 3:
                        message.postEvaluationTransform = 3;
                        break;
                    }
                    return message;
                };
    
                /**
                 * Creates a plain object from a TreeEnsembleRegressor message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @static
                 * @param {CoreML.Specification.TreeEnsembleRegressor} message TreeEnsembleRegressor
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TreeEnsembleRegressor.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.treeEnsemble = null;
                        object.postEvaluationTransform = options.enums === String ? "NoTransform" : 0;
                    }
                    if (message.treeEnsemble != null && message.hasOwnProperty("treeEnsemble"))
                        object.treeEnsemble = $root.CoreML.Specification.TreeEnsembleParameters.toObject(message.treeEnsemble, options);
                    if (message.postEvaluationTransform != null && message.hasOwnProperty("postEvaluationTransform"))
                        object.postEvaluationTransform = options.enums === String ? $root.CoreML.Specification.TreeEnsemblePostEvaluationTransform[message.postEvaluationTransform] : message.postEvaluationTransform;
                    return object;
                };
    
                /**
                 * Converts this TreeEnsembleRegressor to JSON.
                 * @function toJSON
                 * @memberof CoreML.Specification.TreeEnsembleRegressor
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TreeEnsembleRegressor.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };
    
                return TreeEnsembleRegressor;
            })();
    
            return Specification;
        })();
    
        return CoreML;
    })();

    return $root;
})(protobuf);
